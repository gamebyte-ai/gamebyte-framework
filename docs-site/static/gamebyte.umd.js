(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('pixi.js'), require('three'), require('matter-js'), require('cannon-es'), require('three/examples/jsm/renderers/CSS2DRenderer.js')) :
	typeof define === 'function' && define.amd ? define(['exports', 'pixi.js', 'three', 'matter-js', 'cannon-es', 'three/examples/jsm/renderers/CSS2DRenderer.js'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.GameByteFramework = {}, global.PIXI, global.THREE, global.Matter, global.CANNON, global.THREE));
})(this, (function (exports, PIXI, THREE, Matter, CANNON, CSS2DRenderer_js) { 'use strict';

	function _interopNamespaceDefault(e) {
		var n = Object.create(null);
		if (e) {
			Object.keys(e).forEach(function (k) {
				if (k !== 'default') {
					var d = Object.getOwnPropertyDescriptor(e, k);
					Object.defineProperty(n, k, d.get ? d : {
						enumerable: true,
						get: function () { return e[k]; }
					});
				}
			});
		}
		n.default = e;
		return Object.freeze(n);
	}

	var PIXI__namespace = /*#__PURE__*/_interopNamespaceDefault(PIXI);
	var THREE__namespace = /*#__PURE__*/_interopNamespaceDefault(THREE);
	var CANNON__namespace = /*#__PURE__*/_interopNamespaceDefault(CANNON);

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var eventemitter3 = {exports: {}};

	(function (module) {

		var has = Object.prototype.hasOwnProperty
		  , prefix = '~';

		/**
		 * Constructor to create a storage for our `EE` objects.
		 * An `Events` instance is a plain object whose properties are event names.
		 *
		 * @constructor
		 * @private
		 */
		function Events() {}

		//
		// We try to not inherit from `Object.prototype`. In some engines creating an
		// instance in this way is faster than calling `Object.create(null)` directly.
		// If `Object.create(null)` is not supported we prefix the event names with a
		// character to make sure that the built-in object properties are not
		// overridden or used as an attack vector.
		//
		if (Object.create) {
		  Events.prototype = Object.create(null);

		  //
		  // This hack is needed because the `__proto__` property is still inherited in
		  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
		  //
		  if (!new Events().__proto__) prefix = false;
		}

		/**
		 * Representation of a single event listener.
		 *
		 * @param {Function} fn The listener function.
		 * @param {*} context The context to invoke the listener with.
		 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
		 * @constructor
		 * @private
		 */
		function EE(fn, context, once) {
		  this.fn = fn;
		  this.context = context;
		  this.once = once || false;
		}

		/**
		 * Add a listener for a given event.
		 *
		 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn The listener function.
		 * @param {*} context The context to invoke the listener with.
		 * @param {Boolean} once Specify if the listener is a one-time listener.
		 * @returns {EventEmitter}
		 * @private
		 */
		function addListener(emitter, event, fn, context, once) {
		  if (typeof fn !== 'function') {
		    throw new TypeError('The listener must be a function');
		  }

		  var listener = new EE(fn, context || emitter, once)
		    , evt = prefix ? prefix + event : event;

		  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
		  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
		  else emitter._events[evt] = [emitter._events[evt], listener];

		  return emitter;
		}

		/**
		 * Clear event by name.
		 *
		 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
		 * @param {(String|Symbol)} evt The Event name.
		 * @private
		 */
		function clearEvent(emitter, evt) {
		  if (--emitter._eventsCount === 0) emitter._events = new Events();
		  else delete emitter._events[evt];
		}

		/**
		 * Minimal `EventEmitter` interface that is molded against the Node.js
		 * `EventEmitter` interface.
		 *
		 * @constructor
		 * @public
		 */
		function EventEmitter() {
		  this._events = new Events();
		  this._eventsCount = 0;
		}

		/**
		 * Return an array listing the events for which the emitter has registered
		 * listeners.
		 *
		 * @returns {Array}
		 * @public
		 */
		EventEmitter.prototype.eventNames = function eventNames() {
		  var names = []
		    , events
		    , name;

		  if (this._eventsCount === 0) return names;

		  for (name in (events = this._events)) {
		    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
		  }

		  if (Object.getOwnPropertySymbols) {
		    return names.concat(Object.getOwnPropertySymbols(events));
		  }

		  return names;
		};

		/**
		 * Return the listeners registered for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @returns {Array} The registered listeners.
		 * @public
		 */
		EventEmitter.prototype.listeners = function listeners(event) {
		  var evt = prefix ? prefix + event : event
		    , handlers = this._events[evt];

		  if (!handlers) return [];
		  if (handlers.fn) return [handlers.fn];

		  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
		    ee[i] = handlers[i].fn;
		  }

		  return ee;
		};

		/**
		 * Return the number of listeners listening to a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @returns {Number} The number of listeners.
		 * @public
		 */
		EventEmitter.prototype.listenerCount = function listenerCount(event) {
		  var evt = prefix ? prefix + event : event
		    , listeners = this._events[evt];

		  if (!listeners) return 0;
		  if (listeners.fn) return 1;
		  return listeners.length;
		};

		/**
		 * Calls each of the listeners registered for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @returns {Boolean} `true` if the event had listeners, else `false`.
		 * @public
		 */
		EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
		  var evt = prefix ? prefix + event : event;

		  if (!this._events[evt]) return false;

		  var listeners = this._events[evt]
		    , len = arguments.length
		    , args
		    , i;

		  if (listeners.fn) {
		    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

		    switch (len) {
		      case 1: return listeners.fn.call(listeners.context), true;
		      case 2: return listeners.fn.call(listeners.context, a1), true;
		      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
		      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
		      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
		      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
		    }

		    for (i = 1, args = new Array(len -1); i < len; i++) {
		      args[i - 1] = arguments[i];
		    }

		    listeners.fn.apply(listeners.context, args);
		  } else {
		    var length = listeners.length
		      , j;

		    for (i = 0; i < length; i++) {
		      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

		      switch (len) {
		        case 1: listeners[i].fn.call(listeners[i].context); break;
		        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
		        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
		        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
		        default:
		          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
		            args[j - 1] = arguments[j];
		          }

		          listeners[i].fn.apply(listeners[i].context, args);
		      }
		    }
		  }

		  return true;
		};

		/**
		 * Add a listener for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn The listener function.
		 * @param {*} [context=this] The context to invoke the listener with.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */
		EventEmitter.prototype.on = function on(event, fn, context) {
		  return addListener(this, event, fn, context, false);
		};

		/**
		 * Add a one-time listener for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn The listener function.
		 * @param {*} [context=this] The context to invoke the listener with.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */
		EventEmitter.prototype.once = function once(event, fn, context) {
		  return addListener(this, event, fn, context, true);
		};

		/**
		 * Remove the listeners of a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn Only remove the listeners that match this function.
		 * @param {*} context Only remove the listeners that have this context.
		 * @param {Boolean} once Only remove one-time listeners.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */
		EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
		  var evt = prefix ? prefix + event : event;

		  if (!this._events[evt]) return this;
		  if (!fn) {
		    clearEvent(this, evt);
		    return this;
		  }

		  var listeners = this._events[evt];

		  if (listeners.fn) {
		    if (
		      listeners.fn === fn &&
		      (!once || listeners.once) &&
		      (!context || listeners.context === context)
		    ) {
		      clearEvent(this, evt);
		    }
		  } else {
		    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
		      if (
		        listeners[i].fn !== fn ||
		        (once && !listeners[i].once) ||
		        (context && listeners[i].context !== context)
		      ) {
		        events.push(listeners[i]);
		      }
		    }

		    //
		    // Reset the array, or remove it completely if we have no more listeners.
		    //
		    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
		    else clearEvent(this, evt);
		  }

		  return this;
		};

		/**
		 * Remove all listeners, or those of the specified event.
		 *
		 * @param {(String|Symbol)} [event] The event name.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */
		EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
		  var evt;

		  if (event) {
		    evt = prefix ? prefix + event : event;
		    if (this._events[evt]) clearEvent(this, evt);
		  } else {
		    this._events = new Events();
		    this._eventsCount = 0;
		  }

		  return this;
		};

		//
		// Alias methods names because people roll like that.
		//
		EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
		EventEmitter.prototype.addListener = EventEmitter.prototype.on;

		//
		// Expose the prefix.
		//
		EventEmitter.prefixed = prefix;

		//
		// Allow `EventEmitter` to be imported as module namespace.
		//
		EventEmitter.EventEmitter = EventEmitter;

		//
		// Expose the module.
		//
		{
		  module.exports = EventEmitter;
		} 
	} (eventemitter3));

	var eventemitter3Exports = eventemitter3.exports;
	var EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);

	/**
	 * Service container implementation for dependency injection.
	 * Provides Laravel-style service binding and resolution.
	 */
	class ServiceContainer {
	    constructor() {
	        this.bindings = new Map();
	        this.instances = new Map();
	        this.aliases = new Map();
	    }
	    /**
	     * Register a binding in the container.
	     */
	    bind(key, concrete, singleton = false) {
	        this.bindings.set(key, {
	            concrete,
	            singleton,
	            instance: undefined
	        });
	        // Clear any existing instance if rebinding
	        this.instances.delete(key);
	    }
	    /**
	     * Register a singleton binding in the container.
	     */
	    singleton(key, concrete) {
	        this.bind(key, concrete, true);
	    }
	    /**
	     * Register an alias for a service.
	     */
	    alias(alias, abstract) {
	        this.aliases.set(alias, abstract);
	    }
	    /**
	     * Resolve a service from the container.
	     */
	    make(key) {
	        // Resolve alias chains
	        const resolvedKey = this.resolveAlias(key);
	        // Check if we have a cached singleton instance
	        if (this.instances.has(resolvedKey)) {
	            return this.instances.get(resolvedKey);
	        }
	        const binding = this.bindings.get(resolvedKey);
	        if (!binding) {
	            throw new Error(`No binding found for '${key}'`);
	        }
	        let instance;
	        if (typeof binding.concrete === 'function') {
	            instance = binding.concrete();
	        }
	        else {
	            instance = binding.concrete;
	        }
	        // Cache singleton instances
	        if (binding.singleton) {
	            this.instances.set(resolvedKey, instance);
	        }
	        return instance;
	    }
	    /**
	     * Check if a binding exists in the container.
	     */
	    bound(key) {
	        const resolvedKey = this.resolveAlias(key);
	        return this.bindings.has(resolvedKey);
	    }
	    /**
	     * Remove a binding from the container.
	     */
	    unbind(key) {
	        const resolvedKey = this.resolveAlias(key);
	        this.bindings.delete(resolvedKey);
	        this.instances.delete(resolvedKey);
	    }
	    /**
	     * Get all bindings.
	     */
	    getBindings() {
	        return new Map(this.bindings);
	    }
	    /**
	     * Register an existing instance as a singleton.
	     */
	    instance(key, instance) {
	        this.instances.set(key, instance);
	        this.singleton(key, () => instance);
	        return instance;
	    }
	    /**
	     * Flush all bindings and instances.
	     */
	    flush() {
	        this.bindings.clear();
	        this.instances.clear();
	        this.aliases.clear();
	    }
	    /**
	     * Get all registered service keys.
	     */
	    keys() {
	        return Array.from(this.bindings.keys());
	    }
	    /**
	     * Resolve alias chains to get the final key.
	     */
	    resolveAlias(key) {
	        let resolvedKey = key;
	        const visited = new Set();
	        while (this.aliases.has(resolvedKey)) {
	            if (visited.has(resolvedKey)) {
	                throw new Error(`Circular alias reference detected for '${key}'`);
	            }
	            visited.add(resolvedKey);
	            resolvedKey = this.aliases.get(resolvedKey);
	        }
	        return resolvedKey;
	    }
	}

	/**
	 * Rendering modes supported by the framework.
	 */
	exports.RenderingMode = void 0;
	(function (RenderingMode) {
	    RenderingMode["RENDERER_2D"] = "2d";
	    RenderingMode["RENDERER_3D"] = "3d";
	    RenderingMode["HYBRID"] = "hybrid";
	})(exports.RenderingMode || (exports.RenderingMode = {}));

	/**
	 * Font Loader Utility
	 *
	 * Automatically loads and manages fonts for the GameByte framework.
	 * Ensures fonts are available before UI components render.
	 */
	// Default framework font configuration
	// Lilita One - Playful, game-style display font
	const FRAMEWORK_FONT = {
	    family: 'Lilita One',
	    googleFontsUrl: 'https://fonts.googleapis.com/css2?family=Lilita+One&display=swap'
	};
	let fontLoadPromise = null;
	let fontLoaded = false;
	/**
	 * Inject Google Fonts stylesheet if not already present
	 * Returns a promise that resolves when the stylesheet is loaded
	 */
	function injectFontStylesheet() {
	    return new Promise((resolve) => {
	        // Check if already injected
	        const existingLink = document.querySelector(`link[href*="Lilita+One"]`);
	        if (existingLink) {
	            // Already exists, check if loaded
	            if (existingLink.sheet) {
	                resolve();
	            }
	            else {
	                existingLink.addEventListener('load', () => resolve());
	                existingLink.addEventListener('error', () => resolve()); // Resolve anyway on error
	            }
	            return;
	        }
	        // Add preconnect for faster loading
	        const preconnect1 = document.createElement('link');
	        preconnect1.rel = 'preconnect';
	        preconnect1.href = 'https://fonts.googleapis.com';
	        document.head.appendChild(preconnect1);
	        const preconnect2 = document.createElement('link');
	        preconnect2.rel = 'preconnect';
	        preconnect2.href = 'https://fonts.gstatic.com';
	        preconnect2.crossOrigin = 'anonymous';
	        document.head.appendChild(preconnect2);
	        // Add font stylesheet
	        const link = document.createElement('link');
	        link.rel = 'stylesheet';
	        link.href = FRAMEWORK_FONT.googleFontsUrl;
	        link.addEventListener('load', () => resolve());
	        link.addEventListener('error', () => resolve()); // Resolve anyway on error
	        document.head.appendChild(link);
	    });
	}
	/**
	 * Check if the framework font is loaded
	 */
	function isFontLoaded() {
	    if (typeof document === 'undefined' || !document.fonts) {
	        return true; // SSR or no Font API support
	    }
	    return document.fonts.check(`400 24px ${FRAMEWORK_FONT.family}`);
	}
	/**
	 * Load the framework font
	 * Returns a promise that resolves when the font is ready
	 */
	async function loadFrameworkFont() {
	    // Return cached promise if already loading
	    if (fontLoadPromise) {
	        return fontLoadPromise;
	    }
	    // Already loaded
	    if (fontLoaded) {
	        return Promise.resolve();
	    }
	    fontLoadPromise = (async () => {
	        // Skip if no document (SSR)
	        if (typeof document === 'undefined') {
	            fontLoaded = true;
	            return;
	        }
	        // Check if already loaded
	        if (isFontLoaded()) {
	            fontLoaded = true;
	            return;
	        }
	        // Inject stylesheet and wait for it to load
	        await injectFontStylesheet();
	        // Create hidden element to trigger font load
	        const preload = document.createElement('div');
	        preload.style.cssText = `
      font-family: '${FRAMEWORK_FONT.family}', sans-serif;
      font-weight: 400;
      position: absolute;
      left: -9999px;
      visibility: hidden;
      pointer-events: none;
    `;
	        preload.textContent = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
	        document.body.appendChild(preload);
	        // Poll until font is loaded or timeout
	        await new Promise((resolve) => {
	            let attempts = 0;
	            const maxAttempts = 100; // 5 seconds max
	            const checkFont = () => {
	                attempts++;
	                if (isFontLoaded()) {
	                    preload.remove();
	                    fontLoaded = true;
	                    resolve();
	                    return;
	                }
	                if (attempts >= maxAttempts) {
	                    // Timeout - resolve anyway to prevent blocking
	                    console.warn('GameByte: Font loading timeout, using fallback');
	                    preload.remove();
	                    fontLoaded = true;
	                    resolve();
	                    return;
	                }
	                setTimeout(checkFont, 50);
	            };
	            // Start checking immediately since stylesheet is already loaded
	            checkFont();
	        });
	    })();
	    return fontLoadPromise;
	}
	/**
	 * Get the framework font family string for use in styles
	 * Includes emoji font fallbacks for cross-platform emoji support
	 */
	function getFrameworkFontFamily() {
	    return `"${FRAMEWORK_FONT.family}", "Fredoka", "Arial Black", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"`;
	}
	/**
	 * Check if font is ready (non-blocking)
	 */
	function isFontReady() {
	    return fontLoaded;
	}

	/**
	 * Pixi.js Graphics Factory Implementation
	 *
	 * Provides Pixi.js-based implementations of framework graphics primitives.
	 * This allows UI components to work with Pixi.js without directly importing it.
	 */
	/**
	 * Pixi.js Container Wrapper
	 */
	class PixiContainerWrapper extends PIXI__namespace.Container {
	}
	/**
	 * Pixi.js Graphics Wrapper
	 * Uses Pixi v8 modern API only
	 * PIXI.Graphics already implements all IGraphics methods, so we just extend it
	 */
	class PixiGraphicsWrapper extends PIXI__namespace.Graphics {
	}
	// No wrapper needed - use PIXI.Text directly
	/**
	 * Pixi.js Sprite Wrapper
	 */
	class PixiSpriteWrapper extends PIXI__namespace.Sprite {
	    constructor(texture) {
	        if (typeof texture === 'string') {
	            super(PIXI__namespace.Texture.from(texture));
	        }
	        else {
	            super(texture);
	        }
	    }
	}
	/**
	 * Pixi.js Graphics Factory
	 */
	class PixiGraphicsFactory {
	    createContainer() {
	        return new PixiContainerWrapper();
	    }
	    createGraphics() {
	        return new PixiGraphicsWrapper();
	    }
	    createText(text, style) {
	        // Pixi v8: new PIXI.Text({ text, style })
	        // Apply framework default font if not specified
	        const styleWithDefaults = {
	            fontFamily: getFrameworkFontFamily(),
	            ...style
	        };
	        const pixiStyle = PixiGraphicsFactory.convertToPixiV8Style(styleWithDefaults);
	        return new PIXI__namespace.Text({ text, style: pixiStyle });
	    }
	    createSprite(texture) {
	        return new PixiSpriteWrapper(texture);
	    }
	    createTexture(source) {
	        if (typeof source === 'string') {
	            return PIXI__namespace.Texture.from(source);
	        }
	        return PIXI__namespace.Texture.from(source);
	    }
	    createCanvasTexture(width, height, draw) {
	        const canvas = document.createElement('canvas');
	        canvas.width = width;
	        canvas.height = height;
	        const ctx = canvas.getContext('2d');
	        if (ctx) {
	            draw(ctx);
	        }
	        return PIXI__namespace.Texture.from(canvas);
	    }
	    /**
	     * Convert framework text style to Pixi v8 style object format
	     * Pixi v8 uses object format for stroke and dropShadow in Text constructor
	     * Supports both legacy format and modern Pixi v8 format
	     */
	    static convertToPixiV8Style(style) {
	        const config = {
	            fontFamily: style.fontFamily,
	            fontSize: style.fontSize,
	            fontWeight: style.fontWeight,
	            fill: style.fill,
	            align: style.align,
	            wordWrap: style.wordWrap,
	            wordWrapWidth: style.wordWrapWidth,
	            lineHeight: style.lineHeight,
	        };
	        // Copy fontStyle if present
	        if (style.fontStyle) {
	            config.fontStyle = style.fontStyle;
	        }
	        // Pixi v8 stroke format: { color: number, width: number }
	        // Handle both legacy (stroke as color number) and modern (stroke as object) formats
	        if (style.stroke !== undefined) {
	            const strokeValue = style.stroke;
	            if (typeof strokeValue === 'object' && strokeValue !== null && 'color' in strokeValue) {
	                // Modern Pixi v8 format: { color, width }
	                config.stroke = strokeValue;
	            }
	            else if (typeof strokeValue === 'number' || typeof strokeValue === 'string') {
	                // Legacy format: stroke is a color number/string
	                config.stroke = {
	                    color: strokeValue,
	                    width: style.strokeThickness ?? 0
	                };
	            }
	        }
	        else if (style.strokeThickness !== undefined && style.strokeThickness > 0) {
	            // Legacy format with only strokeThickness
	            config.stroke = {
	                color: 0x000000,
	                width: style.strokeThickness
	            };
	        }
	        // Pixi v8 dropShadow format: { alpha, angle, blur, color, distance }
	        // Handle both legacy (dropShadow as boolean) and modern (dropShadow as object) formats
	        if (style.dropShadow !== undefined) {
	            const dropShadowValue = style.dropShadow;
	            if (typeof dropShadowValue === 'object' && dropShadowValue !== null) {
	                // Modern Pixi v8 format: { alpha, angle, blur, color, distance }
	                config.dropShadow = dropShadowValue;
	            }
	            else if (dropShadowValue === true) {
	                // Legacy format: dropShadow is boolean, use individual properties
	                config.dropShadow = {
	                    alpha: style.dropShadowAlpha ?? 0.8,
	                    angle: style.dropShadowAngle ?? 0.523599, // ~30 degrees
	                    blur: style.dropShadowBlur ?? 0,
	                    color: style.dropShadowColor ?? 0x000000,
	                    distance: style.dropShadowDistance ?? 5
	                };
	            }
	        }
	        return config;
	    }
	}

	/**
	 * Graphics Engine
	 *
	 * Provides access to renderer-agnostic graphics primitives.
	 * Automatically selects the correct factory based on the active renderer.
	 */
	/**
	 * Graphics Engine Singleton
	 *
	 * Usage:
	 * ```typescript
	 * import { GraphicsEngine } from '@gamebyte/core';
	 *
	 * // In your UI component or game object
	 * const factory = GraphicsEngine.getFactory();
	 * const container = factory.createContainer();
	 * const text = factory.createText('Hello World', { fontSize: 24 });
	 * ```
	 */
	class GraphicsEngine {
	    constructor(renderingMode, factory) {
	        if (factory) {
	            this._factory = factory;
	            this._type = renderingMode === exports.RenderingMode.RENDERER_2D ? 'PIXI' : 'THREE';
	        }
	        else if (renderingMode === exports.RenderingMode.RENDERER_2D) {
	            this._factory = new PixiGraphicsFactory();
	            this._type = 'PIXI';
	        }
	        else {
	            // For 3D rendering, use initialize3D() which loads ThreeGraphicsFactory dynamically
	            throw new Error('For 3D mode, use GraphicsEngine.initialize3D() which loads the Three.js factory dynamically. ' +
	                'Example: await GraphicsEngine.initialize3D();');
	        }
	    }
	    get factory() {
	        return this._factory;
	    }
	    get type() {
	        return this._type;
	    }
	    /**
	     * Initialize the graphics engine with a rendering mode (2D only)
	     * For 3D mode, use initialize3D() instead
	     */
	    static initialize(renderingMode) {
	        GraphicsEngine.instance = new GraphicsEngine(renderingMode);
	    }
	    /**
	     * Initialize the graphics engine for 3D rendering
	     * This loads ThreeGraphicsFactory dynamically to avoid bundling issues
	     */
	    static async initialize3D() {
	        try {
	            const { ThreeGraphicsFactory } = await Promise.resolve().then(function () { return ThreeGraphicsFactory$1; });
	            GraphicsEngine.instance = new GraphicsEngine(exports.RenderingMode.RENDERER_3D, new ThreeGraphicsFactory());
	        }
	        catch (error) {
	            throw new Error('Failed to load ThreeGraphicsFactory. Make sure Three.js is available. ' +
	                'Error: ' + (error instanceof Error ? error.message : String(error)));
	        }
	    }
	    /**
	     * Get the current graphics factory
	     * Throws error if not initialized
	     */
	    static getFactory() {
	        if (!GraphicsEngine.instance) {
	            throw new Error('GraphicsEngine not initialized. Call GraphicsEngine.initialize(renderingMode) first.');
	        }
	        return GraphicsEngine.instance.factory;
	    }
	    /**
	     * Get the current renderer type
	     */
	    static getType() {
	        if (!GraphicsEngine.instance) {
	            throw new Error('GraphicsEngine not initialized.');
	        }
	        return GraphicsEngine.instance.type;
	    }
	    /**
	     * Set the renderer instance (called by GameByte during initialization)
	     */
	    static setRenderer(renderer) {
	        GraphicsEngine._renderer = renderer;
	    }
	    /**
	     * Get the renderer instance
	     */
	    static getRenderer() {
	        return GraphicsEngine._renderer;
	    }
	    /**
	     * Check if graphics engine is initialized
	     */
	    static isInitialized() {
	        return GraphicsEngine.instance !== undefined;
	    }
	    /**
	     * Switch to a different renderer
	     * This allows runtime switching between 2D and 3D
	     */
	    static switch(renderingMode) {
	        GraphicsEngine.instance = new GraphicsEngine(renderingMode);
	    }
	}
	/**
	 * Convenience function to get graphics factory
	 *
	 * Usage:
	 * ```typescript
	 * import { graphics } from '@gamebyte/core';
	 *
	 * const button = graphics().createContainer();
	 * ```
	 */
	function graphics() {
	    return GraphicsEngine.getFactory();
	}
	/**
	 * Draw any display object to a texture
	 *
	 * For 2D (Pixi): Requires the renderer from game.renderer
	 * For 3D (Three): Uses canvas-based rendering
	 *
	 * @param displayObject - The display object to render (PIXI.Container, PIXI.Graphics, etc.)
	 * @param renderer - The renderer instance (from game.renderer)
	 * @param options - Optional configuration for texture size and resolution
	 * @returns Promise resolving to the created texture
	 * @throws Error if renderer is invalid or rendering fails
	 *
	 * @example
	 * ```typescript
	 * import { drawToTexture, graphics } from '@gamebyte/core';
	 *
	 * const icon = graphics().createGraphics();
	 * icon.circle(16, 16, 16).fill({ color: 0xff0000 });
	 * const texture = await drawToTexture(icon, game.renderer);
	 * ```
	 */
	async function drawToTexture(displayObject, renderer, options) {
	    if (!displayObject) {
	        throw new Error('drawToTexture: displayObject is required');
	    }
	    if (!renderer) {
	        throw new Error('drawToTexture: renderer is required');
	    }
	    const type = GraphicsEngine.getType();
	    if (type === 'PIXI') {
	        // For Pixi v8, use RenderTexture
	        const PIXI = await import('pixi.js');
	        // Get bounds of the display object
	        const displayObj = displayObject;
	        const bounds = displayObj.getBounds?.() || { width: options?.width || 64, height: options?.height || 64 };
	        const width = options?.width || bounds.width || 64;
	        const height = options?.height || bounds.height || 64;
	        const resolution = options?.resolution || window.devicePixelRatio || 1;
	        // Create render texture
	        const renderTexture = PIXI.RenderTexture.create({
	            width,
	            height,
	            resolution
	        });
	        // Get the native Pixi renderer
	        const rendererObj = renderer;
	        const nativeRenderer = rendererObj.getNativeRenderer?.() || renderer;
	        const pixiRenderer = nativeRenderer;
	        // Render the display object to the texture
	        if (!pixiRenderer.render) {
	            throw new Error('drawToTexture: renderer does not have a render method. Make sure you pass game.renderer.');
	        }
	        pixiRenderer.render({ container: displayObject, target: renderTexture });
	        return renderTexture;
	    }
	    else {
	        // For Three.js, render to canvas and create texture
	        const canvas = document.createElement('canvas');
	        const width = options?.width || 64;
	        const height = options?.height || 64;
	        canvas.width = width;
	        canvas.height = height;
	        const ctx = canvas.getContext('2d');
	        if (!ctx) {
	            throw new Error('drawToTexture: failed to get 2D canvas context');
	        }
	        const displayObj = displayObject;
	        if (displayObj.element instanceof HTMLCanvasElement) {
	            // If it's a canvas-based graphics, copy it
	            ctx.drawImage(displayObj.element, 0, 0);
	        }
	        else {
	            console.warn('drawToTexture: Three.js display object does not have a canvas element, returning empty texture');
	        }
	        return GraphicsEngine.getFactory().createTexture(canvas);
	    }
	}

	/**
	 * Main GameByte framework class.
	 * Provides Laravel-inspired architecture for game development.
	 */
	class GameByte extends EventEmitter {
	    constructor() {
	        super();
	        this.providers = new Map();
	        this.booted = false;
	        this.running = false;
	        this.canvas = null;
	        // Quick API: Update and render callbacks
	        this.updateCallbacks = [];
	        this.renderCallbacks = [];
	        // ResizeObserver for container resize handling
	        this.resizeObserver = null;
	        this.container = new ServiceContainer();
	        this.registerCoreServices();
	    }
	    /**
	     * Get the singleton instance of the framework.
	     */
	    static getInstance() {
	        if (!GameByte.instance) {
	            GameByte.instance = new GameByte();
	        }
	        return GameByte.instance;
	    }
	    /**
	     * Create a new GameByte application instance.
	     */
	    static create() {
	        return new GameByte();
	    }
	    /**
	     * Quick 2D game setup - minimal boilerplate
	     * @example
	     * const game = await GameByte.quick2D('#game-container', 800, 600);
	     * game.stage.addChild(mySprite);
	     * game.onUpdate((dt) => { mySprite.x += dt; });
	     */
	    static async quick2D(container, width = 800, height = 600, options = {}) {
	        return GameByte.quick({
	            container,
	            width,
	            height,
	            mode: '2d',
	            autoStart: true,
	            ...options
	        });
	    }
	    /**
	     * Quick 3D game setup - minimal boilerplate
	     * @example
	     * const game = await GameByte.quick3D('#game-container', 800, 600);
	     * game.stage.add(myCube);
	     * game.onUpdate((dt) => { myCube.rotation.y += dt; });
	     */
	    static async quick3D(container, width = 800, height = 600, options = {}) {
	        return GameByte.quick({
	            container,
	            width,
	            height,
	            mode: '3d',
	            autoStart: true,
	            ...options
	        });
	    }
	    /**
	     * Universal quick game setup with config object
	     * @example
	     * const game = await GameByte.quick({
	     *   container: '#game',
	     *   width: 800,
	     *   height: 600,
	     *   mode: '2d',
	     *   backgroundColor: 0x1a1a2e,
	     *   autoStart: true
	     * });
	     */
	    static async quick(config) {
	        // Import service providers dynamically to avoid circular dependencies
	        const { RenderingServiceProvider } = await Promise.resolve().then(function () { return RenderingServiceProvider$1; });
	        const { SceneServiceProvider } = await Promise.resolve().then(function () { return SceneServiceProvider$1; });
	        const { PluginServiceProvider } = await Promise.resolve().then(function () { return PluginServiceProvider$1; });
	        const { UIServiceProvider } = await Promise.resolve().then(function () { return UIServiceProvider$1; });
	        // Create game instance
	        const game = new GameByte();
	        // Register minimal providers for quick setup
	        game.register(new RenderingServiceProvider());
	        game.register(new SceneServiceProvider());
	        game.register(new PluginServiceProvider());
	        game.register(new UIServiceProvider());
	        // Resolve container element
	        let containerElement = null;
	        if (typeof config.container === 'string') {
	            containerElement = document.querySelector(config.container);
	        }
	        else if (config.container instanceof HTMLElement) {
	            containerElement = config.container;
	        }
	        // Create or use canvas
	        let canvas;
	        if (config.canvas) {
	            canvas = config.canvas;
	        }
	        else {
	            canvas = document.createElement('canvas');
	            canvas.width = config.width || 800;
	            canvas.height = config.height || 600;
	            if (containerElement) {
	                containerElement.appendChild(canvas);
	            }
	            else {
	                document.body.appendChild(canvas);
	            }
	        }
	        // Handle resize to container
	        if (config.resizeToContainer && containerElement) {
	            game.resizeObserver = new ResizeObserver(() => {
	                canvas.width = containerElement.clientWidth;
	                canvas.height = containerElement.clientHeight;
	                game.emit('resize', canvas.width, canvas.height);
	            });
	            game.resizeObserver.observe(containerElement);
	        }
	        // Determine rendering mode (default to 2D)
	        let mode;
	        switch (config.mode) {
	            case '3d':
	                mode = exports.RenderingMode.RENDERER_3D;
	                break;
	            case 'hybrid':
	                mode = exports.RenderingMode.HYBRID;
	                break;
	            case '2d':
	            default:
	                mode = exports.RenderingMode.RENDERER_2D;
	        }
	        // Build renderer options
	        const rendererOptions = {
	            width: config.width || canvas.width,
	            height: config.height || canvas.height,
	            backgroundColor: config.backgroundColor,
	            antialias: config.antialias ?? true,
	            resolution: config.resolution ?? window.devicePixelRatio,
	            ...config.rendererOptions
	        };
	        // Initialize game (this sets up update/render event hooks automatically)
	        await game.initialize(canvas, mode, rendererOptions);
	        // Auto-start if requested
	        if (config.autoStart !== false) {
	            game.start();
	        }
	        return game;
	    }
	    /**
	     * Get the service container.
	     */
	    getContainer() {
	        return this.container;
	    }
	    /**
	     * Register a service provider.
	     */
	    register(provider, name) {
	        const providerInstance = typeof provider === 'function' ? new provider() : provider;
	        const providerName = name || providerInstance.constructor.name;
	        this.providers.set(providerName, providerInstance);
	        // Register the provider's services
	        providerInstance.register(this);
	        this.emit('provider:registered', providerName, providerInstance);
	        return this;
	    }
	    /**
	     * Boot all registered service providers.
	     */
	    async boot() {
	        if (this.booted) {
	            return this;
	        }
	        // Boot all providers
	        const bootPromises = [];
	        for (const [name, provider] of this.providers) {
	            if (provider.boot) {
	                const result = provider.boot(this);
	                if (result instanceof Promise) {
	                    bootPromises.push(result);
	                }
	            }
	            this.emit('provider:booted', name, provider);
	        }
	        await Promise.all(bootPromises);
	        this.booted = true;
	        this.emit('booted');
	        return this;
	    }
	    /**
	     * Initialize the framework with a canvas element.
	     *
	     * @example Basic 2D game
	     * ```typescript
	     * const game = createGame();
	     * await game.initialize(canvas, '2d');
	     * game.start();
	     * ```
	     *
	     * @example 3D game with options
	     * ```typescript
	     * await game.initialize(canvas, '3d', {
	     *   antialias: true,
	     *   shadowMap: { enabled: true }
	     * });
	     * ```
	     *
	     * @param canvas - HTML canvas element
	     * @param mode - Rendering mode ('2d' or '3d')
	     * @param options - Optional renderer configuration
	     * @returns Promise resolving to game instance
	     */
	    async initialize(canvas, mode, options) {
	        this.canvas = canvas;
	        // Boot the framework if not already booted
	        if (!this.booted) {
	            await this.boot();
	        }
	        // Initialize GraphicsEngine with rendering mode
	        if (!GraphicsEngine.isInitialized()) {
	            GraphicsEngine.initialize(mode);
	            console.log(`âœ… GraphicsEngine initialized with ${mode === exports.RenderingMode.RENDERER_2D ? '2D (Pixi.js)' : '3D (Three.js)'} renderer`);
	        }
	        // Initialize the renderer
	        const renderer = this.make('renderer');
	        await renderer.initialize(canvas, options);
	        // Store renderer reference in GraphicsEngine for effects that need it
	        GraphicsEngine.setRenderer(renderer);
	        // Setup update/render event hooks on the renderer's tick
	        renderer.on('tick', (deltaTime) => {
	            // Emit update event for game.on('update', ...) listeners
	            this.emit('update', deltaTime);
	            // Call all registered update callbacks (game.onUpdate())
	            for (const callback of this.updateCallbacks) {
	                callback(deltaTime);
	            }
	            // Emit render event for game.on('render', ...) listeners
	            this.emit('render');
	            // Call all registered render callbacks (game.onRender())
	            for (const callback of this.renderCallbacks) {
	                callback();
	            }
	        });
	        this.emit('initialized', { canvas, mode, options });
	        return this;
	    }
	    /**
	     * Start the game loop.
	     */
	    start() {
	        if (this.running) {
	            return this;
	        }
	        const renderer = this.make('renderer');
	        renderer.start();
	        this.running = true;
	        this.emit('started');
	        return this;
	    }
	    /**
	     * Stop the game loop.
	     */
	    stop() {
	        if (!this.running) {
	            return this;
	        }
	        const renderer = this.make('renderer');
	        renderer.stop();
	        this.running = false;
	        this.emit('stopped');
	        return this;
	    }
	    /**
	     * Resolve a service from the container.
	     */
	    make(key) {
	        return this.container.make(key);
	    }
	    /**
	     * Bind a service to the container.
	     */
	    bind(key, concrete, singleton = false) {
	        this.container.bind(key, concrete, singleton);
	        return this;
	    }
	    /**
	     * Bind a singleton service to the container.
	     */
	    singleton(key, concrete) {
	        this.container.singleton(key, concrete);
	        return this;
	    }
	    /**
	     * Check if the framework is booted.
	     */
	    isBooted() {
	        return this.booted;
	    }
	    /**
	     * Check if the framework is running.
	     */
	    isRunning() {
	        return this.running;
	    }
	    /**
	     * Get the current canvas element.
	     */
	    getCanvas() {
	        return this.canvas;
	    }
	    /**
	     * Get direct access to the stage/scene container.
	     * For 2D (Pixi.js): Returns PIXI.Container (stage)
	     * For 3D (Three.js): Returns THREE.Scene
	     * @example
	     * const game = await GameByte.quick2D('#container', 800, 600);
	     * game.stage.addChild(mySprite); // Pixi.js
	     */
	    get stage() {
	        if (!this.container.bound('renderer')) {
	            throw new Error('Renderer not initialized. Call initialize() or use quick2D()/quick3D() first.');
	        }
	        const renderer = this.make('renderer');
	        return renderer.getStage();
	    }
	    /**
	     * Get the native renderer instance.
	     * For 2D: Returns Pixi.js Application/Renderer
	     * For 3D: Returns Three.js WebGLRenderer
	     */
	    get renderer() {
	        if (!this.container.bound('renderer')) {
	            throw new Error('Renderer not initialized. Call initialize() or use quick2D()/quick3D() first.');
	        }
	        return this.make('renderer');
	    }
	    /**
	     * Register an update callback (called every frame with deltaTime)
	     * @example
	     * game.onUpdate((dt) => {
	     *   player.x += speed * dt;
	     * });
	     */
	    onUpdate(callback) {
	        this.updateCallbacks.push(callback);
	        return this;
	    }
	    /**
	     * Remove an update callback
	     */
	    offUpdate(callback) {
	        const index = this.updateCallbacks.indexOf(callback);
	        if (index !== -1) {
	            this.updateCallbacks.splice(index, 1);
	        }
	        return this;
	    }
	    /**
	     * Register a render callback (called every frame after update)
	     * @example
	     * game.onRender(() => {
	     *   debugDraw();
	     * });
	     */
	    onRender(callback) {
	        this.renderCallbacks.push(callback);
	        return this;
	    }
	    /**
	     * Remove a render callback
	     */
	    offRender(callback) {
	        const index = this.renderCallbacks.indexOf(callback);
	        if (index !== -1) {
	            this.renderCallbacks.splice(index, 1);
	        }
	        return this;
	    }
	    /**
	     * Get all registered providers.
	     */
	    getProviders() {
	        return new Map(this.providers);
	    }
	    /**
	     * Register core framework services.
	     */
	    registerCoreServices() {
	        // Register the container itself
	        this.container.instance('container', this.container);
	        this.container.instance('app', this);
	        // These will be registered by their respective service providers
	        this.container.alias('GameByte', 'app');
	    }
	    /**
	     * Destroy the framework and clean up resources.
	     */
	    destroy() {
	        this.stop();
	        // Emit destroyed event before cleanup
	        this.emit('destroyed');
	        if (this.container.bound('renderer')) {
	            const renderer = this.make('renderer');
	            renderer.destroy();
	        }
	        // Clean up ResizeObserver
	        if (this.resizeObserver) {
	            this.resizeObserver.disconnect();
	            this.resizeObserver = null;
	        }
	        // Clear callback arrays
	        this.updateCallbacks.length = 0;
	        this.renderCallbacks.length = 0;
	        this.container.flush();
	        this.providers.clear();
	        this.removeAllListeners();
	        this.booted = false;
	        this.running = false;
	        this.canvas = null;
	    }
	}
	/**
	 * Framework version.
	 */
	GameByte.VERSION = '1.0.0';

	/**
	 * Default implementation of the scene manager.
	 */
	class DefaultSceneManager extends EventEmitter {
	    constructor() {
	        super(...arguments);
	        this.scenes = new Map();
	        this.currentScene = null;
	        this.transitionInProgress = false;
	    }
	    /**
	     * Register a scene with the manager.
	     */
	    add(scene) {
	        if (this.scenes.has(scene.id)) {
	            throw new Error(`Scene with ID '${scene.id}' already exists`);
	        }
	        this.scenes.set(scene.id, scene);
	        this.emit('scene:added', scene);
	    }
	    /**
	     * Remove a scene from the manager.
	     */
	    remove(sceneId) {
	        const scene = this.scenes.get(sceneId);
	        if (!scene) {
	            return;
	        }
	        // Deactivate scene if it's current
	        if (this.currentScene?.id === sceneId) {
	            this.currentScene.deactivate();
	            this.currentScene = null;
	        }
	        // Clean up scene
	        scene.destroy();
	        this.scenes.delete(sceneId);
	        this.emit('scene:removed', scene);
	    }
	    /**
	     * Switch to a different scene.
	     */
	    async switchTo(sceneId, transition) {
	        if (this.transitionInProgress) {
	            throw new Error('Scene transition already in progress');
	        }
	        const targetScene = this.scenes.get(sceneId);
	        if (!targetScene) {
	            throw new Error(`Scene '${sceneId}' not found`);
	        }
	        if (this.currentScene?.id === sceneId) {
	            return; // Already on target scene
	        }
	        this.transitionInProgress = true;
	        const fromScene = this.currentScene;
	        try {
	            // Emit transition start
	            this.emit('scene:transition:start', { from: fromScene, to: targetScene, transition });
	            // Handle transition
	            if (transition && transition.type !== 'instant') {
	                await this.performTransition(fromScene, targetScene, transition);
	            }
	            else {
	                await this.instantTransition(fromScene, targetScene);
	            }
	            // Emit transition complete
	            this.emit('scene:transition:complete', { from: fromScene, to: targetScene, transition });
	            this.emit('scene:changed', fromScene, targetScene);
	        }
	        finally {
	            this.transitionInProgress = false;
	        }
	    }
	    /**
	     * Get the currently active scene.
	     */
	    getCurrentScene() {
	        return this.currentScene;
	    }
	    /**
	     * Get a scene by its ID.
	     */
	    getScene(sceneId) {
	        return this.scenes.get(sceneId) || null;
	    }
	    /**
	     * Check if a scene exists.
	     */
	    hasScene(sceneId) {
	        return this.scenes.has(sceneId);
	    }
	    /**
	     * Update the current scene.
	     */
	    update(deltaTime) {
	        if (this.currentScene && this.currentScene.isActive) {
	            this.currentScene.update(deltaTime);
	        }
	    }
	    /**
	     * Render the current scene.
	     */
	    render(renderer) {
	        if (this.currentScene && this.currentScene.isActive) {
	            this.currentScene.render(renderer);
	        }
	    }
	    /**
	     * Get all registered scenes.
	     */
	    getAllScenes() {
	        return Array.from(this.scenes.values());
	    }
	    /**
	     * Get scene IDs.
	     */
	    getSceneIds() {
	        return Array.from(this.scenes.keys());
	    }
	    /**
	     * Perform instant scene transition.
	     */
	    async instantTransition(fromScene, toScene) {
	        // Deactivate current scene
	        if (fromScene) {
	            fromScene.deactivate();
	        }
	        // Initialize and activate new scene
	        if (!toScene.isActive) {
	            await toScene.initialize();
	        }
	        toScene.activate();
	        this.currentScene = toScene;
	    }
	    /**
	     * Perform animated scene transition.
	     */
	    async performTransition(fromScene, toScene, transition) {
	        const duration = transition.duration || 500;
	        const easing = transition.easing || ((t) => t);
	        // Initialize target scene if needed
	        if (!toScene.isActive) {
	            await toScene.initialize();
	        }
	        return new Promise((resolve) => {
	            let startTime = null;
	            const animate = (currentTime) => {
	                if (!startTime)
	                    startTime = currentTime;
	                const elapsed = currentTime - startTime;
	                const progress = Math.min(elapsed / duration, 1);
	                const easedProgress = easing(progress);
	                // Handle different transition types
	                switch (transition.type) {
	                    case 'fade':
	                        this.handleFadeTransition(fromScene, toScene, easedProgress);
	                        break;
	                    case 'slide':
	                        this.handleSlideTransition(fromScene, toScene, easedProgress);
	                        break;
	                }
	                if (progress < 1) {
	                    requestAnimationFrame(animate);
	                }
	                else {
	                    // Complete transition
	                    if (fromScene) {
	                        fromScene.deactivate();
	                    }
	                    toScene.activate();
	                    this.currentScene = toScene;
	                    resolve();
	                }
	            };
	            requestAnimationFrame(animate);
	        });
	    }
	    /**
	     * Handle fade transition between scenes.
	     */
	    handleFadeTransition(fromScene, toScene, progress) {
	        // This is a simplified implementation
	        // In a real implementation, you'd manipulate the alpha/opacity of scene containers
	        if (progress >= 0.5 && !toScene.isActive) {
	            toScene.activate();
	            if (fromScene) {
	                fromScene.deactivate();
	            }
	        }
	    }
	    /**
	     * Handle slide transition between scenes.
	     */
	    handleSlideTransition(fromScene, toScene, progress) {
	        // This is a simplified implementation
	        // In a real implementation, you'd manipulate the position of scene containers
	        if (progress >= 0.5 && !toScene.isActive) {
	            toScene.activate();
	            if (fromScene) {
	                fromScene.deactivate();
	            }
	        }
	    }
	}

	/**
	 * Base scene implementation for 2D games (Pixi.js)
	 *
	 * Provides:
	 * - Pixi container management
	 * - Lifecycle methods (initialize, activate, deactivate, update, render, destroy)
	 * - Event handling
	 * - Ready-to-extend base for game scenes
	 *
	 * @example
	 * ```typescript
	 * class GameplayScene extends BaseScene {
	 *     constructor() {
	 *         super('gameplay', 'Gameplay Scene');
	 *     }
	 *
	 *     async initialize() {
	 *         await super.initialize();
	 *         // Add your game objects to this.container
	 *         const sprite = PIXI.Sprite.from('player.png');
	 *         this.container.addChild(sprite);
	 *     }
	 *
	 *     update(deltaTime: number) {
	 *         super.update(deltaTime);
	 *         // Update your game logic
	 *     }
	 * }
	 * ```
	 */
	class BaseScene extends EventEmitter {
	    constructor(id, name) {
	        super();
	        this._isActive = false;
	        this.initialized = false;
	        this.id = id;
	        this.name = name;
	        this.container = new PIXI__namespace.Container();
	    }
	    /**
	     * Whether the scene is currently active
	     */
	    get isActive() {
	        return this._isActive;
	    }
	    /**
	     * Get the Pixi container for this scene
	     */
	    getContainer() {
	        return this.container;
	    }
	    /**
	     * Initialize the scene
	     * Override this in your scene to add initialization logic
	     */
	    async initialize() {
	        if (this.initialized) {
	            return;
	        }
	        this.emit('initializing');
	        // Override in subclass to add game objects
	        this.initialized = true;
	        this.emit('initialized');
	    }
	    /**
	     * Called when the scene becomes active
	     * Override this to add activation logic
	     */
	    activate() {
	        this._isActive = true;
	        this.container.visible = true;
	        this.emit('activated');
	    }
	    /**
	     * Called when the scene becomes inactive
	     * Override this to add deactivation logic
	     */
	    deactivate() {
	        this._isActive = false;
	        this.container.visible = false;
	        this.emit('deactivated');
	    }
	    /**
	     * Update the scene logic
	     * Override this to add game logic
	     *
	     * @param deltaTime Time since last frame in milliseconds
	     */
	    update(deltaTime) {
	        if (!this._isActive) {
	            return;
	        }
	        this.emit('update', deltaTime);
	    }
	    /**
	     * Render the scene
	     * Default implementation renders the Pixi container
	     *
	     * @param renderer The renderer instance
	     */
	    render(renderer) {
	        if (!this._isActive || !this.container) {
	            return;
	        }
	        // Get Pixi renderer and render container
	        const pixiRenderer = renderer.getRenderer();
	        if (pixiRenderer && pixiRenderer.render) {
	            pixiRenderer.render(this.container);
	        }
	        this.emit('render', renderer);
	    }
	    /**
	     * Clean up scene resources
	     * Override this to add cleanup logic
	     */
	    destroy() {
	        this.emit('destroying');
	        if (this.container) {
	            this.container.destroy({ children: true });
	        }
	        this.removeAllListeners();
	        this.initialized = false;
	        this._isActive = false;
	        this.emit('destroyed');
	    }
	}
	/**
	 * Base scene implementation for 3D games (Three.js)
	 *
	 * Provides:
	 * - Three.js scene management
	 * - Camera management
	 * - Lifecycle methods
	 * - Ready-to-extend base for 3D game scenes
	 *
	 * @example
	 * ```typescript
	 * class Gameplay3DScene extends BaseScene3D {
	 *     constructor() {
	 *         super('gameplay3d', 'Gameplay 3D Scene');
	 *     }
	 *
	 *     async initialize() {
	 *         await super.initialize();
	 *
	 *         // Setup camera
	 *         this.setupCamera(75, 800/600, 0.1, 1000);
	 *         this.camera.position.z = 5;
	 *
	 *         // Add objects to scene
	 *         const geometry = new THREE.BoxGeometry();
	 *         const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
	 *         const cube = new THREE.Mesh(geometry, material);
	 *         this.scene.add(cube);
	 *     }
	 * }
	 * ```
	 */
	class BaseScene3D extends EventEmitter {
	    constructor(id, name) {
	        super();
	        this._isActive = false;
	        this.camera = null;
	        this.initialized = false;
	        this.id = id;
	        this.name = name;
	        this.scene = new THREE__namespace.Scene();
	    }
	    /**
	     * Whether the scene is currently active
	     */
	    get isActive() {
	        return this._isActive;
	    }
	    /**
	     * Get the Three.js scene
	     */
	    getScene() {
	        return this.scene;
	    }
	    /**
	     * Get the camera
	     */
	    getCamera() {
	        return this.camera;
	    }
	    /**
	     * Setup a perspective camera
	     */
	    setupCamera(fov = 75, aspect = 1, near = 0.1, far = 1000) {
	        this.camera = new THREE__namespace.PerspectiveCamera(fov, aspect, near, far);
	    }
	    /**
	     * Setup an orthographic camera
	     */
	    setupOrthographicCamera(left, right, top, bottom, near = 0.1, far = 1000) {
	        this.camera = new THREE__namespace.OrthographicCamera(left, right, top, bottom, near, far);
	    }
	    /**
	     * Initialize the scene
	     * Override this in your scene to add initialization logic
	     */
	    async initialize() {
	        if (this.initialized) {
	            return;
	        }
	        this.emit('initializing');
	        // Override in subclass to add game objects and setup camera
	        this.initialized = true;
	        this.emit('initialized');
	    }
	    /**
	     * Called when the scene becomes active
	     * Override this to add activation logic
	     */
	    activate() {
	        this._isActive = true;
	        this.emit('activated');
	    }
	    /**
	     * Called when the scene becomes inactive
	     * Override this to add deactivation logic
	     */
	    deactivate() {
	        this._isActive = false;
	        this.emit('deactivated');
	    }
	    /**
	     * Update the scene logic
	     * Override this to add game logic
	     *
	     * @param deltaTime Time since last frame in milliseconds
	     */
	    update(deltaTime) {
	        if (!this._isActive) {
	            return;
	        }
	        this.emit('update', deltaTime);
	    }
	    /**
	     * Render the scene
	     * Default implementation sets the scene and camera on the renderer
	     *
	     * @param renderer The renderer instance
	     */
	    render(renderer) {
	        if (!this._isActive || !this.scene || !this.camera) {
	            return;
	        }
	        // Set scene and camera on renderer
	        if (renderer.setScene) {
	            renderer.setScene(this.scene);
	        }
	        if (renderer.setCamera && this.camera) {
	            renderer.setCamera(this.camera);
	        }
	        this.emit('render', renderer);
	    }
	    /**
	     * Clean up scene resources
	     * Override this to add cleanup logic
	     */
	    destroy() {
	        this.emit('destroying');
	        // Dispose of Three.js objects
	        this.scene.traverse((object) => {
	            if (object instanceof THREE__namespace.Mesh) {
	                if (object.geometry) {
	                    object.geometry.dispose();
	                }
	                if (object.material) {
	                    if (Array.isArray(object.material)) {
	                        object.material.forEach(mat => mat.dispose());
	                    }
	                    else {
	                        object.material.dispose();
	                    }
	                }
	            }
	        });
	        this.scene.clear();
	        this.camera = null;
	        this.removeAllListeners();
	        this.initialized = false;
	        this._isActive = false;
	        this.emit('destroyed');
	    }
	}

	/**
	 * Abstract base class for service providers with common functionality.
	 */
	class AbstractServiceProvider {
	    constructor() {
	        this.deferred = false;
	    }
	    boot(app) {
	        // Default empty implementation
	    }
	    provides() {
	        return [];
	    }
	    isDeferred() {
	        return this.deferred;
	    }
	}

	/**
	 * Audio system performance tiers for mobile optimization
	 */
	exports.AudioPerformanceTier = void 0;
	(function (AudioPerformanceTier) {
	    AudioPerformanceTier["LOW"] = "low";
	    AudioPerformanceTier["MEDIUM"] = "medium";
	    AudioPerformanceTier["HIGH"] = "high";
	    AudioPerformanceTier["PREMIUM"] = "premium";
	})(exports.AudioPerformanceTier || (exports.AudioPerformanceTier = {}));
	/**
	 * Audio quality levels for adaptive audio
	 */
	exports.AudioQuality = void 0;
	(function (AudioQuality) {
	    AudioQuality["LOW"] = "low";
	    AudioQuality["MEDIUM"] = "medium";
	    AudioQuality["HIGH"] = "high";
	    AudioQuality["LOSSLESS"] = "lossless";
	})(exports.AudioQuality || (exports.AudioQuality = {}));
	/**
	 * Audio bus types for mixing system
	 */
	exports.AudioBusType = void 0;
	(function (AudioBusType) {
	    AudioBusType["MASTER"] = "master";
	    AudioBusType["MUSIC"] = "music";
	    AudioBusType["SFX"] = "sfx";
	    AudioBusType["VOICE"] = "voice";
	    AudioBusType["UI"] = "ui";
	    AudioBusType["AMBIENT"] = "ambient";
	    AudioBusType["CUSTOM"] = "custom";
	})(exports.AudioBusType || (exports.AudioBusType = {}));
	/**
	 * Spatial audio distance models
	 */
	exports.DistanceModel = void 0;
	(function (DistanceModel) {
	    DistanceModel["LINEAR"] = "linear";
	    DistanceModel["INVERSE"] = "inverse";
	    DistanceModel["EXPONENTIAL"] = "exponential";
	})(exports.DistanceModel || (exports.DistanceModel = {}));
	/**
	 * Audio environment types for reverb and acoustic modeling
	 */
	exports.AudioEnvironment = void 0;
	(function (AudioEnvironment) {
	    AudioEnvironment["NONE"] = "none";
	    AudioEnvironment["ROOM"] = "room";
	    AudioEnvironment["HALL"] = "hall";
	    AudioEnvironment["CAVE"] = "cave";
	    AudioEnvironment["FOREST"] = "forest";
	    AudioEnvironment["UNDERWATER"] = "underwater";
	    AudioEnvironment["SPACE"] = "space";
	    AudioEnvironment["CUSTOM"] = "custom";
	})(exports.AudioEnvironment || (exports.AudioEnvironment = {}));
	/**
	 * Audio interruption types for mobile handling
	 */
	exports.AudioInterruption = void 0;
	(function (AudioInterruption) {
	    AudioInterruption["PHONE_CALL"] = "phone_call";
	    AudioInterruption["NOTIFICATION"] = "notification";
	    AudioInterruption["SYSTEM_SOUND"] = "system_sound";
	    AudioInterruption["OTHER_APP"] = "other_app";
	    AudioInterruption["HARDWARE"] = "hardware";
	})(exports.AudioInterruption || (exports.AudioInterruption = {}));
	/**
	 * Audio fade types
	 */
	exports.AudioFadeType = void 0;
	(function (AudioFadeType) {
	    AudioFadeType["LINEAR"] = "linear";
	    AudioFadeType["EXPONENTIAL"] = "exponential";
	    AudioFadeType["LOGARITHMIC"] = "logarithmic";
	    AudioFadeType["SMOOTH_STEP"] = "smooth_step";
	})(exports.AudioFadeType || (exports.AudioFadeType = {}));

	/**
	 * Device performance tier categories for mobile optimization
	 */
	exports.DevicePerformanceTier = void 0;
	(function (DevicePerformanceTier) {
	    DevicePerformanceTier["LOW"] = "low";
	    DevicePerformanceTier["MID"] = "mid";
	    DevicePerformanceTier["HIGH"] = "high";
	    DevicePerformanceTier["UNKNOWN"] = "unknown";
	})(exports.DevicePerformanceTier || (exports.DevicePerformanceTier = {}));
	/**
	 * Device thermal state for throttling management
	 */
	exports.DeviceThermalState = void 0;
	(function (DeviceThermalState) {
	    DeviceThermalState["NORMAL"] = "normal";
	    DeviceThermalState["FAIR"] = "fair";
	    DeviceThermalState["SERIOUS"] = "serious";
	    DeviceThermalState["CRITICAL"] = "critical";
	})(exports.DeviceThermalState || (exports.DeviceThermalState = {}));
	/**
	 * Battery optimization modes
	 */
	exports.BatteryOptimizationMode = void 0;
	(function (BatteryOptimizationMode) {
	    BatteryOptimizationMode["PERFORMANCE"] = "performance";
	    BatteryOptimizationMode["BALANCED"] = "balanced";
	    BatteryOptimizationMode["POWER_SAVER"] = "power_saver";
	})(exports.BatteryOptimizationMode || (exports.BatteryOptimizationMode = {}));
	/**
	 * Quality levels for adaptive scaling
	 */
	exports.QualityLevel = void 0;
	(function (QualityLevel) {
	    QualityLevel[QualityLevel["ULTRA_LOW"] = 0] = "ULTRA_LOW";
	    QualityLevel[QualityLevel["LOW"] = 1] = "LOW";
	    QualityLevel[QualityLevel["MEDIUM"] = 2] = "MEDIUM";
	    QualityLevel[QualityLevel["HIGH"] = 3] = "HIGH";
	    QualityLevel[QualityLevel["ULTRA_HIGH"] = 4] = "ULTRA_HIGH";
	})(exports.QualityLevel || (exports.QualityLevel = {}));

	/**
	 * Supported asset types for the GameByte framework.
	 */
	exports.AssetType = void 0;
	(function (AssetType) {
	    AssetType["TEXTURE"] = "texture";
	    AssetType["AUDIO"] = "audio";
	    AssetType["MODEL_3D"] = "model_3d";
	    AssetType["SPRITE"] = "sprite";
	    AssetType["JSON"] = "json";
	    AssetType["FONT"] = "font";
	    AssetType["VIDEO"] = "video";
	    AssetType["BINARY"] = "binary";
	})(exports.AssetType || (exports.AssetType = {}));
	/**
	 * Asset loading states.
	 */
	var AssetLoadingState;
	(function (AssetLoadingState) {
	    AssetLoadingState["PENDING"] = "pending";
	    AssetLoadingState["LOADING"] = "loading";
	    AssetLoadingState["LOADED"] = "loaded";
	    AssetLoadingState["FAILED"] = "failed";
	    AssetLoadingState["CACHED"] = "cached";
	})(AssetLoadingState || (AssetLoadingState = {}));
	/**
	 * Asset loading priority levels.
	 */
	exports.AssetPriority = void 0;
	(function (AssetPriority) {
	    AssetPriority[AssetPriority["LOW"] = 0] = "LOW";
	    AssetPriority[AssetPriority["NORMAL"] = 1] = "NORMAL";
	    AssetPriority[AssetPriority["HIGH"] = 2] = "HIGH";
	    AssetPriority[AssetPriority["CRITICAL"] = 3] = "CRITICAL";
	})(exports.AssetPriority || (exports.AssetPriority = {}));
	/**
	 * Device performance tiers for asset optimization.
	 */
	exports.AssetDevicePerformanceTier = void 0;
	(function (DevicePerformanceTier) {
	    DevicePerformanceTier["LOW"] = "low";
	    DevicePerformanceTier["MEDIUM"] = "medium";
	    DevicePerformanceTier["HIGH"] = "high";
	    DevicePerformanceTier["PREMIUM"] = "premium";
	})(exports.AssetDevicePerformanceTier || (exports.AssetDevicePerformanceTier = {}));
	/**
	 * Cache eviction strategies.
	 */
	exports.CacheEvictionStrategy = void 0;
	(function (CacheEvictionStrategy) {
	    CacheEvictionStrategy["LRU"] = "lru";
	    CacheEvictionStrategy["LFU"] = "lfu";
	    CacheEvictionStrategy["FIFO"] = "fifo";
	    CacheEvictionStrategy["SIZE_BASED"] = "size"; // Evict largest assets first
	})(exports.CacheEvictionStrategy || (exports.CacheEvictionStrategy = {}));

	/**
	 * Unified retry utilities for the GameByte framework.
	 * Provides generic retry logic with exponential backoff.
	 *
	 * @module RetryUtils
	 */
	/**
	 * Default retry options.
	 */
	const DEFAULT_RETRY_OPTIONS = {
	    maxRetries: 3,
	    initialDelay: 1000,
	    maxDelay: 30000,
	    backoffMultiplier: 2,
	};
	/**
	 * Default non-retryable HTTP status codes.
	 * These indicate client errors or authorization issues that won't be fixed by retrying.
	 */
	const DEFAULT_NON_RETRYABLE_STATUSES = [400, 401, 403, 404, 405, 410, 422];
	/**
	 * Default non-retryable error patterns.
	 */
	const DEFAULT_NON_RETRYABLE_ERRORS = [
	    /^404/i,
	    /^403/i,
	    /^401/i,
	    /not found/i,
	    /forbidden/i,
	    /unauthorized/i,
	    /invalid/i,
	];
	/**
	 * Calculate delay for a specific retry attempt using exponential backoff.
	 *
	 * @param attempt - The current attempt number (0-indexed)
	 * @param options - Retry options
	 * @returns Delay in milliseconds
	 */
	function calculateBackoffDelay(attempt, options = {}) {
	    const initialDelay = options.initialDelay ?? DEFAULT_RETRY_OPTIONS.initialDelay;
	    const maxDelay = options.maxDelay ?? DEFAULT_RETRY_OPTIONS.maxDelay;
	    const multiplier = options.backoffMultiplier ?? DEFAULT_RETRY_OPTIONS.backoffMultiplier;
	    // Exponential backoff: initialDelay * multiplier^attempt
	    const delay = initialDelay * Math.pow(multiplier, attempt);
	    // Add some jitter to prevent thundering herd
	    const jitter = delay * 0.1 * Math.random();
	    return Math.min(delay + jitter, maxDelay);
	}
	/**
	 * Check if an error should trigger a retry.
	 *
	 * @param error - The error to check
	 * @param options - Retry options
	 * @returns True if the error is retryable
	 */
	function isRetryableError(error, options = {}) {
	    const errorMessage = error.message;
	    const nonRetryableErrors = options.nonRetryableErrors ?? DEFAULT_NON_RETRYABLE_ERRORS;
	    // Check if error message matches any non-retryable patterns
	    for (const pattern of nonRetryableErrors) {
	        if (pattern.test(errorMessage)) {
	            return false;
	        }
	    }
	    // Check for HTTP status codes in error message
	    const nonRetryableStatuses = options.nonRetryableStatuses ?? DEFAULT_NON_RETRYABLE_STATUSES;
	    for (const status of nonRetryableStatuses) {
	        if (errorMessage.includes(`${status}`) || errorMessage.includes(`HTTP ${status}`)) {
	            return false;
	        }
	    }
	    return true;
	}
	/**
	 * Sleep for a specified duration.
	 *
	 * @param ms - Duration in milliseconds
	 * @returns Promise that resolves after the duration
	 */
	function sleep(ms) {
	    return new Promise((resolve) => setTimeout(resolve, ms));
	}
	/**
	 * Execute an async function with retry logic.
	 *
	 * @param fn - The async function to execute
	 * @param options - Retry options
	 * @returns Promise that resolves with the function result
	 * @throws The last error if all retries are exhausted
	 *
	 * @example
	 * ```typescript
	 * const result = await withRetry(
	 *   () => fetchData(url),
	 *   {
	 *     maxRetries: 3,
	 *     onRetry: (attempt, error, delay) => {
	 *       console.log(`Retry ${attempt} after ${delay}ms: ${error.message}`);
	 *     }
	 *   }
	 * );
	 * ```
	 */
	async function withRetry(fn, options = {}) {
	    const maxRetries = options.maxRetries ?? DEFAULT_RETRY_OPTIONS.maxRetries;
	    let lastError = new Error('Unknown error');
	    for (let attempt = 0; attempt < maxRetries; attempt++) {
	        try {
	            return await fn();
	        }
	        catch (error) {
	            lastError = error;
	            // Check if we should retry
	            if (!isRetryableError(lastError, options)) {
	                throw lastError;
	            }
	            // Check if we have more retries
	            if (attempt < maxRetries - 1) {
	                const delay = calculateBackoffDelay(attempt, options);
	                // Call onRetry callback if provided
	                if (options.onRetry) {
	                    options.onRetry(attempt + 1, lastError, delay);
	                }
	                await sleep(delay);
	            }
	        }
	    }
	    // Call onExhausted callback if provided
	    if (options.onExhausted) {
	        options.onExhausted(lastError, maxRetries);
	    }
	    throw lastError;
	}
	/**
	 * Asset loading specific retry options with sensible defaults.
	 */
	const ASSET_LOADING_RETRY_OPTIONS = {
	    maxRetries: 3,
	    initialDelay: 1000,
	    maxDelay: 10000,
	    backoffMultiplier: 2,
	    nonRetryableStatuses: [400, 401, 403, 404, 405, 410, 422],
	    nonRetryableErrors: [
	        /^404/i,
	        /^403/i,
	        /^401/i,
	        /not found/i,
	        /forbidden/i,
	        /unauthorized/i,
	    ],
	};

	/**
	 * Abstract base class for asset loaders with common functionality.
	 */
	class BaseAssetLoader extends EventEmitter {
	    constructor() {
	        super(...arguments);
	        this.loadingAssets = new Map();
	        this.progressMap = new Map();
	    }
	    /**
	     * Check if this loader can handle the given asset type.
	     */
	    canLoad(type) {
	        return this.supportedTypes.includes(type);
	    }
	    /**
	     * Get loading progress for an asset.
	     */
	    getProgress(assetId) {
	        return this.progressMap.get(assetId) || null;
	    }
	    /**
	     * Cancel asset loading.
	     */
	    cancel(assetId) {
	        const xhr = this.loadingAssets.get(assetId);
	        if (xhr) {
	            xhr.abort();
	            this.loadingAssets.delete(assetId);
	            this.progressMap.delete(assetId);
	            this.emit('cancelled', assetId);
	        }
	    }
	    /**
	     * Clean up resources.
	     */
	    destroy() {
	        // Cancel all ongoing loads
	        for (const [assetId] of this.loadingAssets) {
	            this.cancel(assetId);
	        }
	        this.loadingAssets.clear();
	        this.progressMap.clear();
	        this.removeAllListeners();
	    }
	    /**
	     * Create an XMLHttpRequest with common configuration.
	     */
	    createXHR(config) {
	        const xhr = new XMLHttpRequest();
	        // Configure timeout
	        if (config.options?.timeout) {
	            xhr.timeout = config.options.timeout;
	        }
	        // Configure cross-origin (note: crossOrigin is not a standard XHR property)
	        // This would typically be handled by the server's CORS headers
	        return xhr;
	    }
	    /**
	     * Setup progress tracking for an asset.
	     */
	    setupProgressTracking(xhr, config) {
	        const assetId = config.id;
	        // Initialize progress
	        this.progressMap.set(assetId, {
	            assetId,
	            progress: 0,
	            loaded: 0,
	            total: config.size || 0,
	            state: AssetLoadingState.LOADING
	        });
	        // Track upload progress if available
	        if (xhr.upload) {
	            xhr.upload.addEventListener('progress', (event) => {
	                this.updateProgress(assetId, event);
	            });
	        }
	        // Track download progress
	        xhr.addEventListener('progress', (event) => {
	            this.updateProgress(assetId, event);
	        });
	        // Handle load completion
	        xhr.addEventListener('load', () => {
	            this.updateProgress(assetId, { loaded: xhr.response?.byteLength || 0, total: xhr.response?.byteLength || 0 });
	        });
	        // Handle errors
	        xhr.addEventListener('error', () => {
	            const progress = this.progressMap.get(assetId);
	            if (progress) {
	                progress.state = AssetLoadingState.FAILED;
	                this.emit('progress', progress);
	            }
	        });
	    }
	    /**
	     * Update loading progress for an asset.
	     */
	    updateProgress(assetId, event) {
	        const progress = this.progressMap.get(assetId);
	        if (!progress)
	            return;
	        progress.loaded = event.loaded;
	        progress.total = event.total || progress.total;
	        progress.progress = progress.total > 0 ? event.loaded / progress.total : 0;
	        this.emit('progress', progress);
	    }
	    /**
	     * Load data using XMLHttpRequest with retry logic.
	     * Uses centralized RetryUtils for retry handling.
	     */
	    async loadWithXHR(config, responseType = 'blob', processor) {
	        const retryOptions = {
	            ...ASSET_LOADING_RETRY_OPTIONS,
	            maxRetries: config.options?.maxRetries || ASSET_LOADING_RETRY_OPTIONS.maxRetries,
	        };
	        return withRetry(async () => {
	            const data = await this.performXHRRequest(config, responseType);
	            return processor ? await processor(data) : data;
	        }, retryOptions);
	    }
	    /**
	     * Perform the actual XMLHttpRequest.
	     */
	    performXHRRequest(config, responseType) {
	        return new Promise((resolve, reject) => {
	            const xhr = this.createXHR(config);
	            // Store reference for cancellation
	            this.loadingAssets.set(config.id, xhr);
	            // Setup progress tracking
	            this.setupProgressTracking(xhr, config);
	            xhr.responseType = responseType;
	            xhr.addEventListener('load', () => {
	                this.loadingAssets.delete(config.id);
	                if (xhr.status >= 200 && xhr.status < 300) {
	                    const progress = this.progressMap.get(config.id);
	                    if (progress) {
	                        progress.state = AssetLoadingState.LOADED;
	                        progress.progress = 1;
	                        this.emit('progress', progress);
	                    }
	                    resolve(xhr.response);
	                }
	                else {
	                    reject(new Error(`HTTP ${xhr.status}: ${xhr.statusText}`));
	                }
	            });
	            xhr.addEventListener('error', () => {
	                this.loadingAssets.delete(config.id);
	                reject(new Error('Network error occurred'));
	            });
	            xhr.addEventListener('timeout', () => {
	                this.loadingAssets.delete(config.id);
	                reject(new Error('Request timeout'));
	            });
	            xhr.addEventListener('abort', () => {
	                this.loadingAssets.delete(config.id);
	                reject(new Error('Request aborted'));
	            });
	            // Set custom headers
	            if (config.options?.headers) {
	                Object.entries(config.options.headers).forEach(([key, value]) => {
	                    xhr.setRequestHeader(key, value);
	                });
	            }
	            xhr.open('GET', config.src);
	            xhr.send();
	        });
	    }
	    /**
	     * Get optimal asset quality based on device capabilities.
	     */
	    getOptimalSource(config, deviceTier = 'medium') {
	        if (!config.sources) {
	            return config.src;
	        }
	        const quality = config.options?.quality || 'auto';
	        if (quality === 'auto') {
	            switch (deviceTier) {
	                case 'low':
	                    return config.sources.low || config.sources.medium || config.src;
	                case 'high':
	                case 'premium':
	                    return config.sources.high || config.sources.medium || config.src;
	                default:
	                    return config.sources.medium || config.src;
	            }
	        }
	        return config.sources[quality] || config.src;
	    }
	}

	/**
	 * Unified format detection utilities for the GameByte framework.
	 * Consolidates texture and audio format detection with caching.
	 *
	 * @module FormatDetectionUtils
	 */
	/**
	 * Cache for format detection results.
	 */
	let cachedTextureFormats = null;
	let cachedAudioFormats = null;
	let cachedSupportedTextureFormatsArray = null;
	let cachedSupportedAudioFormatsArray = null;
	/**
	 * Check if a WebGL extension is supported.
	 */
	function checkWebGLExtension(extensionName) {
	    if (typeof document === 'undefined') {
	        return false;
	    }
	    const canvas = document.createElement('canvas');
	    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
	    if (!gl) {
	        return false;
	    }
	    return !!gl.getExtension(extensionName);
	}
	/**
	 * Detect supported texture formats.
	 */
	function detectTextureFormats() {
	    if (cachedTextureFormats) {
	        return cachedTextureFormats;
	    }
	    if (typeof document === 'undefined') {
	        cachedTextureFormats = {
	            webp: false,
	            avif: false,
	            dxt: false,
	            etc: false,
	            astc: false,
	            png: true,
	            jpeg: true,
	        };
	        return cachedTextureFormats;
	    }
	    const canvas = document.createElement('canvas');
	    canvas.width = canvas.height = 1;
	    // Test modern format support
	    let webpSupported = false;
	    let avifSupported = false;
	    try {
	        webpSupported = canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;
	    }
	    catch {
	        // WebP not supported
	    }
	    try {
	        avifSupported = canvas.toDataURL('image/avif').indexOf('data:image/avif') === 0;
	    }
	    catch {
	        // AVIF not supported
	    }
	    cachedTextureFormats = {
	        webp: webpSupported,
	        avif: avifSupported,
	        dxt: checkWebGLExtension('WEBGL_compressed_texture_s3tc'),
	        etc: checkWebGLExtension('WEBGL_compressed_texture_etc'),
	        astc: checkWebGLExtension('WEBGL_compressed_texture_astc'),
	        png: true, // Always supported
	        jpeg: true, // Always supported
	    };
	    return cachedTextureFormats;
	}
	/**
	 * Get array of supported texture format names.
	 * Ordered by preference (modern formats first).
	 */
	function getSupportedTextureFormats() {
	    if (cachedSupportedTextureFormatsArray) {
	        return cachedSupportedTextureFormatsArray;
	    }
	    const formats = detectTextureFormats();
	    const supported = [];
	    // Add formats in order of preference
	    if (formats.avif)
	        supported.push('avif');
	    if (formats.webp)
	        supported.push('webp');
	    if (formats.astc)
	        supported.push('astc');
	    if (formats.etc)
	        supported.push('etc');
	    if (formats.dxt)
	        supported.push('dxt');
	    // Always supported formats
	    supported.push('jpeg', 'png');
	    cachedSupportedTextureFormatsArray = supported;
	    return supported;
	}
	/**
	 * Detect supported audio formats.
	 */
	function detectAudioFormats() {
	    if (cachedAudioFormats) {
	        return cachedAudioFormats;
	    }
	    if (typeof document === 'undefined') {
	        cachedAudioFormats = {
	            mp3: false,
	            ogg: false,
	            webm: false,
	            aac: false,
	            wav: false,
	        };
	        return cachedAudioFormats;
	    }
	    const audio = document.createElement('audio');
	    // Helper to check audio format support
	    // canPlayType returns "" | "maybe" | "probably"
	    function canPlayType(mimeType) {
	        const result = audio.canPlayType(mimeType);
	        return result !== '';
	    }
	    cachedAudioFormats = {
	        mp3: canPlayType('audio/mpeg;'),
	        ogg: canPlayType('audio/ogg; codecs="vorbis"'),
	        webm: canPlayType('audio/webm; codecs="vorbis"'),
	        aac: canPlayType('audio/aac;'),
	        wav: canPlayType('audio/wav; codecs="1"'),
	    };
	    return cachedAudioFormats;
	}
	/**
	 * Get array of supported audio format names.
	 * Ordered by preference (efficient formats first).
	 */
	function getSupportedAudioFormats() {
	    if (cachedSupportedAudioFormatsArray) {
	        return cachedSupportedAudioFormatsArray;
	    }
	    const formats = detectAudioFormats();
	    const supported = [];
	    // Add formats in order of preference (compressed first)
	    if (formats.ogg)
	        supported.push('ogg');
	    if (formats.webm)
	        supported.push('webm');
	    if (formats.mp3)
	        supported.push('mp3');
	    if (formats.aac)
	        supported.push('aac');
	    if (formats.wav)
	        supported.push('wav');
	    cachedSupportedAudioFormatsArray = supported;
	    return supported;
	}
	/**
	 * Get the best available texture format.
	 */
	function getBestTextureFormat() {
	    const formats = detectTextureFormats();
	    if (formats.avif)
	        return 'avif';
	    if (formats.webp)
	        return 'webp';
	    return 'jpeg';
	}

	/**
	 * Unified device detection utilities for the GameByte framework.
	 * Consolidates all device detection logic with caching for expensive operations.
	 *
	 * @module DeviceDetectionUtils
	 */
	/**
	 * Cache for expensive detection operations.
	 */
	let cachedCapabilities = null;
	let cachedGPUInfo = null;
	let cachedWebGLContext = null;
	/**
	 * Get cached WebGL context for GPU detection.
	 */
	function getWebGLContext() {
	    if (cachedWebGLContext) {
	        return cachedWebGLContext;
	    }
	    if (typeof document === 'undefined') {
	        return null;
	    }
	    const canvas = document.createElement('canvas');
	    cachedWebGLContext = (canvas.getContext('webgl2') ||
	        canvas.getContext('webgl') ||
	        canvas.getContext('experimental-webgl'));
	    return cachedWebGLContext;
	}
	/**
	 * Detect platform from user agent.
	 */
	function detectPlatform() {
	    if (typeof navigator === 'undefined') {
	        return 'web';
	    }
	    const ua = navigator.userAgent.toLowerCase();
	    if (/iphone|ipad|ipod/.test(ua)) {
	        return 'ios';
	    }
	    if (/android/.test(ua)) {
	        return 'android';
	    }
	    return 'web';
	}
	/**
	 * Detect device type based on user agent and screen size.
	 */
	function detectDeviceType() {
	    if (typeof navigator === 'undefined' || typeof screen === 'undefined') {
	        return 'unknown';
	    }
	    const userAgent = navigator.userAgent.toLowerCase();
	    const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent);
	    if (isMobile) {
	        const minDimension = Math.min(screen.width, screen.height);
	        const maxDimension = Math.max(screen.width, screen.height);
	        const aspectRatio = maxDimension / minDimension;
	        // Tablets typically have larger screens and different aspect ratios
	        if (minDimension >= 768 || (minDimension >= 600 && aspectRatio < 2)) {
	            return 'tablet';
	        }
	        return 'mobile';
	    }
	    return 'desktop';
	}
	/**
	 * Estimate device memory if navigator.deviceMemory is not available.
	 */
	function estimateDeviceMemory() {
	    if (typeof navigator === 'undefined') {
	        return 4;
	    }
	    const nav = navigator;
	    if (nav.deviceMemory !== undefined) {
	        return nav.deviceMemory;
	    }
	    const ua = navigator.userAgent.toLowerCase();
	    // Estimates based on user agent patterns
	    if (/iphone|ipad/.test(ua)) {
	        if (/iphone.*15|ipad.*15/.test(ua))
	            return 6; // iPhone 15 series
	        if (/iphone.*14|ipad.*14/.test(ua))
	            return 6; // iPhone 14 series
	        if (/iphone.*13|ipad.*13/.test(ua))
	            return 4; // iPhone 13 series
	        return 3; // Older iPhones
	    }
	    if (/android/.test(ua)) {
	        // Most Android devices have 4-8GB RAM
	        return 4;
	    }
	    // Desktop/other - assume higher memory
	    return 8;
	}
	/**
	 * Get hardware concurrency (number of logical processors).
	 */
	function getHardwareConcurrency() {
	    if (typeof navigator === 'undefined') {
	        return 4;
	    }
	    return navigator.hardwareConcurrency || 4;
	}
	/**
	 * Detect GPU tier based on WebGL renderer information.
	 */
	function detectGPUTier() {
	    if (cachedGPUInfo) {
	        return cachedGPUInfo;
	    }
	    const gl = getWebGLContext();
	    if (!gl) {
	        cachedGPUInfo = { tier: 'none', renderer: 'none' };
	        return cachedGPUInfo;
	    }
	    let renderer = 'unknown';
	    let tier = 'unknown';
	    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
	    if (debugInfo) {
	        renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) || 'unknown';
	        if (/nvidia|geforce/i.test(renderer)) {
	            tier = 'high';
	        }
	        else if (/amd|radeon/i.test(renderer)) {
	            tier = 'high';
	        }
	        else if (/apple/i.test(renderer)) {
	            tier = 'high';
	        }
	        else if (/intel/i.test(renderer)) {
	            tier = 'medium';
	        }
	        else if (/mali|adreno|powerVR/i.test(renderer)) {
	            tier = 'medium';
	        }
	    }
	    cachedGPUInfo = { tier, renderer };
	    return cachedGPUInfo;
	}
	/**
	 * Get WebGL version (0, 1, or 2).
	 */
	function getWebGLVersion() {
	    const gl = getWebGLContext();
	    if (!gl)
	        return 0;
	    if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
	        return 2;
	    }
	    if (typeof WebGLRenderingContext !== 'undefined' && gl instanceof WebGLRenderingContext) {
	        return 1;
	    }
	    return 0;
	}
	/**
	 * Get maximum texture size supported by the GPU.
	 */
	function getMaxTextureSize() {
	    const gl = getWebGLContext();
	    if (!gl)
	        return 0;
	    return gl.getParameter(gl.MAX_TEXTURE_SIZE);
	}
	/**
	 * Get maximum viewport dimensions.
	 */
	function getMaxViewportDims() {
	    const gl = getWebGLContext();
	    if (!gl)
	        return [0, 0];
	    const dims = gl.getParameter(gl.MAX_VIEWPORT_DIMS);
	    return [dims[0], dims[1]];
	}
	/**
	 * Get supported WebGL extensions.
	 */
	function getSupportedExtensions() {
	    const gl = getWebGLContext();
	    if (!gl)
	        return [];
	    return gl.getSupportedExtensions() || [];
	}
	/**
	 * Detect network connection type.
	 */
	function detectConnectionType() {
	    if (typeof navigator === 'undefined') {
	        return '4g';
	    }
	    const nav = navigator;
	    const connection = nav.connection;
	    if (connection?.effectiveType) {
	        const type = connection.effectiveType.toLowerCase();
	        if (type === 'slow-2g')
	            return 'slow-2g';
	        if (type === '2g')
	            return '2g';
	        if (type === '3g')
	            return '3g';
	        if (type === '4g')
	            return '4g';
	        if (type === '5g')
	            return '5g';
	    }
	    return '4g';
	}
	/**
	 * Get screen information.
	 */
	function getScreenInfo() {
	    if (typeof window === 'undefined' || typeof screen === 'undefined') {
	        return { width: 1920, height: 1080, pixelRatio: 1 };
	    }
	    return {
	        width: screen.width,
	        height: screen.height,
	        pixelRatio: window.devicePixelRatio || 1,
	    };
	}
	/**
	 * Check if device has touch screen.
	 */
	function hasTouchScreen() {
	    if (typeof window === 'undefined' || typeof navigator === 'undefined') {
	        return false;
	    }
	    return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
	}
	/**
	 * Check if device supports haptic feedback.
	 */
	function supportsHaptics() {
	    if (typeof navigator === 'undefined') {
	        return false;
	    }
	    return 'vibrate' in navigator;
	}
	/**
	 * Check if Battery API is supported.
	 */
	function supportsBatteryAPI() {
	    if (typeof navigator === 'undefined') {
	        return false;
	    }
	    return 'getBattery' in navigator;
	}
	/**
	 * Check if Thermal API is supported.
	 */
	function supportsThermalAPI() {
	    if (typeof navigator === 'undefined') {
	        return false;
	    }
	    const nav = navigator;
	    return 'connection' in navigator && nav.connection !== undefined && 'thermalState' in (nav.connection || {});
	}
	/**
	 * Calculate device performance tier based on multiple heuristics.
	 */
	function calculatePerformanceTier() {
	    const deviceMemory = estimateDeviceMemory();
	    const hardwareConcurrency = getHardwareConcurrency();
	    const screenInfo = getScreenInfo();
	    const connectionType = detectConnectionType();
	    const gpuInfo = detectGPUTier();
	    // Premium tier: High-end devices
	    if (deviceMemory >= 8 && hardwareConcurrency >= 8 && screenInfo.pixelRatio >= 2) {
	        return exports.AssetDevicePerformanceTier.PREMIUM;
	    }
	    // High tier: Good devices
	    if (deviceMemory >= 6 && hardwareConcurrency >= 6 && gpuInfo.tier === 'high') {
	        return exports.AssetDevicePerformanceTier.HIGH;
	    }
	    // Low tier: Limited devices
	    if (deviceMemory <= 2 || hardwareConcurrency <= 2 || connectionType === 'slow-2g') {
	        return exports.AssetDevicePerformanceTier.LOW;
	    }
	    // Default to medium
	    return exports.AssetDevicePerformanceTier.MEDIUM;
	}
	/**
	 * Calculate performance tier using the Performance contract enum.
	 * This is used by DeviceDetector which uses a different enum.
	 */
	function calculatePerformanceTierForPerformanceContract() {
	    const deviceMemory = estimateDeviceMemory();
	    const hardwareConcurrency = getHardwareConcurrency();
	    const webglVersion = getWebGLVersion();
	    const maxTextureSize = getMaxTextureSize();
	    const deviceType = detectDeviceType();
	    let score = 0;
	    // CPU cores contribution (0-20 points)
	    score += Math.min(hardwareConcurrency * 3, 20);
	    // Memory contribution (0-25 points)
	    if (deviceMemory >= 8)
	        score += 25;
	    else if (deviceMemory >= 4)
	        score += 20;
	    else if (deviceMemory >= 2)
	        score += 15;
	    else
	        score += 10;
	    // WebGL contribution (0-20 points)
	    if (webglVersion === 2)
	        score += 20;
	    else if (webglVersion === 1)
	        score += 15;
	    // Texture size contribution (0-15 points)
	    if (maxTextureSize >= 8192)
	        score += 15;
	    else if (maxTextureSize >= 4096)
	        score += 12;
	    else if (maxTextureSize >= 2048)
	        score += 8;
	    else
	        score += 5;
	    // Device type contribution (0-10 points)
	    if (deviceType === 'desktop')
	        score += 10;
	    else if (deviceType === 'tablet')
	        score += 7;
	    else if (deviceType === 'mobile')
	        score += 5;
	    // Advanced features contribution (0-10 points)
	    let featureScore = 0;
	    if (typeof Worker !== 'undefined')
	        featureScore += 2;
	    if (typeof OffscreenCanvas !== 'undefined')
	        featureScore += 2;
	    if (typeof createImageBitmap !== 'undefined')
	        featureScore += 2;
	    if (typeof WebAssembly !== 'undefined')
	        featureScore += 2;
	    if (getSupportedExtensions().length > 20)
	        featureScore += 2;
	    score += featureScore;
	    // Classify based on total score
	    if (score >= 75)
	        return exports.DevicePerformanceTier.HIGH;
	    if (score >= 50)
	        return exports.DevicePerformanceTier.MID;
	    return exports.DevicePerformanceTier.LOW;
	}
	/**
	 * Get device tier based on audio context capabilities.
	 * Used by AudioLoader for audio-specific tier detection.
	 */
	function getAudioDeviceTier(audioContext) {
	    if (!audioContext)
	        return 'low';
	    const maxChannels = audioContext.destination.maxChannelCount;
	    const sampleRate = audioContext.sampleRate;
	    if (maxChannels >= 8 && sampleRate >= 48000)
	        return 'premium';
	    if (maxChannels >= 6 && sampleRate >= 44100)
	        return 'high';
	    if (maxChannels >= 2)
	        return 'medium';
	    return 'low';
	}
	/**
	 * Get device tier based on screen metrics.
	 * Used by TextureLoader for texture-specific tier detection.
	 */
	function getTextureDeviceTier() {
	    const screenInfo = getScreenInfo();
	    const screenSize = screenInfo.width * screenInfo.height;
	    if (screenInfo.pixelRatio >= 3 && screenSize > 2000000)
	        return 'premium';
	    if (screenInfo.pixelRatio >= 2 && screenSize > 1000000)
	        return 'high';
	    if (screenInfo.pixelRatio >= 1.5)
	        return 'medium';
	    return 'low';
	}
	/**
	 * Get all unified device capabilities.
	 * Results are cached for performance.
	 */
	function getUnifiedDeviceCapabilities() {
	    if (cachedCapabilities) {
	        return cachedCapabilities;
	    }
	    cachedCapabilities = {
	        performanceTier: calculatePerformanceTier(),
	        deviceType: detectDeviceType(),
	        platform: detectPlatform(),
	        availableMemory: estimateDeviceMemory() * 1024, // Convert GB to MB
	        hardwareConcurrency: getHardwareConcurrency(),
	        gpuTier: detectGPUTier().tier,
	        connectionType: detectConnectionType(),
	        screen: getScreenInfo(),
	        webglVersion: getWebGLVersion(),
	        maxTextureSize: getMaxTextureSize(),
	        hasTouchScreen: hasTouchScreen(),
	        supportsWebWorkers: typeof Worker !== 'undefined',
	        supportsOffscreenCanvas: typeof OffscreenCanvas !== 'undefined',
	        supportsImageBitmap: typeof createImageBitmap !== 'undefined',
	        supportsWebAssembly: typeof WebAssembly !== 'undefined',
	        supportsBatteryAPI: supportsBatteryAPI(),
	        supportsThermalAPI: supportsThermalAPI(),
	        supportsHaptics: supportsHaptics(),
	    };
	    return cachedCapabilities;
	}

	/**
	 * Texture asset loader optimized for mobile devices.
	 * Supports automatic format detection, compression, and resolution scaling.
	 */
	class TextureLoader extends BaseAssetLoader {
	    constructor() {
	        super();
	        this.supportedTypes = [exports.AssetType.TEXTURE, exports.AssetType.SPRITE];
	        this.supportedFormats = this.detectSupportedFormats();
	        this.canvas = document.createElement('canvas');
	        this.context = this.canvas.getContext('2d');
	    }
	    /**
	     * Load and process a texture asset.
	     */
	    async load(config) {
	        if (!this.canLoad(config.type)) {
	            throw new Error(`TextureLoader cannot load assets of type: ${config.type}`);
	        }
	        // Get optimal source based on supported formats and device capabilities
	        const optimizedSrc = this.getOptimizedSource(config);
	        const optimizedConfig = { ...config, src: optimizedSrc };
	        try {
	            // Load image data
	            const blob = await this.loadWithXHR(optimizedConfig, 'blob');
	            const image = await this.createImageFromBlob(blob);
	            // Process texture based on options
	            const processed = await this.processTexture(image, config);
	            this.emit('loaded', { assetId: config.id, texture: processed });
	            return processed;
	        }
	        catch (error) {
	            this.emit('failed', { assetId: config.id, error });
	            throw error;
	        }
	    }
	    /**
	     * Create an image element from blob data.
	     */
	    createImageFromBlob(blob) {
	        return new Promise((resolve, reject) => {
	            const image = new Image();
	            const url = URL.createObjectURL(blob);
	            image.onload = () => {
	                URL.revokeObjectURL(url);
	                resolve(image);
	            };
	            image.onerror = () => {
	                URL.revokeObjectURL(url);
	                reject(new Error('Failed to decode image'));
	            };
	            image.src = url;
	        });
	    }
	    /**
	     * Process texture for mobile optimization.
	     */
	    async processTexture(image, config) {
	        const options = config.options || {};
	        // Calculate optimal size for mobile
	        const { width, height } = this.calculateOptimalSize(image.width, image.height, options.maxSize || 2048);
	        // Resize if necessary
	        let processedImage = image;
	        if (width !== image.width || height !== image.height) {
	            processedImage = await this.resizeImage(image, width, height, options.quality || 0.9);
	        }
	        // Detect format
	        const format = this.detectImageFormat(processedImage.src);
	        // Calculate file size estimate
	        const size = this.estimateTextureSize(width, height, format);
	        return {
	            image: processedImage,
	            width,
	            height,
	            format,
	            compressed: format === 'webp' || format === 'avif',
	            size
	        };
	    }
	    /**
	     * Calculate optimal texture size for mobile devices.
	     */
	    calculateOptimalSize(originalWidth, originalHeight, maxSize) {
	        // Ensure power of 2 for better GPU compatibility
	        const nextPowerOf2 = (n) => Math.pow(2, Math.ceil(Math.log2(n)));
	        let width = originalWidth;
	        let height = originalHeight;
	        // Scale down if exceeds max size
	        if (width > maxSize || height > maxSize) {
	            const ratio = Math.min(maxSize / width, maxSize / height);
	            width = Math.floor(width * ratio);
	            height = Math.floor(height * ratio);
	        }
	        // Optimize for power of 2 (optional, for WebGL compatibility)
	        const devicePixelRatio = window.devicePixelRatio || 1;
	        if (devicePixelRatio < 2) {
	            // On lower DPI devices, use power of 2 textures for better performance
	            width = Math.min(nextPowerOf2(width), maxSize);
	            height = Math.min(nextPowerOf2(height), maxSize);
	        }
	        return { width, height };
	    }
	    /**
	     * Resize image using canvas with quality optimization.
	     */
	    async resizeImage(image, width, height, quality) {
	        this.canvas.width = width;
	        this.canvas.height = height;
	        // Use better interpolation for high-quality scaling
	        this.context.imageSmoothingEnabled = true;
	        this.context.imageSmoothingQuality = 'high';
	        // Draw resized image
	        this.context.drawImage(image, 0, 0, width, height);
	        // Convert to optimized format
	        const format = this.getBestFormat();
	        const dataUrl = this.canvas.toDataURL(`image/${format}`, quality);
	        return this.createImageFromDataUrl(dataUrl);
	    }
	    /**
	     * Create image from data URL.
	     */
	    createImageFromDataUrl(dataUrl) {
	        return new Promise((resolve, reject) => {
	            const image = new Image();
	            image.onload = () => resolve(image);
	            image.onerror = () => reject(new Error('Failed to create image from data URL'));
	            image.src = dataUrl;
	        });
	    }
	    /**
	     * Get optimized source URL based on supported formats.
	     */
	    getOptimizedSource(config) {
	        if (!config.sources) {
	            return config.src;
	        }
	        // Prefer modern formats if supported
	        if (this.supportedFormats.avif && config.sources.high?.includes('.avif')) {
	            return config.sources.high;
	        }
	        if (this.supportedFormats.webp && config.sources.medium?.includes('.webp')) {
	            return config.sources.medium;
	        }
	        // Fall back to device-appropriate quality
	        return this.getOptimalSource(config, this.getDeviceTier());
	    }
	    /**
	     * Get the best supported format for encoding.
	     * Uses centralized FormatDetectionUtils.
	     */
	    getBestFormat() {
	        return getBestTextureFormat();
	    }
	    /**
	     * Detect supported texture formats.
	     * Uses centralized FormatDetectionUtils.
	     */
	    detectSupportedFormats() {
	        return detectTextureFormats();
	    }
	    /**
	     * Detect image format from source URL.
	     */
	    detectImageFormat(src) {
	        const extension = src.split('.').pop()?.toLowerCase();
	        switch (extension) {
	            case 'webp': return 'webp';
	            case 'avif': return 'avif';
	            case 'png': return 'png';
	            case 'jpg':
	            case 'jpeg': return 'jpeg';
	            default: return 'unknown';
	        }
	    }
	    /**
	     * Estimate texture memory size.
	     */
	    estimateTextureSize(width, height, format) {
	        let bytesPerPixel = 4; // RGBA default
	        switch (format) {
	            case 'webp':
	            case 'avif':
	                bytesPerPixel = 3; // Compressed formats use less memory
	                break;
	            case 'jpeg':
	                bytesPerPixel = 3; // RGB
	                break;
	            case 'png':
	                bytesPerPixel = 4; // RGBA
	                break;
	        }
	        return width * height * bytesPerPixel;
	    }
	    /**
	     * Get device performance tier for optimization.
	     * Uses centralized DeviceDetectionUtils.
	     */
	    getDeviceTier() {
	        return getTextureDeviceTier();
	    }
	    /**
	     * Clean up canvas resources.
	     */
	    destroy() {
	        super.destroy();
	        this.canvas.width = this.canvas.height = 0;
	    }
	}

	/**
	 * Audio asset loader optimized for mobile devices.
	 * Supports multiple formats, streaming, and Web Audio API integration.
	 */
	class AudioLoader extends BaseAssetLoader {
	    constructor() {
	        super();
	        this.supportedTypes = [exports.AssetType.AUDIO];
	        this.audioContext = null;
	        this.supportedFormats = this.detectSupportedFormats();
	        this.initializeAudioContext();
	    }
	    /**
	     * Load and process an audio asset.
	     */
	    async load(config) {
	        if (!this.canLoad(config.type)) {
	            throw new Error(`AudioLoader cannot load assets of type: ${config.type}`);
	        }
	        if (!this.audioContext) {
	            throw new Error('AudioContext not available');
	        }
	        // Get optimal source based on supported formats
	        const optimizedSrc = this.getOptimizedSource(config);
	        const optimizedConfig = { ...config, src: optimizedSrc };
	        try {
	            // Load audio data
	            const arrayBuffer = await this.loadWithXHR(optimizedConfig, 'arraybuffer');
	            // Decode audio buffer
	            const audioBuffer = await this.decodeAudioData(arrayBuffer);
	            // Process audio based on options
	            const processed = await this.processAudio(audioBuffer, config);
	            this.emit('loaded', { assetId: config.id, audio: processed });
	            return processed;
	        }
	        catch (error) {
	            this.emit('failed', { assetId: config.id, error });
	            throw error;
	        }
	    }
	    /**
	     * Initialize Web Audio API context.
	     */
	    initializeAudioContext() {
	        try {
	            // Create audio context with mobile-friendly settings
	            const AudioContextClass = window.AudioContext || window.webkitAudioContext;
	            if (AudioContextClass) {
	                this.audioContext = new AudioContextClass({
	                    latencyHint: 'interactive',
	                    sampleRate: 44100 // Standard sample rate for compatibility
	                });
	                // Handle iOS audio context requirements
	                this.setupIOSAudioUnlock();
	            }
	        }
	        catch (error) {
	            console.warn('Web Audio API not supported:', error);
	        }
	    }
	    /**
	     * Setup iOS audio context unlock on user interaction.
	     */
	    setupIOSAudioUnlock() {
	        if (!this.audioContext)
	            return;
	        const unlockAudio = () => {
	            if (this.audioContext && this.audioContext.state === 'suspended') {
	                this.audioContext.resume().then(() => {
	                    document.removeEventListener('touchstart', unlockAudio);
	                    document.removeEventListener('touchend', unlockAudio);
	                    document.removeEventListener('click', unlockAudio);
	                });
	            }
	        };
	        // Add event listeners for user interaction
	        document.addEventListener('touchstart', unlockAudio);
	        document.addEventListener('touchend', unlockAudio);
	        document.addEventListener('click', unlockAudio);
	    }
	    /**
	     * Decode audio data using Web Audio API.
	     */
	    async decodeAudioData(arrayBuffer) {
	        if (!this.audioContext) {
	            throw new Error('AudioContext not available');
	        }
	        try {
	            return await this.audioContext.decodeAudioData(arrayBuffer);
	        }
	        catch (error) {
	            // Fallback for older browsers
	            return new Promise((resolve, reject) => {
	                this.audioContext.decodeAudioData(arrayBuffer, resolve, reject);
	            });
	        }
	    }
	    /**
	     * Process audio buffer with optimization options.
	     */
	    async processAudio(audioBuffer, config) {
	        const options = config.options || {};
	        let processedBuffer = audioBuffer;
	        // Apply audio processing if needed
	        if (options.normalize || options.fade) {
	            processedBuffer = await this.applyAudioEffects(audioBuffer, options);
	        }
	        // Detect format from source
	        const format = this.detectAudioFormat(config.src);
	        // Calculate estimated size
	        const size = this.estimateAudioSize(processedBuffer);
	        return {
	            buffer: processedBuffer,
	            duration: processedBuffer.duration,
	            sampleRate: processedBuffer.sampleRate,
	            numberOfChannels: processedBuffer.numberOfChannels,
	            size,
	            format,
	            compressed: ['mp3', 'ogg', 'webm', 'aac'].includes(format)
	        };
	    }
	    /**
	     * Apply audio effects like normalization and fade.
	     */
	    async applyAudioEffects(audioBuffer, options) {
	        if (!this.audioContext)
	            return audioBuffer;
	        // Create new buffer for processing
	        const processedBuffer = this.audioContext.createBuffer(audioBuffer.numberOfChannels, audioBuffer.length, audioBuffer.sampleRate);
	        // Process each channel
	        for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
	            const inputData = audioBuffer.getChannelData(channel);
	            const outputData = processedBuffer.getChannelData(channel);
	            // Copy original data
	            outputData.set(inputData);
	            // Apply normalization
	            if (options.normalize) {
	                this.normalizeAudioChannel(outputData);
	            }
	            // Apply fade effects
	            if (options.fade) {
	                this.applyFadeEffects(outputData, audioBuffer.sampleRate, options.fade);
	            }
	        }
	        return processedBuffer;
	    }
	    /**
	     * Normalize audio channel volume.
	     */
	    normalizeAudioChannel(channelData) {
	        // Find peak amplitude
	        let peak = 0;
	        for (let i = 0; i < channelData.length; i++) {
	            peak = Math.max(peak, Math.abs(channelData[i]));
	        }
	        // Normalize to prevent clipping (leave some headroom)
	        if (peak > 0) {
	            const normalizeRatio = 0.95 / peak;
	            for (let i = 0; i < channelData.length; i++) {
	                channelData[i] *= normalizeRatio;
	            }
	        }
	    }
	    /**
	     * Apply fade in/out effects.
	     */
	    applyFadeEffects(channelData, sampleRate, fade) {
	        const { in: fadeIn, out: fadeOut } = fade;
	        // Apply fade in
	        if (fadeIn && fadeIn > 0) {
	            const fadeInSamples = Math.min(fadeIn * sampleRate, channelData.length);
	            for (let i = 0; i < fadeInSamples; i++) {
	                const ratio = i / fadeInSamples;
	                channelData[i] *= ratio;
	            }
	        }
	        // Apply fade out
	        if (fadeOut && fadeOut > 0) {
	            const fadeOutSamples = Math.min(fadeOut * sampleRate, channelData.length);
	            const startIndex = channelData.length - fadeOutSamples;
	            for (let i = 0; i < fadeOutSamples; i++) {
	                const ratio = 1 - (i / fadeOutSamples);
	                channelData[startIndex + i] *= ratio;
	            }
	        }
	    }
	    /**
	     * Get optimized source URL based on supported formats.
	     */
	    getOptimizedSource(config) {
	        if (!config.sources) {
	            return config.src;
	        }
	        const options = config.options || {};
	        const quality = options.quality || 'medium';
	        // Try to find the best supported format
	        const formats = ['ogg', 'webm', 'mp3', 'aac'];
	        for (const format of formats) {
	            if (this.supportedFormats[format]) {
	                const sourceKey = this.getSourceKeyForQuality(quality);
	                const source = config.sources[sourceKey];
	                if (source && source.includes(`.${format}`)) {
	                    return source;
	                }
	            }
	        }
	        // Fall back to device-appropriate quality
	        return this.getOptimalSource(config, this.getDeviceTier());
	    }
	    /**
	     * Get source key based on quality setting.
	     */
	    getSourceKeyForQuality(quality) {
	        switch (quality) {
	            case 'low': return 'low';
	            case 'high': return 'high';
	            default: return 'medium';
	        }
	    }
	    /**
	     * Detect supported audio formats.
	     * Uses centralized FormatDetectionUtils.
	     */
	    detectSupportedFormats() {
	        return detectAudioFormats();
	    }
	    /**
	     * Detect audio format from source URL.
	     */
	    detectAudioFormat(src) {
	        const extension = src.split('.').pop()?.toLowerCase();
	        switch (extension) {
	            case 'mp3': return 'mp3';
	            case 'ogg': return 'ogg';
	            case 'webm': return 'webm';
	            case 'aac':
	            case 'm4a': return 'aac';
	            case 'wav': return 'wav';
	            default: return 'unknown';
	        }
	    }
	    /**
	     * Estimate audio memory size.
	     */
	    estimateAudioSize(audioBuffer) {
	        // Uncompressed audio size: samples * channels * bytes per sample
	        return audioBuffer.length * audioBuffer.numberOfChannels * 4; // Float32 = 4 bytes
	    }
	    /**
	     * Get device performance tier.
	     * Uses centralized DeviceDetectionUtils.
	     */
	    getDeviceTier() {
	        return getAudioDeviceTier(this.audioContext);
	    }
	    /**
	     * Get audio context for advanced audio processing.
	     */
	    getAudioContext() {
	        return this.audioContext;
	    }
	    /**
	     * Clean up audio context and resources.
	     */
	    destroy() {
	        super.destroy();
	        if (this.audioContext && this.audioContext.close) {
	            this.audioContext.close();
	            this.audioContext = null;
	        }
	    }
	}

	/**
	 * JSON asset loader with validation and transformation capabilities.
	 * Optimized for configuration files, game data, and API responses.
	 */
	class JSONLoader extends BaseAssetLoader {
	    constructor() {
	        super(...arguments);
	        this.supportedTypes = [exports.AssetType.JSON];
	    }
	    /**
	     * Load and process a JSON asset.
	     */
	    async load(config) {
	        if (!this.canLoad(config.type)) {
	            throw new Error(`JSONLoader cannot load assets of type: ${config.type}`);
	        }
	        try {
	            // Load JSON data as text for better control
	            const text = await this.loadWithXHR(config, 'text');
	            // Process JSON with options
	            const processed = await this.processJSON(text, config);
	            this.emit('loaded', { assetId: config.id, json: processed });
	            return processed;
	        }
	        catch (error) {
	            this.emit('failed', { assetId: config.id, error });
	            throw error;
	        }
	    }
	    /**
	     * Process JSON text with validation and transformation.
	     */
	    async processJSON(text, config) {
	        const options = config.options || {};
	        // Check size limits
	        if (options.maxSize && text.length > options.maxSize) {
	            throw new Error(`JSON size (${text.length} bytes) exceeds maximum allowed size (${options.maxSize} bytes)`);
	        }
	        // Detect compression
	        const compressed = this.detectCompression(text);
	        // Parse JSON
	        let data;
	        try {
	            data = this.parseJSON(text, options.strict);
	        }
	        catch (error) {
	            throw new Error(`JSON parsing failed: ${error.message}`);
	        }
	        // Apply transformation if provided
	        if (options.transform) {
	            try {
	                data = options.transform(data);
	            }
	            catch (error) {
	                throw new Error(`JSON transformation failed: ${error.message}`);
	            }
	        }
	        // Validate against schema if provided
	        const validation = options.schema ? this.validateJSON(data, options.schema) : { valid: true };
	        // Generate metadata
	        const metadata = this.generateMetadata(data);
	        return {
	            data,
	            size: text.length,
	            compressed,
	            valid: validation.valid,
	            validationErrors: validation.errors,
	            metadata
	        };
	    }
	    /**
	     * Parse JSON with optional strict mode.
	     */
	    parseJSON(text, strict = false) {
	        if (strict) {
	            // Strict parsing: no comments, trailing commas, etc.
	            return JSON.parse(text);
	        }
	        // Relaxed parsing: handle common JSON extensions
	        const cleanedText = this.cleanJSON(text);
	        return JSON.parse(cleanedText);
	    }
	    /**
	     * Clean JSON text to handle common extensions.
	     */
	    cleanJSON(text) {
	        // Remove single-line comments
	        text = text.replace(/\/\/.*$/gm, '');
	        // Remove multi-line comments
	        text = text.replace(/\/\*[\s\S]*?\*\//g, '');
	        // Remove trailing commas (basic implementation)
	        text = text.replace(/,(\s*[}\]])/g, '$1');
	        return text;
	    }
	    /**
	     * Validate JSON data against schema.
	     */
	    validateJSON(data, schema) {
	        const errors = [];
	        if (!this.validateValue(data, schema, '', errors)) {
	            return { valid: false, errors };
	        }
	        return { valid: true };
	    }
	    /**
	     * Validate a value against a schema.
	     */
	    validateValue(value, schema, path, errors) {
	        let valid = true;
	        // Type validation
	        if (schema.type) {
	            const actualType = this.getValueType(value);
	            if (actualType !== schema.type) {
	                errors.push(`${path}: Expected type '${schema.type}', got '${actualType}'`);
	                valid = false;
	            }
	        }
	        // Enum validation
	        if (schema.enum && !schema.enum.includes(value)) {
	            errors.push(`${path}: Value must be one of: ${schema.enum.join(', ')}`);
	            valid = false;
	        }
	        // String validations
	        if (typeof value === 'string') {
	            if (schema.minLength !== undefined && value.length < schema.minLength) {
	                errors.push(`${path}: String length must be at least ${schema.minLength}`);
	                valid = false;
	            }
	            if (schema.maxLength !== undefined && value.length > schema.maxLength) {
	                errors.push(`${path}: String length must not exceed ${schema.maxLength}`);
	                valid = false;
	            }
	        }
	        // Number validations
	        if (typeof value === 'number') {
	            if (schema.minimum !== undefined && value < schema.minimum) {
	                errors.push(`${path}: Value must be at least ${schema.minimum}`);
	                valid = false;
	            }
	            if (schema.maximum !== undefined && value > schema.maximum) {
	                errors.push(`${path}: Value must not exceed ${schema.maximum}`);
	                valid = false;
	            }
	        }
	        // Object validations
	        if (schema.type === 'object' && typeof value === 'object' && value !== null) {
	            if (schema.required) {
	                for (const requiredKey of schema.required) {
	                    if (!(requiredKey in value)) {
	                        errors.push(`${path}: Missing required property '${requiredKey}'`);
	                        valid = false;
	                    }
	                }
	            }
	            if (schema.properties) {
	                for (const [key, subSchema] of Object.entries(schema.properties)) {
	                    if (key in value) {
	                        const subPath = path ? `${path}.${key}` : key;
	                        if (!this.validateValue(value[key], subSchema, subPath, errors)) {
	                            valid = false;
	                        }
	                    }
	                }
	            }
	        }
	        // Array validations
	        if (schema.type === 'array' && Array.isArray(value)) {
	            if (schema.items) {
	                value.forEach((item, index) => {
	                    const subPath = `${path}[${index}]`;
	                    if (!this.validateValue(item, schema.items, subPath, errors)) {
	                        valid = false;
	                    }
	                });
	            }
	        }
	        return valid;
	    }
	    /**
	     * Get the type of a value for validation.
	     */
	    getValueType(value) {
	        if (value === null)
	            return 'null';
	        if (Array.isArray(value))
	            return 'array';
	        return typeof value;
	    }
	    /**
	     * Detect if JSON might be compressed (simple heuristic).
	     */
	    detectCompression(text) {
	        // Simple heuristics for compression detection
	        const hasMinification = !text.includes('\n') && !text.includes('  ');
	        const hasShortKeys = /\"[a-z]{1,2}\":/g.test(text);
	        const compressionRatio = text.length / (text.match(/[{}[\],:]/g) || []).length;
	        return hasMinification && (hasShortKeys || compressionRatio < 10);
	    }
	    /**
	     * Generate metadata about JSON structure.
	     */
	    generateMetadata(data) {
	        return {
	            keys: this.countKeys(data),
	            depth: this.calculateDepth(data),
	            type: this.getValueType(data)
	        };
	    }
	    /**
	     * Count total number of keys in object structure.
	     */
	    countKeys(obj) {
	        if (typeof obj !== 'object' || obj === null) {
	            return 0;
	        }
	        let count = 0;
	        if (Array.isArray(obj)) {
	            obj.forEach(item => {
	                count += this.countKeys(item);
	            });
	        }
	        else {
	            count = Object.keys(obj).length;
	            Object.values(obj).forEach(value => {
	                count += this.countKeys(value);
	            });
	        }
	        return count;
	    }
	    /**
	     * Calculate maximum depth of nested structure.
	     */
	    calculateDepth(obj, currentDepth = 0) {
	        if (typeof obj !== 'object' || obj === null) {
	            return currentDepth;
	        }
	        let maxDepth = currentDepth;
	        if (Array.isArray(obj)) {
	            obj.forEach(item => {
	                maxDepth = Math.max(maxDepth, this.calculateDepth(item, currentDepth + 1));
	            });
	        }
	        else {
	            Object.values(obj).forEach(value => {
	                maxDepth = Math.max(maxDepth, this.calculateDepth(value, currentDepth + 1));
	            });
	        }
	        return maxDepth;
	    }
	    /**
	     * Parse JSON with error recovery.
	     */
	    static parseWithRecovery(text) {
	        try {
	            return { data: JSON.parse(text) };
	        }
	        catch (error) {
	            // Try to fix common JSON issues
	            try {
	                const loader = new JSONLoader();
	                const cleaned = loader.cleanJSON(text);
	                return { data: JSON.parse(cleaned) };
	            }
	            catch (recoveryError) {
	                return { error: error.message };
	            }
	        }
	    }
	    /**
	     * Validate JSON schema itself.
	     */
	    static validateSchema(schema) {
	        const errors = [];
	        // Basic schema validation
	        if (schema.type && !['object', 'array', 'string', 'number', 'boolean'].includes(schema.type)) {
	            errors.push(`Invalid type: ${schema.type}`);
	        }
	        if (schema.minimum !== undefined && schema.maximum !== undefined) {
	            if (schema.minimum > schema.maximum) {
	                errors.push('Minimum value cannot be greater than maximum value');
	            }
	        }
	        if (schema.minLength !== undefined && schema.maxLength !== undefined) {
	            if (schema.minLength > schema.maxLength) {
	                errors.push('Minimum length cannot be greater than maximum length');
	            }
	        }
	        return errors.length > 0 ? { valid: false, errors } : { valid: true };
	    }
	}

	/**
	 * LRU (Least Recently Used) cache implementation optimized for mobile devices.
	 * Features memory pressure handling, TTL support, and multiple eviction strategies.
	 */
	class LRUCache {
	    constructor(config) {
	        this.cache = new Map();
	        this.accessOrder = [];
	        this.stats = {
	            hits: 0,
	            misses: 0,
	            evictions: 0,
	            totalRequests: 0,
	            currentSize: 0,
	            currentItemCount: 0
	        };
	        this.config = {
	            ...config,
	            evictionStrategy: config.evictionStrategy || exports.CacheEvictionStrategy.LRU
	        };
	        // Start cleanup timer for TTL support
	        if (this.config.ttl) {
	            this.startCleanupTimer();
	        }
	        // Setup memory pressure monitoring
	        this.setupMemoryPressureMonitoring();
	    }
	    /**
	     * Store an asset in cache.
	     */
	    async set(key, asset) {
	        const entry = {
	            asset,
	            accessTime: Date.now(),
	            accessCount: 1,
	            createdAt: Date.now(),
	            size: asset.size,
	            ttl: this.config.ttl ? Date.now() + this.config.ttl : undefined
	        };
	        // Remove existing entry if present
	        if (this.cache.has(key)) {
	            await this.delete(key);
	        }
	        // Check if we need to evict items to make space
	        await this.ensureCapacity(entry.size);
	        // Add new entry
	        this.cache.set(key, entry);
	        this.accessOrder.push(key);
	        this.stats.currentSize += entry.size;
	        this.stats.currentItemCount++;
	        // Check memory pressure after addition
	        this.checkMemoryPressure();
	    }
	    /**
	     * Retrieve an asset from cache.
	     */
	    async get(key) {
	        this.stats.totalRequests++;
	        const entry = this.cache.get(key);
	        if (!entry) {
	            this.stats.misses++;
	            return null;
	        }
	        // Check TTL expiration
	        if (entry.ttl && Date.now() > entry.ttl) {
	            await this.delete(key);
	            this.stats.misses++;
	            return null;
	        }
	        // Update access tracking
	        entry.accessTime = Date.now();
	        entry.accessCount++;
	        // Move to end of access order (most recently used)
	        this.moveToEnd(key);
	        this.stats.hits++;
	        return entry.asset;
	    }
	    /**
	     * Check if asset exists in cache.
	     */
	    async has(key) {
	        const entry = this.cache.get(key);
	        if (!entry) {
	            return false;
	        }
	        // Check TTL expiration
	        if (entry.ttl && Date.now() > entry.ttl) {
	            await this.delete(key);
	            return false;
	        }
	        return true;
	    }
	    /**
	     * Remove asset from cache.
	     */
	    async delete(key) {
	        const entry = this.cache.get(key);
	        if (!entry) {
	            return false;
	        }
	        // Remove from cache and access order
	        this.cache.delete(key);
	        this.removeFromAccessOrder(key);
	        // Update stats
	        this.stats.currentSize -= entry.size;
	        this.stats.currentItemCount--;
	        return true;
	    }
	    /**
	     * Clear all cached assets.
	     */
	    async clear() {
	        this.cache.clear();
	        this.accessOrder = [];
	        this.stats.currentSize = 0;
	        this.stats.currentItemCount = 0;
	    }
	    /**
	     * Get cache statistics.
	     */
	    async getStats() {
	        const hitRate = this.stats.totalRequests > 0
	            ? this.stats.hits / this.stats.totalRequests
	            : 0;
	        const missRate = this.stats.totalRequests > 0
	            ? this.stats.misses / this.stats.totalRequests
	            : 0;
	        return {
	            size: this.stats.currentSize,
	            itemCount: this.stats.currentItemCount,
	            hitRate,
	            missRate
	        };
	    }
	    /**
	     * Evict assets based on cache policy.
	     */
	    async evict(targetSize) {
	        if (targetSize === undefined) {
	            // Evict just one item when no target size is specified (e.g., for maxItems)
	            const evictedKey = this.selectEvictionCandidate();
	            if (evictedKey) {
	                await this.delete(evictedKey);
	                this.stats.evictions++;
	            }
	            return;
	        }
	        const evictTo = targetSize;
	        while (this.stats.currentSize > evictTo && this.cache.size > 0) {
	            const evictedKey = this.selectEvictionCandidate();
	            if (evictedKey) {
	                await this.delete(evictedKey);
	                this.stats.evictions++;
	            }
	            else {
	                break; // No more candidates
	            }
	        }
	    }
	    /**
	     * Destroy cache and cleanup.
	     */
	    async destroy() {
	        if (this.cleanupInterval) {
	            clearInterval(this.cleanupInterval);
	        }
	        await this.clear();
	    }
	    /**
	     * Set memory pressure callback.
	     */
	    setMemoryPressureCallback(callback) {
	        this.memoryPressureCallback = callback;
	    }
	    /**
	     * Ensure cache has capacity for new entry.
	     */
	    async ensureCapacity(requiredSize) {
	        // Check item count limit first
	        if (this.config.maxItems && this.stats.currentItemCount >= this.config.maxItems) {
	            await this.evict();
	            return;
	        }
	        const availableSpace = this.config.maxSize - this.stats.currentSize;
	        if (availableSpace >= requiredSize) {
	            return;
	        }
	        // Calculate how much space we need to free
	        const spaceToFree = requiredSize - availableSpace;
	        const targetSize = this.stats.currentSize - spaceToFree;
	        await this.evict(targetSize);
	    }
	    /**
	     * Select candidate for eviction based on strategy.
	     */
	    selectEvictionCandidate() {
	        if (this.cache.size === 0) {
	            return null;
	        }
	        switch (this.config.evictionStrategy) {
	            case exports.CacheEvictionStrategy.LRU:
	                return this.selectLRUCandidate();
	            case exports.CacheEvictionStrategy.LFU:
	                return this.selectLFUCandidate();
	            case exports.CacheEvictionStrategy.FIFO:
	                return this.selectFIFOCandidate();
	            case exports.CacheEvictionStrategy.SIZE_BASED:
	                return this.selectSizeBasedCandidate();
	            default:
	                return this.selectLRUCandidate();
	        }
	    }
	    /**
	     * Select least recently used item.
	     */
	    selectLRUCandidate() {
	        return this.accessOrder.length > 0 ? this.accessOrder[0] : null;
	    }
	    /**
	     * Select least frequently used item.
	     */
	    selectLFUCandidate() {
	        let minAccessCount = Infinity;
	        let candidate = null;
	        for (const [key, entry] of this.cache) {
	            if (entry.accessCount < minAccessCount) {
	                minAccessCount = entry.accessCount;
	                candidate = key;
	            }
	        }
	        return candidate;
	    }
	    /**
	     * Select oldest item (first in, first out).
	     */
	    selectFIFOCandidate() {
	        let oldestTime = Infinity;
	        let candidate = null;
	        for (const [key, entry] of this.cache) {
	            if (entry.createdAt < oldestTime) {
	                oldestTime = entry.createdAt;
	                candidate = key;
	            }
	        }
	        return candidate;
	    }
	    /**
	     * Select largest item for eviction.
	     */
	    selectSizeBasedCandidate() {
	        let maxSize = 0;
	        let candidate = null;
	        for (const [key, entry] of this.cache) {
	            if (entry.size > maxSize) {
	                maxSize = entry.size;
	                candidate = key;
	            }
	        }
	        return candidate;
	    }
	    /**
	     * Move key to end of access order.
	     */
	    moveToEnd(key) {
	        this.removeFromAccessOrder(key);
	        this.accessOrder.push(key);
	    }
	    /**
	     * Remove key from access order array.
	     */
	    removeFromAccessOrder(key) {
	        const index = this.accessOrder.indexOf(key);
	        if (index > -1) {
	            this.accessOrder.splice(index, 1);
	        }
	    }
	    /**
	     * Start cleanup timer for TTL support.
	     */
	    startCleanupTimer() {
	        const cleanupInterval = Math.min(this.config.ttl / 4, 30000); // Every 1/4 TTL or 30s max
	        this.cleanupInterval = setInterval(async () => {
	            await this.cleanupExpired();
	        }, cleanupInterval);
	    }
	    /**
	     * Remove expired entries.
	     */
	    async cleanupExpired() {
	        const now = Date.now();
	        const expiredKeys = [];
	        for (const [key, entry] of this.cache) {
	            if (entry.ttl && now > entry.ttl) {
	                expiredKeys.push(key);
	            }
	        }
	        for (const key of expiredKeys) {
	            await this.delete(key);
	        }
	    }
	    /**
	     * Setup memory pressure monitoring.
	     */
	    setupMemoryPressureMonitoring() {
	        // Monitor memory usage if Performance API is available
	        if ('memory' in performance) {
	            const checkMemory = () => {
	                this.checkMemoryPressure();
	            };
	            // Check memory every 10 seconds
	            setInterval(checkMemory, 10000);
	        }
	    }
	    /**
	     * Check for memory pressure and trigger callback.
	     */
	    checkMemoryPressure() {
	        if (!this.memoryPressureCallback)
	            return;
	        // Simple heuristic: if cache is using > 90% of allowed space
	        const usageRatio = this.stats.currentSize / this.config.maxSize;
	        if (usageRatio > 0.9) {
	            try {
	                this.memoryPressureCallback(this.stats.currentSize, this.config.maxSize);
	            }
	            catch (error) {
	                // Ignore callback errors to prevent cache operations from failing
	                console.warn('Memory pressure callback error:', error);
	            }
	        }
	        // Advanced memory pressure detection if available
	        if ('memory' in performance) {
	            const memInfo = performance.memory;
	            const memoryUsage = memInfo.usedJSHeapSize / memInfo.jsHeapSizeLimit;
	            if (memoryUsage > 0.8) {
	                try {
	                    this.memoryPressureCallback(memInfo.usedJSHeapSize, memInfo.jsHeapSizeLimit);
	                }
	                catch (error) {
	                    // Ignore callback errors to prevent cache operations from failing
	                    console.warn('Memory pressure callback error:', error);
	                }
	            }
	        }
	    }
	    /**
	     * Get detailed cache information for debugging.
	     */
	    getDebugInfo() {
	        const entries = Array.from(this.cache.entries()).map(([key, entry]) => ({
	            key,
	            size: entry.size,
	            accessCount: entry.accessCount,
	            age: Date.now() - entry.createdAt
	        }));
	        return {
	            entries,
	            accessOrder: [...this.accessOrder],
	            stats: { ...this.stats },
	            config: { ...this.config }
	        };
	    }
	}

	/**
	 * Persistent cache implementation using IndexedDB with LRU fallback.
	 * Provides offline support and persistence across browser sessions.
	 */
	class PersistentCache {
	    constructor(config, dbConfig) {
	        this.db = null;
	        this.initPromise = null;
	        this.config = config;
	        this.isSupported = this.checkIndexedDBSupport();
	        this.dbConfig = {
	            name: 'GameByteAssetCache',
	            version: 1,
	            storeName: 'assets',
	            ...dbConfig
	        };
	        // Create memory cache as fallback
	        this.memoryCache = new LRUCache({
	            ...config,
	            maxSize: Math.min(config.maxSize, 50 * 1024 * 1024), // 50MB max for memory
	            persistent: false
	        });
	        if (this.isSupported && config.persistent) {
	            this.initPromise = this.initializeDatabase();
	        }
	    }
	    /**
	     * Store an asset in both memory and persistent cache.
	     */
	    async set(key, asset) {
	        // Always store in memory cache
	        await this.memoryCache.set(key, asset);
	        // Store in persistent cache if supported and enabled
	        if (this.isSupported && this.config.persistent) {
	            await this.setPersistent(key, asset);
	        }
	    }
	    /**
	     * Retrieve an asset from memory cache first, then persistent cache.
	     */
	    async get(key) {
	        // Try memory cache first (fastest)
	        const memoryAsset = await this.memoryCache.get(key);
	        if (memoryAsset) {
	            return memoryAsset;
	        }
	        // Try persistent cache if available
	        if (this.isSupported && this.config.persistent) {
	            const persistentAsset = await this.getPersistent(key);
	            if (persistentAsset) {
	                // Restore to memory cache for faster future access
	                await this.memoryCache.set(key, persistentAsset);
	                return persistentAsset;
	            }
	        }
	        return null;
	    }
	    /**
	     * Check if asset exists in any cache layer.
	     */
	    async has(key) {
	        // Check memory cache first
	        if (await this.memoryCache.has(key)) {
	            return true;
	        }
	        // Check persistent cache
	        if (this.isSupported && this.config.persistent) {
	            return await this.hasPersistent(key);
	        }
	        return false;
	    }
	    /**
	     * Remove asset from both cache layers.
	     */
	    async delete(key) {
	        let deleted = false;
	        // Delete from memory cache
	        if (await this.memoryCache.delete(key)) {
	            deleted = true;
	        }
	        // Delete from persistent cache
	        if (this.isSupported && this.config.persistent) {
	            if (await this.deletePersistent(key)) {
	                deleted = true;
	            }
	        }
	        return deleted;
	    }
	    /**
	     * Clear both cache layers.
	     */
	    async clear() {
	        await this.memoryCache.clear();
	        if (this.isSupported && this.config.persistent) {
	            await this.clearPersistent();
	        }
	    }
	    /**
	     * Get combined cache statistics.
	     */
	    async getStats() {
	        const memoryStats = await this.memoryCache.getStats();
	        if (!this.isSupported || !this.config.persistent) {
	            return memoryStats;
	        }
	        const persistentStats = await this.getPersistentStats();
	        return {
	            size: memoryStats.size + persistentStats.size,
	            itemCount: memoryStats.itemCount + persistentStats.itemCount,
	            hitRate: (memoryStats.hitRate + persistentStats.hitRate) / 2,
	            missRate: (memoryStats.missRate + persistentStats.missRate) / 2
	        };
	    }
	    /**
	     * Evict assets from both cache layers.
	     */
	    async evict(targetSize) {
	        // Evict from memory cache first
	        await this.memoryCache.evict(targetSize);
	        // Evict from persistent cache if needed
	        if (this.isSupported && this.config.persistent && targetSize) {
	            await this.evictPersistent(targetSize);
	        }
	    }
	    /**
	     * Destroy both cache layers.
	     */
	    async destroy() {
	        await this.memoryCache.destroy();
	        if (this.db) {
	            this.db.close();
	            this.db = null;
	        }
	    }
	    /**
	     * Check if IndexedDB is supported.
	     */
	    checkIndexedDBSupport() {
	        try {
	            return 'indexedDB' in window && indexedDB !== null;
	        }
	        catch {
	            return false;
	        }
	    }
	    /**
	     * Initialize IndexedDB database.
	     */
	    async initializeDatabase() {
	        if (!this.isSupported) {
	            throw new Error('IndexedDB not supported');
	        }
	        return new Promise((resolve, reject) => {
	            const request = indexedDB.open(this.dbConfig.name, this.dbConfig.version);
	            request.onerror = () => {
	                reject(new Error('Failed to open IndexedDB'));
	            };
	            request.onsuccess = () => {
	                this.db = request.result;
	                resolve();
	            };
	            request.onupgradeneeded = (event) => {
	                const db = event.target.result;
	                // Create object store if it doesn't exist
	                if (!db.objectStoreNames.contains(this.dbConfig.storeName)) {
	                    const store = db.createObjectStore(this.dbConfig.storeName, { keyPath: 'key' });
	                    store.createIndex('timestamp', 'timestamp', { unique: false });
	                    store.createIndex('ttl', 'ttl', { unique: false });
	                }
	            };
	        });
	    }
	    /**
	     * Ensure database is initialized.
	     */
	    async ensureDatabase() {
	        if (this.initPromise) {
	            await this.initPromise;
	            this.initPromise = null;
	        }
	        if (!this.db) {
	            throw new Error('Database not initialized');
	        }
	    }
	    /**
	     * Store asset in persistent cache.
	     */
	    async setPersistent(key, asset) {
	        await this.ensureDatabase();
	        const entry = {
	            key,
	            asset: {
	                ...asset,
	                // Don't store the actual data for large assets, just metadata
	                data: asset.size > 1024 * 1024 ? null : asset.data
	            },
	            timestamp: Date.now(),
	            ttl: this.config.ttl ? Date.now() + this.config.ttl : undefined,
	            version: this.config.version || '1.0.0'
	        };
	        return new Promise((resolve, reject) => {
	            const transaction = this.db.transaction([this.dbConfig.storeName], 'readwrite');
	            const store = transaction.objectStore(this.dbConfig.storeName);
	            const request = store.put(entry);
	            request.onsuccess = () => resolve();
	            request.onerror = () => reject(new Error('Failed to store in persistent cache'));
	        });
	    }
	    /**
	     * Retrieve asset from persistent cache.
	     */
	    async getPersistent(key) {
	        await this.ensureDatabase();
	        return new Promise((resolve, reject) => {
	            const transaction = this.db.transaction([this.dbConfig.storeName], 'readonly');
	            const store = transaction.objectStore(this.dbConfig.storeName);
	            const request = store.get(key);
	            request.onsuccess = () => {
	                const entry = request.result;
	                if (!entry) {
	                    resolve(null);
	                    return;
	                }
	                // Check TTL expiration
	                if (entry.ttl && Date.now() > entry.ttl) {
	                    this.deletePersistent(key); // Fire and forget cleanup
	                    resolve(null);
	                    return;
	                }
	                // Check version compatibility
	                if (this.config.version && entry.version !== this.config.version) {
	                    this.deletePersistent(key); // Fire and forget cleanup
	                    resolve(null);
	                    return;
	                }
	                resolve(entry.asset);
	            };
	            request.onerror = () => reject(new Error('Failed to retrieve from persistent cache'));
	        });
	    }
	    /**
	     * Check if asset exists in persistent cache.
	     */
	    async hasPersistent(key) {
	        const asset = await this.getPersistent(key);
	        return asset !== null;
	    }
	    /**
	     * Delete asset from persistent cache.
	     */
	    async deletePersistent(key) {
	        await this.ensureDatabase();
	        return new Promise((resolve, reject) => {
	            const transaction = this.db.transaction([this.dbConfig.storeName], 'readwrite');
	            const store = transaction.objectStore(this.dbConfig.storeName);
	            const request = store.delete(key);
	            request.onsuccess = () => resolve(true);
	            request.onerror = () => reject(new Error('Failed to delete from persistent cache'));
	        });
	    }
	    /**
	     * Clear all persistent cache entries.
	     */
	    async clearPersistent() {
	        await this.ensureDatabase();
	        return new Promise((resolve, reject) => {
	            const transaction = this.db.transaction([this.dbConfig.storeName], 'readwrite');
	            const store = transaction.objectStore(this.dbConfig.storeName);
	            const request = store.clear();
	            request.onsuccess = () => resolve();
	            request.onerror = () => reject(new Error('Failed to clear persistent cache'));
	        });
	    }
	    /**
	     * Get persistent cache statistics.
	     */
	    async getPersistentStats() {
	        await this.ensureDatabase();
	        return new Promise((resolve, reject) => {
	            const transaction = this.db.transaction([this.dbConfig.storeName], 'readonly');
	            const store = transaction.objectStore(this.dbConfig.storeName);
	            let totalSize = 0;
	            let itemCount = 0;
	            const request = store.openCursor();
	            request.onsuccess = (event) => {
	                const cursor = event.target.result;
	                if (cursor) {
	                    const entry = cursor.value;
	                    totalSize += entry.asset.size;
	                    itemCount++;
	                    cursor.continue();
	                }
	                else {
	                    resolve({
	                        size: totalSize,
	                        itemCount,
	                        hitRate: 0, // Would need separate tracking
	                        missRate: 0 // Would need separate tracking
	                    });
	                }
	            };
	            request.onerror = () => reject(new Error('Failed to get persistent cache stats'));
	        });
	    }
	    /**
	     * Evict assets from persistent cache.
	     */
	    async evictPersistent(targetSize) {
	        await this.ensureDatabase();
	        // Get all entries sorted by timestamp (oldest first)
	        const entries = await this.getAllPersistentEntries();
	        entries.sort((a, b) => a.timestamp - b.timestamp);
	        let currentSize = entries.reduce((sum, entry) => sum + entry.asset.size, 0);
	        // Remove entries until we're under target size
	        for (const entry of entries) {
	            if (currentSize <= targetSize)
	                break;
	            await this.deletePersistent(entry.key);
	            currentSize -= entry.asset.size;
	        }
	    }
	    /**
	     * Get all persistent cache entries.
	     */
	    async getAllPersistentEntries() {
	        await this.ensureDatabase();
	        return new Promise((resolve, reject) => {
	            const transaction = this.db.transaction([this.dbConfig.storeName], 'readonly');
	            const store = transaction.objectStore(this.dbConfig.storeName);
	            const entries = [];
	            const request = store.openCursor();
	            request.onsuccess = (event) => {
	                const cursor = event.target.result;
	                if (cursor) {
	                    entries.push(cursor.value);
	                    cursor.continue();
	                }
	                else {
	                    resolve(entries);
	                }
	            };
	            request.onerror = () => reject(new Error('Failed to get all persistent entries'));
	        });
	    }
	    /**
	     * Cleanup expired persistent cache entries.
	     */
	    async cleanupExpired() {
	        if (!this.isSupported || !this.config.persistent) {
	            return 0;
	        }
	        await this.ensureDatabase();
	        const now = Date.now();
	        const entries = await this.getAllPersistentEntries();
	        let cleanedCount = 0;
	        for (const entry of entries) {
	            if (entry.ttl && now > entry.ttl) {
	                await this.deletePersistent(entry.key);
	                cleanedCount++;
	            }
	        }
	        return cleanedCount;
	    }
	}

	/**
	 * Asset bundle implementation for efficient web deployment.
	 * Supports compression, streaming, and dependency resolution.
	 */
	class GameByteAssetBundle {
	    constructor(config) {
	        this.manifest = null;
	        this.loadedAssets = new Map();
	        this.bundleData = null;
	        this.id = config.id;
	        this.name = config.name;
	        this.assets = config.assets;
	        this.metadata = config.metadata;
	        this.dependencies = config.dependencies;
	        this.options = config.options;
	    }
	    /**
	     * Get bundle manifest.
	     */
	    getManifest() {
	        return this.manifest;
	    }
	    /**
	     * Set bundle manifest (used during loading).
	     */
	    setManifest(manifest) {
	        this.manifest = manifest;
	    }
	    /**
	     * Get loaded asset from bundle.
	     */
	    getAsset(assetId) {
	        return this.loadedAssets.get(assetId) || null;
	    }
	    /**
	     * Set loaded asset in bundle.
	     */
	    setAsset(assetId, asset) {
	        this.loadedAssets.set(assetId, asset);
	    }
	    /**
	     * Check if asset is loaded in bundle.
	     */
	    hasAsset(assetId) {
	        return this.loadedAssets.has(assetId);
	    }
	    /**
	     * Get all loaded assets.
	     */
	    getAllAssets() {
	        return new Map(this.loadedAssets);
	    }
	    /**
	     * Get bundle data.
	     */
	    getBundleData() {
	        return this.bundleData;
	    }
	    /**
	     * Set bundle data.
	     */
	    setBundleData(data) {
	        this.bundleData = data;
	    }
	    /**
	     * Extract asset data from bundle.
	     */
	    extractAssetData(assetId) {
	        if (!this.bundleData || !this.manifest) {
	            return null;
	        }
	        const assetEntry = this.manifest.assets.find(asset => asset.id === assetId);
	        if (!assetEntry) {
	            return null;
	        }
	        // Extract asset data using offset and size
	        return this.bundleData.slice(assetEntry.offset, assetEntry.offset + assetEntry.size);
	    }
	    /**
	     * Get bundle statistics.
	     */
	    getStats() {
	        const stats = {
	            totalSize: this.manifest?.totalSize || 0,
	            assetCount: this.assets.length,
	            loadedCount: this.loadedAssets.size,
	            compressionRatio: undefined
	        };
	        if (this.manifest?.compression) {
	            stats.compressionRatio = this.manifest.compression.ratio;
	        }
	        return stats;
	    }
	    /**
	     * Validate bundle integrity.
	     */
	    async validateIntegrity() {
	        const errors = [];
	        if (!this.manifest) {
	            errors.push('Bundle manifest is missing');
	            return { valid: false, errors };
	        }
	        if (!this.bundleData) {
	            errors.push('Bundle data is missing');
	            return { valid: false, errors };
	        }
	        // Validate bundle size
	        if (this.bundleData.byteLength !== this.manifest.totalSize) {
	            errors.push(`Bundle size mismatch: expected ${this.manifest.totalSize}, got ${this.bundleData.byteLength}`);
	        }
	        // Validate asset count
	        if (this.manifest.assets.length !== this.assets.length) {
	            errors.push(`Asset count mismatch: expected ${this.assets.length}, got ${this.manifest.assets.length}`);
	        }
	        // Validate individual assets
	        for (const assetEntry of this.manifest.assets) {
	            const assetData = this.extractAssetData(assetEntry.id);
	            if (!assetData) {
	                errors.push(`Failed to extract asset: ${assetEntry.id}`);
	                continue;
	            }
	            if (assetData.byteLength !== assetEntry.size) {
	                errors.push(`Asset size mismatch for ${assetEntry.id}: expected ${assetEntry.size}, got ${assetData.byteLength}`);
	            }
	            // Verify checksum if available
	            if (assetEntry.checksum) {
	                const calculatedChecksum = await this.calculateChecksum(assetData);
	                if (calculatedChecksum !== assetEntry.checksum) {
	                    errors.push(`Checksum mismatch for ${assetEntry.id}`);
	                }
	            }
	        }
	        return { valid: errors.length === 0, errors };
	    }
	    /**
	     * Calculate checksum for data.
	     */
	    async calculateChecksum(data) {
	        if ('crypto' in window && 'subtle' in crypto) {
	            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
	            const hashArray = Array.from(new Uint8Array(hashBuffer));
	            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
	        }
	        // Fallback: simple hash
	        const view = new Uint8Array(data);
	        let hash = 0;
	        for (let i = 0; i < view.length; i++) {
	            hash = ((hash << 5) - hash + view[i]) & 0xffffffff;
	        }
	        return hash.toString(16);
	    }
	    /**
	     * Unload bundle and free memory.
	     */
	    unload() {
	        this.loadedAssets.clear();
	        this.bundleData = null;
	        this.manifest = null;
	    }
	}

	/**
	 * Device detection and capabilities assessment system
	 * Analyzes device hardware and capabilities for optimization
	 */
	class DeviceDetector extends EventEmitter {
	    constructor() {
	        super(...arguments);
	        this.capabilities = null;
	        this.gl = null;
	        this.performanceTier = exports.DevicePerformanceTier.UNKNOWN;
	        this.thermalState = exports.DeviceThermalState.NORMAL;
	        this.thermalMonitorInterval = null;
	    }
	    /**
	     * Initialize device detection
	     */
	    async initialize() {
	        this.capabilities = await this.detectCapabilities();
	        this.performanceTier = this.calculatePerformanceTier();
	        this.startThermalMonitoring();
	        this.emit('initialized', this.capabilities);
	    }
	    /**
	     * Get device capabilities
	     */
	    getCapabilities() {
	        return this.capabilities;
	    }
	    /**
	     * Get device performance tier
	     */
	    getPerformanceTier() {
	        return this.performanceTier;
	    }
	    /**
	     * Get current thermal state
	     */
	    getThermalState() {
	        return this.thermalState;
	    }
	    /**
	     * Force re-detection of capabilities
	     */
	    async refresh() {
	        this.capabilities = await this.detectCapabilities();
	        this.performanceTier = this.calculatePerformanceTier();
	        this.emit('capabilities-updated', this.capabilities);
	    }
	    /**
	     * Detect comprehensive device capabilities.
	     * Uses centralized DeviceDetectionUtils for most detection.
	     */
	    async detectCapabilities() {
	        const canvas = document.createElement('canvas');
	        this.gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
	        const screenInfo = getScreenInfo();
	        const capabilities = {
	            // Hardware info - using centralized utilities
	            deviceType: detectDeviceType(),
	            performanceTier: exports.DevicePerformanceTier.UNKNOWN, // Will be calculated later
	            cores: getHardwareConcurrency(),
	            memory: estimateDeviceMemory() * 1024, // Convert GB to MB
	            // Graphics capabilities - using centralized utilities
	            webglVersion: getWebGLVersion(),
	            maxTextureSize: getMaxTextureSize(),
	            maxViewportDims: getMaxViewportDims(),
	            supportedExtensions: getSupportedExtensions(),
	            // Display info
	            pixelRatio: screenInfo.pixelRatio,
	            screenSize: {
	                width: screenInfo.width,
	                height: screenInfo.height,
	            },
	            refreshRate: this.getRefreshRate(),
	            // Battery and thermal - using centralized utilities
	            supportsBatteryAPI: supportsBatteryAPI(),
	            supportsThermalAPI: supportsThermalAPI(),
	            // Performance features
	            supportsWebWorkers: typeof Worker !== 'undefined',
	            supportsOffscreenCanvas: typeof OffscreenCanvas !== 'undefined',
	            supportsImageBitmap: typeof createImageBitmap !== 'undefined',
	            supportsWebAssembly: typeof WebAssembly !== 'undefined',
	        };
	        canvas.remove();
	        return capabilities;
	    }
	    /**
	     * Get display refresh rate
	     */
	    getRefreshRate() {
	        // Try to detect refresh rate using requestAnimationFrame timing
	        let refreshRate = 60; // Default fallback
	        if ('getDisplayMedia' in navigator.mediaDevices) {
	            // Modern browsers might have display info
	            try {
	                const displayInfo = screen.orientation || {};
	                refreshRate = displayInfo.refreshRate || 60;
	            }
	            catch (e) {
	                // Fallback to 60Hz
	            }
	        }
	        return refreshRate;
	    }
	    /**
	     * Calculate performance tier based on detected capabilities.
	     * Uses centralized utility for consistent tier calculation across the framework.
	     */
	    calculatePerformanceTier() {
	        if (!this.capabilities)
	            return exports.DevicePerformanceTier.UNKNOWN;
	        // Use centralized performance tier calculation
	        return calculatePerformanceTierForPerformanceContract();
	    }
	    /**
	     * Start monitoring thermal state
	     */
	    startThermalMonitoring() {
	        if (!this.capabilities?.supportsThermalAPI)
	            return;
	        // Monitor thermal state every 5 seconds
	        this.thermalMonitorInterval = window.setInterval(() => {
	            this.updateThermalState();
	        }, 5000);
	    }
	    /**
	     * Update thermal state from system APIs
	     */
	    updateThermalState() {
	        try {
	            const connection = navigator.connection;
	            if (connection && 'thermalState' in connection) {
	                const thermalState = connection.thermalState;
	                switch (thermalState) {
	                    case 'nominal':
	                        this.thermalState = exports.DeviceThermalState.NORMAL;
	                        break;
	                    case 'fair':
	                        this.thermalState = exports.DeviceThermalState.FAIR;
	                        break;
	                    case 'serious':
	                        this.thermalState = exports.DeviceThermalState.SERIOUS;
	                        break;
	                    case 'critical':
	                        this.thermalState = exports.DeviceThermalState.CRITICAL;
	                        break;
	                    default:
	                        this.thermalState = exports.DeviceThermalState.NORMAL;
	                }
	                this.emit('thermal-state-changed', this.thermalState);
	            }
	        }
	        catch (error) {
	            // Thermal API not available or failed
	        }
	    }
	    /**
	     * Run performance benchmark to refine tier detection
	     */
	    async runPerformanceBenchmark() {
	        return new Promise((resolve) => {
	            const canvas = document.createElement('canvas');
	            canvas.width = 512;
	            canvas.height = 512;
	            const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
	            if (!gl) {
	                resolve(0);
	                return;
	            }
	            // Simple rendering benchmark
	            const startTime = performance.now();
	            let frames = 0;
	            const maxFrames = 100;
	            const renderFrame = () => {
	                gl.clear(gl.COLOR_BUFFER_BIT);
	                // Draw some geometry to stress test
	                const vertices = new Float32Array([
	                    -1, -1, 1, -1, 0, 1,
	                    -1, -1, 0, 1, -1, 1
	                ]);
	                const buffer = gl.createBuffer();
	                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
	                frames++;
	                if (frames < maxFrames) {
	                    requestAnimationFrame(renderFrame);
	                }
	                else {
	                    const endTime = performance.now();
	                    const totalTime = endTime - startTime;
	                    const fps = (frames * 1000) / totalTime;
	                    canvas.remove();
	                    resolve(fps);
	                }
	            };
	            renderFrame();
	        });
	    }
	    /**
	     * Get device-specific optimization recommendations
	     */
	    getOptimizationRecommendations() {
	        const recommendations = [];
	        if (!this.capabilities)
	            return recommendations;
	        switch (this.performanceTier) {
	            case exports.DevicePerformanceTier.LOW:
	                recommendations.push('Enable aggressive culling');
	                recommendations.push('Reduce texture quality');
	                recommendations.push('Limit particle effects');
	                recommendations.push('Reduce shadow quality');
	                recommendations.push('Enable object pooling');
	                break;
	            case exports.DevicePerformanceTier.MID:
	                recommendations.push('Enable moderate culling');
	                recommendations.push('Use medium texture quality');
	                recommendations.push('Limit complex shaders');
	                recommendations.push('Enable batching');
	                break;
	            case exports.DevicePerformanceTier.HIGH:
	                recommendations.push('Enable all visual effects');
	                recommendations.push('Use high-quality textures');
	                recommendations.push('Enable advanced lighting');
	                break;
	        }
	        if (this.capabilities.deviceType === 'mobile') {
	            recommendations.push('Enable battery optimization');
	            recommendations.push('Reduce background processing');
	            recommendations.push('Use touch-optimized controls');
	        }
	        if (this.thermalState !== exports.DeviceThermalState.NORMAL) {
	            recommendations.push('Enable thermal throttling');
	            recommendations.push('Reduce rendering complexity');
	        }
	        return recommendations;
	    }
	    /**
	     * Clean up resources
	     */
	    destroy() {
	        if (this.thermalMonitorInterval) {
	            clearInterval(this.thermalMonitorInterval);
	            this.thermalMonitorInterval = null;
	        }
	        this.removeAllListeners();
	        this.capabilities = null;
	        this.gl = null;
	    }
	    // ============================================
	    // Static utility methods for synchronous usage
	    // ============================================
	    /**
	     * Quick synchronous device tier detection
	     * Use this when you need immediate tier info without full initialization
	     */
	    static detectTierSync() {
	        const memory = navigator.deviceMemory || 4;
	        const cores = navigator.hardwareConcurrency || 4;
	        const isMobile = DeviceDetector.isMobileDevice();
	        if (isMobile) {
	            if (memory <= 2 || cores <= 2)
	                return 'low';
	            if (memory <= 4 || cores <= 4)
	                return 'medium';
	            return 'high';
	        }
	        else {
	            if (memory <= 4 || cores <= 2)
	                return 'medium';
	            return 'high';
	        }
	    }
	    /**
	     * Check if running on mobile device
	     */
	    static isMobileDevice() {
	        return /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(navigator.userAgent.toLowerCase());
	    }
	    /**
	     * Check if running on tablet
	     */
	    static isTabletDevice() {
	        const userAgent = navigator.userAgent.toLowerCase();
	        const isMobile = /android|ipad/i.test(userAgent);
	        if (!isMobile)
	            return false;
	        const minDim = Math.min(screen.width, screen.height);
	        const maxDim = Math.max(screen.width, screen.height);
	        const aspectRatio = maxDim / minDim;
	        return minDim >= 768 || (minDim >= 600 && aspectRatio < 2);
	    }
	    /**
	     * Get device type synchronously
	     */
	    static getDeviceTypeSync() {
	        if (DeviceDetector.isTabletDevice())
	            return 'tablet';
	        if (DeviceDetector.isMobileDevice())
	            return 'mobile';
	        return 'desktop';
	    }
	    /**
	     * Get CPU core count
	     */
	    static getCoreCount() {
	        return navigator.hardwareConcurrency || 2;
	    }
	    /**
	     * Get estimated device memory in GB
	     */
	    static getDeviceMemory() {
	        return navigator.deviceMemory || 4;
	    }
	    /**
	     * Check if touch is supported
	     */
	    static hasTouchSupport() {
	        return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
	    }
	    /**
	     * Get screen dimensions
	     */
	    static getScreenSize() {
	        return {
	            width: screen.width,
	            height: screen.height
	        };
	    }
	    /**
	     * Get pixel ratio
	     */
	    static getPixelRatio() {
	        return window.devicePixelRatio || 1;
	    }
	}

	/**
	 * Main asset manager implementation for the GameByte framework.
	 * Provides comprehensive asset loading, caching, and optimization for mobile games.
	 *
	 * @example Load a single texture
	 * ```typescript
	 * const assetManager = game.make('assets');
	 * const texture = await assetManager.load({
	 *   key: 'player',
	 *   type: 'texture',
	 *   src: 'assets/player.png'
	 * });
	 * ```
	 *
	 * @example Batch load with progress
	 * ```typescript
	 * assetManager.on('progress', (progress) => {
	 *   console.log(`Loading: ${Math.round(progress * 100)}%`);
	 * });
	 *
	 * const assets = await assetManager.loadBatch([
	 *   { key: 'player', type: 'texture', src: 'assets/player.png' },
	 *   { key: 'bgMusic', type: 'audio', src: 'assets/music.mp3' },
	 *   { key: 'level1', type: 'json', src: 'assets/level1.json' }
	 * ]);
	 * ```
	 *
	 * @example Get cached asset
	 * ```typescript
	 * const texture = assetManager.get('player');
	 * if (texture) {
	 *   sprite.texture = texture.data;
	 * }
	 * ```
	 */
	class GameByteAssetManager extends EventEmitter {
	    constructor(config) {
	        super();
	        this.loaders = new Map();
	        this.loadedAssets = new Map();
	        this.loadingQueue = [];
	        this.activeLoads = new Set();
	        this.batchContext = null;
	        this.memoryUsage = { total: 0, cached: 0, active: 0 };
	        this.queueProcessorInterval = null;
	        this.config = {
	            maxConcurrentLoads: 6,
	            defaultTimeout: 30000,
	            defaultRetries: 3,
	            autoMemoryOptimization: true,
	            memoryPressureThreshold: 0.8,
	            ...config
	        };
	        // Initialize cache
	        this.cache = this.createCache(this.config.cache);
	        // Setup memory pressure monitoring
	        if (this.cache instanceof LRUCache || this.cache instanceof PersistentCache) {
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Cache interface doesn't define optional method
	            this.cache.setMemoryPressureCallback?.((usage, limit) => {
	                this.emit('memory:pressure', usage, limit);
	                if (this.config.autoMemoryOptimization) {
	                    this.optimizeMemory();
	                }
	            });
	        }
	        // Detect device capabilities
	        this.deviceCapabilities = config.deviceCapabilities || this.detectDeviceCapabilities();
	        // Register default loaders
	        this.registerDefaultLoaders();
	        // Start processing queue
	        this.startQueueProcessor();
	    }
	    /**
	     * Load a single asset.
	     */
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Generic default allows flexible API
	    async load(config) {
	        // Check if already loaded
	        const existing = this.loadedAssets.get(config.id);
	        if (existing) {
	            this.emit('cache:hit', config.id);
	            return existing;
	        }
	        // Check cache
	        const cached = await this.cache.get(config.id);
	        if (cached) {
	            this.loadedAssets.set(config.id, cached);
	            this.emit('cache:hit', config.id);
	            return cached;
	        }
	        // Cache miss - emit event
	        this.emit('cache:miss', config.id);
	        // Check if already in queue
	        const existingEntry = this.loadingQueue.find(e => e.config.id === config.id);
	        if (existingEntry) {
	            return existingEntry.promise;
	        }
	        // Add to loading queue
	        // Create entry first without promise
	        /* eslint-disable @typescript-eslint/no-explicit-any -- Promise constructor circular dependency pattern */
	        const entry = {
	            config: this.optimizeAssetConfig(config),
	            priority: config.options?.priority || exports.AssetPriority.NORMAL,
	            resolve: null,
	            reject: null,
	            retries: 0,
	            promise: null,
	        };
	        /* eslint-enable @typescript-eslint/no-explicit-any */
	        // Now create the promise and set resolve/reject on entry
	        const promise = new Promise((resolve, reject) => {
	            entry.resolve = resolve;
	            entry.reject = reject;
	        });
	        // Set the promise on the entry AFTER it's created
	        entry.promise = promise;
	        this.loadingQueue.push(entry);
	        this.sortLoadingQueue();
	        this.processQueue();
	        return promise;
	    }
	    /**
	     * Load multiple assets in batch.
	     */
	    async loadBatch(configs) {
	        const batchId = `batch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
	        this.batchContext = {
	            id: batchId,
	            totalAssets: configs.length,
	            loadedAssets: 0,
	            failedAssets: 0,
	            results: new Map(),
	            errors: new Map(),
	            startTime: Date.now()
	        };
	        this.emit('batch:started', configs.length);
	        try {
	            // Load all assets
	            const loadPromises = configs.map(async (config) => {
	                try {
	                    const asset = await this.load(config);
	                    const ctx = this.batchContext; // Store local reference
	                    if (ctx) {
	                        ctx.results.set(config.id, asset);
	                        ctx.loadedAssets++;
	                    }
	                    this.updateBatchProgress();
	                    return { id: config.id, asset, error: null };
	                }
	                catch (error) {
	                    const ctx = this.batchContext; // Store local reference
	                    if (ctx) {
	                        ctx.errors.set(config.id, error);
	                        ctx.failedAssets++;
	                    }
	                    this.updateBatchProgress();
	                    return { id: config.id, asset: null, error: error };
	                }
	            });
	            await Promise.allSettled(loadPromises);
	            const results = this.batchContext.results;
	            this.emit('batch:completed', results);
	            return results;
	        }
	        finally {
	            this.batchContext = null;
	        }
	    }
	    /**
	     * Load an asset bundle.
	     */
	    async loadBundle(bundle) {
	        this.emit('bundle:started', bundle.id);
	        try {
	            // Load bundle data if not already loaded
	            if (bundle instanceof GameByteAssetBundle && !bundle.getBundleData()) {
	                await this.loadBundleData(bundle);
	            }
	            // Load individual assets from bundle
	            const results = new Map();
	            for (const assetConfig of bundle.assets) {
	                try {
	                    let asset;
	                    // Try to extract from bundle first
	                    if (bundle instanceof GameByteAssetBundle) {
	                        const extractedData = bundle.extractAssetData(assetConfig.id);
	                        if (extractedData) {
	                            asset = await this.loadAssetFromData(assetConfig, extractedData);
	                        }
	                        else {
	                            asset = await this.load(assetConfig);
	                        }
	                    }
	                    else {
	                        asset = await this.load(assetConfig);
	                    }
	                    results.set(assetConfig.id, asset);
	                    // Store in bundle for quick access
	                    if (bundle instanceof GameByteAssetBundle) {
	                        bundle.setAsset(assetConfig.id, asset);
	                    }
	                }
	                catch (error) {
	                    console.warn(`Failed to load asset ${assetConfig.id} from bundle ${bundle.id}:`, error);
	                }
	            }
	            this.emit('bundle:completed', bundle.id, results);
	            return results;
	        }
	        catch (error) {
	            this.emit('bundle:failed', bundle.id, error);
	            throw error;
	        }
	    }
	    /**
	     * Get a loaded asset.
	     */
	    get(assetId) {
	        return this.loadedAssets.get(assetId) || null;
	    }
	    /**
	     * Check if asset is loaded.
	     */
	    has(assetId) {
	        return this.loadedAssets.has(assetId);
	    }
	    /**
	     * Unload an asset.
	     */
	    unload(assetId) {
	        const asset = this.loadedAssets.get(assetId);
	        if (!asset)
	            return false;
	        this.loadedAssets.delete(assetId);
	        this.cache.delete(assetId);
	        this.updateMemoryUsage();
	        this.emit('asset:unloaded', assetId);
	        return true;
	    }
	    /**
	     * Unload multiple assets.
	     */
	    unloadBatch(assetIds) {
	        let unloaded = 0;
	        for (const assetId of assetIds) {
	            if (this.unload(assetId)) {
	                unloaded++;
	            }
	        }
	        return unloaded;
	    }
	    /**
	     * Preload assets in background.
	     */
	    async preload(configs) {
	        const preloadConfigs = configs.map(config => ({
	            ...config,
	            options: {
	                ...config.options,
	                preload: true,
	                priority: exports.AssetPriority.LOW
	            }
	        }));
	        // Load in background without waiting
	        this.loadBatch(preloadConfigs).catch(error => {
	            console.warn('Preload failed:', error);
	        });
	    }
	    /**
	     * Get loading progress for batch operations.
	     */
	    getBatchProgress() {
	        if (!this.batchContext)
	            return null;
	        const progress = this.batchContext.totalAssets > 0
	            ? (this.batchContext.loadedAssets + this.batchContext.failedAssets) / this.batchContext.totalAssets
	            : 0;
	        return {
	            totalAssets: this.batchContext.totalAssets,
	            loadedAssets: this.batchContext.loadedAssets,
	            failedAssets: this.batchContext.failedAssets,
	            progress,
	            assetProgress: new Map() // Would need to track individual progress
	        };
	    }
	    /**
	     * Get asset loading progress.
	     */
	    getProgress(assetId) {
	        // Check active loaders for progress
	        for (const loader of this.loaders.values()) {
	            const progress = loader.getProgress?.(assetId);
	            if (progress)
	                return progress;
	        }
	        return null;
	    }
	    /**
	     * Cancel asset loading.
	     */
	    cancel(assetId) {
	        // Remove from queue
	        this.loadingQueue = this.loadingQueue.filter(entry => entry.config.id !== assetId);
	        // Cancel active loading
	        for (const loader of this.loaders.values()) {
	            loader.cancel?.(assetId);
	        }
	        this.activeLoads.delete(assetId);
	    }
	    /**
	     * Register a custom asset loader.
	     */
	    registerLoader(loader) {
	        for (const type of loader.supportedTypes) {
	            this.loaders.set(type, loader);
	        }
	    }
	    /**
	     * Get cache instance.
	     */
	    getCache() {
	        return this.cache;
	    }
	    /**
	     * Get current memory usage.
	     */
	    getMemoryUsage() {
	        return { ...this.memoryUsage };
	    }
	    /**
	     * Set memory pressure callback for custom memory management.
	     */
	    setMemoryPressureCallback(callback) {
	        if (this.cache instanceof LRUCache || this.cache instanceof PersistentCache) {
	            this.cache.setMemoryPressureCallback?.(callback);
	        }
	    }
	    /**
	     * Optimize memory usage based on device constraints.
	     */
	    async optimizeMemory() {
	        const currentUsage = this.memoryUsage.total;
	        const memoryLimit = this.getMemoryLimit();
	        if (currentUsage > memoryLimit * this.config.memoryPressureThreshold) {
	            // Aggressive cache eviction
	            await this.cache.evict(Math.floor(memoryLimit * 0.6));
	            // Remove unused assets from memory
	            const unusedAssets = [];
	            for (const [assetId, asset] of this.loadedAssets) {
	                // Simple heuristic: remove assets loaded more than 5 minutes ago
	                if (Date.now() - asset.loadedAt > 5 * 60 * 1000) {
	                    unusedAssets.push(assetId);
	                }
	            }
	            const freedBytes = this.unloadBatch(unusedAssets);
	            this.emit('memory:optimized', freedBytes);
	        }
	    }
	    /**
	     * Destroy and cleanup all resources.
	     */
	    async destroy() {
	        // Stop queue processor
	        if (this.queueProcessorInterval) {
	            clearInterval(this.queueProcessorInterval);
	            this.queueProcessorInterval = null;
	        }
	        // Cancel all pending loads - wrap rejections to prevent unhandled promise rejections
	        const rejectionPromises = [];
	        for (const entry of this.loadingQueue) {
	            try {
	                entry.reject(new Error('Asset manager destroyed'));
	                rejectionPromises.push(entry.promise.catch(() => { })); // Catch and ignore the rejection
	            }
	            catch (error) {
	                // Ignore synchronous errors during rejection
	            }
	            if (entry.timeout) {
	                clearTimeout(entry.timeout);
	            }
	        }
	        // Wait for all rejections to be processed
	        await Promise.allSettled(rejectionPromises);
	        this.loadingQueue = [];
	        this.activeLoads.clear();
	        // Destroy loaders
	        for (const loader of this.loaders.values()) {
	            loader.destroy?.();
	        }
	        // Destroy cache
	        await this.cache.destroy();
	        // Clear loaded assets
	        this.loadedAssets.clear();
	        // Reset memory usage tracking
	        this.memoryUsage = { total: 0, cached: 0, active: 0 };
	        this.removeAllListeners();
	    }
	    /**
	     * Create cache instance based on configuration.
	     */
	    createCache(config) {
	        if (config.persistent) {
	            return new PersistentCache(config);
	        }
	        else {
	            return new LRUCache(config);
	        }
	    }
	    /**
	     * Register default asset loaders.
	     */
	    registerDefaultLoaders() {
	        this.registerLoader(new TextureLoader());
	        this.registerLoader(new AudioLoader());
	        this.registerLoader(new JSONLoader());
	    }
	    /**
	     * Detect device capabilities using centralized DeviceDetector.
	     */
	    detectDeviceCapabilities() {
	        const screenSize = DeviceDetector.getScreenSize();
	        const nav = navigator;
	        const connectionType = nav.connection?.effectiveType || '4g';
	        // Use centralized DeviceDetector for hardware info
	        const deviceMemory = DeviceDetector.getDeviceMemory();
	        const cores = DeviceDetector.getCoreCount();
	        // Map DeviceDetector tier to AssetManager's DevicePerformanceTier
	        let performanceTier = exports.AssetDevicePerformanceTier.MEDIUM;
	        const tier = DeviceDetector.detectTierSync();
	        if (tier === 'high') {
	            // Check if it qualifies for PREMIUM
	            if (deviceMemory >= 8 && cores >= 8) {
	                performanceTier = exports.AssetDevicePerformanceTier.PREMIUM;
	            }
	            else {
	                performanceTier = exports.AssetDevicePerformanceTier.HIGH;
	            }
	        }
	        else if (tier === 'low') {
	            performanceTier = exports.AssetDevicePerformanceTier.LOW;
	        }
	        return {
	            performanceTier,
	            availableMemory: deviceMemory * 1024, // Convert to MB
	            gpuTier: 'unknown', // Would need WebGL detection
	            supportedTextureFormats: this.detectTextureFormats(),
	            supportedAudioFormats: this.detectAudioFormats(),
	            connectionType: connectionType,
	            screen: {
	                width: screenSize.width,
	                height: screenSize.height,
	                pixelRatio: DeviceDetector.getPixelRatio()
	            },
	            platform: this.detectPlatform()
	        };
	    }
	    /**
	     * Detect supported texture formats.
	     */
	    detectTextureFormats() {
	        const formats = [];
	        const canvas = document.createElement('canvas');
	        // Check for WebP support
	        if (canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0) {
	            formats.push('webp');
	        }
	        // Check for AVIF support
	        if (canvas.toDataURL('image/avif').indexOf('data:image/avif') === 0) {
	            formats.push('avif');
	        }
	        formats.push('jpeg', 'png'); // Always supported
	        return formats;
	    }
	    /**
	     * Detect supported audio formats.
	     */
	    detectAudioFormats() {
	        const audio = document.createElement('audio');
	        const formats = [];
	        if (audio.canPlayType('audio/mpeg;'))
	            formats.push('mp3');
	        if (audio.canPlayType('audio/ogg; codecs="vorbis"'))
	            formats.push('ogg');
	        if (audio.canPlayType('audio/webm; codecs="vorbis"'))
	            formats.push('webm');
	        if (audio.canPlayType('audio/aac;'))
	            formats.push('aac');
	        return formats;
	    }
	    /**
	     * Detect platform.
	     */
	    detectPlatform() {
	        const ua = navigator.userAgent.toLowerCase();
	        if (/iphone|ipad|ipod/.test(ua))
	            return 'ios';
	        if (/android/.test(ua))
	            return 'android';
	        return 'web';
	    }
	    /**
	     * Get memory limit based on device capabilities.
	     */
	    getMemoryLimit() {
	        const baseMB = this.deviceCapabilities.availableMemory;
	        // Reserve memory for the browser and other processes
	        switch (this.deviceCapabilities.performanceTier) {
	            case exports.AssetDevicePerformanceTier.LOW:
	                return baseMB * 0.3 * 1024 * 1024; // 30% of available memory
	            case exports.AssetDevicePerformanceTier.MEDIUM:
	                return baseMB * 0.5 * 1024 * 1024; // 50% of available memory
	            case exports.AssetDevicePerformanceTier.HIGH:
	                return baseMB * 0.7 * 1024 * 1024; // 70% of available memory
	            case exports.AssetDevicePerformanceTier.PREMIUM:
	                return baseMB * 0.8 * 1024 * 1024; // 80% of available memory
	            default:
	                return baseMB * 0.5 * 1024 * 1024;
	        }
	    }
	    /**
	     * Optimize asset configuration based on device capabilities.
	     */
	    optimizeAssetConfig(config) {
	        const optimized = { ...config };
	        // Adjust quality based on device tier
	        if (!optimized.options?.quality || optimized.options.quality === 'auto') {
	            switch (this.deviceCapabilities.performanceTier) {
	                case exports.AssetDevicePerformanceTier.LOW:
	                    optimized.options = { ...optimized.options, quality: 'low' };
	                    break;
	                case exports.AssetDevicePerformanceTier.HIGH:
	                case exports.AssetDevicePerformanceTier.PREMIUM:
	                    optimized.options = { ...optimized.options, quality: 'high' };
	                    break;
	                default:
	                    optimized.options = { ...optimized.options, quality: 'medium' };
	            }
	        }
	        // Set default timeout and retries
	        optimized.options = {
	            timeout: this.config.defaultTimeout,
	            maxRetries: this.config.defaultRetries,
	            cache: true,
	            ...optimized.options
	        };
	        return optimized;
	    }
	    /**
	     * Sort loading queue by priority.
	     */
	    sortLoadingQueue() {
	        this.loadingQueue.sort((a, b) => b.priority - a.priority);
	    }
	    /**
	     * Start queue processor.
	     */
	    startQueueProcessor() {
	        if (this.queueProcessorInterval) {
	            clearInterval(this.queueProcessorInterval);
	        }
	        this.queueProcessorInterval = setInterval(() => {
	            this.processQueue();
	        }, 100); // Process every 100ms
	    }
	    /**
	     * Process loading queue.
	     */
	    async processQueue() {
	        while (this.loadingQueue.length > 0 &&
	            this.activeLoads.size < this.config.maxConcurrentLoads) {
	            const entry = this.loadingQueue.shift();
	            this.activeLoads.add(entry.config.id);
	            this.loadAssetEntry(entry);
	        }
	    }
	    /**
	     * Load individual asset entry.
	     */
	    async loadAssetEntry(entry) {
	        const { config } = entry;
	        try {
	            this.emit('asset:loading', config.id, config);
	            // Set timeout
	            if (config.options?.timeout) {
	                entry.timeout = setTimeout(() => {
	                    this.activeLoads.delete(config.id);
	                    entry.reject(new Error(`Asset loading timeout: ${config.id}`));
	                }, config.options.timeout);
	            }
	            // Get appropriate loader
	            const loader = this.loaders.get(config.type);
	            if (!loader) {
	                throw new Error(`No loader available for asset type: ${config.type}`);
	            }
	            // Load asset
	            const data = await loader.load(config);
	            // Create loaded asset
	            const asset = {
	                config,
	                data,
	                state: AssetLoadingState.LOADED,
	                loadedAt: Date.now(),
	                size: this.estimateAssetSize(data, config),
	                progress: 1
	            };
	            // Store in memory and cache
	            this.loadedAssets.set(config.id, asset);
	            if (config.options?.cache !== false) {
	                await this.cache.set(config.id, asset);
	            }
	            this.updateMemoryUsage();
	            // Clear timeout
	            if (entry.timeout) {
	                clearTimeout(entry.timeout);
	            }
	            this.activeLoads.delete(config.id);
	            this.emit('asset:loaded', asset);
	            entry.resolve(asset);
	        }
	        catch (error) {
	            this.activeLoads.delete(config.id);
	            // Clear timeout
	            if (entry.timeout) {
	                clearTimeout(entry.timeout);
	            }
	            // Retry if configured
	            if (entry.retries < (config.options?.maxRetries || this.config.defaultRetries)) {
	                entry.retries++;
	                this.loadingQueue.unshift(entry); // Add back to front of queue
	                this.processQueue();
	                return;
	            }
	            this.emit('asset:failed', config.id, error);
	            entry.reject(error);
	        }
	    }
	    /**
	     * Load asset from bundle data.
	     */
	    async loadAssetFromData(config, data) {
	        // This would need to be implemented based on asset type
	        // For now, create a basic loaded asset
	        return {
	            config,
	            data,
	            state: AssetLoadingState.LOADED,
	            loadedAt: Date.now(),
	            size: data.byteLength,
	            progress: 1
	        };
	    }
	    /**
	     * Load bundle data from URL.
	     */
	    async loadBundleData(bundle) {
	        // This would load the bundle manifest and data
	        // Implementation depends on bundle storage format
	        throw new Error('Bundle loading not implemented');
	    }
	    /**
	     * Estimate asset size in bytes.
	     */
	    estimateAssetSize(data, config) {
	        if (typeof data === 'object' && data !== null) {
	            if (data instanceof ArrayBuffer) {
	                return data.byteLength;
	            }
	            if (data.size !== undefined) {
	                return data.size;
	            }
	            if (data.buffer && data.buffer instanceof ArrayBuffer) {
	                return data.buffer.byteLength;
	            }
	        }
	        // Fallback estimate
	        return config.size || 1024;
	    }
	    /**
	     * Update memory usage statistics.
	     */
	    updateMemoryUsage() {
	        let total = 0;
	        let active = 0;
	        for (const asset of this.loadedAssets.values()) {
	            const size = asset.size;
	            total += size;
	            active += size;
	        }
	        this.memoryUsage = {
	            total,
	            cached: 0, // Would need to query cache
	            active
	        };
	    }
	    /**
	     * Update batch loading progress.
	     */
	    updateBatchProgress() {
	        if (!this.batchContext)
	            return;
	        const progress = {
	            totalAssets: this.batchContext.totalAssets,
	            loadedAssets: this.batchContext.loadedAssets,
	            failedAssets: this.batchContext.failedAssets,
	            progress: (this.batchContext.loadedAssets + this.batchContext.failedAssets) / this.batchContext.totalAssets,
	            assetProgress: new Map() // Individual progress would need more tracking
	        };
	        this.emit('batch:progress', progress);
	    }
	}

	/**
	 * Centralized device-specific configurations for the GameByte framework.
	 * Provides tier-based configurations for cache, audio, and other systems.
	 *
	 * @module DeviceConfigurations
	 */
	/**
	 * Get cache configuration based on device performance tier.
	 *
	 * @param tier - The device performance tier
	 * @param overrides - Optional configuration overrides
	 * @returns Cache configuration for the tier
	 */
	function getCacheConfigForTier(tier, overrides) {
	    const baseConfig = {
	        maxSizeMB: 50,
	        maxItems: 25,
	        evictionStrategy: exports.CacheEvictionStrategy.LRU,
	        persistent: true,
	    };
	    let tierConfig;
	    switch (tier) {
	        case exports.AssetDevicePerformanceTier.LOW:
	            tierConfig = {
	                maxSizeMB: 25,
	                maxItems: 12,
	            };
	            break;
	        case exports.AssetDevicePerformanceTier.MEDIUM:
	            tierConfig = {
	                maxSizeMB: 50,
	                maxItems: 25,
	            };
	            break;
	        case exports.AssetDevicePerformanceTier.HIGH:
	            tierConfig = {
	                maxSizeMB: 100,
	                maxItems: 50,
	            };
	            break;
	        case exports.AssetDevicePerformanceTier.PREMIUM:
	            tierConfig = {
	                maxSizeMB: 200,
	                maxItems: 100,
	            };
	            break;
	        default:
	            tierConfig = {};
	    }
	    return { ...baseConfig, ...tierConfig, ...overrides };
	}
	/**
	 * Get audio configuration based on audio performance tier.
	 *
	 * @param tier - The audio performance tier
	 * @returns Audio configuration for the tier
	 */
	function getAudioConfigForTier(tier) {
	    const baseConfig = {
	        maxConcurrentSounds: 32,
	        memoryLimit: 64,
	        cpuLimit: 15,
	        backgroundAudio: false,
	        adaptiveQuality: true,
	        hardwareAcceleration: true,
	    };
	    switch (tier) {
	        case exports.AudioPerformanceTier.LOW:
	            return {
	                ...baseConfig,
	                maxConcurrentSounds: 16,
	                memoryLimit: 32,
	                cpuLimit: 10,
	                adaptiveQuality: true,
	            };
	        case exports.AudioPerformanceTier.MEDIUM:
	            return {
	                ...baseConfig,
	                maxConcurrentSounds: 32,
	                memoryLimit: 64,
	                cpuLimit: 15,
	            };
	        case exports.AudioPerformanceTier.HIGH:
	            return {
	                ...baseConfig,
	                maxConcurrentSounds: 64,
	                memoryLimit: 128,
	                cpuLimit: 20,
	                backgroundAudio: true,
	            };
	        case exports.AudioPerformanceTier.PREMIUM:
	            return {
	                ...baseConfig,
	                maxConcurrentSounds: 128,
	                memoryLimit: 256,
	                cpuLimit: 25,
	                backgroundAudio: true,
	                hardwareAcceleration: true,
	            };
	        default:
	            return baseConfig;
	    }
	}
	/**
	 * Get concurrent load configuration based on device performance tier.
	 *
	 * @param tier - The device performance tier
	 * @param screenWidth - Screen width for additional optimization
	 * @returns Concurrency configuration for the tier
	 */
	function getConcurrencyConfigForTier(tier, screenWidth = 1024) {
	    const baseConcurrency = screenWidth > 1024 ? 8 : 6;
	    switch (tier) {
	        case exports.AssetDevicePerformanceTier.LOW:
	            return {
	                maxConcurrentLoads: Math.min(baseConcurrency - 2, 3),
	                maxRetries: 2,
	                defaultTimeout: 45000,
	            };
	        case exports.AssetDevicePerformanceTier.MEDIUM:
	            return {
	                maxConcurrentLoads: baseConcurrency - 1,
	                maxRetries: 3,
	                defaultTimeout: 30000,
	            };
	        case exports.AssetDevicePerformanceTier.HIGH:
	            return {
	                maxConcurrentLoads: baseConcurrency,
	                maxRetries: 3,
	                defaultTimeout: 30000,
	            };
	        case exports.AssetDevicePerformanceTier.PREMIUM:
	            return {
	                maxConcurrentLoads: baseConcurrency + 2,
	                maxRetries: 3,
	                defaultTimeout: 25000,
	            };
	        default:
	            return {
	                maxConcurrentLoads: baseConcurrency,
	                maxRetries: 3,
	                defaultTimeout: 30000,
	            };
	    }
	}
	/**
	 * Get input configuration based on device performance tier.
	 *
	 * @param tier - The device performance tier (as string)
	 * @returns Input configuration for the tier
	 */
	function getInputConfigForTier(tier) {
	    switch (tier) {
	        case 'low':
	            return {
	                maxQueueSize: 50,
	                performanceTarget: 'battery',
	                enableInputPrediction: false,
	            };
	        case 'medium':
	            return {
	                maxQueueSize: 75,
	                performanceTarget: 'balanced',
	                enableInputPrediction: false,
	            };
	        case 'high':
	            return {
	                maxQueueSize: 100,
	                performanceTarget: 'performance',
	                enableInputPrediction: true,
	            };
	        default:
	            return {
	                maxQueueSize: 75,
	                performanceTarget: 'balanced',
	                enableInputPrediction: false,
	            };
	    }
	}
	/**
	 * Map framework performance tier string to AudioPerformanceTier enum.
	 *
	 * @param frameworkTier - The framework tier as string or enum
	 * @returns AudioPerformanceTier enum value
	 */
	function mapToAudioPerformanceTier(frameworkTier) {
	    if (typeof frameworkTier === 'string') {
	        switch (frameworkTier.toLowerCase()) {
	            case 'low':
	                return exports.AudioPerformanceTier.LOW;
	            case 'medium':
	                return exports.AudioPerformanceTier.MEDIUM;
	            case 'high':
	                return exports.AudioPerformanceTier.HIGH;
	            case 'premium':
	                return exports.AudioPerformanceTier.PREMIUM;
	            default:
	                return exports.AudioPerformanceTier.MEDIUM;
	        }
	    }
	    return exports.AudioPerformanceTier.MEDIUM;
	}

	/**
	 * Asset service provider for the GameByte framework.
	 * Integrates the asset management system with the framework's service container.
	 */
	class AssetServiceProvider extends AbstractServiceProvider {
	    constructor(config = {}) {
	        super();
	        this.config = {
	            autoDetectDevice: true,
	            enablePreloading: false,
	            ...config
	        };
	    }
	    /**
	     * Register asset management services in the container.
	     */
	    register(app) {
	        // Register asset manager as singleton
	        app.singleton('asset.manager', () => {
	            const assetManagerConfig = this.createAssetManagerConfig();
	            return new GameByteAssetManager(assetManagerConfig);
	        });
	        // Register alias for easier access
	        app.getContainer().alias('AssetManager', 'asset.manager');
	        app.getContainer().alias('assets', 'asset.manager');
	        // Register device capabilities service
	        app.singleton('device.capabilities', () => {
	            if (this.config.autoDetectDevice) {
	                return this.detectDeviceCapabilities();
	            }
	            return this.config.assetManager?.deviceCapabilities || this.getDefaultDeviceCapabilities();
	        });
	    }
	    /**
	     * Boot asset management services.
	     */
	    async boot(app) {
	        const assetManager = app.make('asset.manager');
	        // Setup event listeners for framework integration
	        this.setupEventListeners(app, assetManager);
	        // Preload assets if enabled
	        if (this.config.enablePreloading && this.config.preloadAssets) {
	            await this.preloadAssets(assetManager);
	        }
	        // Setup memory management integration
	        this.setupMemoryManagement(app, assetManager);
	        // Register cleanup handler
	        this.setupCleanupHandler(app, assetManager);
	    }
	    /**
	     * Define services this provider provides.
	     */
	    provides() {
	        return [
	            'asset.manager',
	            'AssetManager',
	            'assets',
	            'device.capabilities'
	        ];
	    }
	    /**
	     * Create asset manager configuration.
	     */
	    createAssetManagerConfig() {
	        const deviceCapabilities = this.config.autoDetectDevice
	            ? this.detectDeviceCapabilities()
	            : this.config.assetManager?.deviceCapabilities || this.getDefaultDeviceCapabilities();
	        // Calculate cache size based on device tier
	        const cacheConfig = this.createCacheConfig(deviceCapabilities);
	        return {
	            cache: cacheConfig,
	            maxConcurrentLoads: this.getOptimalConcurrentLoads(deviceCapabilities),
	            defaultTimeout: 30000,
	            defaultRetries: 3,
	            autoMemoryOptimization: true,
	            memoryPressureThreshold: 0.8,
	            deviceCapabilities,
	            ...this.config.assetManager
	        };
	    }
	    /**
	     * Create cache configuration based on device capabilities.
	     * Uses centralized DeviceConfigurations for tier-based settings.
	     */
	    createCacheConfig(deviceCapabilities) {
	        const userConfig = this.config.cacheConfig || {};
	        // Get tier-based config from centralized configuration
	        const tierConfig = getCacheConfigForTier(deviceCapabilities.performanceTier, {
	            maxSizeMB: userConfig.maxSizeMB,
	        });
	        const maxItems = userConfig.maxItems || tierConfig.maxItems;
	        const ttl = userConfig.ttlMinutes ? userConfig.ttlMinutes * 60 * 1000 : undefined;
	        return {
	            maxSize: tierConfig.maxSizeMB * 1024 * 1024, // Convert to bytes
	            maxItems,
	            evictionStrategy: userConfig.evictionStrategy || tierConfig.evictionStrategy,
	            ttl,
	            persistent: userConfig.enablePersistent !== false ? tierConfig.persistent : false,
	            version: '1.0.0',
	        };
	    }
	    /**
	     * Get optimal concurrent loads based on device capabilities.
	     * Uses centralized DeviceConfigurations for tier-based settings.
	     */
	    getOptimalConcurrentLoads(deviceCapabilities) {
	        const concurrencyConfig = getConcurrencyConfigForTier(deviceCapabilities.performanceTier, deviceCapabilities.screen.width);
	        return concurrencyConfig.maxConcurrentLoads;
	    }
	    /**
	     * Detect device capabilities.
	     * Uses centralized DeviceDetectionUtils and FormatDetectionUtils.
	     */
	    detectDeviceCapabilities() {
	        const unified = getUnifiedDeviceCapabilities();
	        const screenInfo = getScreenInfo();
	        const gpuInfo = detectGPUTier();
	        const connectionType = detectConnectionType();
	        const platform = detectPlatform();
	        return {
	            performanceTier: unified.performanceTier,
	            availableMemory: unified.availableMemory,
	            gpuTier: gpuInfo.tier,
	            supportedTextureFormats: getSupportedTextureFormats(),
	            supportedAudioFormats: getSupportedAudioFormats(),
	            connectionType: connectionType,
	            screen: screenInfo,
	            platform: platform,
	        };
	    }
	    /**
	     * Get default device capabilities.
	     */
	    getDefaultDeviceCapabilities() {
	        return {
	            performanceTier: exports.AssetDevicePerformanceTier.MEDIUM,
	            availableMemory: 4096, // 4GB
	            gpuTier: 'medium',
	            supportedTextureFormats: ['jpeg', 'png', 'webp'],
	            supportedAudioFormats: ['mp3', 'ogg', 'aac'],
	            connectionType: '4g',
	            screen: {
	                width: window.screen.width,
	                height: window.screen.height,
	                pixelRatio: window.devicePixelRatio || 1
	            },
	            platform: 'web'
	        };
	    }
	    /**
	     * Setup event listeners for framework integration.
	     */
	    setupEventListeners(app, assetManager) {
	        // Forward asset manager events to framework
	        assetManager.on('asset:loaded', (asset) => {
	            app.emit('asset:loaded', asset);
	        });
	        assetManager.on('asset:failed', (assetId, error) => {
	            app.emit('asset:failed', assetId, error);
	        });
	        assetManager.on('batch:completed', (results) => {
	            app.emit('assets:batch:completed', results);
	        });
	        assetManager.on('memory:pressure', (usage, limit) => {
	            app.emit('memory:pressure', usage, limit);
	        });
	        // Listen for framework events
	        app.on('scene:changing', () => {
	            // Trigger garbage collection on scene changes
	            assetManager.optimizeMemory().catch(console.warn);
	        });
	        app.on('visibility:hidden', () => {
	            // Aggressive cleanup when app goes to background
	            assetManager.getCache().evict().catch(console.warn);
	        });
	    }
	    /**
	     * Preload configured assets.
	     */
	    async preloadAssets(assetManager) {
	        if (!this.config.preloadAssets)
	            return;
	        try {
	            const assetConfigs = this.config.preloadAssets.map(asset => ({
	                id: asset.id,
	                type: asset.type,
	                src: asset.src,
	                options: {
	                    priority: asset.priority || 0,
	                    cache: true,
	                    preload: true
	                }
	            }));
	            await assetManager.preload(assetConfigs);
	        }
	        catch (error) {
	            console.warn('Asset preloading failed:', error);
	        }
	    }
	    /**
	     * Setup memory management integration.
	     */
	    setupMemoryManagement(app, assetManager) {
	        // Monitor memory pressure
	        assetManager.on('memory:pressure', (usage, limit) => {
	            console.warn(`Memory pressure detected: ${Math.round(usage / 1024 / 1024)}MB / ${Math.round(limit / 1024 / 1024)}MB`);
	            // Emit framework-level memory warning
	            app.emit('performance:memory:warning', { usage, limit });
	        });
	        // Setup periodic memory optimization
	        setInterval(() => {
	            const memoryUsage = assetManager.getMemoryUsage();
	            const deviceCapabilities = app.make('device.capabilities');
	            // Calculate memory limit based on device
	            const memoryLimit = deviceCapabilities.availableMemory * 1024 * 1024 * 0.5; // 50% of device memory
	            if (memoryUsage.total > memoryLimit * 0.8) {
	                assetManager.optimizeMemory().catch(console.warn);
	            }
	        }, 30000); // Check every 30 seconds
	    }
	    /**
	     * Setup cleanup handler for framework destruction.
	     */
	    setupCleanupHandler(app, assetManager) {
	        app.on('destroyed', () => {
	            assetManager.destroy().catch(console.warn);
	        });
	        // Cleanup on page unload
	        window.addEventListener('beforeunload', () => {
	            assetManager.destroy().catch(console.warn);
	        });
	    }
	}

	/**
	 * Base facade class for providing static access to services.
	 * Inspired by Laravel's facade pattern.
	 */
	class Facade {
	    /**
	     * Set the GameByte application instance.
	     */
	    static setApplication(app) {
	        Facade.app = app;
	    }
	    /**
	     * Get the GameByte application instance.
	     */
	    static getApplication() {
	        if (!Facade.app) {
	            throw new Error('GameByte application not set on facade');
	        }
	        return Facade.app;
	    }
	    /**
	     * Get the service key that this facade represents.
	     * Must be implemented by concrete facade classes.
	     */
	    static getFacadeAccessor() {
	        throw new Error('Facade must implement getFacadeAccessor method');
	    }
	    /**
	     * Resolve the facade root instance from the service container.
	     */
	    static resolveFacadeInstance() {
	        const app = Facade.getApplication();
	        const accessor = this.getFacadeAccessor();
	        if (!app.getContainer().bound(accessor)) {
	            throw new Error(`Service '${accessor}' not found in container`);
	        }
	        return app.make(accessor);
	    }
	    /**
	     * Handle static method calls by forwarding them to the facade root.
	     */
	    static callStatic(method, args) {
	        const instance = this.resolveFacadeInstance();
	        if (!instance || instance === null || instance === undefined) {
	            throw new Error(`Facade root instance is ${instance === null ? 'null' : 'undefined'}`);
	        }
	        if (typeof instance[method] !== 'function') {
	            throw new Error(`Method '${method}' does not exist on facade root`);
	        }
	        return instance[method](...args);
	    }
	    /**
	     * Resolve a service from the container
	     */
	    static resolve(key) {
	        const app = this.getApplication();
	        const serviceKey = key || this.getFacadeAccessor();
	        return app.make(serviceKey);
	    }
	}
	Facade.app = null;

	/**
	 * Assets facade for static access to asset management functionality.
	 * Provides a clean, static API for loading and managing game assets.
	 */
	class Assets extends Facade {
	    /**
	     * Get the service key for the asset manager.
	     */
	    static getFacadeAccessor() {
	        return 'asset.manager';
	    }
	    /**
	     * Load a single asset.
	     *
	     * @example
	     * ```typescript
	     * const texture = await Assets.load({
	     *   id: 'player-sprite',
	     *   type: AssetType.TEXTURE,
	     *   src: '/assets/player.png'
	     * });
	     * ```
	     */
	    static async load(config) {
	        const manager = this.resolveFacadeInstance();
	        return manager.load(config);
	    }
	    /**
	     * Load multiple assets in batch.
	     *
	     * @example
	     * ```typescript
	     * const assets = await Assets.loadBatch([
	     *   { id: 'bg', type: AssetType.TEXTURE, src: '/assets/bg.jpg' },
	     *   { id: 'music', type: AssetType.AUDIO, src: '/assets/music.mp3' }
	     * ]);
	     * ```
	     */
	    static async loadBatch(configs) {
	        const manager = this.resolveFacadeInstance();
	        return manager.loadBatch(configs);
	    }
	    /**
	     * Load an asset bundle.
	     *
	     * @example
	     * ```typescript
	     * const bundle = new GameByteAssetBundle({
	     *   id: 'level1',
	     *   name: 'Level 1 Assets',
	     *   assets: [...]
	     * });
	     * const assets = await Assets.loadBundle(bundle);
	     * ```
	     */
	    static async loadBundle(bundle) {
	        const manager = this.resolveFacadeInstance();
	        return manager.loadBundle(bundle);
	    }
	    /**
	     * Get a loaded asset by ID.
	     *
	     * @example
	     * ```typescript
	     * const playerTexture = Assets.get<ProcessedTexture>('player-sprite');
	     * if (playerTexture) {
	     *   // Use the texture
	     *   const image = playerTexture.data.image;
	     * }
	     * ```
	     */
	    static get(assetId) {
	        const manager = this.resolveFacadeInstance();
	        return manager.get(assetId);
	    }
	    /**
	     * Check if an asset is loaded.
	     *
	     * @example
	     * ```typescript
	     * if (Assets.has('player-sprite')) {
	     *   const texture = Assets.get('player-sprite');
	     * }
	     * ```
	     */
	    static has(assetId) {
	        const manager = this.resolveFacadeInstance();
	        return manager.has(assetId);
	    }
	    /**
	     * Unload an asset and free its memory.
	     *
	     * @example
	     * ```typescript
	     * Assets.unload('old-level-bg');
	     * ```
	     */
	    static unload(assetId) {
	        const manager = this.resolveFacadeInstance();
	        return manager.unload(assetId);
	    }
	    /**
	     * Unload multiple assets.
	     *
	     * @example
	     * ```typescript
	     * const unloadedCount = Assets.unloadBatch(['bg1', 'bg2', 'music1']);
	     * console.log(`Unloaded ${unloadedCount} assets`);
	     * ```
	     */
	    static unloadBatch(assetIds) {
	        const manager = this.resolveFacadeInstance();
	        return manager.unloadBatch(assetIds);
	    }
	    /**
	     * Preload assets in the background.
	     *
	     * @example
	     * ```typescript
	     * // Preload next level assets
	     * Assets.preload([
	     *   { id: 'level2-bg', type: AssetType.TEXTURE, src: '/assets/level2/bg.jpg' },
	     *   { id: 'level2-music', type: AssetType.AUDIO, src: '/assets/level2/music.mp3' }
	     * ]);
	     * ```
	     */
	    static async preload(configs) {
	        const manager = this.resolveFacadeInstance();
	        return manager.preload(configs);
	    }
	    /**
	     * Get batch loading progress.
	     *
	     * @example
	     * ```typescript
	     * const progress = Assets.getBatchProgress();
	     * if (progress) {
	     *   console.log(`Loading: ${progress.loadedAssets}/${progress.totalAssets}`);
	     * }
	     * ```
	     */
	    static getBatchProgress() {
	        const manager = this.resolveFacadeInstance();
	        return manager.getBatchProgress();
	    }
	    /**
	     * Get individual asset loading progress.
	     *
	     * @example
	     * ```typescript
	     * const progress = Assets.getProgress('large-video');
	     * if (progress) {
	     *   console.log(`Progress: ${Math.round(progress.progress * 100)}%`);
	     * }
	     * ```
	     */
	    static getProgress(assetId) {
	        const manager = this.resolveFacadeInstance();
	        return manager.getProgress(assetId);
	    }
	    /**
	     * Cancel asset loading.
	     *
	     * @example
	     * ```typescript
	     * Assets.cancel('large-video'); // Cancel if still loading
	     * ```
	     */
	    static cancel(assetId) {
	        const manager = this.resolveFacadeInstance();
	        return manager.cancel(assetId);
	    }
	    /**
	     * Register a custom asset loader.
	     *
	     * @example
	     * ```typescript
	     * class CustomModelLoader extends BaseAssetLoader<CustomModel> {
	     *   readonly supportedTypes = [AssetType.MODEL_3D];
	     *   // ... implementation
	     * }
	     *
	     * Assets.registerLoader(new CustomModelLoader());
	     * ```
	     */
	    static registerLoader(loader) {
	        const manager = this.resolveFacadeInstance();
	        return manager.registerLoader(loader);
	    }
	    /**
	     * Get the cache instance for advanced operations.
	     *
	     * @example
	     * ```typescript
	     * const cache = Assets.getCache();
	     * const stats = await cache.getStats();
	     * console.log(`Cache hit rate: ${Math.round(stats.hitRate * 100)}%`);
	     * ```
	     */
	    static getCache() {
	        const manager = this.resolveFacadeInstance();
	        return manager.getCache();
	    }
	    /**
	     * Get current memory usage statistics.
	     *
	     * @example
	     * ```typescript
	     * const usage = Assets.getMemoryUsage();
	     * console.log(`Memory usage: ${Math.round(usage.total / 1024 / 1024)}MB`);
	     * ```
	     */
	    static getMemoryUsage() {
	        const manager = this.resolveFacadeInstance();
	        return manager.getMemoryUsage();
	    }
	    /**
	     * Manually trigger memory optimization.
	     *
	     * @example
	     * ```typescript
	     * // On level change or low memory warning
	     * await Assets.optimizeMemory();
	     * ```
	     */
	    static async optimizeMemory() {
	        const manager = this.resolveFacadeInstance();
	        return manager.optimizeMemory();
	    }
	    /**
	     * Clean up and destroy the asset manager.
	     * Usually called during app shutdown.
	     *
	     * @example
	     * ```typescript
	     * window.addEventListener('beforeunload', () => {
	     *   Assets.destroy();
	     * });
	     * ```
	     */
	    static async destroy() {
	        const manager = this.resolveFacadeInstance();
	        return manager.destroy();
	    }
	    // Convenience methods for common asset operations
	    /**
	     * Load a texture asset with optimized settings.
	     *
	     * @example
	     * ```typescript
	     * const texture = await Assets.loadTexture('player-sprite', '/assets/player.png', {
	     *   quality: 'high',
	     *   generateMipmaps: true
	     * });
	     * ```
	     */
	    static async loadTexture(id, src, options) {
	        return this.load({
	            id,
	            type: 'texture',
	            src,
	            options: {
	                ...options,
	                cache: true
	            }
	        });
	    }
	    /**
	     * Load an audio asset with optimized settings.
	     *
	     * @example
	     * ```typescript
	     * const audio = await Assets.loadAudio('bgm', '/assets/music.mp3', {
	     *   streaming: true,
	     *   quality: 'medium'
	     * });
	     * ```
	     */
	    static async loadAudio(id, src, options) {
	        return this.load({
	            id,
	            type: 'audio',
	            src,
	            options: {
	                ...options,
	                cache: true
	            }
	        });
	    }
	    /**
	     * Load a JSON data asset.
	     *
	     * @example
	     * ```typescript
	     * const levelData = await Assets.loadJSON<LevelConfig>('level1', '/data/level1.json');
	     * const config = levelData.data.data; // Access the parsed JSON
	     * ```
	     */
	    static async loadJSON(id, src, options) {
	        return this.load({
	            id,
	            type: 'json',
	            src,
	            options: {
	                ...options,
	                cache: true
	            }
	        });
	    }
	    /**
	     * Batch load common game assets.
	     *
	     * @example
	     * ```typescript
	     * const gameAssets = await Assets.loadGameAssets({
	     *   textures: {
	     *     'player': '/assets/player.png',
	     *     'enemy': '/assets/enemy.png'
	     *   },
	     *   audio: {
	     *     'jump': '/assets/sounds/jump.wav',
	     *     'bgm': '/assets/music/level1.mp3'
	     *   },
	     *   data: {
	     *     'config': '/data/game-config.json'
	     *   }
	     * });
	     * ```
	     */
	    static async loadGameAssets(assets) {
	        const configs = [];
	        // Add texture assets
	        if (assets.textures) {
	            for (const [id, src] of Object.entries(assets.textures)) {
	                configs.push({
	                    id: `texture_${id}`,
	                    type: 'texture',
	                    src,
	                    options: { cache: true, quality: 'auto' }
	                });
	            }
	        }
	        // Add audio assets
	        if (assets.audio) {
	            for (const [id, src] of Object.entries(assets.audio)) {
	                configs.push({
	                    id: `audio_${id}`,
	                    type: 'audio',
	                    src,
	                    options: { cache: true, quality: 'medium' }
	                });
	            }
	        }
	        // Add data assets
	        if (assets.data) {
	            for (const [id, src] of Object.entries(assets.data)) {
	                configs.push({
	                    id: `data_${id}`,
	                    type: 'json',
	                    src,
	                    options: { cache: true }
	                });
	            }
	        }
	        return this.loadBatch(configs);
	    }
	    /**
	     * Create a simple asset loading progress callback.
	     *
	     * @example
	     * ```typescript
	     * const stopProgress = Assets.onBatchProgress((progress) => {
	     *   updateLoadingBar(progress.progress);
	     *   if (progress.progress === 1) {
	     *     stopProgress(); // Stop listening
	     *   }
	     * });
	     * ```
	     */
	    static onBatchProgress(callback) {
	        const manager = this.resolveFacadeInstance();
	        const progressHandler = (progress) => {
	            callback(progress);
	        };
	        manager.on('batch:progress', progressHandler);
	        // Return cleanup function
	        return () => {
	            manager.off('batch:progress', progressHandler);
	        };
	    }
	    /**
	     * Wait for all assets to finish loading.
	     *
	     * @example
	     * ```typescript
	     * Assets.preload(preloadAssets);
	     * await Assets.waitForAll();
	     * console.log('All assets loaded!');
	     * ```
	     */
	    static async waitForAll() {
	        return new Promise((resolve) => {
	            const manager = this.resolveFacadeInstance();
	            const checkProgress = () => {
	                const progress = manager.getBatchProgress();
	                if (!progress || progress.progress === 1) {
	                    resolve();
	                }
	                else {
	                    setTimeout(checkProgress, 100);
	                }
	            };
	            checkProgress();
	        });
	    }
	}

	/**
	 * Version Detection Utilities
	 *
	 * Provides runtime detection of library versions and feature availability
	 * to ensure backward compatibility across Pixi.js v7/v8 and Three.js r150-r180+
	 */
	/**
	 * Parse semantic version string into components
	 */
	function parseVersion(versionString) {
	    const match = versionString.match(/(\d+)\.(\d+)\.(\d+)/);
	    if (!match) {
	        return { major: 0, minor: 0, patch: 0, raw: versionString };
	    }
	    return {
	        major: parseInt(match[1], 10),
	        minor: parseInt(match[2], 10),
	        patch: parseInt(match[3], 10),
	        raw: versionString
	    };
	}
	/**
	 * Detect Pixi.js version and available features
	 */
	class PixiVersionDetector {
	    /**
	     * Get Pixi.js version information
	     */
	    static getVersion() {
	        if (this.cachedVersion) {
	            return this.cachedVersion;
	        }
	        try {
	            if (PIXI__namespace && PIXI__namespace.VERSION) {
	                this.cachedVersion = parseVersion(PIXI__namespace.VERSION);
	            }
	            else {
	                // Fallback: assume v8 if VERSION is not available
	                this.cachedVersion = { major: 8, minor: 0, patch: 0, raw: '8.0.0' };
	            }
	        }
	        catch (error) {
	            // Default to v8 if detection fails
	            this.cachedVersion = { major: 8, minor: 0, patch: 0, raw: '8.0.0' };
	        }
	        return this.cachedVersion;
	    }
	    /**
	     * Check if Pixi.js is v8 or higher
	     */
	    static isV8OrHigher() {
	        const version = this.getVersion();
	        return version.major >= 8;
	    }
	    /**
	     * Check if Pixi.js is v7
	     */
	    static isV7() {
	        const version = this.getVersion();
	        return version.major === 7;
	    }
	    /**
	     * Detect available rendering features
	     */
	    static getFeatureSupport() {
	        if (this.cachedFeatures) {
	            return this.cachedFeatures;
	        }
	        this.cachedFeatures = {
	            webgpu: this.hasWebGPUSupport(),
	            webgl2: this.hasWebGL2Support(),
	            webgl: this.hasWebGLSupport()
	        };
	        return this.cachedFeatures;
	    }
	    /**
	     * Check if WebGPU is available in browser and Pixi.js
	     */
	    static hasWebGPUSupport() {
	        // WebGPU only available in Pixi v8+
	        if (!this.isV8OrHigher()) {
	            return false;
	        }
	        // Check browser WebGPU support
	        if (typeof navigator === 'undefined') {
	            return false;
	        }
	        return 'gpu' in navigator;
	    }
	    /**
	     * Check if WebGL2 is available
	     */
	    static hasWebGL2Support() {
	        if (typeof document === 'undefined') {
	            return false;
	        }
	        try {
	            const canvas = document.createElement('canvas');
	            return !!(canvas.getContext('webgl2') || canvas.getContext('experimental-webgl2'));
	        }
	        catch {
	            return false;
	        }
	    }
	    /**
	     * Check if WebGL is available
	     */
	    static hasWebGLSupport() {
	        if (typeof document === 'undefined') {
	            return false;
	        }
	        try {
	            const canvas = document.createElement('canvas');
	            return !!(canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
	        }
	        catch {
	            return false;
	        }
	    }
	    /**
	     * Check if autoDetectRenderer is available (v8 feature)
	     */
	    static hasAutoDetectRenderer() {
	        try {
	            return typeof PIXI__namespace.autoDetectRenderer === 'function';
	        }
	        catch {
	            return false;
	        }
	    }
	    /**
	     * Check if ParticleContainer is available
	     */
	    static hasParticleContainer() {
	        try {
	            return typeof PIXI__namespace.ParticleContainer !== 'undefined';
	        }
	        catch {
	            return false;
	        }
	    }
	}
	PixiVersionDetector.cachedVersion = null;
	PixiVersionDetector.cachedFeatures = null;
	/**
	 * Detect Three.js version and available features
	 */
	class ThreeVersionDetector {
	    /**
	     * Get Three.js version (revision number)
	     */
	    static getVersion() {
	        if (this.cachedVersion) {
	            return this.cachedVersion;
	        }
	        try {
	            if (THREE__namespace && THREE__namespace.REVISION) {
	                const revision = parseInt(THREE__namespace.REVISION, 10);
	                // Three.js uses revision numbers like "150", "160", "180"
	                // Convert to semantic version for consistency
	                this.cachedVersion = {
	                    major: 0,
	                    minor: revision,
	                    patch: 0,
	                    raw: `0.${revision}.0`
	                };
	            }
	            else {
	                // Fallback
	                this.cachedVersion = { major: 0, minor: 180, patch: 0, raw: '0.180.0' };
	            }
	        }
	        catch (error) {
	            // Default to r180
	            this.cachedVersion = { major: 0, minor: 180, patch: 0, raw: '0.180.0' };
	        }
	        return this.cachedVersion;
	    }
	    /**
	     * Get revision number
	     */
	    static getRevision() {
	        return this.getVersion().minor;
	    }
	    /**
	     * Check if Three.js is r180 or higher
	     */
	    static isR180OrHigher() {
	        return this.getRevision() >= 180;
	    }
	    /**
	     * Check if Three.js is r160 or higher
	     */
	    static isR160OrHigher() {
	        return this.getRevision() >= 160;
	    }
	    /**
	     * Check if Three.js is below r160
	     */
	    static isLegacy() {
	        return this.getRevision() < 160;
	    }
	    /**
	     * Detect available rendering features
	     */
	    static getFeatureSupport() {
	        if (this.cachedFeatures) {
	            return this.cachedFeatures;
	        }
	        this.cachedFeatures = {
	            webgpu: this.hasWebGPUSupport(),
	            webgl2: this.hasWebGL2Support(),
	            webgl: this.hasWebGLSupport()
	        };
	        return this.cachedFeatures;
	    }
	    /**
	     * Check if WebGPURenderer might be available (version check only)
	     * WebGPURenderer is in examples/jsm, not main Three.js export
	     */
	    static hasWebGPURenderer() {
	        // WebGPURenderer available from r160+
	        // Actual availability requires runtime dynamic import check
	        return this.getRevision() >= 160;
	    }
	    /**
	     * Attempt to load WebGPURenderer dynamically
	     * Returns true if WebGPURenderer can be imported
	     */
	    static async canLoadWebGPURenderer() {
	        if (this.getRevision() < 160) {
	            return false;
	        }
	        try {
	            // @ts-expect-error - WebGPURenderer is in examples/jsm, not in main type definitions
	            await import('three/examples/jsm/renderers/webgpu/WebGPURenderer.js');
	            return true;
	        }
	        catch {
	            return false;
	        }
	    }
	    /**
	     * Check if browser supports WebGPU
	     */
	    static hasWebGPUSupport() {
	        if (typeof navigator === 'undefined') {
	            return false;
	        }
	        return 'gpu' in navigator && this.hasWebGPURenderer();
	    }
	    /**
	     * Check if WebGL2 is available
	     */
	    static hasWebGL2Support() {
	        if (typeof document === 'undefined') {
	            return false;
	        }
	        try {
	            const canvas = document.createElement('canvas');
	            return !!(canvas.getContext('webgl2') || canvas.getContext('experimental-webgl2'));
	        }
	        catch {
	            return false;
	        }
	    }
	    /**
	     * Check if WebGL is available
	     */
	    static hasWebGLSupport() {
	        if (typeof document === 'undefined') {
	            return false;
	        }
	        try {
	            const canvas = document.createElement('canvas');
	            return !!(canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
	        }
	        catch {
	            return false;
	        }
	    }
	    /**
	     * Check if instanced rendering is available
	     */
	    static hasInstancedMesh() {
	        try {
	            return typeof THREE__namespace.InstancedMesh !== 'undefined';
	        }
	        catch {
	            return false;
	        }
	    }
	    /**
	     * Check if LOD (Level of Detail) is available
	     */
	    static hasLOD() {
	        try {
	            return typeof THREE__namespace.LOD !== 'undefined';
	        }
	        catch {
	            return false;
	        }
	    }
	}
	ThreeVersionDetector.cachedVersion = null;
	ThreeVersionDetector.cachedFeatures = null;
	/**
	 * Browser feature detection
	 */
	class BrowserFeatureDetector {
	    /**
	     * Check if WebGPU is available in the browser
	     */
	    static hasWebGPU() {
	        if (typeof navigator === 'undefined') {
	            return false;
	        }
	        return 'gpu' in navigator;
	    }
	    /**
	     * Check if WebGL2 is available
	     */
	    static hasWebGL2() {
	        if (typeof document === 'undefined') {
	            return false;
	        }
	        try {
	            const canvas = document.createElement('canvas');
	            const gl = canvas.getContext('webgl2');
	            return gl !== null;
	        }
	        catch {
	            return false;
	        }
	    }
	    /**
	     * Check if WebGL is available
	     */
	    static hasWebGL() {
	        if (typeof document === 'undefined') {
	            return false;
	        }
	        try {
	            const canvas = document.createElement('canvas');
	            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
	            return gl !== null;
	        }
	        catch {
	            return false;
	        }
	    }
	    /**
	     * Get best available rendering context
	     */
	    static getBestRenderingContext() {
	        if (this.hasWebGPU())
	            return 'webgpu';
	        if (this.hasWebGL2())
	            return 'webgl2';
	        if (this.hasWebGL())
	            return 'webgl';
	        return null;
	    }
	    /**
	     * Check if running on mobile device
	     */
	    static isMobile() {
	        if (typeof navigator === 'undefined') {
	            return false;
	        }
	        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
	    }
	    /**
	     * Check if Battery Status API is available
	     */
	    static hasBatteryAPI() {
	        if (typeof navigator === 'undefined') {
	            return false;
	        }
	        return 'getBattery' in navigator;
	    }
	}
	/**
	 * Unified version detection and feature support
	 */
	class FrameworkCompatibility {
	    /**
	     * Get comprehensive compatibility report
	     */
	    static getCompatibilityReport() {
	        return {
	            pixi: {
	                version: PixiVersionDetector.getVersion(),
	                isV8: PixiVersionDetector.isV8OrHigher(),
	                isV7: PixiVersionDetector.isV7(),
	                features: PixiVersionDetector.getFeatureSupport(),
	                hasAutoDetectRenderer: PixiVersionDetector.hasAutoDetectRenderer(),
	                hasParticleContainer: PixiVersionDetector.hasParticleContainer()
	            },
	            three: {
	                version: ThreeVersionDetector.getVersion(),
	                revision: ThreeVersionDetector.getRevision(),
	                isR180Plus: ThreeVersionDetector.isR180OrHigher(),
	                isR160Plus: ThreeVersionDetector.isR160OrHigher(),
	                features: ThreeVersionDetector.getFeatureSupport(),
	                hasWebGPURenderer: ThreeVersionDetector.hasWebGPURenderer(),
	                hasInstancedMesh: ThreeVersionDetector.hasInstancedMesh(),
	                hasLOD: ThreeVersionDetector.hasLOD()
	            },
	            browser: {
	                hasWebGPU: BrowserFeatureDetector.hasWebGPU(),
	                hasWebGL2: BrowserFeatureDetector.hasWebGL2(),
	                hasWebGL: BrowserFeatureDetector.hasWebGL(),
	                bestContext: BrowserFeatureDetector.getBestRenderingContext(),
	                isMobile: BrowserFeatureDetector.isMobile(),
	                hasBatteryAPI: BrowserFeatureDetector.hasBatteryAPI()
	            }
	        };
	    }
	    /**
	     * Log compatibility report to console
	     */
	    static logCompatibilityReport() {
	        const report = this.getCompatibilityReport();
	        console.group('ðŸ” GameByte Framework - Compatibility Report');
	        console.log('Pixi.js:', report.pixi);
	        console.log('Three.js:', report.three);
	        console.log('Browser:', report.browser);
	        console.groupEnd();
	    }
	}

	/**
	 * Renderer Compatibility Utilities
	 *
	 * Provides fallback mechanisms and compatibility helpers for working with
	 * different versions of Pixi.js (v7/v8) and Three.js (r150-r180+)
	 */
	/**
	 * Pixi.js Compatibility Helpers
	 */
	class PixiCompatibility {
	    /**
	     * Create a Pixi v8 renderer using autoDetectRenderer
	     * Framework only supports Pixi v8+
	     */
	    static async createRenderer(options) {
	        const version = PixiVersionDetector.getVersion();
	        const features = BrowserFeatureDetector.getBestRenderingContext();
	        console.log('ðŸŽ¨ Creating Pixi v8 renderer:', {
	            version: version.raw,
	            bestContext: features
	        });
	        return this.createV8Renderer(options);
	    }
	    /**
	     * Create renderer using Pixi.js v8 API (autoDetectRenderer with WebGPU support)
	     * Framework requires Pixi v8+
	     */
	    static async createV8Renderer(options) {
	        const autoDetect = PIXI__namespace.autoDetectRenderer;
	        if (!autoDetect) {
	            throw new Error('Pixi.js v8 autoDetectRenderer not found. Framework requires Pixi v8+');
	        }
	        // Determine preferred renderer type based on browser capabilities
	        // Default to WebGL (stable) instead of WebGPU (experimental)
	        let preference = options.preference || 'webgl';
	        if (preference === 'webgpu' && !BrowserFeatureDetector.hasWebGPU()) {
	            console.log('âš ï¸ WebGPU not available, falling back to WebGL2');
	            preference = 'webgl2';
	        }
	        if (preference === 'webgl2' && !BrowserFeatureDetector.hasWebGL2()) {
	            console.log('âš ï¸ WebGL2 not available, falling back to WebGL');
	            preference = 'webgl';
	        }
	        // Create renderer with v8 API
	        const rendererOptions = {
	            canvas: options.canvas,
	            width: options.width || 800,
	            height: options.height || 600,
	            backgroundColor: options.backgroundColor,
	            backgroundAlpha: options.backgroundAlpha,
	            antialias: options.antialias !== false,
	            preserveDrawingBuffer: options.preserveDrawingBuffer || false,
	            resolution: options.resolution || (window.devicePixelRatio || 1),
	            autoDensity: options.autoDensity ?? true,
	            powerPreference: options.powerPreference,
	            preference
	        };
	        console.log('âœ… Creating Pixi v8 renderer with preference:', preference);
	        const renderer = await autoDetect(rendererOptions);
	        return renderer;
	    }
	    /**
	     * Check if ParticleContainer is available and return appropriate container class
	     */
	    static getParticleContainer() {
	        if (PixiVersionDetector.hasParticleContainer()) {
	            return PIXI__namespace.ParticleContainer;
	        }
	        console.warn('âš ï¸ ParticleContainer not available, using regular Container');
	        return PIXI__namespace.Container;
	    }
	    /**
	     * Get the renderer instance (Pixi v8 returns renderer directly)
	     */
	    static getRenderer(renderer) {
	        return renderer;
	    }
	    /**
	     * Get the canvas from Pixi v8 renderer
	     */
	    static getCanvas(renderer) {
	        if (renderer.view) {
	            return renderer.view.canvas || renderer.view;
	        }
	        if (renderer.canvas) {
	            return renderer.canvas;
	        }
	        throw new Error('Could not find canvas on Pixi v8 renderer');
	    }
	    /**
	     * Get or create stage for Pixi v8 renderer
	     */
	    static getStage(renderer) {
	        // v8 doesn't have stage, need to create one
	        const Container = PIXI__namespace.Container;
	        return new Container();
	    }
	    /**
	     * Resize Pixi v8 renderer
	     */
	    static resize(renderer, width, height) {
	        if (renderer.resize) {
	            renderer.resize(width, height);
	        }
	        else {
	            throw new Error('Resize method not found on Pixi v8 renderer');
	        }
	    }
	    /**
	     * Render with Pixi v8 renderer
	     */
	    static render(renderer, stage) {
	        if (renderer.render) {
	            renderer.render(stage);
	        }
	        else {
	            throw new Error('Render method not found on Pixi v8 renderer');
	        }
	    }
	}
	/**
	 * Three.js Compatibility Helpers
	 */
	class ThreeCompatibility {
	    /**
	     * Create a Three.js renderer with automatic version detection and fallback
	     * Supports WebGPURenderer (r160+) with fallback to WebGLRenderer
	     */
	    static async createRenderer(options) {
	        const hasWebGPURenderer = ThreeVersionDetector.hasWebGPURenderer();
	        const hasWebGPU = BrowserFeatureDetector.hasWebGPU();
	        const revision = ThreeVersionDetector.getRevision();
	        console.log('ðŸŽ¨ Creating Three.js renderer:', {
	            revision,
	            hasWebGPURenderer,
	            hasWebGPU,
	            bestContext: BrowserFeatureDetector.getBestRenderingContext()
	        });
	        // Try WebGPU first if available (r160+)
	        if (hasWebGPURenderer && hasWebGPU) {
	            try {
	                const webgpuRenderer = await this.createWebGPURenderer(options);
	                console.log('âœ… Created WebGPU renderer');
	                return webgpuRenderer;
	            }
	            catch (error) {
	                console.warn('âš ï¸ WebGPU renderer failed, falling back to WebGL:', error);
	            }
	        }
	        // Fall back to WebGL
	        console.log('âœ… Creating WebGL renderer');
	        return this.createWebGLRenderer(options);
	    }
	    /**
	     * Create WebGPU renderer (Three.js r160+)
	     * WebGPURenderer is in examples/jsm, requires dynamic import
	     */
	    static async createWebGPURenderer(options) {
	        try {
	            // Dynamic import to avoid build-time resolution errors
	            // @ts-expect-error - WebGPURenderer is in examples/jsm, not in main type definitions
	            const { WebGPURenderer } = await import('three/examples/jsm/renderers/webgpu/WebGPURenderer.js');
	            if (!WebGPURenderer) {
	                throw new Error('WebGPURenderer not available after import');
	            }
	            const renderer = new WebGPURenderer({
	                canvas: options.canvas,
	                antialias: options.antialias !== false,
	                alpha: options.alpha || false,
	                powerPreference: options.powerPreference || 'high-performance'
	            });
	            await renderer.init();
	            console.log('âœ… WebGPURenderer initialized successfully');
	            return renderer;
	        }
	        catch (error) {
	            console.warn('âš ï¸ Failed to load WebGPURenderer:', error);
	            throw new Error(`WebGPURenderer not available: ${error}`);
	        }
	    }
	    /**
	     * Create WebGL renderer (All Three.js versions)
	     */
	    static createWebGLRenderer(options) {
	        const rendererOptions = {
	            canvas: options.canvas,
	            antialias: options.antialias !== false,
	            alpha: options.alpha || false,
	            preserveDrawingBuffer: options.preserveDrawingBuffer || false,
	            powerPreference: options.powerPreference || 'high-performance',
	            stencil: options.stencil !== false,
	            depth: options.depth !== false,
	            logarithmicDepthBuffer: options.logarithmicDepthBuffer || false,
	            precision: options.precision || 'highp'
	        };
	        return new THREE__namespace.WebGLRenderer(rendererOptions);
	    }
	    /**
	     * Check if instanced rendering is available
	     */
	    static hasInstancedMesh() {
	        return ThreeVersionDetector.hasInstancedMesh();
	    }
	    /**
	     * Get InstancedMesh class if available
	     */
	    static getInstancedMesh() {
	        if (this.hasInstancedMesh()) {
	            return THREE__namespace.InstancedMesh;
	        }
	        console.warn('âš ï¸ InstancedMesh not available in this Three.js version');
	        return null;
	    }
	    /**
	     * Check if LOD (Level of Detail) is available
	     */
	    static hasLOD() {
	        return ThreeVersionDetector.hasLOD();
	    }
	    /**
	     * Get LOD class if available
	     */
	    static getLOD() {
	        if (this.hasLOD()) {
	            return THREE__namespace.LOD;
	        }
	        console.warn('âš ï¸ LOD not available in this Three.js version');
	        return null;
	    }
	    /**
	     * Enable shadow optimization based on version
	     */
	    static optimizeShadows(renderer, quality = 'medium') {
	        const isWebGPU = renderer.isWebGPURenderer;
	        if (!isWebGPU && renderer.shadowMap) {
	            // WebGL shadow optimization
	            renderer.shadowMap.enabled = true;
	            switch (quality) {
	                case 'low':
	                    renderer.shadowMap.type = THREE__namespace.BasicShadowMap;
	                    break;
	                case 'medium':
	                    renderer.shadowMap.type = THREE__namespace.PCFShadowMap;
	                    break;
	                case 'high':
	                    renderer.shadowMap.type = THREE__namespace.PCFSoftShadowMap;
	                    break;
	            }
	        }
	        else if (isWebGPU) {
	            // WebGPU has built-in shadow support
	            console.log('âœ… WebGPU renderer with native shadow support');
	        }
	    }
	    /**
	     * Get renderer type for diagnostics
	     */
	    static getRendererType(renderer) {
	        if (renderer.isWebGPURenderer) {
	            return 'webgpu';
	        }
	        const gl = renderer.getContext();
	        if (gl && gl.constructor.name.includes('2')) {
	            return 'webgl2';
	        }
	        return 'webgl';
	    }
	}
	/**
	 * General rendering compatibility helpers
	 */
	class RenderingCompatibility {
	    /**
	     * Detect optimal pixel ratio for device
	     */
	    static getOptimalPixelRatio() {
	        const dpr = window.devicePixelRatio || 1;
	        const isMobile = BrowserFeatureDetector.isMobile();
	        // Limit pixel ratio on mobile to save performance
	        if (isMobile) {
	            return Math.min(dpr, 2);
	        }
	        // Desktop can handle higher DPR
	        return Math.min(dpr, 3);
	    }
	    /**
	     * Get recommended anti-aliasing setting
	     */
	    static getRecommendedAntialias() {
	        const isMobile = BrowserFeatureDetector.isMobile();
	        const hasWebGPU = BrowserFeatureDetector.hasWebGPU();
	        // WebGPU has better AA performance
	        if (hasWebGPU) {
	            return true;
	        }
	        // Mobile with WebGL - disable AA for performance
	        if (isMobile) {
	            return false;
	        }
	        // Desktop with WebGL - enable AA
	        return true;
	    }
	    /**
	     * Get recommended power preference
	     */
	    static getRecommendedPowerPreference() {
	        const isMobile = BrowserFeatureDetector.isMobile();
	        const hasBattery = BrowserFeatureDetector.hasBatteryAPI();
	        if (isMobile || hasBattery) {
	            // Mobile and battery-powered devices: balance performance and battery
	            return 'default';
	        }
	        // Desktop: prefer high performance
	        return 'high-performance';
	    }
	    /**
	     * Log compatibility report
	     */
	    static logCompatibilityReport() {
	        console.group('ðŸ” Rendering Compatibility Report');
	        console.log('Pixi.js:', {
	            version: PixiVersionDetector.getVersion().raw,
	            isV8: PixiVersionDetector.isV8OrHigher(),
	            hasWebGPU: PixiVersionDetector.getFeatureSupport().webgpu,
	            hasAutoDetect: PixiVersionDetector.hasAutoDetectRenderer(),
	            hasParticleContainer: PixiVersionDetector.hasParticleContainer()
	        });
	        console.log('Three.js:', {
	            revision: ThreeVersionDetector.getRevision(),
	            isR180Plus: ThreeVersionDetector.isR180OrHigher(),
	            hasWebGPU: ThreeVersionDetector.hasWebGPURenderer(),
	            hasInstancedMesh: ThreeVersionDetector.hasInstancedMesh(),
	            hasLOD: ThreeVersionDetector.hasLOD()
	        });
	        console.log('Recommendations:', {
	            pixelRatio: this.getOptimalPixelRatio(),
	            antialias: this.getRecommendedAntialias(),
	            powerPreference: this.getRecommendedPowerPreference()
	        });
	        console.groupEnd();
	    }
	}

	/**
	 * Responsive Helper Utilities
	 *
	 * Provides automatic responsive scaling for game UI elements based on viewport size.
	 * Uses a mobile-first approach with a base design size and calculates scale factors.
	 */
	/**
	 * ResponsiveScaleCalculator
	 *
	 * Calculates scale factors based on viewport size relative to base design size.
	 * Uses mobile-first approach: designs are created at base size (e.g., 1080x1920)
	 * and scaled up/down based on actual viewport dimensions.
	 */
	class ResponsiveScaleCalculator {
	    constructor(config) {
	        this.resizeCallbacks = [];
	        this.config = {
	            baseWidth: config.baseWidth,
	            baseHeight: config.baseHeight,
	            minScale: config.minScale ?? 0.5,
	            maxScale: config.maxScale ?? 2.0
	        };
	        this.currentSize = this.calculate();
	        this.setupResizeObserver();
	    }
	    /**
	     * Calculate current responsive size and scale factor
	     */
	    calculate() {
	        const width = window.innerWidth;
	        const height = window.innerHeight;
	        // Calculate scale factor based on width (mobile-first)
	        const scale = Math.max(this.config.minScale, Math.min(width / this.config.baseWidth, this.config.maxScale));
	        return { width, height, scale };
	    }
	    /**
	     * Get current responsive size
	     */
	    getSize() {
	        return { ...this.currentSize };
	    }
	    /**
	     * Get current scale factor
	     */
	    getScale() {
	        return this.currentSize.scale;
	    }
	    /**
	     * Scale a base value by the current scale factor
	     */
	    scale(baseValue) {
	        return baseValue * this.currentSize.scale;
	    }
	    /**
	     * Scale a size value (width, height, radius, etc.)
	     */
	    scaleSize(baseSize) {
	        return this.scale(baseSize);
	    }
	    /**
	     * Scale a font size
	     */
	    scaleFont(baseFontSize) {
	        return this.scale(baseFontSize);
	    }
	    /**
	     * Scale a position value (x, y)
	     */
	    scalePosition(basePosition) {
	        return this.scale(basePosition);
	    }
	    /**
	     * Scale a padding/margin value
	     */
	    scalePadding(basePadding) {
	        return this.scale(basePadding);
	    }
	    /**
	     * Scale a stroke width
	     */
	    scaleStroke(baseStroke) {
	        return this.scale(baseStroke);
	    }
	    /**
	     * Register a callback for resize events
	     */
	    onResize(callback) {
	        this.resizeCallbacks.push(callback);
	    }
	    /**
	     * Remove a resize callback
	     */
	    offResize(callback) {
	        const index = this.resizeCallbacks.indexOf(callback);
	        if (index !== -1) {
	            this.resizeCallbacks.splice(index, 1);
	        }
	    }
	    /**
	     * Set up window resize observer
	     */
	    setupResizeObserver() {
	        window.addEventListener('resize', () => {
	            const oldScale = this.currentSize.scale;
	            this.currentSize = this.calculate();
	            // Only trigger callbacks if scale changed significantly
	            if (Math.abs(this.currentSize.scale - oldScale) > 0.01) {
	                this.resizeCallbacks.forEach(callback => callback(this.currentSize));
	            }
	        });
	    }
	    /**
	     * Destroy and clean up
	     */
	    destroy() {
	        this.resizeCallbacks = [];
	    }
	}
	/**
	 * ResponsiveContainer
	 *
	 * A wrapper for Pixi containers that automatically applies responsive scaling
	 * to all child elements and their properties.
	 */
	class ResponsiveContainer {
	    constructor(calculator, container) {
	        this.baseValues = new Map();
	        this.calculator = calculator;
	        this.container = container;
	        // Listen for resize events
	        this.calculator.onResize((size) => {
	            this.updateScale();
	        });
	    }
	    /**
	     * Store base values for an element before scaling
	     */
	    storeBaseValues(element, values) {
	        this.baseValues.set(element, { ...values });
	    }
	    /**
	     * Get the Pixi container
	     */
	    getContainer() {
	        return this.container;
	    }
	    /**
	     * Apply responsive scaling to an element's properties
	     */
	    applyScale(element, properties) {
	        const baseValues = this.baseValues.get(element);
	        if (!baseValues) {
	            console.warn('No base values stored for element. Call storeBaseValues() first.');
	            return;
	        }
	        const scale = this.calculator.getScale();
	        properties.forEach(prop => {
	            if (baseValues[prop] !== undefined) {
	                element[prop] = baseValues[prop] * scale;
	            }
	        });
	    }
	    /**
	     * Apply responsive scaling to text style
	     */
	    applyTextScale(text, baseStyle) {
	        const scale = this.calculator.getScale();
	        if (text.style) {
	            if (baseStyle.fontSize !== undefined) {
	                text.style.fontSize = baseStyle.fontSize * scale;
	            }
	            if (baseStyle.strokeThickness !== undefined) {
	                text.style.strokeThickness = baseStyle.strokeThickness * scale;
	            }
	            if (baseStyle.stroke && baseStyle.stroke.width !== undefined) {
	                text.style.stroke.width = baseStyle.stroke.width * scale;
	            }
	            if (baseStyle.dropShadow) {
	                if (baseStyle.dropShadow.distance !== undefined) {
	                    text.style.dropShadow.distance = baseStyle.dropShadow.distance * scale;
	                }
	                if (baseStyle.dropShadow.blur !== undefined) {
	                    text.style.dropShadow.blur = baseStyle.dropShadow.blur * scale;
	                }
	            }
	        }
	    }
	    /**
	     * Update scale for all stored elements
	     */
	    updateScale() {
	        // This should be implemented by the user to update their specific elements
	        // Or we can provide a mechanism to register auto-update callbacks
	    }
	    /**
	     * Destroy and clean up
	     */
	    destroy() {
	        this.baseValues.clear();
	    }
	}
	/**
	 * Helper class for managing responsive canvas sizing
	 */
	class ResponsiveCanvas {
	    constructor(calculator, canvas) {
	        this.calculator = calculator;
	        this.canvas = canvas;
	        // Initial sizing
	        this.updateSize();
	        // Listen for resize events
	        this.calculator.onResize(() => {
	            this.updateSize();
	        });
	    }
	    /**
	     * Update canvas size to match current viewport
	     */
	    updateSize() {
	        const size = this.calculator.getSize();
	        // Update canvas internal resolution
	        this.canvas.width = size.width;
	        this.canvas.height = size.height;
	        // Update canvas CSS display size
	        this.canvas.style.width = size.width + 'px';
	        this.canvas.style.height = size.height + 'px';
	    }
	    /**
	     * Get current canvas size
	     */
	    getSize() {
	        return this.calculator.getSize();
	    }
	}
	/**
	 * Create a responsive scale calculator with common mobile-first defaults
	 */
	function createResponsiveCalculator(config) {
	    return new ResponsiveScaleCalculator({
	        baseWidth: config?.baseWidth ?? 1080,
	        baseHeight: config?.baseHeight ?? 1920,
	        minScale: config?.minScale ?? 0.5,
	        maxScale: config?.maxScale ?? 2.0
	    });
	}

	/**
	 * 2D renderer implementation using Pixi.js with WebGPU support.
	 * Supports both Pixi.js v7 and v8 with automatic fallback.
	 */
	class PixiRenderer extends EventEmitter {
	    constructor() {
	        super(...arguments);
	        this.mode = exports.RenderingMode.RENDERER_2D;
	        this.app = null; // Can be Application (v7) or Renderer (v8)
	        this.stage = null; // Pixi Container for scene graph
	        this.lastTime = 0;
	        this.frameCount = 0;
	        this.fps = 60;
	        this.renderMode = 'continuous';
	        this.needsRender = false;
	        this.enableStats = false;
	        this.responsiveCalculator = null;
	        this.canvas = null;
	    }
	    /**
	     * Initialize the 2D renderer with WebGPU support and v7/v8 compatibility.
	     */
	    async initialize(canvas, options = {}) {
	        // Log compatibility info
	        console.log('ðŸŽ® Initializing PixiRenderer with Pixi.js', PixiVersionDetector.getVersion().raw);
	        // Store canvas reference
	        this.canvas = canvas;
	        // Set configuration
	        this.renderMode = options.renderMode || 'continuous';
	        this.enableStats = options.enableStats ?? false;
	        // Initialize responsive calculator if enabled
	        if (options.responsive) {
	            const responsiveConfig = typeof options.responsive === 'boolean'
	                ? { baseWidth: 1080, baseHeight: 1920 } // Mobile-first defaults
	                : options.responsive;
	            this.responsiveCalculator = new ResponsiveScaleCalculator(responsiveConfig);
	            // Set up canvas resize handling
	            this.responsiveCalculator.onResize((size) => {
	                this.handleResponsiveResize(size);
	            });
	            console.log('ðŸ“± Responsive mode enabled with base size:', responsiveConfig.baseWidth, 'x', responsiveConfig.baseHeight);
	        }
	        // Get optimal settings for device
	        const optimalPixelRatio = RenderingCompatibility.getOptimalPixelRatio();
	        const recommendedAntialias = RenderingCompatibility.getRecommendedAntialias();
	        // Build Pixi options with smart defaults
	        const pixiOptions = {
	            canvas,
	            width: options.width || canvas.width || 800,
	            height: options.height || canvas.height || 600,
	            antialias: options.antialias ?? recommendedAntialias,
	            backgroundAlpha: options.transparent ? 0 : 1,
	            backgroundColor: options.backgroundColor,
	            preserveDrawingBuffer: options.preserveDrawingBuffer ?? false,
	            powerPreference: options.powerPreference, // Let Pixi handle default (WebGPU doesn't accept 'default')
	            autoDensity: options.autoDensity ?? true,
	            resolution: options.resolution || optimalPixelRatio,
	            preference: options.preference || 'webgl' // Default to stable WebGL (WebGPU is experimental)
	        };
	        // Create renderer using compatibility layer (supports v7 and v8)
	        try {
	            this.app = await PixiCompatibility.createRenderer(pixiOptions);
	            console.log('âœ… PixiRenderer initialized successfully');
	        }
	        catch (error) {
	            console.error('âŒ Failed to initialize PixiRenderer:', error);
	            throw error;
	        }
	        // Get stage (v7 has it, v8 needs to create it)
	        this.stage = PixiCompatibility.getStage(this.app);
	        // Set up resize handling if available
	        const renderer = PixiCompatibility.getRenderer(this.app);
	        if (renderer && renderer.on) {
	            renderer.on('resize', (width, height) => {
	                this.emit('resize', width, height);
	                this.requestRender(); // Re-render on resize
	            });
	        }
	        this.emit('initialized');
	    }
	    /**
	     * Start the render loop.
	     * In on-demand mode, this just enables rendering when requested.
	     * In continuous mode, this starts the ticker.
	     */
	    start() {
	        if (!this.app) {
	            throw new Error('Renderer not initialized');
	        }
	        if (this.renderMode === 'continuous') {
	            // Continuous rendering - use ticker
	            const ticker = this.getTicker();
	            if (ticker) {
	                ticker.start();
	                ticker.add(this.onTick, this);
	            }
	        }
	        else {
	            // On-demand rendering - just mark as ready
	            console.log('ðŸ“Š PixiRenderer started in on-demand mode');
	        }
	        this.emit('started');
	    }
	    /**
	     * Stop the render loop.
	     */
	    stop() {
	        if (!this.app) {
	            return;
	        }
	        const ticker = this.getTicker();
	        if (ticker) {
	            ticker.remove(this.onTick, this);
	            ticker.stop();
	        }
	        this.emit('stopped');
	    }
	    /**
	     * Request a render frame (useful for on-demand rendering).
	     */
	    requestRender() {
	        if (this.renderMode === 'on-demand') {
	            this.needsRender = true;
	            this.render();
	        }
	    }
	    /**
	     * Mark scene as dirty and needing re-render.
	     */
	    markDirty() {
	        this.needsRender = true;
	    }
	    /**
	     * Resize the renderer using compatibility helper.
	     */
	    resize(width, height) {
	        if (!this.app) {
	            return;
	        }
	        PixiCompatibility.resize(this.app, width, height);
	        this.emit('resize', width, height);
	        this.requestRender(); // Re-render after resize
	    }
	    /**
	     * Render a single frame using compatibility helper.
	     * In on-demand mode, only renders if scene is dirty.
	     */
	    render(deltaTime) {
	        if (!this.app || !this.stage) {
	            return;
	        }
	        // In on-demand mode, only render if needed
	        if (this.renderMode === 'on-demand' && !this.needsRender) {
	            return;
	        }
	        PixiCompatibility.render(this.app, this.stage);
	        this.needsRender = false;
	        this.emit('render', deltaTime);
	    }
	    /**
	     * Get the current canvas element using compatibility helper.
	     */
	    getCanvas() {
	        if (!this.app) {
	            return null;
	        }
	        try {
	            return PixiCompatibility.getCanvas(this.app);
	        }
	        catch {
	            return null;
	        }
	    }
	    /**
	     * Get the underlying 2D renderer application/renderer instance.
	     * Can be Application (v7) or Renderer (v8).
	     */
	    getApplication() {
	        return this.app;
	    }
	    /**
	     * Get the Pixi stage (scene graph root).
	     */
	    getStage() {
	        return this.stage;
	    }
	    /**
	     * Get the actual renderer instance (unwrapped from Application if needed).
	     */
	    getRenderer() {
	        if (!this.app) {
	            return null;
	        }
	        return PixiCompatibility.getRenderer(this.app);
	    }
	    /**
	     * Get the native renderer instance (implements Renderer interface).
	     * For PixiRenderer, returns the Pixi Application or Renderer.
	     */
	    getNativeRenderer() {
	        return (this.app || this.getRenderer());
	    }
	    /**
	     * Get the ticker for animation loop.
	     */
	    getTicker() {
	        if (!this.app) {
	            return null;
	        }
	        // v7 Application has ticker
	        if (this.app.ticker) {
	            return this.app.ticker;
	        }
	        // v8 needs to create shared ticker
	        const Ticker = PIXI__namespace.Ticker;
	        if (Ticker && Ticker.shared) {
	            return Ticker.shared;
	        }
	        return null;
	    }
	    /**
	     * Get renderer statistics with improved tracking.
	     */
	    getStats() {
	        const renderer = PixiCompatibility.getRenderer(this.app);
	        const ticker = this.getTicker();
	        const gl = renderer?.gl;
	        // Try to get actual stats from renderer
	        let drawCalls = 0;
	        if (this.enableStats && renderer) {
	            // Pixi v8 may expose renderer.renderTarget or renderer.batch
	            const batch = renderer.batch;
	            if (batch && batch.drawCalls !== undefined) {
	                drawCalls = batch.drawCalls;
	            }
	            // Get texture binding count if available
	            if (renderer.texture && renderer.texture.boundTextures) {
	                renderer.texture.boundTextures.length || 0;
	            }
	        }
	        return {
	            fps: this.fps,
	            deltaTime: ticker?.deltaMS || 0,
	            drawCalls,
	            triangles: 0, // Pixi doesn't expose this
	            memory: {
	                used: gl ? gl.memory?.used || 0 : 0,
	                total: gl ? gl.memory?.total || 0 : 0
	            }
	        };
	    }
	    /**
	     * Get detailed renderer information for debugging.
	     */
	    getRendererInfo() {
	        const renderer = PixiCompatibility.getRenderer(this.app);
	        return {
	            version: PixiVersionDetector.getVersion(),
	            type: renderer?.type || 'unknown',
	            renderMode: this.renderMode,
	            resolution: renderer?.resolution || 1,
	            fps: this.fps,
	            features: PixiVersionDetector.getFeatureSupport()
	        };
	    }
	    /**
	     * Get the responsive scale calculator (if responsive mode is enabled)
	     */
	    getResponsiveCalculator() {
	        return this.responsiveCalculator;
	    }
	    /**
	     * Get current responsive size and scale (if responsive mode is enabled)
	     */
	    getResponsiveSize() {
	        return this.responsiveCalculator ? this.responsiveCalculator.getSize() : null;
	    }
	    /**
	     * Get current responsive scale factor (if responsive mode is enabled)
	     */
	    getResponsiveScale() {
	        return this.responsiveCalculator ? this.responsiveCalculator.getScale() : null;
	    }
	    /**
	     * Handle responsive resize events
	     */
	    handleResponsiveResize(size) {
	        if (!this.canvas || !this.app) {
	            return;
	        }
	        // Update canvas size
	        this.canvas.width = size.width;
	        this.canvas.height = size.height;
	        this.canvas.style.width = size.width + 'px';
	        this.canvas.style.height = size.height + 'px';
	        // Update renderer size
	        PixiCompatibility.resize(this.app, size.width, size.height);
	        // Emit resize event with scale information
	        this.emit('resize', size.width, size.height, size.scale);
	        this.emit('responsiveResize', size);
	        this.requestRender();
	    }
	    /**
	     * Destroy the renderer and clean up resources.
	     */
	    destroy() {
	        if (this.app) {
	            const ticker = this.getTicker();
	            if (ticker) {
	                ticker.remove(this.onTick, this);
	            }
	            // Destroy application/renderer
	            if (this.app.destroy) {
	                this.app.destroy(true);
	            }
	            this.app = null;
	            this.stage = null;
	        }
	        // Clean up responsive calculator
	        if (this.responsiveCalculator) {
	            this.responsiveCalculator.destroy();
	            this.responsiveCalculator = null;
	        }
	        this.canvas = null;
	        this.removeAllListeners();
	        this.emit('destroyed');
	    }
	    /**
	     * Handle ticker updates with improved FPS calculation.
	     */
	    onTick() {
	        const now = performance.now();
	        const deltaTime = now - this.lastTime;
	        this.lastTime = now;
	        // Calculate FPS with smoothing
	        this.frameCount++;
	        if (this.frameCount >= 30) { // Check every 30 frames for more stable FPS
	            const averageDelta = deltaTime / this.frameCount;
	            this.fps = Math.round(1000 / averageDelta);
	            this.frameCount = 0;
	        }
	        // Emit tick event for game loop
	        this.emit('tick', deltaTime);
	        // In continuous mode, always mark for re-render and render
	        if (this.renderMode === 'continuous') {
	            this.needsRender = true;
	            this.render(deltaTime);
	        }
	    }
	}

	/**
	 * 3D renderer implementation using Three.js with WebGPU support.
	 * Supports WebGPURenderer (r160+) with automatic fallback to WebGLRenderer.
	 */
	class ThreeRenderer extends EventEmitter {
	    constructor() {
	        super(...arguments);
	        this.mode = exports.RenderingMode.RENDERER_3D;
	        this.renderer = null; // Can be WebGLRenderer or WebGPURenderer
	        this.scene = null;
	        this.camera = null;
	        this.clock = new THREE.Clock();
	        this.animationId = null;
	        this.lastTime = 0;
	        this.frameCount = 0;
	        this.fps = 60;
	        this.renderMode = 'continuous';
	        this.needsRender = false;
	        this.enableStats = false;
	        this.shadowQuality = 'medium';
	        this.enableFrustumCulling = true;
	        /**
	         * Main render loop with improved FPS calculation.
	         */
	        this.renderLoop = () => {
	            const now = performance.now();
	            const deltaTime = now - this.lastTime;
	            this.lastTime = now;
	            // Calculate FPS with smoothing
	            this.frameCount++;
	            if (this.frameCount >= 30) { // Check every 30 frames for more stable FPS
	                const averageDelta = deltaTime / this.frameCount;
	                this.fps = Math.round(1000 / averageDelta);
	                this.frameCount = 0;
	            }
	            this.emit('tick', deltaTime);
	            // In continuous mode, always mark for re-render
	            if (this.renderMode === 'continuous') {
	                this.needsRender = true;
	            }
	            this.render(deltaTime);
	            this.animationId = requestAnimationFrame(this.renderLoop);
	        };
	    }
	    /**
	     * Initialize the 3D renderer with WebGPU support and r180 optimizations.
	     */
	    async initialize(canvas, options = {}) {
	        // Log compatibility info
	        console.log('ðŸŽ® Initializing ThreeRenderer with Three.js r' + ThreeVersionDetector.getRevision());
	        // Set configuration
	        this.renderMode = options.renderMode || 'continuous';
	        this.enableStats = options.enableStats ?? false;
	        this.shadowQuality = options.shadowQuality || 'medium';
	        this.enableFrustumCulling = options.enableFrustumCulling ?? true;
	        // Get optimal settings for device
	        const optimalPixelRatio = RenderingCompatibility.getOptimalPixelRatio();
	        const recommendedAntialias = RenderingCompatibility.getRecommendedAntialias();
	        const recommendedPower = RenderingCompatibility.getRecommendedPowerPreference();
	        // Build Three.js options with smart defaults
	        const threeOptions = {
	            canvas,
	            antialias: options.antialias ?? recommendedAntialias,
	            alpha: options.transparent ?? false,
	            preserveDrawingBuffer: options.preserveDrawingBuffer ?? false,
	            powerPreference: options.powerPreference || recommendedPower
	        };
	        // Create renderer using compatibility layer (WebGPU or WebGL)
	        try {
	            this.renderer = await ThreeCompatibility.createRenderer(threeOptions);
	            console.log('âœ… ThreeRenderer initialized with', ThreeCompatibility.getRendererType(this.renderer));
	        }
	        catch (error) {
	            console.error('âŒ Failed to initialize ThreeRenderer:', error);
	            throw error;
	        }
	        // Set renderer size and pixel ratio
	        this.renderer.setSize(options.width || canvas.width || 800, options.height || canvas.height || 600, false);
	        if (options.resolution) {
	            this.renderer.setPixelRatio(options.resolution);
	        }
	        else {
	            this.renderer.setPixelRatio(optimalPixelRatio);
	        }
	        // Set background color if provided
	        if (options.backgroundColor !== undefined) {
	            const color = typeof options.backgroundColor === 'string'
	                ? options.backgroundColor
	                : `#${options.backgroundColor.toString(16).padStart(6, '0')}`;
	            if (this.renderer.setClearColor) {
	                this.renderer.setClearColor(color);
	            }
	        }
	        // Apply shadow optimization
	        ThreeCompatibility.optimizeShadows(this.renderer, this.shadowQuality);
	        // Create default scene
	        this.scene = new THREE.Scene();
	        // Frustum culling is enabled by default in Three.js
	        // Objects are automatically culled based on camera frustum
	        this.emit('initialized');
	    }
	    /**
	     * Start the render loop.
	     * In on-demand mode, this just enables rendering when requested.
	     * In continuous mode, this starts the animation loop.
	     */
	    start() {
	        if (!this.renderer) {
	            throw new Error('Renderer not initialized');
	        }
	        this.clock.start();
	        if (this.renderMode === 'continuous') {
	            this.renderLoop();
	        }
	        else {
	            console.log('ðŸ“Š ThreeRenderer started in on-demand mode');
	        }
	        this.emit('started');
	    }
	    /**
	     * Stop the render loop.
	     */
	    stop() {
	        if (this.animationId) {
	            cancelAnimationFrame(this.animationId);
	            this.animationId = null;
	        }
	        this.clock.stop();
	        this.emit('stopped');
	    }
	    /**
	     * Request a render frame (useful for on-demand rendering).
	     */
	    requestRender() {
	        if (this.renderMode === 'on-demand') {
	            this.needsRender = true;
	            this.render();
	        }
	    }
	    /**
	     * Mark scene as dirty and needing re-render.
	     */
	    markDirty() {
	        this.needsRender = true;
	    }
	    /**
	     * Resize the renderer and update camera.
	     */
	    resize(width, height) {
	        if (!this.renderer) {
	            return;
	        }
	        this.renderer.setSize(width, height, false);
	        // Update camera aspect ratio if it's a perspective camera
	        if (this.camera && 'aspect' in this.camera) {
	            this.camera.aspect = width / height;
	            this.camera.updateProjectionMatrix?.();
	        }
	        this.emit('resize', width, height);
	        this.requestRender(); // Re-render after resize
	    }
	    /**
	     * Render a single frame.
	     * In on-demand mode, only renders if scene is dirty.
	     */
	    render(deltaTime) {
	        if (!this.renderer || !this.scene || !this.camera) {
	            return;
	        }
	        // In on-demand mode, only render if needed
	        if (this.renderMode === 'on-demand' && !this.needsRender) {
	            return;
	        }
	        this.renderer.render(this.scene, this.camera);
	        this.needsRender = false;
	        this.emit('render', deltaTime);
	    }
	    /**
	     * Get the current canvas element.
	     */
	    getCanvas() {
	        return this.renderer?.domElement || null;
	    }
	    /**
	     * Get the underlying 3D renderer instance.
	     * Can be WebGLRenderer or WebGPURenderer (r160+).
	     */
	    getRenderer() {
	        return this.renderer;
	    }
	    /**
	     * Get the current scene.
	     */
	    getScene() {
	        return this.scene;
	    }
	    /**
	     * Set the active scene.
	     */
	    setScene(scene) {
	        this.scene = scene;
	    }
	    /**
	     * Get the current camera.
	     */
	    getCamera() {
	        return this.camera;
	    }
	    /**
	     * Set the active camera.
	     */
	    setCamera(camera) {
	        this.camera = camera;
	    }
	    /**
	     * Get renderer statistics with improved tracking.
	     */
	    getStats() {
	        const info = this.renderer?.info;
	        const memory = info?.memory;
	        const render = info?.render;
	        // Get delta time without consuming it
	        const delta = this.clock.running ? performance.now() - this.lastTime : 0;
	        return {
	            fps: this.fps,
	            deltaTime: delta,
	            drawCalls: render?.calls || 0,
	            triangles: render?.triangles || 0,
	            memory: {
	                used: (memory?.geometries || 0) + (memory?.textures || 0),
	                total: 0 // Three.js doesn't provide total memory info
	            }
	        };
	    }
	    /**
	     * Get detailed renderer information for debugging.
	     */
	    getRendererInfo() {
	        return {
	            revision: ThreeVersionDetector.getRevision(),
	            type: ThreeCompatibility.getRendererType(this.renderer),
	            renderMode: this.renderMode,
	            shadowQuality: this.shadowQuality,
	            frustumCulling: this.enableFrustumCulling,
	            resolution: this.renderer?.getPixelRatio() || 1,
	            fps: this.fps,
	            features: ThreeVersionDetector.getFeatureSupport(),
	            info: this.renderer?.info
	        };
	    }
	    /**
	     * Enable or disable shadow rendering
	     */
	    setShadowQuality(quality) {
	        this.shadowQuality = quality;
	        if (this.renderer) {
	            ThreeCompatibility.optimizeShadows(this.renderer, quality);
	        }
	    }
	    /**
	     * Get the Three.js scene (implements Renderer interface).
	     */
	    getStage() {
	        return this.scene;
	    }
	    /**
	     * Get the native Three.js renderer (implements Renderer interface).
	     */
	    getNativeRenderer() {
	        return this.renderer;
	    }
	    /**
	     * Destroy the renderer and clean up resources.
	     */
	    destroy() {
	        this.stop();
	        if (this.renderer) {
	            this.renderer.dispose();
	            this.renderer = null;
	        }
	        this.scene = null;
	        this.camera = null;
	        this.removeAllListeners();
	        this.emit('destroyed');
	    }
	}

	/**
	 * Hybrid renderer that combines Three.js (3D) and Pixi.js (2D) using stacked canvas approach.
	 *
	 * Architecture:
	 * - Layer 1 (z-index: 1): Three.js canvas for 3D background/scene
	 * - Layer 2 (z-index: 2): Pixi.js canvas for 2D UI overlay (transparent)
	 *
	 * Both renderers run independently with synchronized dimensions and render loops.
	 * Perfect for games that need 3D environments with 2D UI overlays.
	 *
	 * @example
	 * ```typescript
	 * const hybridRenderer = new HybridRenderer();
	 * await hybridRenderer.initialize(containerElement, {
	 *   width: 1080,
	 *   height: 1920,
	 *   antialias: true,
	 *   transparent: false // Three.js opaque, Pixi.js transparent
	 * });
	 *
	 * // Get Three.js components
	 * const threeScene = hybridRenderer.getThreeScene();
	 * const threeCamera = hybridRenderer.getThreeCamera();
	 *
	 * // Get Pixi.js stage
	 * const pixiStage = hybridRenderer.getPixiStage();
	 *
	 * // Start rendering both layers
	 * hybridRenderer.start();
	 * ```
	 */
	class HybridRenderer extends EventEmitter {
	    constructor() {
	        super(...arguments);
	        this.mode = exports.RenderingMode.HYBRID;
	        // Three.js (3D Layer)
	        this.threeRenderer = null;
	        this.threeScene = null;
	        this.threeCamera = null;
	        this.threeCanvas = null;
	        this.clock = new THREE.Clock();
	        // Pixi.js (2D UI Layer)
	        this.pixiApp = null; // Can be Application (v7) or Renderer (v8)
	        this.pixiStage = null; // Pixi Container
	        this.pixiCanvas = null;
	        // Shared state
	        this.container = null;
	        this.animationId = null;
	        this.lastTime = 0;
	        this.frameCount = 0;
	        this.fps = 60;
	        this.renderMode = 'continuous';
	        this.needsRender = false;
	        this.enableStats = false;
	        // Configuration
	        this.shadowQuality = 'medium';
	        this.enableFrustumCulling = true;
	        this.threeZIndex = 1;
	        this.pixiZIndex = 2;
	    }
	    /**
	     * Initialize the hybrid renderer with stacked canvas architecture.
	     *
	     * @param container - Parent HTML element to contain both canvases
	     * @param options - Configuration options
	     */
	    async initialize(container, options = {}) {
	        console.log('ðŸŽ® Initializing HybridRenderer (Three.js + Pixi.js)');
	        console.log('   Three.js r' + ThreeVersionDetector.getRevision());
	        console.log('   Pixi.js', PixiVersionDetector.getVersion().raw);
	        this.container = container;
	        // Set configuration
	        this.renderMode = options.renderMode || 'continuous';
	        this.enableStats = options.enableStats ?? false;
	        this.shadowQuality = options.shadowQuality || 'medium';
	        this.enableFrustumCulling = options.enableFrustumCulling ?? true;
	        this.threeZIndex = options.threeZIndex ?? 1;
	        this.pixiZIndex = options.pixiZIndex ?? 2;
	        // Get optimal settings for device
	        const optimalPixelRatio = RenderingCompatibility.getOptimalPixelRatio();
	        const recommendedAntialias = RenderingCompatibility.getRecommendedAntialias();
	        const recommendedPower = RenderingCompatibility.getRecommendedPowerPreference();
	        const width = options.width || container.clientWidth || 800;
	        const height = options.height || container.clientHeight || 600;
	        // Setup container styles
	        container.style.position = 'relative';
	        container.style.width = `${width}px`;
	        container.style.height = `${height}px`;
	        container.style.overflow = 'hidden';
	        // Initialize Three.js (3D Background Layer)
	        await this.initializeThreeLayer(width, height, {
	            antialias: options.antialias ?? recommendedAntialias,
	            alpha: false, // Opaque background (Three.js uses 'alpha' not 'transparent')
	            preserveDrawingBuffer: options.preserveDrawingBuffer ?? false,
	            powerPreference: options.powerPreference || recommendedPower
	        }, {
	            backgroundColor: options.backgroundColor,
	            resolution: options.resolution || optimalPixelRatio
	        });
	        // Initialize Pixi.js (2D UI Overlay Layer)
	        await this.initializePixiLayer(width, height, {
	            antialias: options.antialias ?? recommendedAntialias,
	            backgroundAlpha: 0, // Transparent to show 3D layer below
	            preserveDrawingBuffer: options.preserveDrawingBuffer ?? false,
	            powerPreference: options.powerPreference || recommendedPower,
	            resolution: options.resolution || optimalPixelRatio,
	            preference: options.pixiPreference
	        });
	        // Set up synchronized resize handling
	        this.setupResizeHandling();
	        console.log('âœ… HybridRenderer initialized successfully');
	        console.log('   Three.js layer: z-index', this.threeZIndex);
	        console.log('   Pixi.js layer: z-index', this.pixiZIndex);
	        this.emit('initialized');
	    }
	    /**
	     * Initialize Three.js 3D background layer
	     */
	    async initializeThreeLayer(width, height, options, extraOptions) {
	        // Create Three.js canvas
	        this.threeCanvas = document.createElement('canvas');
	        this.threeCanvas.id = 'three-canvas';
	        this.threeCanvas.style.position = 'absolute';
	        this.threeCanvas.style.top = '0';
	        this.threeCanvas.style.left = '0';
	        this.threeCanvas.style.zIndex = String(this.threeZIndex);
	        this.threeCanvas.style.pointerEvents = 'none'; // UI layer handles interactions
	        // Append to container
	        this.container.appendChild(this.threeCanvas);
	        // Create Three.js renderer
	        const threeOptions = {
	            canvas: this.threeCanvas,
	            antialias: options.antialias ?? true,
	            alpha: options.alpha ?? false,
	            preserveDrawingBuffer: options.preserveDrawingBuffer ?? false,
	            powerPreference: options.powerPreference || 'high-performance'
	        };
	        try {
	            this.threeRenderer = await ThreeCompatibility.createRenderer(threeOptions);
	            console.log('âœ… Three.js layer initialized with', ThreeCompatibility.getRendererType(this.threeRenderer));
	        }
	        catch (error) {
	            console.error('âŒ Failed to initialize Three.js layer:', error);
	            throw error;
	        }
	        // Set renderer size and pixel ratio
	        this.threeRenderer.setSize(width, height, false);
	        if (extraOptions?.resolution) {
	            this.threeRenderer.setPixelRatio(extraOptions.resolution);
	        }
	        else {
	            this.threeRenderer.setPixelRatio(RenderingCompatibility.getOptimalPixelRatio());
	        }
	        // Set background color
	        if (extraOptions?.backgroundColor !== undefined) {
	            const bgColor = typeof extraOptions.backgroundColor === 'string'
	                ? parseInt(extraOptions.backgroundColor.replace('#', '0x'), 16)
	                : extraOptions.backgroundColor;
	            this.threeRenderer.setClearColor(bgColor, 1.0);
	        }
	        // Configure shadow quality
	        if (this.threeRenderer.shadowMap) {
	            this.threeRenderer.shadowMap.enabled = true;
	            switch (this.shadowQuality) {
	                case 'low':
	                    this.threeRenderer.shadowMap.type = 0; // BasicShadowMap
	                    break;
	                case 'medium':
	                    this.threeRenderer.shadowMap.type = 1; // PCFShadowMap
	                    break;
	                case 'high':
	                    this.threeRenderer.shadowMap.type = 2; // PCFSoftShadowMap
	                    break;
	            }
	        }
	        // Create default scene (can be replaced by user)
	        this.threeScene = new THREE.Scene();
	        // Camera will be set by user via setThreeCamera()
	    }
	    /**
	     * Initialize Pixi.js 2D UI overlay layer
	     */
	    async initializePixiLayer(width, height, options) {
	        // Create Pixi.js canvas
	        this.pixiCanvas = document.createElement('canvas');
	        this.pixiCanvas.id = 'pixi-canvas';
	        this.pixiCanvas.style.position = 'absolute';
	        this.pixiCanvas.style.top = '0';
	        this.pixiCanvas.style.left = '0';
	        this.pixiCanvas.style.zIndex = String(this.pixiZIndex);
	        this.pixiCanvas.style.pointerEvents = 'auto'; // Handle all interactions
	        // Append to container
	        this.container.appendChild(this.pixiCanvas);
	        // Create Pixi.js renderer
	        const pixiOptions = {
	            canvas: this.pixiCanvas,
	            width,
	            height,
	            antialias: options.antialias ?? true,
	            backgroundAlpha: 0, // Fully transparent
	            backgroundColor: 0x000000, // Black (won't be visible)
	            preserveDrawingBuffer: options.preserveDrawingBuffer ?? false,
	            powerPreference: options.powerPreference || 'high-performance',
	            autoDensity: true,
	            resolution: options.resolution || RenderingCompatibility.getOptimalPixelRatio(),
	            preference: options.preference
	        };
	        try {
	            this.pixiApp = await PixiCompatibility.createRenderer(pixiOptions);
	            console.log('âœ… Pixi.js layer initialized (transparent overlay)');
	        }
	        catch (error) {
	            console.error('âŒ Failed to initialize Pixi.js layer:', error);
	            throw error;
	        }
	        // Get stage
	        this.pixiStage = PixiCompatibility.getStage(this.pixiApp);
	    }
	    /**
	     * Setup synchronized resize handling for both layers
	     */
	    setupResizeHandling() {
	        const renderer = PixiCompatibility.getRenderer(this.pixiApp);
	        if (renderer && renderer.on) {
	            renderer.on('resize', (width, height) => {
	                // Resize Three.js layer to match
	                if (this.threeRenderer) {
	                    this.threeRenderer.setSize(width, height, false);
	                }
	                // Update container size
	                if (this.container) {
	                    this.container.style.width = `${width}px`;
	                    this.container.style.height = `${height}px`;
	                }
	                this.emit('resize', width, height);
	                this.requestRender();
	            });
	        }
	    }
	    /**
	     * Start the hybrid render loop.
	     * Both Three.js and Pixi.js render in the same animation frame.
	     */
	    start() {
	        if (this.animationId !== null) {
	            console.warn('HybridRenderer already started');
	            return;
	        }
	        console.log('â–¶ï¸ Starting HybridRenderer');
	        if (this.renderMode === 'continuous') {
	            this.startContinuousRendering();
	        }
	        else {
	            console.log('On-demand mode enabled. Call requestRender() to render.');
	        }
	        this.emit('start');
	    }
	    /**
	     * Start continuous rendering loop
	     */
	    startContinuousRendering() {
	        const animate = (currentTime) => {
	            this.animationId = requestAnimationFrame(animate);
	            // Calculate delta time
	            const deltaTime = this.lastTime > 0 ? (currentTime - this.lastTime) / 1000 : 0;
	            this.lastTime = currentTime;
	            // Calculate FPS
	            this.frameCount++;
	            if (this.frameCount >= 60) {
	                this.fps = Math.round(1 / deltaTime);
	                this.frameCount = 0;
	            }
	            // Render both layers
	            this.render(deltaTime);
	            // Emit tick event
	            this.emit('tick', deltaTime);
	        };
	        this.animationId = requestAnimationFrame(animate);
	    }
	    /**
	     * Stop the render loop.
	     */
	    stop() {
	        if (this.animationId !== null) {
	            cancelAnimationFrame(this.animationId);
	            this.animationId = null;
	            console.log('â¸ï¸ HybridRenderer stopped');
	        }
	        this.emit('stop');
	    }
	    /**
	     * Render a single frame (both Three.js and Pixi.js).
	     */
	    render(deltaTime) {
	        if (this.renderMode === 'on-demand' && !this.needsRender) {
	            return; // Skip rendering if not requested
	        }
	        // Render Three.js 3D layer
	        if (this.threeRenderer && this.threeScene && this.threeCamera) {
	            this.threeRenderer.render(this.threeScene, this.threeCamera);
	        }
	        // Render Pixi.js 2D UI layer
	        if (this.pixiApp && this.pixiStage) {
	            const renderer = PixiCompatibility.getRenderer(this.pixiApp);
	            if (renderer) {
	                renderer.render(this.pixiStage);
	            }
	        }
	        // Reset render request flag
	        this.needsRender = false;
	        // Emit render event
	        if (deltaTime !== undefined) {
	            this.emit('render', deltaTime);
	        }
	    }
	    /**
	     * Request a render in on-demand mode.
	     * In continuous mode, this has no effect.
	     */
	    requestRender() {
	        if (this.renderMode === 'on-demand') {
	            this.needsRender = true;
	            // Trigger single frame render
	            if (this.animationId === null) {
	                requestAnimationFrame(() => {
	                    const deltaTime = this.clock.getDelta();
	                    this.render(deltaTime);
	                });
	            }
	        }
	    }
	    /**
	     * Resize both renderer layers.
	     */
	    resize(width, height) {
	        // Resize Three.js
	        if (this.threeRenderer) {
	            this.threeRenderer.setSize(width, height, false);
	        }
	        // Resize Pixi.js
	        if (this.pixiApp) {
	            const renderer = PixiCompatibility.getRenderer(this.pixiApp);
	            if (renderer && renderer.resize) {
	                renderer.resize(width, height);
	            }
	        }
	        // Update container
	        if (this.container) {
	            this.container.style.width = `${width}px`;
	            this.container.style.height = `${height}px`;
	        }
	        // Update camera aspect ratio if it's a PerspectiveCamera
	        if (this.threeCamera && 'aspect' in this.threeCamera) {
	            this.threeCamera.aspect = width / height;
	            this.threeCamera.updateProjectionMatrix();
	        }
	        this.requestRender();
	        this.emit('resize', width, height);
	    }
	    /**
	     * Get the Three.js canvas element.
	     */
	    getCanvas() {
	        // Return Pixi canvas since it's the top layer handling interactions
	        return this.pixiCanvas;
	    }
	    /**
	     * Get the Three.js canvas element specifically.
	     */
	    getThreeCanvas() {
	        return this.threeCanvas;
	    }
	    /**
	     * Get the Pixi.js canvas element specifically.
	     */
	    getPixiCanvas() {
	        return this.pixiCanvas;
	    }
	    /**
	     * Get the Three.js scene.
	     * Add your 3D objects to this scene.
	     */
	    getThreeScene() {
	        return this.threeScene;
	    }
	    /**
	     * Set the Three.js scene (optional, default scene is created).
	     */
	    setThreeScene(scene) {
	        this.threeScene = scene;
	        this.requestRender();
	    }
	    /**
	     * Get the Three.js camera.
	     */
	    getThreeCamera() {
	        return this.threeCamera;
	    }
	    /**
	     * Set the Three.js camera.
	     * This must be called before rendering.
	     */
	    setThreeCamera(camera) {
	        this.threeCamera = camera;
	        this.requestRender();
	    }
	    /**
	     * Get the Three.js renderer instance.
	     */
	    getThreeRenderer() {
	        return this.threeRenderer;
	    }
	    /**
	     * Get the Pixi.js stage container.
	     * Add your 2D UI elements to this container.
	     */
	    getPixiStage() {
	        return this.pixiStage;
	    }
	    /**
	     * Get the Pixi.js application/renderer instance.
	     */
	    getPixiApp() {
	        return this.pixiApp;
	    }
	    /**
	     * Get renderer statistics.
	     */
	    getStats() {
	        const stats = {
	            fps: this.fps,
	            deltaTime: this.clock.getDelta(),
	            drawCalls: 0,
	            triangles: 0,
	            memory: {
	                used: 0,
	                total: 0
	            }
	        };
	        // Get Three.js stats if available
	        if (this.threeRenderer && this.threeRenderer.info) {
	            const info = this.threeRenderer.info;
	            stats.drawCalls += info.render?.calls || 0;
	            stats.triangles += info.render?.triangles || 0;
	            if (info.memory) {
	                stats.memory.used += info.memory.geometries || 0;
	                stats.memory.used += info.memory.textures || 0;
	            }
	        }
	        // Get Pixi.js stats if available
	        if (this.pixiApp) {
	            const renderer = PixiCompatibility.getRenderer(this.pixiApp);
	            if (renderer && renderer.renderingToScreen !== undefined) ;
	        }
	        // Get memory info if available
	        if (performance.memory) {
	            const mem = performance.memory;
	            stats.memory.used = mem.usedJSHeapSize / 1048576; // Convert to MB
	            stats.memory.total = mem.totalJSHeapSize / 1048576;
	        }
	        return stats;
	    }
	    /**
	     * Get the primary stage (3D scene for hybrid renderer).
	     * For accessing 2D stage, use getPixiStage() instead.
	     */
	    getStage() {
	        return this.threeScene;
	    }
	    /**
	     * Get the native renderer (returns Three.js renderer for hybrid).
	     */
	    getNativeRenderer() {
	        return this.threeRenderer;
	    }
	    /**
	     * Destroy the hybrid renderer and clean up all resources.
	     */
	    destroy() {
	        console.log('Destroying HybridRenderer');
	        // Stop rendering
	        this.stop();
	        // Destroy Three.js
	        if (this.threeRenderer) {
	            this.threeRenderer.dispose();
	            this.threeRenderer = null;
	        }
	        if (this.threeScene) {
	            // Dispose scene resources
	            this.threeScene.traverse((object) => {
	                if (object.geometry)
	                    object.geometry.dispose();
	                if (object.material) {
	                    if (Array.isArray(object.material)) {
	                        object.material.forEach((mat) => mat.dispose());
	                    }
	                    else {
	                        object.material.dispose();
	                    }
	                }
	            });
	            this.threeScene = null;
	        }
	        // Destroy Pixi.js
	        if (this.pixiApp) {
	            if (this.pixiApp.destroy) {
	                this.pixiApp.destroy(true, { children: true, texture: true, baseTexture: true });
	            }
	            this.pixiApp = null;
	        }
	        // Remove canvases
	        if (this.threeCanvas && this.threeCanvas.parentNode) {
	            this.threeCanvas.parentNode.removeChild(this.threeCanvas);
	            this.threeCanvas = null;
	        }
	        if (this.pixiCanvas && this.pixiCanvas.parentNode) {
	            this.pixiCanvas.parentNode.removeChild(this.pixiCanvas);
	            this.pixiCanvas = null;
	        }
	        // Clear references
	        this.container = null;
	        this.threeCamera = null;
	        this.pixiStage = null;
	        // Remove all event listeners
	        this.removeAllListeners();
	        this.emit('destroyed');
	        console.log('âœ… HybridRenderer destroyed');
	    }
	}

	// ThreeRenderer NOT imported statically to avoid bundling in UMD
	// import { ThreeRenderer } from './ThreeRenderer';
	/**
	 * Factory for creating renderer instances based on rendering mode.
	 * Supports 2D, 3D, and hybrid rendering across all platforms.
	 * Does not make assumptions about device capabilities - respects developer choice.
	 */
	class RendererFactory {
	    /**
	     * Create a renderer instance based on the specified mode.
	     */
	    static create(mode) {
	        switch (mode) {
	            case exports.RenderingMode.RENDERER_2D:
	                return new PixiRenderer();
	            case exports.RenderingMode.RENDERER_3D:
	                // ThreeRenderer not available in UMD builds
	                // Use dist/renderers/three3d.js for 3D rendering
	                throw new Error('3D renderer not available in main bundle. ' +
	                    'Please use dist/renderers/three3d.js for 3D rendering, ' +
	                    'or import ThreeRenderer directly in ESM/CJS environments.');
	            case exports.RenderingMode.HYBRID:
	                // For hybrid mode, we'll default to 2D renderer and allow 3D overlay
	                // This can be extended later for more sophisticated hybrid rendering
	                return new PixiRenderer();
	            default:
	                // Fallback to 2D renderer if mode is not recognized
	                console.warn(`Unsupported rendering mode: ${mode}. Falling back to 2D renderer.`);
	                return new PixiRenderer();
	        }
	    }
	    /**
	     * Get all supported rendering modes.
	     */
	    static getSupportedModes() {
	        return [
	            exports.RenderingMode.RENDERER_2D,
	            exports.RenderingMode.RENDERER_3D,
	            exports.RenderingMode.HYBRID
	        ];
	    }
	    /**
	     * Check if a rendering mode is supported.
	     */
	    static isSupported(mode) {
	        return this.getSupportedModes().includes(mode);
	    }
	    /**
	     * Create a renderer with automatic fallback if the requested mode is not supported.
	     */
	    static createWithFallback(preferredMode, fallbackMode) {
	        try {
	            // Check if WebGL is required and available
	            if (preferredMode === exports.RenderingMode.RENDERER_3D || preferredMode === exports.RenderingMode.HYBRID) {
	                const canvas = document.createElement('canvas');
	                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
	                if (!gl && preferredMode === exports.RenderingMode.RENDERER_3D) {
	                    console.warn('WebGL not supported, falling back to 2D renderer');
	                    return this.create(fallbackMode || exports.RenderingMode.RENDERER_2D);
	                }
	            }
	            return this.create(preferredMode);
	        }
	        catch (error) {
	            console.warn(`Failed to create ${preferredMode} renderer:`, error);
	            if (fallbackMode && fallbackMode !== preferredMode) {
	                console.info(`Falling back to ${fallbackMode} renderer`);
	                return this.create(fallbackMode);
	            }
	            // Final fallback to 2D
	            return this.create(exports.RenderingMode.RENDERER_2D);
	        }
	    }
	    /**
	     * Detect the best rendering mode based on browser capabilities.
	     * This method does not make assumptions about device type - both 2D and 3D
	     * are available on all platforms. The choice should be made by the developer.
	     */
	    static detectBestMode() {
	        // Check for WebGL support
	        const canvas = document.createElement('canvas');
	        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
	        if (!gl) {
	            // Fallback to 2D if WebGL is not supported
	            console.info('WebGL not supported, defaulting to 2D renderer');
	            return exports.RenderingMode.RENDERER_2D;
	        }
	        // Default to 2D renderer - developers should explicitly choose 3D when needed
	        // This ensures consistent behavior across all platforms
	        return exports.RenderingMode.RENDERER_2D;
	    }
	}

	/**
	 * Default music configuration
	 */
	const DEFAULT_MUSIC_CONFIG = {
	    crossfade: {
	        enabled: true,
	        duration: 2.0,
	        curve: exports.AudioFadeType.EXPONENTIAL
	    },
	    adaptive: {
	        enabled: false,
	        parameters: []
	    },
	    loop: {
	        enabled: true,
	        seamless: true,
	        points: []
	    }
	};
	/**
	 * GameByte Music System - Advanced adaptive and interactive music system
	 *
	 * Features:
	 * - Multi-layered adaptive music with dynamic mixing
	 * - Seamless crossfading between tracks and sections
	 * - Interactive music that responds to game state parameters
	 * - Precision loop management with custom loop points
	 * - Real-time parameter control for adaptive scoring
	 * - Memory-efficient track and layer management
	 * - Mobile-optimized audio streaming and caching
	 */
	class GameByteMusicSystem extends EventEmitter {
	    constructor(context, audioManager) {
	        super();
	        this._currentTrack = null;
	        this._tracks = new Map();
	        this._activeLayers = new Set();
	        this._adaptiveParameters = new Map();
	        this._isPlaying = false;
	        // Crossfading
	        this._crossfadeInProgress = false;
	        this._crossfadeTarget = null;
	        this._crossfadeStartTime = 0;
	        this._crossfadeDuration = 2.0;
	        // Adaptive music
	        this._adaptiveUpdateInterval = null;
	        this._lastAdaptiveUpdate = 0;
	        // Performance monitoring
	        this._performanceMetrics = {
	            activeTracks: 0,
	            activeLayers: 0,
	            memoryUsage: 0,
	            cpuUsage: 0
	        };
	        this._context = context;
	        this._audioManager = audioManager;
	        this.createAudioNodes();
	    }
	    get currentTrack() {
	        return this._currentTrack;
	    }
	    get isPlaying() {
	        return this._isPlaying;
	    }
	    get activeLayers() {
	        return new Set(this._activeLayers);
	    }
	    /**
	     * Initialize the music system
	     */
	    async initialize() {
	        try {
	            // Start adaptive music parameter monitoring
	            this.startAdaptiveMonitoring();
	            // Setup performance monitoring
	            this.startPerformanceMonitoring();
	            this.emit('music:initialized', {});
	        }
	        catch (error) {
	            console.error('Music system initialization failed:', error);
	            throw error;
	        }
	    }
	    /**
	     * Create audio processing nodes
	     */
	    createAudioNodes() {
	        // Master gain for music volume control
	        this._masterGain = this._context.createGain();
	        this._masterGain.gain.value = 1.0;
	        // Crossfade gain for smooth transitions
	        this._crossfadeGain = this._context.createGain();
	        this._crossfadeGain.gain.value = 1.0;
	        // Analysis node for music visualization
	        this._analysisNode = this._context.createAnalyser();
	        this._analysisNode.fftSize = 1024;
	        this._analysisNode.smoothingTimeConstant = 0.8;
	        // Connect audio chain
	        this._masterGain.connect(this._crossfadeGain);
	        this._crossfadeGain.connect(this._analysisNode);
	        // Connect to music bus
	        const musicBus = this._audioManager.getBus('music');
	        if (musicBus && 'getInputNode' in musicBus) {
	            this._analysisNode.connect(musicBus.getInputNode());
	        }
	    }
	    /**
	     * Start adaptive music parameter monitoring
	     */
	    startAdaptiveMonitoring() {
	        if (this._adaptiveUpdateInterval) {
	            clearInterval(this._adaptiveUpdateInterval);
	        }
	        this._adaptiveUpdateInterval = window.setInterval(() => {
	            this.updateAdaptiveMusic();
	        }, 100); // Update 10 times per second
	    }
	    /**
	     * Start performance monitoring
	     */
	    startPerformanceMonitoring() {
	        setInterval(() => {
	            this.updatePerformanceMetrics();
	        }, 1000); // Update every second
	    }
	    /**
	     * Update performance metrics
	     */
	    updatePerformanceMetrics() {
	        this._performanceMetrics.activeTracks = this._tracks.size;
	        this._performanceMetrics.activeLayers = this._activeLayers.size;
	        // Calculate memory usage (approximate)
	        let memoryUsage = 0;
	        this._tracks.forEach(track => {
	            track.layers.forEach(layer => {
	                if (layer.buffer) {
	                    memoryUsage += layer.buffer.length * layer.buffer.numberOfChannels * 4;
	                }
	            });
	        });
	        this._performanceMetrics.memoryUsage = memoryUsage / (1024 * 1024); // Convert to MB
	    }
	    // Track management
	    async loadTrack(name, url, config = {}) {
	        if (this._tracks.has(name)) {
	            console.warn(`Music track '${name}' already loaded`);
	            return;
	        }
	        try {
	            const mergedConfig = { ...DEFAULT_MUSIC_CONFIG, ...config };
	            // Create track structure
	            const track = {
	                name,
	                layers: new Map(),
	                config: mergedConfig,
	                masterGain: this._context.createGain(),
	                isPlaying: false,
	                isPaused: false,
	                currentTime: 0,
	                duration: 0,
	                loopPoints: new Map()
	            };
	            // Load main audio source
	            const mainSource = await this._audioManager.loadAudio(`${name}_main`, url);
	            track.duration = mainSource.duration;
	            // Create main layer
	            const mainLayer = {
	                name: 'main',
	                source: mainSource,
	                gain: this._context.createGain(),
	                volume: 1.0,
	                isActive: true,
	                fadeTime: 0
	            };
	            track.layers.set('main', mainSource);
	            // Load additional layers if specified
	            if (mergedConfig.layers) {
	                for (const layerConfig of mergedConfig.layers) {
	                    await this.loadTrackLayer(track, layerConfig.name, `${url}_${layerConfig.name}`, layerConfig);
	                }
	            }
	            // Setup loop points
	            if (mergedConfig.loop?.points) {
	                mergedConfig.loop.points.forEach(point => {
	                    track.loopPoints.set(point.name, point.time);
	                });
	            }
	            // Connect track audio chain
	            this.connectTrackAudio(track);
	            this._tracks.set(name, track);
	            this.emit('music:track-loaded', {
	                track: name,
	                duration: track.duration
	            });
	        }
	        catch (error) {
	            console.error(`Failed to load music track '${name}':`, error);
	            throw error;
	        }
	    }
	    /**
	     * Load additional layer for a track
	     */
	    async loadTrackLayer(track, layerName, url, layerConfig) {
	        try {
	            const source = await this._audioManager.loadAudio(`${track.name}_${layerName}`, url);
	            track.layers.set(layerName, source);
	            this.emit('music:layer-loaded', {
	                track: track.name,
	                layer: layerName
	            });
	        }
	        catch (error) {
	            console.warn(`Failed to load layer '${layerName}' for track '${track.name}':`, error);
	        }
	    }
	    /**
	     * Connect track audio processing chain
	     */
	    connectTrackAudio(track) {
	        // Connect track master gain to music system master
	        track.masterGain.connect(this._masterGain);
	        // Setup layers will be connected when activated
	    }
	    async playTrack(name, fadeTime = 0) {
	        const track = this._tracks.get(name);
	        if (!track) {
	            throw new Error(`Music track '${name}' not found`);
	        }
	        // Handle crossfading if another track is playing
	        if (this._currentTrack && this._currentTrack !== name) {
	            if (fadeTime > 0 || track.config.crossfade?.enabled) {
	                const crossfadeDuration = fadeTime || track.config.crossfade?.duration || 2.0;
	                await this.crossfadeTo(name, crossfadeDuration);
	                return;
	            }
	            else {
	                // Stop current track immediately
	                await this.stopTrack(0);
	            }
	        }
	        try {
	            // Activate main layer
	            const mainLayer = track.layers.get('main');
	            if (mainLayer) {
	                await mainLayer.play();
	            }
	            // Activate layers based on conditions
	            if (track.config.layers) {
	                for (const layerConfig of track.config.layers) {
	                    if (!layerConfig.condition || layerConfig.condition()) {
	                        this.enableLayer(layerConfig.name, layerConfig.fadeTime);
	                    }
	                }
	            }
	            track.isPlaying = true;
	            track.isPaused = false;
	            this._currentTrack = name;
	            this._isPlaying = true;
	            // Apply fade in if specified
	            if (fadeTime > 0) {
	                track.masterGain.gain.value = 0;
	                track.masterGain.gain.exponentialRampToValueAtTime(1.0, this._context.currentTime + fadeTime);
	            }
	            // Setup looping if enabled
	            if (track.config.loop?.enabled) {
	                this.setupTrackLooping(track);
	            }
	            this.emit('music:track-change', {
	                previous: this._currentTrack === name ? undefined : this._currentTrack,
	                current: name
	            });
	            this.emit('audio:play', {
	                source: mainLayer
	            });
	        }
	        catch (error) {
	            console.error(`Failed to play music track '${name}':`, error);
	            throw error;
	        }
	    }
	    /**
	     * Setup looping for a track
	     */
	    setupTrackLooping(track) {
	        track.layers.forEach(layer => {
	            if (layer.setLoop) {
	                layer.setLoop(true);
	            }
	        });
	        // Handle custom loop points if specified
	        if (track.config.loop?.seamless && track.loopPoints.size > 0) {
	            this.setupSeamlessLooping(track);
	        }
	    }
	    /**
	     * Setup seamless looping with custom loop points
	     */
	    setupSeamlessLooping(track) {
	        // This would require more complex implementation with precise timing
	        // For now, we'll use the basic looping functionality
	        console.log(`Seamless looping setup for track: ${track.name}`);
	    }
	    async stopTrack(fadeTime = 0) {
	        if (!this._currentTrack) {
	            return;
	        }
	        const track = this._tracks.get(this._currentTrack);
	        if (!track) {
	            return;
	        }
	        try {
	            if (fadeTime > 0) {
	                // Fade out
	                track.masterGain.gain.exponentialRampToValueAtTime(0.001, this._context.currentTime + fadeTime);
	                // Stop after fade completes
	                setTimeout(() => {
	                    this.stopTrackImmediate(track);
	                }, fadeTime * 1000);
	            }
	            else {
	                this.stopTrackImmediate(track);
	            }
	        }
	        catch (error) {
	            console.error('Failed to stop music track:', error);
	        }
	    }
	    /**
	     * Stop track immediately without fading
	     */
	    stopTrackImmediate(track) {
	        // Stop all layers
	        track.layers.forEach(layer => {
	            layer.stop();
	        });
	        track.isPlaying = false;
	        track.isPaused = false;
	        track.currentTime = 0;
	        track.masterGain.gain.value = 1.0; // Reset gain
	        // Clear active layers
	        this._activeLayers.clear();
	        this._currentTrack = null;
	        this._isPlaying = false;
	        this.emit('audio:stop', {
	            source: track.layers.get('main')
	        });
	    }
	    pauseTrack() {
	        if (!this._currentTrack) {
	            return;
	        }
	        const track = this._tracks.get(this._currentTrack);
	        if (!track || !track.isPlaying) {
	            return;
	        }
	        track.layers.forEach(layer => {
	            layer.pause();
	        });
	        track.isPlaying = false;
	        track.isPaused = true;
	        this._isPlaying = false;
	        this.emit('audio:pause', {
	            source: track.layers.get('main')
	        });
	    }
	    resumeTrack() {
	        if (!this._currentTrack) {
	            return;
	        }
	        const track = this._tracks.get(this._currentTrack);
	        if (!track || !track.isPaused) {
	            return;
	        }
	        track.layers.forEach(layer => {
	            layer.play();
	        });
	        track.isPlaying = true;
	        track.isPaused = false;
	        this._isPlaying = true;
	        this.emit('audio:play', {
	            source: track.layers.get('main')
	        });
	    }
	    // Layer management
	    enableLayer(layer, fadeTime = 0) {
	        if (!this._currentTrack) {
	            return;
	        }
	        const track = this._tracks.get(this._currentTrack);
	        if (!track) {
	            return;
	        }
	        const layerSource = track.layers.get(layer);
	        if (!layerSource) {
	            console.warn(`Layer '${layer}' not found in track '${this._currentTrack}'`);
	            return;
	        }
	        if (this._activeLayers.has(layer)) {
	            return; // Already active
	        }
	        try {
	            // Play the layer
	            layerSource.play();
	            // Apply fade in if specified
	            if (fadeTime > 0) {
	                layerSource.setVolume(0, 0);
	                layerSource.setVolume(1.0, fadeTime);
	            }
	            this._activeLayers.add(layer);
	            this.emit('music:layer-change', {
	                layer,
	                active: true
	            });
	        }
	        catch (error) {
	            console.error(`Failed to enable layer '${layer}':`, error);
	        }
	    }
	    disableLayer(layer, fadeTime = 0) {
	        if (!this._activeLayers.has(layer)) {
	            return;
	        }
	        if (!this._currentTrack) {
	            return;
	        }
	        const track = this._tracks.get(this._currentTrack);
	        if (!track) {
	            return;
	        }
	        const layerSource = track.layers.get(layer);
	        if (!layerSource) {
	            return;
	        }
	        try {
	            if (fadeTime > 0) {
	                // Fade out then stop
	                layerSource.setVolume(0, fadeTime);
	                setTimeout(() => {
	                    layerSource.stop();
	                    this._activeLayers.delete(layer);
	                }, fadeTime * 1000);
	            }
	            else {
	                layerSource.stop();
	                this._activeLayers.delete(layer);
	            }
	            this.emit('music:layer-change', {
	                layer,
	                active: false
	            });
	        }
	        catch (error) {
	            console.error(`Failed to disable layer '${layer}':`, error);
	        }
	    }
	    setLayerVolume(layer, volume, fadeTime = 0) {
	        if (!this._currentTrack) {
	            return;
	        }
	        const track = this._tracks.get(this._currentTrack);
	        if (!track) {
	            return;
	        }
	        const layerSource = track.layers.get(layer);
	        if (!layerSource) {
	            return;
	        }
	        layerSource.setVolume(Math.max(0, Math.min(1, volume)), fadeTime);
	    }
	    // Adaptive music
	    setParameter(name, value) {
	        const parameter = this._adaptiveParameters.get(name);
	        if (parameter) {
	            parameter.value = Math.max(parameter.minValue, Math.min(parameter.maxValue, value));
	        }
	        else {
	            // Create new parameter
	            this._adaptiveParameters.set(name, {
	                name,
	                value,
	                minValue: 0,
	                maxValue: 1,
	                smoothing: 0.1
	            });
	        }
	        this.emit('music:parameter-changed', {
	            parameter: name,
	            value
	        });
	    }
	    getParameter(name) {
	        const parameter = this._adaptiveParameters.get(name);
	        return parameter ? parameter.value : 0;
	    }
	    updateAdaptiveMusic() {
	        if (!this._currentTrack) {
	            return;
	        }
	        const track = this._tracks.get(this._currentTrack);
	        if (!track || !track.config.adaptive?.enabled) {
	            return;
	        }
	        const now = this._context.currentTime;
	        if (now - this._lastAdaptiveUpdate < 0.1) {
	            return; // Throttle updates
	        }
	        this._lastAdaptiveUpdate = now;
	        // Update layers based on adaptive parameters
	        if (track.config.layers) {
	            track.config.layers.forEach(layerConfig => {
	                if (layerConfig.condition) {
	                    const shouldBeActive = layerConfig.condition();
	                    const isActive = this._activeLayers.has(layerConfig.name);
	                    if (shouldBeActive && !isActive) {
	                        this.enableLayer(layerConfig.name, layerConfig.fadeTime);
	                    }
	                    else if (!shouldBeActive && isActive) {
	                        this.disableLayer(layerConfig.name, layerConfig.fadeTime);
	                    }
	                }
	            });
	        }
	        // Update adaptive parameters
	        if (track.config.adaptive?.parameters) {
	            track.config.adaptive.parameters.forEach(paramConfig => {
	                const parameter = this._adaptiveParameters.get(paramConfig.name);
	                if (parameter && paramConfig.target) {
	                    // Apply parameter to target (layer volume, effect parameter, etc.)
	                    this.applyParameterToTarget(paramConfig.target, parameter.value);
	                }
	            });
	        }
	    }
	    /**
	     * Apply adaptive parameter to its target
	     */
	    applyParameterToTarget(target, value) {
	        // Parse target string (e.g., "layer:drums", "effect:reverb.roomSize")
	        const [targetType, targetName] = target.split(':');
	        if (targetType === 'layer') {
	            this.setLayerVolume(targetName, value);
	        }
	        else if (targetType === 'effect') {
	            // Handle effect parameter updates
	            const [effectName, parameter] = targetName.split('.');
	            // Implementation would depend on effect system integration
	        }
	    }
	    // Crossfading
	    async crossfadeTo(track, duration = 2.0) {
	        if (this._crossfadeInProgress) {
	            return; // Already crossfading
	        }
	        const targetTrack = this._tracks.get(track);
	        if (!targetTrack) {
	            throw new Error(`Target track '${track}' not found`);
	        }
	        this._crossfadeInProgress = true;
	        this._crossfadeTarget = track;
	        this._crossfadeStartTime = this._context.currentTime;
	        this._crossfadeDuration = duration;
	        try {
	            // Start target track at zero volume
	            targetTrack.masterGain.gain.value = 0;
	            await this.playTrack(track, 0);
	            // Crossfade between tracks
	            const currentTrack = this._currentTrack ? this._tracks.get(this._currentTrack) : null;
	            if (currentTrack && currentTrack.name !== track) {
	                // Fade out current track
	                currentTrack.masterGain.gain.exponentialRampToValueAtTime(0.001, this._context.currentTime + duration);
	                // Stop current track after fade
	                setTimeout(() => {
	                    this.stopTrackImmediate(currentTrack);
	                }, duration * 1000);
	            }
	            // Fade in target track
	            targetTrack.masterGain.gain.exponentialRampToValueAtTime(1.0, this._context.currentTime + duration);
	            // Complete crossfade
	            setTimeout(() => {
	                this._crossfadeInProgress = false;
	                this._crossfadeTarget = null;
	                this.emit('music:crossfade-complete', {
	                    track
	                });
	            }, duration * 1000);
	        }
	        catch (error) {
	            this._crossfadeInProgress = false;
	            this._crossfadeTarget = null;
	            throw error;
	        }
	    }
	    // Loop management
	    setLoopPoints(start, end) {
	        if (!this._currentTrack) {
	            return;
	        }
	        const track = this._tracks.get(this._currentTrack);
	        if (!track) {
	            return;
	        }
	        track.loopPoints.set('loop_start', start);
	        track.loopPoints.set('loop_end', end);
	        // Update loop configuration
	        if (!track.config.loop) {
	            track.config.loop = { enabled: true, seamless: true, points: [] };
	        }
	        track.config.loop.points = [
	            { name: 'loop_start', time: start },
	            { name: 'loop_end', time: end }
	        ];
	    }
	    addLoopMarker(name, time) {
	        if (!this._currentTrack) {
	            return;
	        }
	        const track = this._tracks.get(this._currentTrack);
	        if (!track) {
	            return;
	        }
	        track.loopPoints.set(name, time);
	        if (!track.config.loop) {
	            track.config.loop = { enabled: true, seamless: true, points: [] };
	        }
	        if (!track.config.loop.points) {
	            track.config.loop.points = [];
	        }
	        track.config.loop.points.push({ name, time });
	    }
	    jumpToMarker(name) {
	        if (!this._currentTrack) {
	            return;
	        }
	        const track = this._tracks.get(this._currentTrack);
	        if (!track) {
	            return;
	        }
	        const markerTime = track.loopPoints.get(name);
	        if (markerTime !== undefined) {
	            track.layers.forEach(layer => {
	                layer.seek(markerTime);
	            });
	            track.currentTime = markerTime;
	            this.emit('music:marker-jump', {
	                track: track.name,
	                marker: name,
	                time: markerTime
	            });
	        }
	    }
	    /**
	     * Get music analysis data for visualization
	     */
	    getAnalysisData() {
	        const frequencyData = new Uint8Array(this._analysisNode.frequencyBinCount);
	        const timeDomainData = new Uint8Array(this._analysisNode.frequencyBinCount);
	        this._analysisNode.getByteFrequencyData(frequencyData);
	        this._analysisNode.getByteTimeDomainData(timeDomainData);
	        // Calculate RMS level
	        let sum = 0;
	        for (let i = 0; i < frequencyData.length; i++) {
	            sum += frequencyData[i] * frequencyData[i];
	        }
	        const rmsLevel = Math.sqrt(sum / frequencyData.length) / 255;
	        // Calculate peak level
	        let peak = 0;
	        for (let i = 0; i < frequencyData.length; i++) {
	            peak = Math.max(peak, frequencyData[i]);
	        }
	        const peakLevel = peak / 255;
	        return {
	            frequencyData,
	            timeDomainData,
	            rmsLevel,
	            peakLevel
	        };
	    }
	    /**
	     * Get current performance metrics
	     */
	    getPerformanceMetrics() {
	        return { ...this._performanceMetrics };
	    }
	    /**
	     * Clean up resources
	     */
	    destroy() {
	        // Stop adaptive monitoring
	        if (this._adaptiveUpdateInterval) {
	            clearInterval(this._adaptiveUpdateInterval);
	            this._adaptiveUpdateInterval = null;
	        }
	        // Stop all tracks
	        this._tracks.forEach(track => {
	            this.stopTrackImmediate(track);
	        });
	        // Disconnect audio nodes
	        this._masterGain.disconnect();
	        this._crossfadeGain.disconnect();
	        this._analysisNode.disconnect();
	        // Clear collections
	        this._tracks.clear();
	        this._activeLayers.clear();
	        this._adaptiveParameters.clear();
	        this.removeAllListeners();
	    }
	}

	/**
	 * GameByte Audio Source - Individual audio playback instance
	 *
	 * Features:
	 * - Web Audio API integration
	 * - Spatial 3D positioning
	 * - Real-time effects processing
	 * - Volume and fade control
	 * - Loop and seek functionality
	 */
	class GameByteAudioSource extends EventEmitter {
	    constructor(id, buffer, context, masterGain, options = {}) {
	        super();
	        // Audio nodes
	        this._sourceNode = null;
	        this._pannerNode = null;
	        this._analyserNode = null;
	        this._effectNodes = new Map();
	        // Playback state
	        this._isPlaying = false;
	        this._isPaused = false;
	        this._isLooping = false;
	        this._volume = 1.0;
	        this._muted = false;
	        this._startTime = 0;
	        this._pauseTime = 0;
	        this._playbackRate = 1.0;
	        // Spatial audio
	        this._position = { x: 0, y: 0, z: 0 };
	        this._velocity = { x: 0, y: 0, z: 0 };
	        this._spatialConfig = null;
	        // Fade control
	        this._fadeTimeouts = new Set();
	        this._id = id;
	        this._buffer = buffer;
	        this._context = context;
	        this._masterGain = masterGain;
	        // Apply options
	        this._volume = options.volume ?? 1.0;
	        this._isLooping = options.loop ?? false;
	        this._playbackRate = options.playbackRate ?? 1.0;
	        // Create audio nodes
	        this.createAudioNodes(options.spatial ?? false);
	    }
	    get id() {
	        return this._id;
	    }
	    get buffer() {
	        return this._buffer;
	    }
	    get duration() {
	        return this._buffer ? this._buffer.duration : 0;
	    }
	    get currentTime() {
	        if (!this._isPlaying) {
	            return this._pauseTime;
	        }
	        if (this._startTime === 0) {
	            return 0;
	        }
	        return (this._context.currentTime - this._startTime) * this._playbackRate;
	    }
	    get isPlaying() {
	        return this._isPlaying;
	    }
	    get isPaused() {
	        return this._isPaused;
	    }
	    get isLooping() {
	        return this._isLooping;
	    }
	    /**
	     * Get the output gain node for routing to buses
	     * This allows connecting this source to an AudioBus
	     */
	    getOutputNode() {
	        return this._gainNode;
	    }
	    /**
	     * Disconnect from current destination and connect to a new target node
	     * Used when routing through an AudioBus
	     */
	    connectToNode(targetNode) {
	        // Disconnect analyser from master (if connected)
	        if (this._analyserNode) {
	            try {
	                this._analyserNode.disconnect(this._masterGain);
	            }
	            catch (e) {
	                // Already disconnected or not connected
	            }
	            // Connect analyser to target node
	            this._analyserNode.connect(targetNode);
	        }
	    }
	    /**
	     * Reconnect to the master gain (when removed from a bus)
	     */
	    reconnectToMaster() {
	        if (this._analyserNode) {
	            try {
	                this._analyserNode.disconnect();
	            }
	            catch (e) {
	                // Already disconnected
	            }
	            this._analyserNode.connect(this._masterGain);
	        }
	    }
	    /**
	     * Create and connect audio nodes
	     */
	    createAudioNodes(spatial) {
	        // Create gain node for volume control
	        this._gainNode = this._context.createGain();
	        this._gainNode.gain.value = this._muted ? 0 : this._volume;
	        // Create spatial audio nodes if enabled
	        if (spatial) {
	            this._pannerNode = this._context.createPanner();
	            this._pannerNode.panningModel = 'HRTF';
	            this._pannerNode.distanceModel = 'inverse';
	            this._pannerNode.refDistance = 1;
	            this._pannerNode.maxDistance = 100;
	            this._pannerNode.rolloffFactor = 1;
	            this._pannerNode.coneInnerAngle = 360;
	            this._pannerNode.coneOuterAngle = 0;
	            this._pannerNode.coneOuterGain = 0;
	            // Set default position
	            this.updatePannerPosition();
	        }
	        // Create analyser node for visualization
	        this._analyserNode = this._context.createAnalyser();
	        this._analyserNode.fftSize = 256;
	        this._analyserNode.smoothingTimeConstant = 0.8;
	        // Connect nodes
	        this.connectAudioNodes();
	    }
	    /**
	     * Connect audio nodes in the processing chain
	     */
	    connectAudioNodes() {
	        let currentNode = this._gainNode;
	        // Connect effects chain
	        this._effectNodes.forEach(effectNode => {
	            currentNode.connect(effectNode);
	            currentNode = effectNode;
	        });
	        // Connect spatial audio
	        if (this._pannerNode) {
	            currentNode.connect(this._pannerNode);
	            currentNode = this._pannerNode;
	        }
	        // Connect analyser and master
	        currentNode.connect(this._analyserNode);
	        this._analyserNode.connect(this._masterGain);
	    }
	    /**
	     * Disconnect all audio nodes
	     */
	    disconnectAudioNodes() {
	        if (this._sourceNode) {
	            this._sourceNode.disconnect();
	            this._sourceNode = null;
	        }
	        this._gainNode.disconnect();
	        if (this._pannerNode) {
	            this._pannerNode.disconnect();
	        }
	        if (this._analyserNode) {
	            this._analyserNode.disconnect();
	        }
	        this._effectNodes.forEach(node => node.disconnect());
	    }
	    /**
	     * Play the audio source
	     */
	    async play(when = 0) {
	        if (this._isPlaying && !this._isPaused) {
	            return;
	        }
	        try {
	            // Stop current playback if any
	            if (this._sourceNode) {
	                this._sourceNode.stop();
	                this._sourceNode.disconnect();
	            }
	            // Create new source node
	            this._sourceNode = this._context.createBufferSource();
	            this._sourceNode.buffer = this._buffer;
	            this._sourceNode.loop = this._isLooping;
	            this._sourceNode.playbackRate.value = this._playbackRate;
	            // Connect source to gain node
	            this._sourceNode.connect(this._gainNode);
	            // Handle playback end
	            this._sourceNode.onended = () => {
	                if (!this._isLooping) {
	                    this._isPlaying = false;
	                    this._isPaused = false;
	                    this._startTime = 0;
	                    this._pauseTime = 0;
	                    this.emit('audio:end', { source: this });
	                }
	            };
	            // Calculate start time
	            const startTime = when > 0 ? when : this._context.currentTime;
	            const offset = this._isPaused ? this._pauseTime : 0;
	            // Start playback
	            this._sourceNode.start(startTime, offset);
	            this._isPlaying = true;
	            this._isPaused = false;
	            this._startTime = startTime - offset / this._playbackRate;
	            this.emit('audio:play', { source: this });
	        }
	        catch (error) {
	            this.emit('audio:error', { source: this, error: error });
	            throw error;
	        }
	    }
	    /**
	     * Pause the audio source
	     */
	    pause() {
	        if (!this._isPlaying || this._isPaused) {
	            return;
	        }
	        this._pauseTime = this.currentTime;
	        this._isPaused = true;
	        if (this._sourceNode) {
	            this._sourceNode.stop();
	            this._sourceNode.disconnect();
	            this._sourceNode = null;
	        }
	        this.emit('audio:pause', { source: this });
	    }
	    /**
	     * Stop the audio source
	     */
	    stop() {
	        if (!this._isPlaying) {
	            return;
	        }
	        this._isPlaying = false;
	        this._isPaused = false;
	        this._startTime = 0;
	        this._pauseTime = 0;
	        if (this._sourceNode) {
	            this._sourceNode.stop();
	            this._sourceNode.disconnect();
	            this._sourceNode = null;
	        }
	        // Clear any active fades
	        this._fadeTimeouts.forEach(timeout => clearTimeout(timeout));
	        this._fadeTimeouts.clear();
	        this.emit('audio:stop', { source: this });
	    }
	    /**
	     * Seek to a specific time position
	     */
	    seek(time) {
	        const clampedTime = Math.max(0, Math.min(time, this.duration));
	        if (this._isPlaying && !this._isPaused) {
	            // Restart playback from new position
	            this._pauseTime = clampedTime;
	            this.pause();
	            this.play();
	        }
	        else {
	            this._pauseTime = clampedTime;
	        }
	    }
	    /**
	     * Set volume with optional fade
	     */
	    setVolume(volume, fadeTime = 0) {
	        const clampedVolume = Math.max(0, Math.min(1, volume));
	        this._volume = clampedVolume;
	        const targetVolume = this._muted ? 0 : clampedVolume;
	        if (fadeTime > 0) {
	            // Clear any existing fades
	            this._fadeTimeouts.forEach(timeout => clearTimeout(timeout));
	            this._fadeTimeouts.clear();
	            // Perform exponential fade
	            this._gainNode.gain.exponentialRampToValueAtTime(Math.max(0.001, targetVolume), // Avoid zero for exponential ramp
	            this._context.currentTime + fadeTime);
	            // Set final volume after fade completes
	            const timeout = window.setTimeout(() => {
	                this._gainNode.gain.value = targetVolume;
	                this._fadeTimeouts.delete(timeout);
	            }, fadeTime * 1000);
	            this._fadeTimeouts.add(timeout);
	        }
	        else {
	            this._gainNode.gain.value = targetVolume;
	        }
	        this.emit('audio:volume-change', { source: this, volume: clampedVolume });
	    }
	    getVolume() {
	        return this._volume;
	    }
	    /**
	     * Set muted state
	     */
	    setMuted(muted) {
	        this._muted = muted;
	        this._gainNode.gain.value = muted ? 0 : this._volume;
	    }
	    isMuted() {
	        return this._muted;
	    }
	    /**
	     * Set 3D position
	     */
	    setPosition(position) {
	        this._position = { ...position };
	        this.updatePannerPosition();
	    }
	    getPosition() {
	        return { ...this._position };
	    }
	    /**
	     * Set velocity for Doppler effect
	     */
	    setVelocity(velocity) {
	        this._velocity = { ...velocity };
	        this.updatePannerVelocity();
	    }
	    /**
	     * Set spatial audio configuration
	     */
	    setSpatialConfig(config) {
	        if (!this._pannerNode) {
	            // Create panner node if spatial audio wasn't initially enabled
	            this._pannerNode = this._context.createPanner();
	            this.connectAudioNodes();
	        }
	        this._spatialConfig = { ...this._spatialConfig, ...config };
	        // Apply spatial configuration
	        if (config.distanceModel) {
	            this._pannerNode.distanceModel = config.distanceModel;
	        }
	        if (config.maxDistance !== undefined) {
	            this._pannerNode.maxDistance = config.maxDistance;
	        }
	        if (config.rolloffFactor !== undefined) {
	            this._pannerNode.rolloffFactor = config.rolloffFactor;
	        }
	    }
	    /**
	     * Update panner node position
	     */
	    updatePannerPosition() {
	        if (this._pannerNode) {
	            this._pannerNode.positionX.value = this._position.x;
	            this._pannerNode.positionY.value = this._position.y;
	            this._pannerNode.positionZ.value = this._position.z;
	        }
	    }
	    /**
	     * Update panner node velocity
	     */
	    updatePannerVelocity() {
	        if (this._pannerNode) ;
	    }
	    /**
	     * Add audio effect
	     */
	    addEffect(name, config) {
	        // Remove existing effect if it exists
	        this.removeEffect(name);
	        const effectNode = this.createEffectNode(config);
	        if (effectNode) {
	            this._effectNodes.set(name, effectNode);
	            this.connectAudioNodes();
	        }
	    }
	    /**
	     * Remove audio effect
	     */
	    removeEffect(name) {
	        const effectNode = this._effectNodes.get(name);
	        if (effectNode) {
	            effectNode.disconnect();
	            this._effectNodes.delete(name);
	            this.connectAudioNodes();
	        }
	    }
	    /**
	     * Update audio effect
	     */
	    updateEffect(name, config) {
	        const effectNode = this._effectNodes.get(name);
	        if (effectNode) {
	            // Update effect parameters
	            this.updateEffectNode(effectNode, config);
	        }
	    }
	    /**
	     * Create effect node based on configuration
	     */
	    createEffectNode(config) {
	        if (config.filter) {
	            const filter = this._context.createBiquadFilter();
	            filter.type = config.filter.type;
	            filter.frequency.value = config.filter.frequency;
	            filter.Q.value = config.filter.Q;
	            if (config.filter.gain !== undefined) {
	                filter.gain.value = config.filter.gain;
	            }
	            return filter;
	        }
	        if (config.delay) {
	            const delay = this._context.createDelay(1); // Max 1 second delay
	            const feedback = this._context.createGain();
	            const wetGain = this._context.createGain();
	            delay.delayTime.value = config.delay.delayTime;
	            feedback.gain.value = config.delay.feedback;
	            wetGain.gain.value = config.delay.wetness;
	            // Connect delay feedback loop
	            delay.connect(feedback);
	            feedback.connect(delay);
	            delay.connect(wetGain);
	            return delay;
	        }
	        if (config.compressor) {
	            const compressor = this._context.createDynamicsCompressor();
	            compressor.threshold.value = config.compressor.threshold;
	            compressor.knee.value = config.compressor.knee;
	            compressor.ratio.value = config.compressor.ratio;
	            compressor.attack.value = config.compressor.attack;
	            compressor.release.value = config.compressor.release;
	            return compressor;
	        }
	        return null;
	    }
	    /**
	     * Update effect node parameters
	     */
	    updateEffectNode(node, config) {
	        if (config.filter && 'frequency' in node) {
	            const filter = node;
	            if (config.filter.frequency !== undefined) {
	                filter.frequency.value = config.filter.frequency;
	            }
	            if (config.filter.Q !== undefined) {
	                filter.Q.value = config.filter.Q;
	            }
	            if (config.filter.gain !== undefined && 'gain' in filter) {
	                filter.gain.value = config.filter.gain;
	            }
	        }
	        if (config.compressor && 'threshold' in node) {
	            const compressor = node;
	            if (config.compressor.threshold !== undefined) {
	                compressor.threshold.value = config.compressor.threshold;
	            }
	            if (config.compressor.knee !== undefined) {
	                compressor.knee.value = config.compressor.knee;
	            }
	            if (config.compressor.ratio !== undefined) {
	                compressor.ratio.value = config.compressor.ratio;
	            }
	            if (config.compressor.attack !== undefined) {
	                compressor.attack.value = config.compressor.attack;
	            }
	            if (config.compressor.release !== undefined) {
	                compressor.release.value = config.compressor.release;
	            }
	        }
	    }
	    /**
	     * Get analyser node for visualization
	     */
	    getAnalyser() {
	        return this._analyserNode;
	    }
	    /**
	     * Get RMS level for volume metering
	     */
	    getRMSLevel() {
	        if (!this._analyserNode)
	            return 0;
	        const bufferLength = this._analyserNode.frequencyBinCount;
	        const dataArray = new Uint8Array(bufferLength);
	        this._analyserNode.getByteFrequencyData(dataArray);
	        let sum = 0;
	        for (let i = 0; i < bufferLength; i++) {
	            sum += dataArray[i] * dataArray[i];
	        }
	        return Math.sqrt(sum / bufferLength) / 255;
	    }
	    /**
	     * Get peak level for volume metering
	     */
	    getPeakLevel() {
	        if (!this._analyserNode)
	            return 0;
	        const bufferLength = this._analyserNode.frequencyBinCount;
	        const dataArray = new Uint8Array(bufferLength);
	        this._analyserNode.getByteFrequencyData(dataArray);
	        let peak = 0;
	        for (let i = 0; i < bufferLength; i++) {
	            peak = Math.max(peak, dataArray[i]);
	        }
	        return peak / 255;
	    }
	    /**
	     * Set playback rate (pitch)
	     */
	    setPlaybackRate(rate) {
	        this._playbackRate = Math.max(0.1, Math.min(4, rate)); // Clamp between 0.1x and 4x
	        if (this._sourceNode) {
	            this._sourceNode.playbackRate.value = this._playbackRate;
	        }
	    }
	    getPlaybackRate() {
	        return this._playbackRate;
	    }
	    /**
	     * Set loop state
	     */
	    setLoop(loop) {
	        this._isLooping = loop;
	        if (this._sourceNode) {
	            this._sourceNode.loop = loop;
	        }
	    }
	    /**
	     * Clean up resources
	     */
	    destroy() {
	        this.stop();
	        this.disconnectAudioNodes();
	        // Clear fade timeouts
	        this._fadeTimeouts.forEach(timeout => clearTimeout(timeout));
	        this._fadeTimeouts.clear();
	        this.removeAllListeners();
	    }
	}

	/**
	 * Default performance configuration
	 */
	const DEFAULT_PERFORMANCE_CONFIG = {
	    maxConcurrentSounds: 32,
	    maxPoolSize: 8,
	    priorityThreshold: 0.5,
	    distanceCulling: true,
	    maxDistance: 100,
	    memoryLimit: 32,
	    adaptiveQuality: true
	};
	/**
	 * GameByte SFX System - High-performance sound effects management
	 *
	 * Features:
	 * - Intelligent sound effect pooling for memory efficiency
	 * - Priority-based playback system with automatic culling
	 * - Sound variation system for dynamic and varied audio
	 * - Concurrent sound limiting with smart voice management
	 * - Mobile-optimized performance with adaptive quality
	 * - Distance-based culling and 3D spatial positioning
	 * - Real-time performance monitoring and optimization
	 */
	class GameByteSFXSystem extends EventEmitter {
	    constructor(context, audioManager) {
	        super();
	        this._soundPools = new Map();
	        this._activeSounds = new Map();
	        this._variations = new Map();
	        // Performance monitoring
	        this._performanceMetrics = {
	            activeSounds: 0,
	            pooledSounds: 0,
	            memoryUsage: 0,
	            droppedSounds: 0,
	            cpuUsage: 0
	        };
	        // Culling and optimization
	        this._listenerPosition = { x: 0, y: 0, z: 0 };
	        this._cullUpdateInterval = null;
	        this._lastCullUpdate = 0;
	        // Priority queue for sound management
	        this._soundQueue = [];
	        this._context = context;
	        this._audioManager = audioManager;
	        this._performanceConfig = { ...DEFAULT_PERFORMANCE_CONFIG };
	        this.createAudioNodes();
	    }
	    /**
	     * Initialize the SFX system
	     */
	    async initialize() {
	        try {
	            // Start performance monitoring
	            this.startPerformanceMonitoring();
	            // Start culling system
	            this.startCullingSystem();
	            this.emit('sfx:initialized', {});
	        }
	        catch (error) {
	            console.error('SFX system initialization failed:', error);
	            throw error;
	        }
	    }
	    /**
	     * Create audio processing nodes
	     */
	    createAudioNodes() {
	        // Master gain for SFX volume control
	        this._masterGain = this._context.createGain();
	        this._masterGain.gain.value = 1.0;
	        // Master compressor to prevent clipping with many sounds
	        this._compressor = this._context.createDynamicsCompressor();
	        this._compressor.threshold.value = -12;
	        this._compressor.knee.value = 6;
	        this._compressor.ratio.value = 4;
	        this._compressor.attack.value = 0.003;
	        this._compressor.release.value = 0.1;
	        // Connect audio chain
	        this._masterGain.connect(this._compressor);
	        // Connect to SFX bus
	        const sfxBus = this._audioManager.getBus('sfx');
	        if (sfxBus && 'getInputNode' in sfxBus) {
	            this._compressor.connect(sfxBus.getInputNode());
	        }
	    }
	    /**
	     * Start performance monitoring
	     */
	    startPerformanceMonitoring() {
	        setInterval(() => {
	            this.updatePerformanceMetrics();
	            this.optimizePerformance();
	        }, 1000); // Update every second
	    }
	    /**
	     * Start distance culling system
	     */
	    startCullingSystem() {
	        if (this._cullUpdateInterval) {
	            clearInterval(this._cullUpdateInterval);
	        }
	        this._cullUpdateInterval = window.setInterval(() => {
	            if (this._performanceConfig.distanceCulling) {
	                this.updateDistanceCulling();
	            }
	        }, 100); // Update 10 times per second
	    }
	    /**
	     * Update performance metrics
	     */
	    updatePerformanceMetrics() {
	        this._performanceMetrics.activeSounds = this._activeSounds.size;
	        this._performanceMetrics.pooledSounds = Array.from(this._soundPools.values())
	            .reduce((total, pool) => total + pool.sources.length, 0);
	        // Calculate memory usage
	        let memoryUsage = 0;
	        this._soundPools.forEach(pool => {
	            pool.sources.forEach(source => {
	                if (source.buffer) {
	                    memoryUsage += source.buffer.length * source.buffer.numberOfChannels * 4;
	                }
	            });
	        });
	        this._performanceMetrics.memoryUsage = memoryUsage / (1024 * 1024); // Convert to MB
	    }
	    /**
	     * Optimize performance based on current metrics
	     */
	    optimizePerformance() {
	        const metrics = this._performanceMetrics;
	        // Reduce concurrent sounds if memory usage is high
	        if (metrics.memoryUsage > this._performanceConfig.memoryLimit * 0.8) {
	            this.cullLowPrioritySounds();
	        }
	        // Adjust quality if too many sounds are playing
	        if (metrics.activeSounds > this._performanceConfig.maxConcurrentSounds * 0.8) {
	            this.cullDistantSounds();
	        }
	        // Clean up finished sounds
	        this.cleanupFinishedSounds();
	    }
	    /**
	     * Update distance-based culling
	     */
	    updateDistanceCulling() {
	        const now = this._context.currentTime;
	        if (now - this._lastCullUpdate < 0.1) {
	            return; // Throttle updates
	        }
	        this._lastCullUpdate = now;
	        this._activeSounds.forEach((activeSound, id) => {
	            if (activeSound.options.position) {
	                const distance = this.calculateDistance(this._listenerPosition, activeSound.options.position);
	                if (distance > this._performanceConfig.maxDistance) {
	                    this.stopSound(activeSound.source);
	                    this._activeSounds.delete(id);
	                }
	            }
	        });
	    }
	    /**
	     * Calculate distance between two points
	     */
	    calculateDistance(pos1, pos2) {
	        const dx = pos1.x - pos2.x;
	        const dy = pos1.y - pos2.y;
	        const dz = pos1.z - pos2.z;
	        return Math.sqrt(dx * dx + dy * dy + dz * dz);
	    }
	    /**
	     * Cull low priority sounds
	     */
	    cullLowPrioritySounds() {
	        const soundsToStop = [];
	        this._activeSounds.forEach((activeSound, id) => {
	            if (activeSound.priority < this._performanceConfig.priorityThreshold) {
	                soundsToStop.push(id);
	            }
	        });
	        soundsToStop.forEach(id => {
	            const activeSound = this._activeSounds.get(id);
	            if (activeSound) {
	                this.stopSound(activeSound.source);
	                this._activeSounds.delete(id);
	                this._performanceMetrics.droppedSounds++;
	            }
	        });
	    }
	    /**
	     * Cull distant sounds
	     */
	    cullDistantSounds() {
	        const soundsWithDistance = [];
	        this._activeSounds.forEach((activeSound, id) => {
	            if (activeSound.options.position) {
	                const distance = this.calculateDistance(this._listenerPosition, activeSound.options.position);
	                soundsWithDistance.push({ id, sound: activeSound, distance });
	            }
	        });
	        // Sort by distance and stop the farthest sounds
	        soundsWithDistance.sort((a, b) => b.distance - a.distance);
	        const soundsToStop = soundsWithDistance.slice(0, Math.floor(soundsWithDistance.length * 0.3));
	        soundsToStop.forEach(({ id, sound }) => {
	            this.stopSound(sound.source);
	            this._activeSounds.delete(id);
	            this._performanceMetrics.droppedSounds++;
	        });
	    }
	    /**
	     * Clean up finished sounds
	     */
	    cleanupFinishedSounds() {
	        const finishedSounds = [];
	        this._activeSounds.forEach((activeSound, id) => {
	            if (!activeSound.source.isPlaying && !activeSound.source.isPaused) {
	                finishedSounds.push(id);
	            }
	        });
	        finishedSounds.forEach(id => {
	            this._activeSounds.delete(id);
	        });
	    }
	    // Main playback methods
	    async play(name, options = {}) {
	        try {
	            // Check if we're at the concurrent sound limit
	            if (this._activeSounds.size >= this._performanceConfig.maxConcurrentSounds) {
	                // Try to make room by stopping low priority sounds
	                this.cullLowPrioritySounds();
	                // If still at limit, queue the sound or reject based on priority
	                if (this._activeSounds.size >= this._performanceConfig.maxConcurrentSounds) {
	                    const priority = options.priority || 0.5;
	                    if (priority < this._performanceConfig.priorityThreshold) {
	                        throw new Error('Sound rejected due to low priority and resource constraints');
	                    }
	                    // Queue high priority sound
	                    this._soundQueue.push({
	                        name,
	                        options,
	                        timestamp: this._context.currentTime
	                    });
	                    // Process queue asynchronously
	                    setTimeout(() => this.processQueue(), 10);
	                    // Return a placeholder for now
	                    return this.createPlaceholderSource();
	                }
	            }
	            // Get or create sound pool
	            const pool = await this.getOrCreatePool(name);
	            // Get available source from pool
	            const source = this.getPooledSource(pool);
	            // Configure source
	            this.configureSource(source, options);
	            // Play the source
	            await source.play(options.delay ? this._context.currentTime + options.delay : undefined);
	            // Track active sound
	            const activeSound = {
	                source,
	                name,
	                priority: options.priority || 0.5,
	                startTime: this._context.currentTime,
	                options
	            };
	            const soundId = `${name}_${Date.now()}_${Math.random()}`;
	            this._activeSounds.set(soundId, activeSound);
	            // Setup cleanup when sound ends
	            source.on('audio:end', () => {
	                this._activeSounds.delete(soundId);
	                this.returnSourceToPool(pool, source);
	            });
	            this.emit('audio:play', { source });
	            return source;
	        }
	        catch (error) {
	            console.error(`Failed to play sound '${name}':`, error);
	            throw error;
	        }
	    }
	    /**
	     * Process queued sounds
	     */
	    processQueue() {
	        if (this._soundQueue.length === 0) {
	            return;
	        }
	        // Sort queue by priority and timestamp
	        this._soundQueue.sort((a, b) => {
	            const priorityDiff = (b.options.priority || 0.5) - (a.options.priority || 0.5);
	            if (priorityDiff !== 0)
	                return priorityDiff;
	            return a.timestamp - b.timestamp; // Earlier sounds first for same priority
	        });
	        // Try to play queued sounds
	        while (this._soundQueue.length > 0 &&
	            this._activeSounds.size < this._performanceConfig.maxConcurrentSounds) {
	            const queuedSound = this._soundQueue.shift();
	            try {
	                this.play(queuedSound.name, queuedSound.options);
	            }
	            catch (error) {
	                console.warn('Failed to play queued sound:', error);
	            }
	        }
	    }
	    /**
	     * Create placeholder source for queued sounds
	     */
	    createPlaceholderSource() {
	        // This would return a mock AudioSource that represents a queued sound
	        // Implementation depends on your AudioSource interface
	        throw new Error('Sound queued - will play when resources available');
	    }
	    /**
	     * Get or create sound pool
	     */
	    async getOrCreatePool(name) {
	        let pool = this._soundPools.get(name);
	        if (!pool) {
	            // Create new pool
	            pool = {
	                name,
	                sources: [],
	                maxSize: this._performanceConfig.maxPoolSize,
	                currentIndex: 0,
	                priority: 0.5,
	                variations: [],
	                maxConcurrent: 4,
	                activeSources: new Set()
	            };
	            // Load initial source
	            const source = await this._audioManager.loadAudio(name, `sounds/${name}.ogg`);
	            pool.sources.push(source);
	            this._soundPools.set(name, pool);
	        }
	        return pool;
	    }
	    /**
	     * Get available source from pool
	     */
	    getPooledSource(pool) {
	        // Find an inactive source
	        for (const source of pool.sources) {
	            if (!source.isPlaying && !source.isPaused) {
	                return source;
	            }
	        }
	        // If pool not full, create new source
	        if (pool.sources.length < pool.maxSize) {
	            try {
	                // Clone the first source's buffer for new instances
	                const originalSource = pool.sources[0];
	                if (originalSource.buffer) {
	                    const newSource = this.createSourceFromBuffer(originalSource.buffer, pool.name);
	                    pool.sources.push(newSource);
	                    return newSource;
	                }
	            }
	            catch (error) {
	                console.warn('Failed to create new pooled source:', error);
	            }
	        }
	        // Pool is full, use round-robin selection
	        const source = pool.sources[pool.currentIndex];
	        pool.currentIndex = (pool.currentIndex + 1) % pool.sources.length;
	        // Stop the source if it's playing
	        if (source.isPlaying) {
	            source.stop();
	        }
	        return source;
	    }
	    /**
	     * Create new AudioSource from buffer
	     */
	    createSourceFromBuffer(buffer, name) {
	        // Implementation depends on your AudioSource constructor
	        // This is a simplified version
	        return new GameByteAudioSource(`${name}_${Date.now()}`, buffer, this._context, this._masterGain);
	    }
	    /**
	     * Configure source with play options
	     */
	    configureSource(source, options) {
	        if (options.volume !== undefined) {
	            source.setVolume(options.volume, options.fadeIn || 0);
	        }
	        if (options.pitch !== undefined && 'setPlaybackRate' in source) {
	            source.setPlaybackRate(options.pitch);
	        }
	        if (options.position) {
	            source.setPosition(options.position);
	        }
	        if (options.loop !== undefined && 'setLoop' in source) {
	            source.setLoop(options.loop);
	        }
	    }
	    /**
	     * Return source to pool
	     */
	    returnSourceToPool(pool, source) {
	        pool.activeSources.delete(source);
	        // Reset source state
	        source.setVolume(1.0, 0);
	        if ('setPlaybackRate' in source) {
	            source.setPlaybackRate(1.0);
	        }
	        if ('setLoop' in source) {
	            source.setLoop(false);
	        }
	    }
	    /**
	     * Stop a specific sound source
	     */
	    stopSound(source) {
	        try {
	            source.stop();
	        }
	        catch (error) {
	            console.warn('Error stopping sound:', error);
	        }
	    }
	    // Pool management
	    async preload(sounds) {
	        const loadPromises = sounds.map(async (sound) => {
	            try {
	                await this.getOrCreatePool(sound);
	            }
	            catch (error) {
	                console.warn(`Failed to preload sound '${sound}':`, error);
	            }
	        });
	        await Promise.all(loadPromises);
	        this.emit('sfx:preloaded', {
	            sounds,
	            count: sounds.length
	        });
	    }
	    setPoolSize(sound, size) {
	        const pool = this._soundPools.get(sound);
	        if (pool) {
	            pool.maxSize = Math.max(1, Math.min(size, 16)); // Clamp between 1 and 16
	            // Trim pool if needed
	            if (pool.sources.length > pool.maxSize) {
	                const toRemove = pool.sources.splice(pool.maxSize);
	                toRemove.forEach(source => {
	                    if ('destroy' in source) {
	                        source.destroy();
	                    }
	                });
	            }
	        }
	    }
	    warmUp() {
	        // Pre-initialize pools with multiple sources
	        this._soundPools.forEach(async (pool) => {
	            while (pool.sources.length < Math.min(pool.maxSize, 2)) {
	                try {
	                    const originalSource = pool.sources[0];
	                    if (originalSource.buffer) {
	                        const newSource = this.createSourceFromBuffer(originalSource.buffer, pool.name);
	                        pool.sources.push(newSource);
	                    }
	                }
	                catch (error) {
	                    console.warn('Failed to warm up pool:', error);
	                    break;
	                }
	            }
	        });
	    }
	    // Variation system
	    addVariation(baseName, variations) {
	        const variation = {
	            baseName,
	            variations,
	            playPattern: 'random',
	            lastPlayedIndex: -1
	        };
	        this._variations.set(baseName, variation);
	        // Preload variation sounds
	        this.preload(variations);
	    }
	    async playVariation(baseName, options = {}) {
	        const variation = this._variations.get(baseName);
	        if (!variation) {
	            // Fall back to base sound
	            return this.play(baseName, options);
	        }
	        let soundName;
	        switch (variation.playPattern) {
	            case 'sequential':
	                variation.lastPlayedIndex = (variation.lastPlayedIndex + 1) % variation.variations.length;
	                soundName = variation.variations[variation.lastPlayedIndex];
	                break;
	            case 'weighted':
	                soundName = this.selectWeightedVariation(variation);
	                break;
	            case 'random':
	            default:
	                soundName = variation.variations[Math.floor(Math.random() * variation.variations.length)];
	                break;
	        }
	        return this.play(soundName, options);
	    }
	    /**
	     * Select variation based on weights
	     */
	    selectWeightedVariation(variation) {
	        if (!variation.weights || variation.weights.length !== variation.variations.length) {
	            // Fall back to random selection
	            return variation.variations[Math.floor(Math.random() * variation.variations.length)];
	        }
	        const totalWeight = variation.weights.reduce((sum, weight) => sum + weight, 0);
	        const random = Math.random() * totalWeight;
	        let currentWeight = 0;
	        for (let i = 0; i < variation.variations.length; i++) {
	            currentWeight += variation.weights[i];
	            if (random <= currentWeight) {
	                return variation.variations[i];
	            }
	        }
	        // Fallback
	        return variation.variations[variation.variations.length - 1];
	    }
	    // Priority system
	    setPriority(sound, priority) {
	        const pool = this._soundPools.get(sound);
	        if (pool) {
	            pool.priority = Math.max(0, Math.min(1, priority));
	        }
	    }
	    setMaxConcurrent(sound, max) {
	        const pool = this._soundPools.get(sound);
	        if (pool) {
	            pool.maxConcurrent = Math.max(1, max);
	        }
	    }
	    /**
	     * Stop low priority sounds to make room for higher priority ones
	     */
	    stopLowPrioritySounds() {
	        this.cullLowPrioritySounds();
	    }
	    /**
	     * Set listener position for distance culling
	     */
	    setListenerPosition(position) {
	        this._listenerPosition = { ...position };
	    }
	    /**
	     * Get current performance metrics
	     */
	    getPerformanceMetrics() {
	        return { ...this._performanceMetrics };
	    }
	    /**
	     * Update performance configuration
	     */
	    updatePerformanceConfig(config) {
	        this._performanceConfig = { ...this._performanceConfig, ...config };
	    }
	    /**
	     * Clean up resources
	     */
	    destroy() {
	        // Stop culling system
	        if (this._cullUpdateInterval) {
	            clearInterval(this._cullUpdateInterval);
	            this._cullUpdateInterval = null;
	        }
	        // Stop all active sounds
	        this._activeSounds.forEach(activeSound => {
	            this.stopSound(activeSound.source);
	        });
	        this._activeSounds.clear();
	        // Destroy all pools
	        this._soundPools.forEach(pool => {
	            pool.sources.forEach(source => {
	                if ('destroy' in source) {
	                    source.destroy();
	                }
	            });
	        });
	        this._soundPools.clear();
	        // Disconnect audio nodes
	        this._masterGain.disconnect();
	        this._compressor.disconnect();
	        // Clear collections
	        this._variations.clear();
	        this._soundQueue.length = 0;
	        this.removeAllListeners();
	    }
	}

	/**
	 * GameByte Audio Zone - Environmental audio zone with spatial effects
	 *
	 * Features:
	 * - Geometric shape-based containment (sphere, box, cylinder)
	 * - Environmental audio effects and reverb
	 * - Distance-based influence calculation
	 * - Seamless zone transitions with fading
	 * - Priority-based zone mixing
	 */
	class GameByteAudioZone extends EventEmitter {
	    constructor(config, context, effectsProcessor) {
	        super();
	        this._isActive = false;
	        this._influence = 0;
	        this._effectNodes = new Map();
	        this._name = config.name;
	        this._config = { ...config };
	        this._context = context;
	        this._effectsProcessor = effectsProcessor;
	        // Create audio processing nodes
	        this.createAudioNodes();
	        // Calculate bounding sphere for optimization
	        this._boundingSphere = this.calculateBoundingSphere();
	        // Apply initial effects
	        if (config.effects) {
	            this.updateEffects(config.effects);
	        }
	    }
	    get name() {
	        return this._name;
	    }
	    get config() {
	        return { ...this._config };
	    }
	    get isActive() {
	        return this._isActive;
	    }
	    get influence() {
	        return this._influence;
	    }
	    /**
	     * Create audio processing nodes for the zone
	     */
	    createAudioNodes() {
	        this._inputGain = this._context.createGain();
	        this._inputGain.gain.value = 1.0;
	        this._outputGain = this._context.createGain();
	        this._outputGain.gain.value = 1.0;
	        // Connect basic chain
	        this._inputGain.connect(this._outputGain);
	    }
	    /**
	     * Calculate bounding sphere for efficient containment testing
	     */
	    calculateBoundingSphere() {
	        const center = { ...this._config.position };
	        let radius;
	        switch (this._config.shape) {
	            case 'sphere':
	                radius = typeof this._config.size === 'number' ?
	                    this._config.size :
	                    Math.max(this._config.size.x, this._config.size.y, this._config.size.z);
	                break;
	            case 'box':
	                if (typeof this._config.size === 'number') {
	                    radius = this._config.size * Math.sqrt(3); // Diagonal of cube
	                }
	                else {
	                    const { x, y, z } = this._config.size;
	                    radius = Math.sqrt(x * x + y * y + z * z) / 2; // Half diagonal
	                }
	                break;
	            case 'cylinder':
	                if (typeof this._config.size === 'number') {
	                    radius = this._config.size;
	                }
	                else {
	                    radius = Math.max(this._config.size.x, this._config.size.z);
	                }
	                break;
	            default:
	                radius = 10; // Default radius
	                break;
	        }
	        // Add fade distance to bounding sphere
	        radius += this._config.fadeDistance;
	        return { center, radius };
	    }
	    /**
	     * Check if a position is contained within the zone
	     */
	    contains(position) {
	        // Quick bounding sphere test first
	        const distToBounds = this.distanceToPoint(position, this._boundingSphere.center);
	        if (distToBounds > this._boundingSphere.radius) {
	            return false;
	        }
	        // Detailed shape-based containment test
	        return this.containsDetailed(position);
	    }
	    /**
	     * Detailed containment test based on zone shape
	     */
	    containsDetailed(position) {
	        const zonePos = this._config.position;
	        const relativePos = {
	            x: position.x - zonePos.x,
	            y: position.y - zonePos.y,
	            z: position.z - zonePos.z
	        };
	        switch (this._config.shape) {
	            case 'sphere':
	                const sphereRadius = typeof this._config.size === 'number' ?
	                    this._config.size :
	                    Math.max(this._config.size.x, this._config.size.y, this._config.size.z);
	                const distanceFromCenter = Math.sqrt(relativePos.x * relativePos.x +
	                    relativePos.y * relativePos.y +
	                    relativePos.z * relativePos.z);
	                return distanceFromCenter <= sphereRadius;
	            case 'box':
	                if (typeof this._config.size === 'number') {
	                    const halfSize = this._config.size / 2;
	                    return Math.abs(relativePos.x) <= halfSize &&
	                        Math.abs(relativePos.y) <= halfSize &&
	                        Math.abs(relativePos.z) <= halfSize;
	                }
	                else {
	                    const halfX = this._config.size.x / 2;
	                    const halfY = this._config.size.y / 2;
	                    const halfZ = this._config.size.z / 2;
	                    return Math.abs(relativePos.x) <= halfX &&
	                        Math.abs(relativePos.y) <= halfY &&
	                        Math.abs(relativePos.z) <= halfZ;
	                }
	            case 'cylinder':
	                const cylinderRadius = typeof this._config.size === 'number' ?
	                    this._config.size :
	                    Math.max(this._config.size.x, this._config.size.z);
	                const cylinderHeight = typeof this._config.size === 'number' ?
	                    this._config.size * 2 :
	                    this._config.size.y;
	                const radialDistance = Math.sqrt(relativePos.x * relativePos.x + relativePos.z * relativePos.z);
	                return radialDistance <= cylinderRadius &&
	                    Math.abs(relativePos.y) <= cylinderHeight / 2;
	            default:
	                return false;
	        }
	    }
	    /**
	     * Calculate influence factor based on distance and fade settings
	     */
	    getInfluence(position) {
	        const distanceToEdge = this.distanceToEdge(position);
	        if (distanceToEdge < 0) {
	            // Inside the zone
	            this._influence = 1.0;
	            this._isActive = true;
	        }
	        else if (distanceToEdge < this._config.fadeDistance) {
	            // In fade region
	            const fadeProgress = distanceToEdge / this._config.fadeDistance;
	            this._influence = 1.0 - fadeProgress;
	            this._isActive = this._influence > 0.01; // Consider active if influence > 1%
	        }
	        else {
	            // Outside fade region
	            this._influence = 0.0;
	            this._isActive = false;
	        }
	        return this._influence;
	    }
	    /**
	     * Calculate distance from position to zone edge
	     */
	    distanceToEdge(position) {
	        const zonePos = this._config.position;
	        const relativePos = {
	            x: position.x - zonePos.x,
	            y: position.y - zonePos.y,
	            z: position.z - zonePos.z
	        };
	        switch (this._config.shape) {
	            case 'sphere':
	                const sphereRadius = typeof this._config.size === 'number' ?
	                    this._config.size :
	                    Math.max(this._config.size.x, this._config.size.y, this._config.size.z);
	                const centerDistance = Math.sqrt(relativePos.x * relativePos.x +
	                    relativePos.y * relativePos.y +
	                    relativePos.z * relativePos.z);
	                return centerDistance - sphereRadius;
	            case 'box':
	                let halfSizes;
	                if (typeof this._config.size === 'number') {
	                    const halfSize = this._config.size / 2;
	                    halfSizes = { x: halfSize, y: halfSize, z: halfSize };
	                }
	                else {
	                    halfSizes = {
	                        x: this._config.size.x / 2,
	                        y: this._config.size.y / 2,
	                        z: this._config.size.z / 2
	                    };
	                }
	                const dx = Math.max(0, Math.abs(relativePos.x) - halfSizes.x);
	                const dy = Math.max(0, Math.abs(relativePos.y) - halfSizes.y);
	                const dz = Math.max(0, Math.abs(relativePos.z) - halfSizes.z);
	                return Math.sqrt(dx * dx + dy * dy + dz * dz);
	            case 'cylinder':
	                const cylinderRadius = typeof this._config.size === 'number' ?
	                    this._config.size :
	                    Math.max(this._config.size.x, this._config.size.z);
	                const cylinderHeight = typeof this._config.size === 'number' ?
	                    this._config.size * 2 :
	                    this._config.size.y;
	                const radialDist = Math.sqrt(relativePos.x * relativePos.x + relativePos.z * relativePos.z);
	                const radialExcess = Math.max(0, radialDist - cylinderRadius);
	                const verticalExcess = Math.max(0, Math.abs(relativePos.y) - cylinderHeight / 2);
	                return Math.sqrt(radialExcess * radialExcess + verticalExcess * verticalExcess);
	            default:
	                return Infinity;
	        }
	    }
	    /**
	     * Calculate distance between two points
	     */
	    distanceToPoint(pos1, pos2) {
	        const dx = pos1.x - pos2.x;
	        const dy = pos1.y - pos2.y;
	        const dz = pos1.z - pos2.z;
	        return Math.sqrt(dx * dx + dy * dy + dz * dz);
	    }
	    // Position and shape management
	    setPosition(position) {
	        this._config.position = { ...position };
	        this._boundingSphere = this.calculateBoundingSphere();
	        this.emit('zone:moved', {
	            zone: this,
	            position
	        });
	    }
	    getPosition() {
	        return { ...this._config.position };
	    }
	    setSize(size) {
	        this._config.size = typeof size === 'number' ? size : { ...size };
	        this._boundingSphere = this.calculateBoundingSphere();
	        this.emit('zone:resized', {
	            zone: this,
	            size
	        });
	    }
	    // Environment management
	    setEnvironment(environment) {
	        this._config.environment = environment;
	        // Update environmental effects
	        this.updateEnvironmentalEffects();
	        this.emit('zone:environment-changed', {
	            zone: this,
	            environment
	        });
	    }
	    getEnvironment() {
	        return this._config.environment;
	    }
	    /**
	     * Update environmental effects based on environment type
	     */
	    updateEnvironmentalEffects() {
	        const environment = this._config.environment;
	        // Remove existing environmental effects
	        this.removeEffect('environmental-filter');
	        this.removeEffect('environmental-reverb');
	        // Apply environment-specific effects
	        switch (environment) {
	            case exports.AudioEnvironment.UNDERWATER:
	                this.addEffect('environmental-filter', {
	                    filter: {
	                        type: 'lowpass',
	                        frequency: 400,
	                        Q: 2
	                    }
	                });
	                break;
	            case exports.AudioEnvironment.CAVE:
	                this.addEffect('environmental-reverb', {
	                    reverb: {
	                        roomSize: 0.9,
	                        damping: 0.1,
	                        wetness: 0.7,
	                        dryness: 0.3,
	                        width: 1.0,
	                        freezeMode: false
	                    }
	                });
	                break;
	            case exports.AudioEnvironment.FOREST:
	                this.addEffect('environmental-filter', {
	                    filter: {
	                        type: 'highpass',
	                        frequency: 80,
	                        Q: 0.7
	                    }
	                });
	                break;
	            case exports.AudioEnvironment.HALL:
	                this.addEffect('environmental-reverb', {
	                    reverb: {
	                        roomSize: 0.8,
	                        damping: 0.2,
	                        wetness: 0.5,
	                        dryness: 0.5,
	                        width: 1.0,
	                        freezeMode: false
	                    }
	                });
	                break;
	        }
	    }
	    updateEffects(config) {
	        this._config.effects = { ...config };
	        // Clear existing effects
	        this._effectNodes.forEach(node => node.disconnect());
	        this._effectNodes.clear();
	        // Recreate effects chain
	        this.createEffectsChain(config);
	        this.emit('zone:effects-updated', {
	            zone: this,
	            effects: config
	        });
	    }
	    /**
	     * Create effects processing chain
	     */
	    createEffectsChain(config) {
	        this._inputGain;
	        this._outputGain;
	        // Disconnect existing connections
	        this._inputGain.disconnect();
	        // Create effects in order
	        const effects = [];
	        if (config.filter) {
	            const filter = this._context.createBiquadFilter();
	            filter.type = config.filter.type;
	            filter.frequency.value = config.filter.frequency;
	            filter.Q.value = config.filter.Q;
	            if (config.filter.gain !== undefined) {
	                filter.gain.value = config.filter.gain;
	            }
	            effects.push(filter);
	            this._effectNodes.set('filter', filter);
	        }
	        if (config.compressor) {
	            const compressor = this._context.createDynamicsCompressor();
	            compressor.threshold.value = config.compressor.threshold;
	            compressor.knee.value = config.compressor.knee;
	            compressor.ratio.value = config.compressor.ratio;
	            compressor.attack.value = config.compressor.attack;
	            compressor.release.value = config.compressor.release;
	            effects.push(compressor);
	            this._effectNodes.set('compressor', compressor);
	        }
	        if (config.delay) {
	            const delayEffect = this.createDelayEffect(config.delay);
	            effects.push(delayEffect);
	            this._effectNodes.set('delay', delayEffect);
	        }
	        if (config.reverb) {
	            const reverbEffect = this.createReverbEffect(config.reverb);
	            effects.push(reverbEffect);
	            this._effectNodes.set('reverb', reverbEffect);
	        }
	        // Chain effects together
	        let previousNode = this._inputGain;
	        effects.forEach(effect => {
	            previousNode.connect(effect);
	            previousNode = effect;
	        });
	        // Connect final effect to output
	        if (effects.length > 0) {
	            previousNode.connect(this._outputGain);
	        }
	        else {
	            this._inputGain.connect(this._outputGain);
	        }
	    }
	    /**
	     * Create delay effect
	     */
	    createDelayEffect(config) {
	        const delay = this._context.createDelay(1);
	        const feedback = this._context.createGain();
	        const wetGain = this._context.createGain();
	        const dryGain = this._context.createGain();
	        const mixer = this._context.createGain();
	        delay.delayTime.value = config.delayTime;
	        feedback.gain.value = config.feedback;
	        wetGain.gain.value = config.wetness;
	        dryGain.gain.value = 1 - config.wetness;
	        // Create feedback loop
	        delay.connect(feedback);
	        feedback.connect(delay);
	        // Create wet/dry mix
	        delay.connect(wetGain);
	        wetGain.connect(mixer);
	        dryGain.connect(mixer);
	        // Create input splitter
	        const inputSplitter = this._context.createGain();
	        inputSplitter.connect(delay);
	        inputSplitter.connect(dryGain);
	        // Store reference to input node
	        mixer._inputNode = inputSplitter;
	        return mixer;
	    }
	    /**
	     * Create reverb effect
	     */
	    createReverbEffect(config) {
	        const convolver = this._context.createConvolver();
	        const wetGain = this._context.createGain();
	        const dryGain = this._context.createGain();
	        const mixer = this._context.createGain();
	        wetGain.gain.value = config.wetness;
	        dryGain.gain.value = config.dryness;
	        // Generate impulse response
	        const impulse = this.generateReverbImpulse(config);
	        convolver.buffer = impulse;
	        // Connect reverb chain
	        convolver.connect(wetGain);
	        wetGain.connect(mixer);
	        dryGain.connect(mixer);
	        // Create input splitter
	        const inputSplitter = this._context.createGain();
	        inputSplitter.connect(convolver);
	        inputSplitter.connect(dryGain);
	        mixer._inputNode = inputSplitter;
	        return mixer;
	    }
	    /**
	     * Generate reverb impulse response
	     */
	    generateReverbImpulse(config) {
	        const sampleRate = this._context.sampleRate;
	        const duration = config.roomSize * 3; // Scale duration with room size
	        const length = Math.floor(sampleRate * duration);
	        const buffer = this._context.createBuffer(2, length, sampleRate);
	        for (let channel = 0; channel < 2; channel++) {
	            const channelData = buffer.getChannelData(channel);
	            for (let i = 0; i < length; i++) {
	                const time = i / sampleRate;
	                const envelope = Math.exp(-time * (1 / config.roomSize));
	                const dampedEnvelope = envelope * (1 - config.damping * time / duration);
	                channelData[i] = (Math.random() * 2 - 1) * dampedEnvelope * 0.3;
	            }
	        }
	        return buffer;
	    }
	    /**
	     * Add individual effect to the zone
	     */
	    addEffect(name, config) {
	        // This is a simplified version - in practice, you'd rebuild the entire chain
	        console.log(`Adding effect ${name} to zone ${this._name}`);
	    }
	    /**
	     * Remove individual effect from the zone
	     */
	    removeEffect(name) {
	        const effect = this._effectNodes.get(name);
	        if (effect) {
	            effect.disconnect();
	            this._effectNodes.delete(name);
	        }
	    }
	    /**
	     * Get audio input node for connecting sources
	     */
	    getInputNode() {
	        return this._inputGain;
	    }
	    /**
	     * Get audio output node for connecting to master
	     */
	    getOutputNode() {
	        return this._outputGain;
	    }
	    /**
	     * Clean up resources
	     */
	    destroy() {
	        // Disconnect all audio nodes
	        this._inputGain.disconnect();
	        this._outputGain.disconnect();
	        this._effectNodes.forEach(node => node.disconnect());
	        this._effectNodes.clear();
	        this.removeAllListeners();
	    }
	}

	/**
	 * Default spatial audio configuration
	 */
	const DEFAULT_SPATIAL_CONFIG = {
	    enabled: true,
	    distanceModel: exports.DistanceModel.INVERSE,
	    maxDistance: 100,
	    rolloffFactor: 1,
	    dopplerFactor: 1,
	    speedOfSound: 343,
	    hrtfEnabled: true
	};
	/**
	 * GameByte Spatial Audio System - Advanced 3D audio positioning and environmental effects
	 *
	 * Features:
	 * - 3D positioned audio with HRTF processing
	 * - Environmental audio zones with acoustic modeling
	 * - Distance-based attenuation and occlusion
	 * - Doppler effects for moving sound sources
	 * - Audio listener management with orientation
	 * - Performance optimization for mobile devices
	 * - Zone-based environmental effects and reverb
	 */
	class GameByteSpatialAudioSystem extends EventEmitter {
	    constructor(context, effectsProcessor) {
	        super();
	        this._zones = new Map();
	        this._globalEnvironment = exports.AudioEnvironment.NONE;
	        // HRTF and 3D audio support
	        this._hrtfEnabled = true;
	        this._hrtfData = null;
	        this._environmentalFilter = null;
	        this._masterConvolver = null;
	        // Performance monitoring
	        this._activeSources = new Set();
	        this._occlusionSources = new Map();
	        // Zone management
	        this._activeZones = new Set();
	        this._zoneUpdateInterval = null;
	        this._context = context;
	        this._effectsProcessor = effectsProcessor;
	        this._spatialConfig = { ...DEFAULT_SPATIAL_CONFIG };
	        // Initialize listener at origin
	        this._listenerPosition = {
	            position: { x: 0, y: 0, z: 0 },
	            velocity: { x: 0, y: 0, z: 0 },
	            orientation: {
	                forward: { x: 0, y: 0, z: -1 },
	                up: { x: 0, y: 1, z: 0 }
	            }
	        };
	    }
	    get listenerPosition() {
	        return { ...this._listenerPosition };
	    }
	    get zones() {
	        return new Map(this._zones);
	    }
	    /**
	     * Initialize the spatial audio system
	     */
	    async initialize() {
	        try {
	            // Configure audio context listener
	            this.updateAudioListener();
	            // Create environmental processing chain
	            await this.createEnvironmentalProcessing();
	            // Enable HRTF if available
	            if (this._spatialConfig.hrtfEnabled) {
	                await this.initializeHRTF();
	            }
	            // Start zone monitoring
	            this.startZoneMonitoring();
	            this.emit('spatial:initialized', {});
	        }
	        catch (error) {
	            console.warn('Spatial audio initialization failed:', error);
	            // Continue with limited functionality
	        }
	    }
	    /**
	     * Initialize HRTF processing
	     */
	    async initializeHRTF() {
	        try {
	            // Check if HRTF is supported
	            if (this._context.listener && 'positionX' in this._context.listener) {
	                this._hrtfEnabled = true;
	                console.log('HRTF spatial audio enabled');
	            }
	            else {
	                console.warn('HRTF not supported, falling back to basic panner');
	                this._hrtfEnabled = false;
	            }
	        }
	        catch (error) {
	            console.warn('HRTF initialization failed:', error);
	            this._hrtfEnabled = false;
	        }
	    }
	    /**
	     * Create environmental audio processing chain
	     */
	    async createEnvironmentalProcessing() {
	        // Create master environmental filter
	        this._environmentalFilter = this._context.createBiquadFilter();
	        this._environmentalFilter.type = 'lowpass';
	        this._environmentalFilter.frequency.value = 20000; // No filtering by default
	        this._environmentalFilter.Q.value = 1;
	        // Create master convolution reverb
	        this._masterConvolver = this._context.createConvolver();
	        // Generate default impulse response
	        const impulse = this.generateEnvironmentalImpulse(exports.AudioEnvironment.NONE);
	        this._masterConvolver.buffer = impulse;
	    }
	    /**
	     * Generate environmental impulse response
	     */
	    generateEnvironmentalImpulse(environment) {
	        const sampleRate = this._context.sampleRate;
	        let duration = 1.0; // Default 1 second
	        let decay = 0.3;
	        let damping = 0.5;
	        switch (environment) {
	            case exports.AudioEnvironment.ROOM:
	                duration = 0.5;
	                decay = 0.4;
	                damping = 0.6;
	                break;
	            case exports.AudioEnvironment.HALL:
	                duration = 3.0;
	                decay = 0.8;
	                damping = 0.2;
	                break;
	            case exports.AudioEnvironment.CAVE:
	                duration = 5.0;
	                decay = 0.9;
	                damping = 0.1;
	                break;
	            case exports.AudioEnvironment.FOREST:
	                duration = 2.0;
	                decay = 0.6;
	                damping = 0.7;
	                break;
	            case exports.AudioEnvironment.UNDERWATER:
	                duration = 1.5;
	                decay = 0.7;
	                damping = 0.9;
	                break;
	            case exports.AudioEnvironment.SPACE:
	                duration = 0.1;
	                decay = 0.1;
	                damping = 1.0;
	                break;
	            case exports.AudioEnvironment.NONE:
	            default:
	                duration = 0.1;
	                decay = 0.0;
	                damping = 1.0;
	                break;
	        }
	        const length = Math.floor(sampleRate * duration);
	        const buffer = this._context.createBuffer(2, length, sampleRate);
	        for (let channel = 0; channel < 2; channel++) {
	            const channelData = buffer.getChannelData(channel);
	            for (let i = 0; i < length; i++) {
	                const time = i / sampleRate;
	                const envelope = Math.exp(-time * (1 / decay));
	                const dampedEnvelope = envelope * (1 - damping * time / duration);
	                // Add environmental characteristics
	                let signal = 0;
	                switch (environment) {
	                    case exports.AudioEnvironment.CAVE:
	                        // Multiple reflections with metallic resonance
	                        signal = (Math.random() * 2 - 1) * dampedEnvelope;
	                        signal += Math.sin(time * 150 * Math.PI) * 0.1 * envelope;
	                        break;
	                    case exports.AudioEnvironment.FOREST:
	                        // Diffuse reflections with natural decay
	                        signal = (Math.random() * 2 - 1) * dampedEnvelope * 0.7;
	                        break;
	                    case exports.AudioEnvironment.UNDERWATER:
	                        // Muffled with bubble effects
	                        signal = (Math.random() * 2 - 1) * dampedEnvelope * 0.5;
	                        signal += Math.sin(time * 50 * Math.PI) * 0.05 * envelope;
	                        break;
	                    default:
	                        signal = (Math.random() * 2 - 1) * dampedEnvelope;
	                        break;
	                }
	                channelData[i] = signal * 0.3; // Overall gain
	            }
	        }
	        return buffer;
	    }
	    /**
	     * Update audio context listener position and orientation
	     */
	    updateAudioListener() {
	        const listener = this._context.listener;
	        const pos = this._listenerPosition.position;
	        const vel = this._listenerPosition.velocity || { x: 0, y: 0, z: 0 };
	        const ori = this._listenerPosition.orientation;
	        if (this._hrtfEnabled && 'positionX' in listener) {
	            // Modern Web Audio API with AudioParam
	            listener.positionX.value = pos.x;
	            listener.positionY.value = pos.y;
	            listener.positionZ.value = pos.z;
	            if (ori) {
	                listener.forwardX.value = ori.forward.x;
	                listener.forwardY.value = ori.forward.y;
	                listener.forwardZ.value = ori.forward.z;
	                listener.upX.value = ori.up.x;
	                listener.upY.value = ori.up.y;
	                listener.upZ.value = ori.up.z;
	            }
	        }
	        else {
	            // Legacy Web Audio API
	            if ('setPosition' in listener) {
	                listener.setPosition(pos.x, pos.y, pos.z);
	            }
	            if ('setVelocity' in listener) {
	                listener.setVelocity(vel.x, vel.y, vel.z);
	            }
	            if (ori && 'setOrientation' in listener) {
	                listener.setOrientation(ori.forward.x, ori.forward.y, ori.forward.z, ori.up.x, ori.up.y, ori.up.z);
	            }
	        }
	    }
	    /**
	     * Start zone monitoring for environmental effects
	     */
	    startZoneMonitoring() {
	        if (this._zoneUpdateInterval) {
	            clearInterval(this._zoneUpdateInterval);
	        }
	        this._zoneUpdateInterval = window.setInterval(() => {
	            this.updateZones(this._listenerPosition.position);
	        }, 100); // Update 10 times per second
	    }
	    // Listener management
	    setListenerPosition(position) {
	        this._listenerPosition = { ...position };
	        this.updateAudioListener();
	        // Update zones based on new position
	        this.updateZones(position.position);
	        this.emit('listener:moved', {
	            position: position.position
	        });
	    }
	    getListenerPosition() {
	        return { ...this._listenerPosition };
	    }
	    // Zone management
	    createZone(config) {
	        if (this._zones.has(config.name)) {
	            throw new Error(`Audio zone '${config.name}' already exists`);
	        }
	        const zone = new GameByteAudioZone(config, this._context, this._effectsProcessor);
	        this._zones.set(config.name, zone);
	        // Set up zone event handlers
	        zone.on('zone:entered', (data) => {
	            this._activeZones.add(zone);
	            this.updateEnvironmentalEffects();
	            this.emit('audio:zone-enter', {
	                zone,
	                position: this._listenerPosition.position
	            });
	        });
	        zone.on('zone:exited', (data) => {
	            this._activeZones.delete(zone);
	            this.updateEnvironmentalEffects();
	            this.emit('audio:zone-exit', {
	                zone,
	                position: this._listenerPosition.position
	            });
	        });
	        this.emit('zone:created', {
	            zone,
	            config
	        });
	        return zone;
	    }
	    removeZone(name) {
	        const zone = this._zones.get(name);
	        if (zone) {
	            this._activeZones.delete(zone);
	            this._zones.delete(name);
	            if ('destroy' in zone && typeof zone.destroy === 'function') {
	                zone.destroy();
	            }
	            this.updateEnvironmentalEffects();
	            this.emit('zone:removed', {
	                name
	            });
	        }
	    }
	    getZone(name) {
	        return this._zones.get(name) || null;
	    }
	    updateZones(listenerPosition) {
	        this._zones.forEach(zone => {
	            const wasActive = this._activeZones.has(zone);
	            const isActive = zone.contains(listenerPosition);
	            const influence = zone.getInfluence(listenerPosition);
	            if (isActive && !wasActive) {
	                zone.emit('zone:entered', { position: listenerPosition });
	            }
	            else if (!isActive && wasActive) {
	                zone.emit('zone:exited', { position: listenerPosition });
	            }
	            else if (isActive) {
	                zone.emit('zone:influence-changed', {
	                    position: listenerPosition,
	                    influence
	                });
	            }
	        });
	    }
	    /**
	     * Update environmental effects based on active zones
	     */
	    updateEnvironmentalEffects() {
	        if (!this._environmentalFilter || !this._masterConvolver) {
	            return;
	        }
	        // Find the highest priority active zone
	        let dominantZone = null;
	        let highestPriority = -1;
	        let maxInfluence = 0;
	        this._activeZones.forEach(zone => {
	            const influence = zone.getInfluence(this._listenerPosition.position);
	            if (zone.config.priority > highestPriority ||
	                (zone.config.priority === highestPriority && influence > maxInfluence)) {
	                dominantZone = zone;
	                highestPriority = zone.config.priority;
	                maxInfluence = influence;
	            }
	        });
	        // Update environmental processing based on dominant zone
	        if (dominantZone) {
	            this.applyZoneEnvironment(dominantZone, maxInfluence);
	        }
	        else {
	            this.applyGlobalEnvironment();
	        }
	    }
	    /**
	     * Apply zone-specific environmental effects
	     */
	    applyZoneEnvironment(zone, influence) {
	        const environment = zone.getEnvironment();
	        // Update environmental filter
	        if (this._environmentalFilter) {
	            switch (environment) {
	                case exports.AudioEnvironment.UNDERWATER:
	                    this._environmentalFilter.frequency.exponentialRampToValueAtTime(400 * influence + 20000 * (1 - influence), this._context.currentTime + 0.1);
	                    break;
	                case exports.AudioEnvironment.CAVE:
	                    this._environmentalFilter.frequency.exponentialRampToValueAtTime(8000 * influence + 20000 * (1 - influence), this._context.currentTime + 0.1);
	                    break;
	                default:
	                    this._environmentalFilter.frequency.exponentialRampToValueAtTime(20000, this._context.currentTime + 0.1);
	                    break;
	            }
	        }
	        // Update convolution reverb
	        if (this._masterConvolver) {
	            const impulse = this.generateEnvironmentalImpulse(environment);
	            this._masterConvolver.buffer = impulse;
	        }
	    }
	    /**
	     * Apply global environmental effects
	     */
	    applyGlobalEnvironment() {
	        if (this._environmentalFilter) {
	            this._environmentalFilter.frequency.exponentialRampToValueAtTime(20000, this._context.currentTime + 0.1);
	        }
	        if (this._masterConvolver) {
	            const impulse = this.generateEnvironmentalImpulse(this._globalEnvironment);
	            this._masterConvolver.buffer = impulse;
	        }
	    }
	    // HRTF management
	    enableHRTF(enabled) {
	        this._spatialConfig.hrtfEnabled = enabled;
	        this._hrtfEnabled = enabled && this._context.listener && 'positionX' in this._context.listener;
	        this.emit('hrtf:toggled', {
	            enabled: this._hrtfEnabled
	        });
	    }
	    isHRTFEnabled() {
	        return this._hrtfEnabled;
	    }
	    async loadHRTFData(url) {
	        try {
	            const response = await fetch(url);
	            const arrayBuffer = await response.arrayBuffer();
	            this._hrtfData = await this._context.decodeAudioData(arrayBuffer);
	            this.emit('hrtf:loaded', {
	                url
	            });
	        }
	        catch (error) {
	            console.error('Failed to load HRTF data:', error);
	            throw error;
	        }
	    }
	    // Environmental audio
	    setGlobalEnvironment(environment) {
	        this._globalEnvironment = environment;
	        // Update environmental processing if no zones are active
	        if (this._activeZones.size === 0) {
	            this.applyGlobalEnvironment();
	        }
	        this.emit('environment:changed', {
	            environment
	        });
	    }
	    getGlobalEnvironment() {
	        return this._globalEnvironment;
	    }
	    /**
	     * Create spatially positioned audio source
	     */
	    createSpatialSource(position, config) {
	        const panner = this._context.createPanner();
	        // Apply spatial configuration
	        const spatialConfig = { ...this._spatialConfig, ...config };
	        panner.panningModel = 'HRTF';
	        panner.distanceModel = spatialConfig.distanceModel;
	        panner.maxDistance = spatialConfig.maxDistance;
	        panner.rolloffFactor = spatialConfig.rolloffFactor;
	        panner.refDistance = 1;
	        panner.coneInnerAngle = 360;
	        panner.coneOuterAngle = 0;
	        panner.coneOuterGain = 0;
	        // Set position
	        if ('positionX' in panner) {
	            panner.positionX.value = position.x;
	            panner.positionY.value = position.y;
	            panner.positionZ.value = position.z;
	        }
	        else {
	            panner.setPosition(position.x, position.y, position.z);
	        }
	        this._activeSources.add(panner);
	        return panner;
	    }
	    /**
	     * Update source position with Doppler effect
	     */
	    updateSourcePosition(source, position, velocity) {
	        // Update position
	        if ('positionX' in source) {
	            source.positionX.value = position.x;
	            source.positionY.value = position.y;
	            source.positionZ.value = position.z;
	        }
	        else {
	            source.setPosition(position.x, position.y, position.z);
	        }
	        // Update velocity for Doppler effect
	        if (velocity) {
	            ({
	                x: velocity.x * this._spatialConfig.dopplerFactor,
	                y: velocity.y * this._spatialConfig.dopplerFactor,
	                z: velocity.z * this._spatialConfig.dopplerFactor
	            });
	            // Web Audio API doesn't directly support velocity, so we simulate Doppler
	            // by adjusting playback rate based on relative velocity
	            this.simulateDopplerEffect(source, position, velocity);
	        }
	    }
	    /**
	     * Simulate Doppler effect by adjusting playback rate
	     */
	    simulateDopplerEffect(source, position, velocity) {
	        const listenerPos = this._listenerPosition.position;
	        const listenerVel = this._listenerPosition.velocity || { x: 0, y: 0, z: 0 };
	        // Calculate distance vector
	        const dx = position.x - listenerPos.x;
	        const dy = position.y - listenerPos.y;
	        const dz = position.z - listenerPos.z;
	        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
	        if (distance > 0) {
	            // Calculate relative velocity towards listener
	            ((velocity.x - listenerVel.x) * dx +
	                (velocity.y - listenerVel.y) * dy +
	                (velocity.z - listenerVel.z) * dz) / distance;
	            // Calculate Doppler shift
	            this._spatialConfig.speedOfSound;
	            // Apply to connected buffer source nodes (if accessible)
	            // Note: This is a simplified implementation
	            // In practice, you'd need to track which buffer sources are connected
	        }
	    }
	    /**
	     * Calculate occlusion based on obstacles
	     */
	    calculateOcclusion(sourcePosition, obstacles) {
	        const listenerPos = this._listenerPosition.position;
	        let occlusionFactor = 1.0;
	        obstacles.forEach(obstacle => {
	            if (this.isLineOccluded(sourcePosition, listenerPos, obstacle.position, obstacle.size)) {
	                occlusionFactor *= 0.5; // 50% reduction per obstacle
	            }
	        });
	        return Math.max(0.1, occlusionFactor); // Minimum 10% volume
	    }
	    /**
	     * Check if line of sight is occluded by obstacle
	     */
	    isLineOccluded(start, end, obstaclePos, obstacleSize) {
	        // Simple sphere-line intersection test
	        const dx = end.x - start.x;
	        const dy = end.y - start.y;
	        const dz = end.z - start.z;
	        const fx = start.x - obstaclePos.x;
	        const fy = start.y - obstaclePos.y;
	        const fz = start.z - obstaclePos.z;
	        const a = dx * dx + dy * dy + dz * dz;
	        const b = 2 * (fx * dx + fy * dy + fz * dz);
	        const c = fx * fx + fy * fy + fz * fz - obstacleSize * obstacleSize;
	        const discriminant = b * b - 4 * a * c;
	        if (discriminant >= 0) {
	            const t1 = (-b - Math.sqrt(discriminant)) / (2 * a);
	            const t2 = (-b + Math.sqrt(discriminant)) / (2 * a);
	            return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);
	        }
	        return false;
	    }
	    /**
	     * Apply occlusion effect to audio source
	     */
	    applyOcclusion(source, occlusionFactor) {
	        // Create or update low-pass filter for occlusion
	        const filter = this._context.createBiquadFilter();
	        filter.type = 'lowpass';
	        filter.frequency.value = 20000 * occlusionFactor; // Reduce high frequencies
	        filter.Q.value = 1;
	        // Connect filter between source and destination
	        // Note: This requires restructuring the audio graph
	    }
	    /**
	     * Get spatial audio performance metrics
	     */
	    getPerformanceMetrics() {
	        return {
	            activeSources: this._activeSources.size,
	            activeZones: this._activeZones.size,
	            hrtfEnabled: this._hrtfEnabled,
	            occludedSources: this._occlusionSources.size
	        };
	    }
	    /**
	     * Clean up resources
	     */
	    destroy() {
	        // Stop zone monitoring
	        if (this._zoneUpdateInterval) {
	            clearInterval(this._zoneUpdateInterval);
	            this._zoneUpdateInterval = null;
	        }
	        // Destroy all zones
	        this._zones.forEach(zone => {
	            if ('destroy' in zone && typeof zone.destroy === 'function') {
	                zone.destroy();
	            }
	        });
	        this._zones.clear();
	        this._activeZones.clear();
	        // Disconnect environmental processing
	        if (this._environmentalFilter) {
	            this._environmentalFilter.disconnect();
	            this._environmentalFilter = null;
	        }
	        if (this._masterConvolver) {
	            this._masterConvolver.disconnect();
	            this._masterConvolver = null;
	        }
	        // Clean up tracking
	        this._activeSources.clear();
	        this._occlusionSources.clear();
	        this.removeAllListeners();
	    }
	}

	/**
	 * Default mobile audio configuration
	 */
	const DEFAULT_MOBILE_CONFIG$1 = {
	    batteryOptimization: true,
	    backgroundAudio: false,
	    interruptionHandling: true,
	    hardwareAcceleration: true,
	    adaptiveQuality: true,
	    maxConcurrentSounds: 32,
	    memoryLimit: 64,
	    cpuLimit: 15
	};
	/**
	 * GameByte Mobile Audio Manager - Device-specific audio optimizations
	 *
	 * Features:
	 * - Intelligent background audio handling with app state management
	 * - Comprehensive interruption management (calls, notifications, system sounds)
	 * - Advanced battery optimization with adaptive performance scaling
	 * - Thermal throttling and hardware acceleration management
	 * - Device-specific optimizations for iOS and Android
	 * - Real-time performance monitoring and automatic quality adjustment
	 * - Web Audio API fallbacks and compatibility layers
	 */
	class GameByteMobileAudioManager extends EventEmitter {
	    constructor(config, audioManager) {
	        super();
	        // App state management
	        this._currentAppState = 'active';
	        this._wasPlayingBeforeBackground = false;
	        this._backgroundAudioEnabled = false;
	        // Interruption handling
	        this._interruptionHandler = null;
	        this._activeInterruptions = new Set();
	        this._audioStateBeforeInterruption = null;
	        // Battery and thermal management
	        this._batteryStatus = null;
	        this._thermalState = 'nominal';
	        this._batteryMonitorInterval = null;
	        this._thermalMonitorInterval = null;
	        // Performance adaptation
	        this._performanceMonitorInterval = null;
	        this._lastPerformanceUpdate = 0;
	        this._performanceHistory = [];
	        // Hardware optimization
	        this._hardwareAccelerationEnabled = true;
	        this._originalConfig = {};
	        // Platform detection
	        this._platform = 'web';
	        this._isWebView = false;
	        this._config = { ...DEFAULT_MOBILE_CONFIG$1, ...config };
	        this._audioManager = audioManager;
	        this._originalConfig = { ...this._config };
	        // Initialize performance metrics
	        this._performanceMetrics = {
	            cpuUsage: 0,
	            memoryUsage: 0,
	            latency: 0,
	            activeSources: 0,
	            droppedFrames: 0,
	            contextState: 'suspended',
	            thermalState: 'nominal'
	        };
	        // Detect platform and device capabilities
	        this.detectPlatform();
	        this.detectDeviceCapabilities();
	    }
	    get config() {
	        return { ...this._config };
	    }
	    get performanceMetrics() {
	        return { ...this._performanceMetrics };
	    }
	    /**
	     * Initialize the mobile audio manager
	     */
	    async initialize() {
	        try {
	            // Setup platform-specific optimizations
	            await this.setupPlatformOptimizations();
	            // Initialize battery monitoring
	            this.initializeBatteryMonitoring();
	            // Initialize thermal monitoring
	            this.initializeThermalMonitoring();
	            // Setup interruption handling
	            this.setupInterruptionHandling();
	            // Setup app state change handling
	            this.setupAppStateHandling();
	            // Start performance monitoring
	            this.startPerformanceMonitoring();
	            // Apply initial optimizations
	            this.optimizeForDevice();
	            this.emit('mobile:initialized', {
	                platform: this._platform,
	                capabilities: this._deviceCapabilities
	            });
	        }
	        catch (error) {
	            console.error('Mobile audio manager initialization failed:', error);
	            throw error;
	        }
	    }
	    /**
	     * Detect the current platform
	     */
	    detectPlatform() {
	        const userAgent = navigator.userAgent.toLowerCase();
	        // Check for iOS
	        if (/iphone|ipad|ipod/.test(userAgent)) {
	            this._platform = 'ios';
	        }
	        // Check for Android
	        else if (/android/.test(userAgent)) {
	            this._platform = 'android';
	        }
	        // Default to web
	        else {
	            this._platform = 'web';
	        }
	        // Check if running in a WebView
	        this._isWebView = /; wv\)|webview/.test(userAgent) ||
	            window.ReactNativeWebView !== undefined ||
	            window.webkit?.messageHandlers !== undefined;
	    }
	    /**
	     * Detect device audio capabilities
	     */
	    detectDeviceCapabilities() {
	        const audioContext = this._audioManager.context;
	        this._deviceCapabilities = {
	            maxChannels: audioContext.destination.maxChannelCount || 2,
	            sampleRate: audioContext.sampleRate || 44100,
	            latency: audioContext.baseLatency || 0,
	            hardwareAcceleration: this.detectHardwareAcceleration(),
	            supportsWebAudio: !!(window.AudioContext || window.webkitAudioContext),
	            supportsSpatialAudio: this.detectSpatialAudioSupport(),
	            batteryAPI: 'getBattery' in navigator,
	            thermalAPI: 'thermal' in navigator
	        };
	    }
	    /**
	     * Detect hardware acceleration support
	     */
	    detectHardwareAcceleration() {
	        // Check for WebGL support as a proxy for hardware acceleration
	        try {
	            const canvas = document.createElement('canvas');
	            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
	            return !!gl;
	        }
	        catch (e) {
	            return false;
	        }
	    }
	    /**
	     * Detect spatial audio support
	     */
	    detectSpatialAudioSupport() {
	        const audioContext = this._audioManager.context;
	        return !!(audioContext.listener && 'positionX' in audioContext.listener);
	    }
	    /**
	     * Setup platform-specific optimizations
	     */
	    async setupPlatformOptimizations() {
	        switch (this._platform) {
	            case 'ios':
	                await this.setupIOSOptimizations();
	                break;
	            case 'android':
	                await this.setupAndroidOptimizations();
	                break;
	            case 'web':
	                await this.setupWebOptimizations();
	                break;
	        }
	    }
	    /**
	     * Setup iOS-specific optimizations
	     */
	    async setupIOSOptimizations() {
	        // iOS requires user interaction to unlock audio
	        this.setupIOSAudioUnlock();
	        // Configure audio session for iOS
	        if (this._isWebView) {
	            this.configureIOSAudioSession();
	        }
	        // Optimize for iOS battery life
	        if (this._config.batteryOptimization) {
	            this._config.maxConcurrentSounds = Math.min(this._config.maxConcurrentSounds, 16);
	            this._config.memoryLimit = Math.min(this._config.memoryLimit, 32);
	        }
	    }
	    /**
	     * Setup audio unlock for iOS
	     */
	    setupIOSAudioUnlock() {
	        const unlockAudio = async () => {
	            const audioContext = this._audioManager.context;
	            if (audioContext.state === 'suspended') {
	                try {
	                    await audioContext.resume();
	                    // Remove listeners after successful unlock
	                    document.removeEventListener('touchstart', unlockAudio);
	                    document.removeEventListener('touchend', unlockAudio);
	                    this.emit('audio:unlocked', {
	                        platform: 'ios'
	                    });
	                }
	                catch (error) {
	                    console.warn('Failed to unlock iOS audio:', error);
	                }
	            }
	        };
	        document.addEventListener('touchstart', unlockAudio, { passive: true });
	        document.addEventListener('touchend', unlockAudio, { passive: true });
	    }
	    /**
	     * Configure iOS audio session
	     */
	    configureIOSAudioSession() {
	        // This would require native iOS integration
	        // For web context, we can only make suggestions
	        console.log('iOS audio session configuration suggested');
	    }
	    /**
	     * Setup Android-specific optimizations
	     */
	    async setupAndroidOptimizations() {
	        // Android-specific audio optimizations
	        if (this._config.batteryOptimization) {
	            this.setupAndroidBatteryOptimization();
	        }
	        // Handle Android audio focus
	        this.setupAndroidAudioFocus();
	        // Optimize for various Android device capabilities
	        this.optimizeForAndroidDevice();
	    }
	    /**
	     * Setup Android battery optimization
	     */
	    setupAndroidBatteryOptimization() {
	        // Reduce audio processing on low battery
	        this.on('battery:low', () => {
	            this._config.maxConcurrentSounds = Math.floor(this._config.maxConcurrentSounds * 0.7);
	            this._config.memoryLimit = Math.floor(this._config.memoryLimit * 0.8);
	        });
	    }
	    /**
	     * Setup Android audio focus handling
	     */
	    setupAndroidAudioFocus() {
	        // Android audio focus would be handled through native integration
	        // For web context, we simulate with page visibility
	        this.setupPageVisibilityHandling();
	    }
	    /**
	     * Optimize for Android device variations
	     */
	    optimizeForAndroidDevice() {
	        // Detect device performance tier based on hardware
	        const memory = navigator.deviceMemory || 2;
	        const cores = navigator.hardwareConcurrency || 2;
	        if (memory < 2 || cores < 4) {
	            // Low-end device optimizations
	            this._config.maxConcurrentSounds = Math.min(this._config.maxConcurrentSounds, 8);
	            this._config.memoryLimit = Math.min(this._config.memoryLimit, 16);
	            this._config.adaptiveQuality = true;
	        }
	    }
	    /**
	     * Setup web-specific optimizations
	     */
	    async setupWebOptimizations() {
	        // Web-specific audio handling
	        this.setupPageVisibilityHandling();
	        // Handle tab switching
	        this.setupTabSwitchHandling();
	        // Setup web-based interruption simulation
	        this.setupWebInterruptionHandling();
	    }
	    /**
	     * Setup page visibility handling
	     */
	    setupPageVisibilityHandling() {
	        document.addEventListener('visibilitychange', () => {
	            if (document.hidden) {
	                this.handleAppStateChange('background');
	            }
	            else {
	                this.handleAppStateChange('active');
	            }
	        });
	    }
	    /**
	     * Setup tab switching handling
	     */
	    setupTabSwitchHandling() {
	        window.addEventListener('blur', () => {
	            this.handleAppStateChange('background');
	        });
	        window.addEventListener('focus', () => {
	            this.handleAppStateChange('active');
	        });
	    }
	    /**
	     * Setup web-based interruption handling
	     */
	    setupWebInterruptionHandling() {
	        // Simulate interruptions for web context
	        // In a real implementation, this might integrate with notification APIs
	    }
	    /**
	     * Initialize battery monitoring
	     */
	    initializeBatteryMonitoring() {
	        if (!this._config.batteryOptimization || !this._deviceCapabilities.batteryAPI) {
	            return;
	        }
	        // Modern battery API
	        if ('getBattery' in navigator) {
	            navigator.getBattery().then((battery) => {
	                this._batteryStatus = {
	                    level: battery.level,
	                    charging: battery.charging,
	                    chargingTime: battery.chargingTime,
	                    dischargingTime: battery.dischargingTime
	                };
	                // Setup battery event listeners
	                battery.addEventListener('levelchange', () => {
	                    this._batteryStatus.level = battery.level;
	                    this.handleBatteryChange();
	                });
	                battery.addEventListener('chargingchange', () => {
	                    this._batteryStatus.charging = battery.charging;
	                    this.handleBatteryChange();
	                });
	                this.handleBatteryChange();
	            }).catch(() => {
	                console.warn('Battery API not available');
	            });
	        }
	    }
	    /**
	     * Handle battery level changes
	     */
	    handleBatteryChange() {
	        if (!this._batteryStatus)
	            return;
	        const level = this._batteryStatus.level;
	        const charging = this._batteryStatus.charging;
	        // Adjust performance based on battery level
	        if (level < 0.2 && !charging) {
	            // Critical battery level
	            this.enableAggressiveBatteryOptimization();
	            this.emit('battery:critical', { level });
	        }
	        else if (level < 0.5 && !charging) {
	            // Low battery level
	            this.enableStandardBatteryOptimization();
	            this.emit('battery:low', { level });
	        }
	        else {
	            // Normal battery level
	            this.disableBatteryOptimization();
	            this.emit('battery:normal', { level });
	        }
	    }
	    /**
	     * Enable aggressive battery optimization
	     */
	    enableAggressiveBatteryOptimization() {
	        this._config.maxConcurrentSounds = Math.min(this._originalConfig.maxConcurrentSounds || 32, 4);
	        this._config.memoryLimit = Math.min(this._originalConfig.memoryLimit || 64, 8);
	        this._config.cpuLimit = Math.min(this._originalConfig.cpuLimit || 15, 5);
	        // Reduce spatial audio processing
	        const spatialSystem = this._audioManager.getSpatialAudioSystem();
	        if (spatialSystem) {
	            spatialSystem.enableHRTF(false);
	        }
	    }
	    /**
	     * Enable standard battery optimization
	     */
	    enableStandardBatteryOptimization() {
	        this._config.maxConcurrentSounds = Math.floor((this._originalConfig.maxConcurrentSounds || 32) * 0.7);
	        this._config.memoryLimit = Math.floor((this._originalConfig.memoryLimit || 64) * 0.8);
	        this._config.cpuLimit = Math.floor((this._originalConfig.cpuLimit || 15) * 0.8);
	    }
	    /**
	     * Disable battery optimization
	     */
	    disableBatteryOptimization() {
	        this._config.maxConcurrentSounds = this._originalConfig.maxConcurrentSounds || 32;
	        this._config.memoryLimit = this._originalConfig.memoryLimit || 64;
	        this._config.cpuLimit = this._originalConfig.cpuLimit || 15;
	        // Re-enable spatial audio processing
	        const spatialSystem = this._audioManager.getSpatialAudioSystem();
	        if (spatialSystem && this._originalConfig.hardwareAcceleration) {
	            spatialSystem.enableHRTF(true);
	        }
	    }
	    /**
	     * Initialize thermal monitoring
	     */
	    initializeThermalMonitoring() {
	        // Check for thermal API support
	        if ('thermal' in navigator) {
	            // Modern thermal API (experimental)
	            navigator.thermal.addEventListener('change', (event) => {
	                this._thermalState = event.state;
	                this.handleThermalStateChange();
	            });
	        }
	        else {
	            // Simulate thermal monitoring based on performance
	            this._thermalMonitorInterval = window.setInterval(() => {
	                this.estimateThermalState();
	            }, 5000); // Check every 5 seconds
	        }
	    }
	    /**
	     * Handle thermal state changes
	     */
	    handleThermalStateChange() {
	        this._performanceMetrics.thermalState = this._thermalState;
	        switch (this._thermalState) {
	            case 'critical':
	                this.enableCriticalThermalThrottling();
	                this.emit('thermal:critical', { state: this._thermalState });
	                break;
	            case 'serious':
	                this.enableSeriousThermalThrottling();
	                this.emit('thermal:serious', { state: this._thermalState });
	                break;
	            case 'fair':
	                this.enableModerateThermalThrottling();
	                this.emit('thermal:fair', { state: this._thermalState });
	                break;
	            case 'nominal':
	            default:
	                this.disableThermalThrottling();
	                this.emit('thermal:nominal', { state: this._thermalState });
	                break;
	        }
	    }
	    /**
	     * Estimate thermal state based on performance metrics
	     */
	    estimateThermalState() {
	        const cpuUsage = this._performanceMetrics.cpuUsage;
	        if (cpuUsage > 80) {
	            this._thermalState = 'critical';
	        }
	        else if (cpuUsage > 60) {
	            this._thermalState = 'serious';
	        }
	        else if (cpuUsage > 40) {
	            this._thermalState = 'fair';
	        }
	        else {
	            this._thermalState = 'nominal';
	        }
	        this.handleThermalStateChange();
	    }
	    /**
	     * Enable critical thermal throttling
	     */
	    enableCriticalThermalThrottling() {
	        this._config.maxConcurrentSounds = Math.min(this._config.maxConcurrentSounds, 2);
	        this._config.memoryLimit = Math.min(this._config.memoryLimit, 8);
	        // Disable spatial audio
	        const spatialSystem = this._audioManager.getSpatialAudioSystem();
	        if (spatialSystem) {
	            spatialSystem.enableHRTF(false);
	        }
	        // Reduce music quality
	        const musicSystem = this._audioManager.getMusicSystem();
	        if (musicSystem && musicSystem.isPlaying) {
	            // Disable non-essential layers
	            musicSystem.activeLayers.forEach(layer => {
	                if (layer !== 'main') {
	                    musicSystem.disableLayer(layer, 1.0);
	                }
	            });
	        }
	    }
	    /**
	     * Enable serious thermal throttling
	     */
	    enableSeriousThermalThrottling() {
	        this._config.maxConcurrentSounds = Math.floor(this._originalConfig.maxConcurrentSounds * 0.3);
	        this._config.memoryLimit = Math.floor(this._originalConfig.memoryLimit * 0.5);
	    }
	    /**
	     * Enable moderate thermal throttling
	     */
	    enableModerateThermalThrottling() {
	        this._config.maxConcurrentSounds = Math.floor(this._originalConfig.maxConcurrentSounds * 0.7);
	        this._config.memoryLimit = Math.floor(this._originalConfig.memoryLimit * 0.8);
	    }
	    /**
	     * Disable thermal throttling
	     */
	    disableThermalThrottling() {
	        this._config.maxConcurrentSounds = this._originalConfig.maxConcurrentSounds;
	        this._config.memoryLimit = this._originalConfig.memoryLimit;
	    }
	    /**
	     * Setup interruption handling
	     */
	    setupInterruptionHandling() {
	        // Handle phone calls (simulated for web)
	        if ('onbeforecallstart' in window) {
	            window.onbeforecallstart = () => {
	                this.handleInterruption(exports.AudioInterruption.PHONE_CALL, 'begin');
	            };
	        }
	        // Handle notifications
	        if ('Notification' in window && Notification.permission === 'granted') {
	            // Listen for visibility changes that might indicate notifications
	            document.addEventListener('visibilitychange', () => {
	                if (document.hidden) {
	                    this.handleInterruption(exports.AudioInterruption.NOTIFICATION, 'begin');
	                }
	                else {
	                    this.handleInterruption(exports.AudioInterruption.NOTIFICATION, 'end');
	                }
	            });
	        }
	    }
	    /**
	     * Setup app state change handling
	     */
	    setupAppStateHandling() {
	        // Already handled in platform-specific setup
	    }
	    /**
	     * Start performance monitoring
	     */
	    startPerformanceMonitoring() {
	        if (this._performanceMonitorInterval) {
	            clearInterval(this._performanceMonitorInterval);
	        }
	        this._performanceMonitorInterval = window.setInterval(() => {
	            this.updatePerformanceMetrics();
	            this.adaptToPerformance(this._performanceMetrics);
	        }, 1000); // Update every second
	    }
	    /**
	     * Update performance metrics
	     */
	    updatePerformanceMetrics() {
	        const audioMetrics = this._audioManager.getPerformanceMetrics();
	        this._performanceMetrics = {
	            ...audioMetrics,
	            thermalState: this._thermalState,
	            batteryLevel: this._batteryStatus?.level
	        };
	        // Track performance history for trend analysis
	        this._performanceHistory.push(this._performanceMetrics.cpuUsage);
	        if (this._performanceHistory.length > 60) {
	            this._performanceHistory.shift(); // Keep last 60 seconds
	        }
	    }
	    // Background audio handling
	    handleAppStateChange(state) {
	        const previousState = this._currentAppState;
	        this._currentAppState = state;
	        switch (state) {
	            case 'background':
	                this.handleAppGoingBackground();
	                break;
	            case 'suspended':
	                this.handleAppSuspended();
	                break;
	            case 'active':
	                this.handleAppReturningActive(previousState);
	                break;
	        }
	        this.emit('app:state-change', {
	            previous: previousState,
	            current: state
	        });
	    }
	    /**
	     * Handle app going to background
	     */
	    handleAppGoingBackground() {
	        const musicSystem = this._audioManager.getMusicSystem();
	        this._audioManager.getSFXSystem();
	        if (this._backgroundAudioEnabled) {
	            // Keep music playing, stop SFX
	            this._wasPlayingBeforeBackground = musicSystem.isPlaying;
	            // SFX typically stops in background
	        }
	        else {
	            // Stop all audio
	            this._wasPlayingBeforeBackground = musicSystem.isPlaying;
	            if (musicSystem.isPlaying) {
	                musicSystem.pauseTrack();
	            }
	        }
	    }
	    /**
	     * Handle app suspended
	     */
	    handleAppSuspended() {
	        // Force stop all audio when suspended
	        const musicSystem = this._audioManager.getMusicSystem();
	        if (musicSystem.isPlaying) {
	            musicSystem.pauseTrack();
	        }
	    }
	    /**
	     * Handle app returning to active state
	     */
	    handleAppReturningActive(previousState) {
	        if (previousState === 'background' || previousState === 'suspended') {
	            const musicSystem = this._audioManager.getMusicSystem();
	            if (this._wasPlayingBeforeBackground && !musicSystem.isPlaying) {
	                musicSystem.resumeTrack();
	            }
	            this._wasPlayingBeforeBackground = false;
	        }
	    }
	    enableBackgroundAudio(enabled) {
	        this._backgroundAudioEnabled = enabled;
	        this._config.backgroundAudio = enabled;
	        this.emit('background-audio:toggled', {
	            enabled
	        });
	    }
	    isBackgroundAudioEnabled() {
	        return this._backgroundAudioEnabled;
	    }
	    // Interruption handling
	    handleInterruption(type, action) {
	        if (action === 'begin') {
	            this._activeInterruptions.add(type);
	            if (this._activeInterruptions.size === 1) {
	                // First interruption - save audio state
	                this.saveAudioStateBeforeInterruption();
	            }
	            this.applyInterruptionBehavior(type);
	        }
	        else {
	            this._activeInterruptions.delete(type);
	            if (this._activeInterruptions.size === 0) {
	                // Last interruption ended - restore audio state
	                this.restoreAudioStateAfterInterruption();
	            }
	        }
	        // Call custom interruption handler if set
	        if (this._interruptionHandler) {
	            this._interruptionHandler(type, action);
	        }
	        this.emit('audio:interruption', { type, action });
	    }
	    /**
	     * Save audio state before interruption
	     */
	    saveAudioStateBeforeInterruption() {
	        const musicSystem = this._audioManager.getMusicSystem();
	        this._audioStateBeforeInterruption = {
	            masterVolume: this._audioManager.getMasterVolume(),
	            musicPlaying: musicSystem.isPlaying,
	            sfxEnabled: true // Assume SFX was enabled
	        };
	    }
	    /**
	     * Apply interruption-specific behavior
	     */
	    applyInterruptionBehavior(type) {
	        const musicSystem = this._audioManager.getMusicSystem();
	        switch (type) {
	            case exports.AudioInterruption.PHONE_CALL:
	                // Pause all audio during phone calls
	                if (musicSystem.isPlaying) {
	                    musicSystem.pauseTrack();
	                }
	                this._audioManager.setMasterMuted(true);
	                break;
	            case exports.AudioInterruption.NOTIFICATION:
	                // Temporarily duck audio volume
	                this._audioManager.setMasterVolume(0.3, 0.1);
	                break;
	            case exports.AudioInterruption.SYSTEM_SOUND:
	                // Brief duck
	                this._audioManager.setMasterVolume(0.5, 0.05);
	                break;
	            case exports.AudioInterruption.OTHER_APP:
	                // Pause music, keep SFX
	                if (musicSystem.isPlaying) {
	                    musicSystem.pauseTrack();
	                }
	                break;
	            case exports.AudioInterruption.HARDWARE:
	                // Handle hardware-based interruptions
	                this._audioManager.setMasterMuted(true);
	                break;
	        }
	    }
	    /**
	     * Restore audio state after interruption
	     */
	    restoreAudioStateAfterInterruption() {
	        if (!this._audioStateBeforeInterruption)
	            return;
	        const musicSystem = this._audioManager.getMusicSystem();
	        const state = this._audioStateBeforeInterruption;
	        // Restore master volume
	        this._audioManager.setMasterVolume(state.masterVolume, 0.2);
	        this._audioManager.setMasterMuted(false);
	        // Restore music playback
	        if (state.musicPlaying && !musicSystem.isPlaying) {
	            setTimeout(() => {
	                musicSystem.resumeTrack();
	            }, 200); // Small delay for smooth transition
	        }
	        this._audioStateBeforeInterruption = null;
	    }
	    setInterruptionHandler(handler) {
	        this._interruptionHandler = handler;
	    }
	    // Performance optimization
	    adaptToPerformance(metrics) {
	        const now = Date.now();
	        if (now - this._lastPerformanceUpdate < 1000) {
	            return; // Throttle adaptation
	        }
	        this._lastPerformanceUpdate = now;
	        // Adapt based on CPU usage
	        if (metrics.cpuUsage > this._config.cpuLimit * 0.9) {
	            this.reduceCPUUsage();
	        }
	        else if (metrics.cpuUsage < this._config.cpuLimit * 0.5) {
	            this.increaseCPUUsage();
	        }
	        // Adapt based on memory usage
	        if (metrics.memoryUsage > this._config.memoryLimit * 0.9) {
	            this.reduceMemoryUsage();
	        }
	        // Emit performance warning if needed
	        if (metrics.cpuUsage > this._config.cpuLimit ||
	            metrics.memoryUsage > this._config.memoryLimit) {
	            this.emit('audio:performance-warning', {
	                metric: 'resource-limit',
	                value: Math.max(metrics.cpuUsage, metrics.memoryUsage),
	                threshold: Math.max(this._config.cpuLimit, this._config.memoryLimit)
	            });
	        }
	    }
	    /**
	     * Reduce CPU usage by limiting audio processing
	     */
	    reduceCPUUsage() {
	        this._config.maxConcurrentSounds = Math.max(4, this._config.maxConcurrentSounds - 2);
	        // Reduce spatial audio quality
	        const spatialSystem = this._audioManager.getSpatialAudioSystem();
	        if (spatialSystem) {
	            spatialSystem.enableHRTF(false);
	        }
	    }
	    /**
	     * Increase CPU usage when resources are available
	     */
	    increaseCPUUsage() {
	        if (this._config.maxConcurrentSounds < this._originalConfig.maxConcurrentSounds) {
	            this._config.maxConcurrentSounds = Math.min(this._originalConfig.maxConcurrentSounds, this._config.maxConcurrentSounds + 2);
	        }
	        // Re-enable spatial audio if originally enabled
	        if (this._originalConfig.hardwareAcceleration) {
	            const spatialSystem = this._audioManager.getSpatialAudioSystem();
	            if (spatialSystem) {
	                spatialSystem.enableHRTF(true);
	            }
	        }
	    }
	    /**
	     * Reduce memory usage
	     */
	    reduceMemoryUsage() {
	        // Ask SFX system to clean up pools
	        const sfxSystem = this._audioManager.getSFXSystem();
	        if (sfxSystem && 'stopLowPrioritySounds' in sfxSystem) {
	            sfxSystem.stopLowPrioritySounds();
	        }
	    }
	    enableBatteryOptimization(enabled) {
	        this._config.batteryOptimization = enabled;
	        if (enabled) {
	            this.handleBatteryChange();
	        }
	        else {
	            this.disableBatteryOptimization();
	        }
	    }
	    isBatteryOptimizationEnabled() {
	        return this._config.batteryOptimization;
	    }
	    setThermalThrottling(enabled) {
	        if (enabled) {
	            this.initializeThermalMonitoring();
	        }
	        else {
	            if (this._thermalMonitorInterval) {
	                clearInterval(this._thermalMonitorInterval);
	                this._thermalMonitorInterval = null;
	            }
	            this.disableThermalThrottling();
	        }
	    }
	    // Hardware optimization
	    enableHardwareAcceleration(enabled) {
	        this._hardwareAccelerationEnabled = enabled;
	        this._config.hardwareAcceleration = enabled;
	        // Apply hardware acceleration settings
	        const spatialSystem = this._audioManager.getSpatialAudioSystem();
	        if (spatialSystem) {
	            spatialSystem.enableHRTF(enabled && this._deviceCapabilities.supportsSpatialAudio);
	        }
	    }
	    optimizeForDevice() {
	        const tier = this._audioManager.performanceTier;
	        switch (tier) {
	            case exports.AudioPerformanceTier.LOW:
	                this.applyLowEndOptimizations();
	                break;
	            case exports.AudioPerformanceTier.MEDIUM:
	                this.applyMidRangeOptimizations();
	                break;
	            case exports.AudioPerformanceTier.HIGH:
	                this.applyHighEndOptimizations();
	                break;
	            case exports.AudioPerformanceTier.PREMIUM:
	                this.applyPremiumOptimizations();
	                break;
	        }
	    }
	    /**
	     * Apply optimizations for low-end devices
	     */
	    applyLowEndOptimizations() {
	        this._config.maxConcurrentSounds = Math.min(this._config.maxConcurrentSounds, 8);
	        this._config.memoryLimit = Math.min(this._config.memoryLimit, 16);
	        this._config.adaptiveQuality = true;
	        this.enableHardwareAcceleration(false);
	    }
	    /**
	     * Apply optimizations for mid-range devices
	     */
	    applyMidRangeOptimizations() {
	        this._config.maxConcurrentSounds = Math.min(this._config.maxConcurrentSounds, 16);
	        this._config.memoryLimit = Math.min(this._config.memoryLimit, 32);
	        this.enableHardwareAcceleration(this._deviceCapabilities.hardwareAcceleration);
	    }
	    /**
	     * Apply optimizations for high-end devices
	     */
	    applyHighEndOptimizations() {
	        this._config.maxConcurrentSounds = Math.min(this._config.maxConcurrentSounds, 32);
	        this._config.memoryLimit = Math.min(this._config.memoryLimit, 64);
	        this.enableHardwareAcceleration(true);
	    }
	    /**
	     * Apply optimizations for premium devices
	     */
	    applyPremiumOptimizations() {
	        // No limits for premium devices - use original configuration
	        this._config.maxConcurrentSounds = this._originalConfig.maxConcurrentSounds;
	        this._config.memoryLimit = this._originalConfig.memoryLimit;
	        this.enableHardwareAcceleration(true);
	    }
	    getDeviceCapabilities() {
	        return {
	            maxChannels: this._deviceCapabilities.maxChannels,
	            sampleRate: this._deviceCapabilities.sampleRate,
	            latency: this._deviceCapabilities.latency,
	            hardwareAcceleration: this._deviceCapabilities.hardwareAcceleration
	        };
	    }
	    /**
	     * Get platform-specific information
	     */
	    getPlatformInfo() {
	        return {
	            platform: this._platform,
	            isWebView: this._isWebView,
	            capabilities: this._deviceCapabilities
	        };
	    }
	    /**
	     * Clean up resources
	     */
	    destroy() {
	        // Stop monitoring intervals
	        if (this._batteryMonitorInterval) {
	            clearInterval(this._batteryMonitorInterval);
	            this._batteryMonitorInterval = null;
	        }
	        if (this._thermalMonitorInterval) {
	            clearInterval(this._thermalMonitorInterval);
	            this._thermalMonitorInterval = null;
	        }
	        if (this._performanceMonitorInterval) {
	            clearInterval(this._performanceMonitorInterval);
	            this._performanceMonitorInterval = null;
	        }
	        // Clear collections
	        this._activeInterruptions.clear();
	        this._performanceHistory.length = 0;
	        this.removeAllListeners();
	    }
	}

	/**
	 * GameByte Audio Analytics System
	 *
	 * Features:
	 * - Comprehensive playback tracking and metrics
	 * - User preference learning and adaptation
	 * - Performance monitoring and optimization insights
	 * - Privacy-focused local data collection
	 * - Exportable analytics for game optimization
	 * - Real-time behavioral analysis
	 */
	class GameByteAudioAnalytics extends EventEmitter {
	    constructor() {
	        super();
	        this._currentSession = null;
	        // Tracking state
	        this._trackPlayCounts = new Map();
	        this._hourlyUsage = new Array(24).fill(0);
	        this._volumeHistory = [];
	        this._qualityHistory = [];
	        this._performanceHistory = [];
	        // Analytics intervals
	        this._insightsUpdateInterval = null;
	        this._performanceTrackingInterval = null;
	        // Privacy settings
	        this._dataRetentionDays = 30;
	        this._maxSessionsStored = 1000;
	        // Initialize analytics with default values
	        this._analytics = {
	            totalPlaytime: 0,
	            musicVolume: 0.8,
	            sfxVolume: 1.0,
	            environmentalAudio: true,
	            preferredQuality: exports.AudioQuality.MEDIUM,
	            interruptionEvents: 0,
	            batteryOptimizationEnabled: true,
	            deviceInfo: {
	                audioContextSampleRate: 44100,
	                maxChannelCount: 2,
	                latency: 0,
	                performanceTier: exports.AudioPerformanceTier.MEDIUM
	            }
	        };
	        this._sessions = [];
	        this._insights = {
	            totalSessions: 0,
	            averageSessionDuration: 0,
	            mostPlayedTracks: [],
	            peakUsageHours: [],
	            preferredVolumeRange: { min: 0.5, max: 1.0 },
	            interruptionRate: 0,
	            qualityPreferences: new Map()
	        };
	        // Load saved data
	        this.loadAnalyticsData();
	        // Start analytics tracking
	        this.startAnalyticsTracking();
	    }
	    get analytics() {
	        return { ...this._analytics };
	    }
	    /**
	     * Load analytics data from storage
	     */
	    loadAnalyticsData() {
	        try {
	            const stored = localStorage.getItem('gamebyte-audio-analytics');
	            if (stored) {
	                const data = JSON.parse(stored);
	                this._analytics = { ...this._analytics, ...data.analytics };
	                this._sessions = data.sessions || [];
	                this._trackPlayCounts = new Map(data.trackPlayCounts || []);
	                this._hourlyUsage = data.hourlyUsage || new Array(24).fill(0);
	                this._volumeHistory = data.volumeHistory || [];
	                this._qualityHistory = data.qualityHistory || [];
	                // Update insights
	                this.updateInsights();
	            }
	        }
	        catch (error) {
	            console.warn('Failed to load audio analytics data:', error);
	        }
	    }
	    /**
	     * Save analytics data to storage
	     */
	    saveAnalyticsData() {
	        try {
	            const data = {
	                analytics: this._analytics,
	                sessions: this._sessions.slice(-this._maxSessionsStored), // Keep only recent sessions
	                trackPlayCounts: Array.from(this._trackPlayCounts.entries()),
	                hourlyUsage: this._hourlyUsage,
	                volumeHistory: this._volumeHistory.slice(-1000), // Keep last 1000 volume changes
	                qualityHistory: this._qualityHistory.slice(-1000), // Keep last 1000 quality changes
	                lastUpdated: Date.now()
	            };
	            localStorage.setItem('gamebyte-audio-analytics', JSON.stringify(data));
	        }
	        catch (error) {
	            console.warn('Failed to save audio analytics data:', error);
	        }
	    }
	    /**
	     * Start analytics tracking intervals
	     */
	    startAnalyticsTracking() {
	        // Update insights every 5 minutes
	        this._insightsUpdateInterval = window.setInterval(() => {
	            this.updateInsights();
	            this.saveAnalyticsData();
	        }, 5 * 60 * 1000);
	        // Clean up old data daily
	        this._performanceTrackingInterval = window.setInterval(() => {
	            this.cleanupOldData();
	        }, 24 * 60 * 60 * 1000);
	    }
	    /**
	     * Start a new audio session
	     */
	    startSession() {
	        // End current session if exists
	        if (this._currentSession) {
	            this.endSession();
	        }
	        this._currentSession = {
	            startTime: Date.now(),
	            duration: 0,
	            tracksPlayed: [],
	            soundsPlayed: 0,
	            averageVolume: this._analytics.musicVolume,
	            interruptionCount: 0,
	            qualityChanges: 0
	        };
	        // Track usage by hour
	        const hour = new Date().getHours();
	        this._hourlyUsage[hour]++;
	    }
	    /**
	     * End current audio session
	     */
	    endSession() {
	        if (!this._currentSession)
	            return;
	        this._currentSession.endTime = Date.now();
	        this._currentSession.duration = this._currentSession.endTime - this._currentSession.startTime;
	        // Update total playtime
	        this._analytics.totalPlaytime += this._currentSession.duration;
	        // Store session
	        this._sessions.push(this._currentSession);
	        this._currentSession = null;
	        // Update insights
	        this.updateInsights();
	    }
	    // Data collection methods
	    trackPlayback(source, duration) {
	        if (this._currentSession) {
	            this._currentSession.soundsPlayed++;
	            // Track if this is a music track
	            if (source.id.includes('music') || source.id.includes('track')) {
	                if (!this._currentSession.tracksPlayed.includes(source.id)) {
	                    this._currentSession.tracksPlayed.push(source.id);
	                }
	                // Update track play count
	                const currentCount = this._trackPlayCounts.get(source.id) || 0;
	                this._trackPlayCounts.set(source.id, currentCount + 1);
	            }
	        }
	        this.emit('analytics:playback-tracked', {
	            sourceId: source.id,
	            duration
	        });
	    }
	    trackVolumeChange(type, volume) {
	        if (type === 'music') {
	            this._analytics.musicVolume = volume;
	        }
	        else {
	            this._analytics.sfxVolume = volume;
	        }
	        // Track volume history
	        this._volumeHistory.push(volume);
	        // Update current session average volume
	        if (this._currentSession) {
	            const totalVolume = this._currentSession.averageVolume * this._currentSession.soundsPlayed + volume;
	            this._currentSession.averageVolume = totalVolume / (this._currentSession.soundsPlayed + 1);
	        }
	        this.emit('analytics:volume-tracked', {
	            type,
	            volume
	        });
	    }
	    trackInterruption(type) {
	        this._analytics.interruptionEvents++;
	        if (this._currentSession) {
	            this._currentSession.interruptionCount++;
	        }
	        this.emit('analytics:interruption-tracked', {
	            type,
	            count: this._analytics.interruptionEvents
	        });
	    }
	    trackPerformance(metrics) {
	        // Keep recent performance history
	        this._performanceHistory.push(metrics);
	        if (this._performanceHistory.length > 100) {
	            this._performanceHistory.shift();
	        }
	        // Update device info
	        this._analytics.deviceInfo = {
	            audioContextSampleRate: metrics.contextState === 'running' ? 44100 : 0,
	            maxChannelCount: 2, // Would be determined from actual context
	            latency: metrics.latency,
	            performanceTier: this.determinePerformanceTier(metrics)
	        };
	    }
	    /**
	     * Determine performance tier from metrics
	     */
	    determinePerformanceTier(metrics) {
	        let score = 0;
	        // CPU usage score (lower is better)
	        if (metrics.cpuUsage < 5)
	            score += 3;
	        else if (metrics.cpuUsage < 10)
	            score += 2;
	        else if (metrics.cpuUsage < 20)
	            score += 1;
	        // Memory usage score (lower is better)
	        if (metrics.memoryUsage < 32)
	            score += 3;
	        else if (metrics.memoryUsage < 64)
	            score += 2;
	        else if (metrics.memoryUsage < 128)
	            score += 1;
	        // Latency score (lower is better)
	        if (metrics.latency < 0.02)
	            score += 3;
	        else if (metrics.latency < 0.05)
	            score += 2;
	        else if (metrics.latency < 0.1)
	            score += 1;
	        // Active sources handling
	        if (metrics.activeSources > 32)
	            score += 3;
	        else if (metrics.activeSources > 16)
	            score += 2;
	        else if (metrics.activeSources > 8)
	            score += 1;
	        // Determine tier based on score
	        if (score >= 10)
	            return exports.AudioPerformanceTier.PREMIUM;
	        if (score >= 7)
	            return exports.AudioPerformanceTier.HIGH;
	        if (score >= 4)
	            return exports.AudioPerformanceTier.MEDIUM;
	        return exports.AudioPerformanceTier.LOW;
	    }
	    // User preferences
	    updateUserPreferences(preferences) {
	        this._analytics = { ...this._analytics, ...preferences };
	        // Track quality preference changes
	        if (preferences.preferredQuality) {
	            this._qualityHistory.push(preferences.preferredQuality);
	            if (this._currentSession) {
	                this._currentSession.qualityChanges++;
	            }
	        }
	        this.saveAnalyticsData();
	        this.emit('analytics:preferences-updated', {
	            preferences
	        });
	    }
	    getUserPreferences() {
	        return this.analytics;
	    }
	    exportAnalytics() {
	        const exportData = {
	            analytics: this._analytics,
	            insights: this._insights,
	            sessions: this._sessions,
	            trackPlayCounts: Object.fromEntries(this._trackPlayCounts),
	            hourlyUsage: this._hourlyUsage,
	            exportedAt: new Date().toISOString(),
	            version: '1.0'
	        };
	        return JSON.stringify(exportData, null, 2);
	    }
	    // Insights generation
	    getPlaytimeInsights() {
	        const totalTime = this._analytics.totalPlaytime;
	        const averageSession = this._sessions.length > 0
	            ? this._sessions.reduce((sum, session) => sum + session.duration, 0) / this._sessions.length
	            : 0;
	        // Find peak usage hours (top 3)
	        const hoursWithUsage = this._hourlyUsage
	            .map((usage, hour) => ({ hour, usage }))
	            .sort((a, b) => b.usage - a.usage)
	            .slice(0, 3)
	            .map(item => item.hour);
	        return {
	            totalTime,
	            averageSession,
	            preferredTimes: hoursWithUsage
	        };
	    }
	    getPerformanceInsights() {
	        const recentMetrics = this._performanceHistory.slice(-50); // Last 50 entries
	        const averageCPU = recentMetrics.length > 0
	            ? recentMetrics.reduce((sum, metric) => sum + metric.cpuUsage, 0) / recentMetrics.length
	            : 0;
	        const peakMemory = recentMetrics.length > 0
	            ? Math.max(...recentMetrics.map(metric => metric.memoryUsage))
	            : 0;
	        const interruptionRate = this._sessions.length > 0
	            ? this._analytics.interruptionEvents / this._sessions.length
	            : 0;
	        return {
	            averageCPU,
	            peakMemory,
	            interruptionRate
	        };
	    }
	    /**
	     * Update comprehensive insights
	     */
	    updateInsights() {
	        this._insights.totalSessions = this._sessions.length;
	        // Calculate average session duration
	        if (this._sessions.length > 0) {
	            this._insights.averageSessionDuration =
	                this._sessions.reduce((sum, session) => sum + session.duration, 0) / this._sessions.length;
	        }
	        // Most played tracks
	        this._insights.mostPlayedTracks = Array.from(this._trackPlayCounts.entries())
	            .sort((a, b) => b[1] - a[1])
	            .slice(0, 10)
	            .map(([track, playCount]) => ({ track, playCount }));
	        // Peak usage hours
	        this._insights.peakUsageHours = this._hourlyUsage
	            .map((usage, hour) => ({ hour, usage }))
	            .sort((a, b) => b.usage - a.usage)
	            .slice(0, 5)
	            .map(item => item.hour);
	        // Preferred volume range
	        if (this._volumeHistory.length > 0) {
	            const sortedVolumes = [...this._volumeHistory].sort((a, b) => a - b);
	            const q1Index = Math.floor(sortedVolumes.length * 0.25);
	            const q3Index = Math.floor(sortedVolumes.length * 0.75);
	            this._insights.preferredVolumeRange = {
	                min: sortedVolumes[q1Index],
	                max: sortedVolumes[q3Index]
	            };
	        }
	        // Interruption rate
	        this._insights.interruptionRate = this._sessions.length > 0
	            ? this._analytics.interruptionEvents / this._sessions.length
	            : 0;
	        // Quality preferences
	        const qualityCount = new Map();
	        this._qualityHistory.forEach(quality => {
	            qualityCount.set(quality, (qualityCount.get(quality) || 0) + 1);
	        });
	        this._insights.qualityPreferences = qualityCount;
	    }
	    /**
	     * Clean up old data for privacy and performance
	     */
	    cleanupOldData() {
	        const cutoffDate = Date.now() - (this._dataRetentionDays * 24 * 60 * 60 * 1000);
	        // Remove old sessions
	        this._sessions = this._sessions.filter(session => session.startTime > cutoffDate);
	        // Limit history arrays
	        if (this._volumeHistory.length > 1000) {
	            this._volumeHistory = this._volumeHistory.slice(-500);
	        }
	        if (this._qualityHistory.length > 1000) {
	            this._qualityHistory = this._qualityHistory.slice(-500);
	        }
	        if (this._performanceHistory.length > 200) {
	            this._performanceHistory = this._performanceHistory.slice(-100);
	        }
	    }
	    /**
	     * Get recommendations based on analytics
	     */
	    getRecommendations() {
	        const recommendations = [];
	        // Volume recommendations
	        if (this._volumeHistory.length > 10) {
	            const avgVolume = this._volumeHistory.reduce((sum, vol) => sum + vol, 0) / this._volumeHistory.length;
	            if (avgVolume < 0.3) {
	                recommendations.push({
	                    type: 'volume',
	                    message: 'Consider increasing audio volume for better experience',
	                    confidence: 0.7
	                });
	            }
	            else if (avgVolume > 0.9) {
	                recommendations.push({
	                    type: 'volume',
	                    message: 'High volume detected - consider hearing protection',
	                    confidence: 0.8
	                });
	            }
	        }
	        // Performance recommendations
	        const performanceInsights = this.getPerformanceInsights();
	        if (performanceInsights.averageCPU > 20) {
	            recommendations.push({
	                type: 'performance',
	                message: 'Consider reducing audio quality to improve performance',
	                confidence: 0.9
	            });
	        }
	        // Usage timing recommendations
	        const playtimeInsights = this.getPlaytimeInsights();
	        if (playtimeInsights.preferredTimes.length > 0) {
	            recommendations.push({
	                type: 'timing',
	                message: `Optimal gaming time appears to be around ${playtimeInsights.preferredTimes[0]}:00`,
	                confidence: 0.6
	            });
	        }
	        return recommendations;
	    }
	    /**
	     * Get detailed analytics report
	     */
	    getDetailedReport() {
	        return {
	            summary: this.analytics,
	            insights: this._insights,
	            recommendations: this.getRecommendations(),
	            performanceMetrics: this.getPerformanceInsights()
	        };
	    }
	    /**
	     * Reset analytics data (for privacy)
	     */
	    resetAnalytics() {
	        this._analytics = {
	            totalPlaytime: 0,
	            musicVolume: 0.8,
	            sfxVolume: 1.0,
	            environmentalAudio: true,
	            preferredQuality: exports.AudioQuality.MEDIUM,
	            interruptionEvents: 0,
	            batteryOptimizationEnabled: true,
	            deviceInfo: {
	                audioContextSampleRate: 44100,
	                maxChannelCount: 2,
	                latency: 0,
	                performanceTier: exports.AudioPerformanceTier.MEDIUM
	            }
	        };
	        this._sessions = [];
	        this._trackPlayCounts.clear();
	        this._hourlyUsage.fill(0);
	        this._volumeHistory = [];
	        this._qualityHistory = [];
	        this._performanceHistory = [];
	        // Clear storage
	        localStorage.removeItem('gamebyte-audio-analytics');
	        this.emit('analytics:reset', {});
	    }
	    /**
	     * Clean up resources
	     */
	    destroy() {
	        // End current session
	        if (this._currentSession) {
	            this.endSession();
	        }
	        // Save final data
	        this.saveAnalyticsData();
	        // Clear intervals
	        if (this._insightsUpdateInterval) {
	            clearInterval(this._insightsUpdateInterval);
	            this._insightsUpdateInterval = null;
	        }
	        if (this._performanceTrackingInterval) {
	            clearInterval(this._performanceTrackingInterval);
	            this._performanceTrackingInterval = null;
	        }
	        this.removeAllListeners();
	    }
	}

	/**
	 * Audio effect presets for common game scenarios
	 */
	const EFFECT_PRESETS = {
	    // Reverb presets
	    room: {
	        reverb: {
	            roomSize: 0.3,
	            damping: 0.5,
	            wetness: 0.3,
	            dryness: 0.7,
	            width: 1.0,
	            freezeMode: false
	        }
	    },
	    hall: {
	        reverb: {
	            roomSize: 0.8,
	            damping: 0.2,
	            wetness: 0.5,
	            dryness: 0.5,
	            width: 1.0,
	            freezeMode: false
	        }
	    },
	    cave: {
	        reverb: {
	            roomSize: 0.9,
	            damping: 0.1,
	            wetness: 0.7,
	            dryness: 0.3,
	            width: 1.0,
	            freezeMode: false
	        }
	    },
	    // Filter presets
	    underwater: {
	        filter: {
	            type: 'lowpass',
	            frequency: 400,
	            Q: 2,
	            gain: 0
	        }
	    },
	    radio: {
	        filter: {
	            type: 'bandpass',
	            frequency: 1000,
	            Q: 5,
	            gain: 0
	        }
	    },
	    telephone: {
	        filter: {
	            type: 'bandpass',
	            frequency: 800,
	            Q: 10,
	            gain: 0
	        }
	    },
	    // Distortion presets
	    overdrive: {
	        distortion: {
	            amount: 20,
	            oversample: '2x'
	        }
	    },
	    fuzz: {
	        distortion: {
	            amount: 50,
	            oversample: '4x'
	        }
	    },
	    // Delay presets
	    echo: {
	        delay: {
	            delayTime: 0.3,
	            feedback: 0.3,
	            wetness: 0.3
	        }
	    },
	    slap: {
	        delay: {
	            delayTime: 0.1,
	            feedback: 0.1,
	            wetness: 0.2
	        }
	    },
	    // Compressor presets
	    vocal: {
	        compressor: {
	            threshold: -18,
	            knee: 12,
	            ratio: 4,
	            attack: 0.01,
	            release: 0.1
	        }
	    },
	    drums: {
	        compressor: {
	            threshold: -12,
	            knee: 6,
	            ratio: 8,
	            attack: 0.003,
	            release: 0.05
	        }
	    },
	    limiter: {
	        limiter: {
	            threshold: -3,
	            lookAhead: 0.005,
	            release: 0.1
	        }
	    }
	};
	/**
	 * GameByte Audio Effects Processor
	 *
	 * Features:
	 * - Comprehensive effects library (reverb, delay, filters, distortion, dynamics)
	 * - Effect presets for common game scenarios
	 * - Real-time parameter control
	 * - Audio worklet support for custom processors
	 * - Mobile-optimized processing
	 * - Visual analysis and metering
	 */
	class GameByteAudioEffectsProcessor extends EventEmitter {
	    constructor(context) {
	        super();
	        this._effects = new Map();
	        this._presets = new Map();
	        this._worklets = new Map();
	        this._convolutionBuffers = new Map();
	        // Analysis nodes
	        this._analyzers = new Map();
	        // Worklet processors loaded
	        this._workletProcessorsLoaded = new Set();
	        this._context = context;
	        // Load default presets
	        Object.entries(EFFECT_PRESETS).forEach(([name, config]) => {
	            this._presets.set(name, config);
	        });
	    }
	    get context() {
	        return this._context;
	    }
	    get effects() {
	        return new Map(this._effects);
	    }
	    /**
	     * Initialize the effects processor
	     */
	    async initialize() {
	        try {
	            // Load audio worklet processors for advanced effects
	            await this.loadWorkletProcessors();
	            // Generate impulse responses for reverb
	            await this.generateReverbImpulses();
	            this.emit('effects:initialized', {});
	        }
	        catch (error) {
	            console.warn('Some effects features may not be available:', error);
	            // Continue initialization even if some features fail
	        }
	    }
	    /**
	     * Load audio worklet processors
	     */
	    async loadWorkletProcessors() {
	        const workletProcessors = [
	            'reverb-processor',
	            'granular-processor',
	            'spectral-processor'
	        ];
	        for (const processor of workletProcessors) {
	            try {
	                // In a real implementation, you would load from actual worklet files
	                // await this._context.audioWorklet.addModule(`/worklets/${processor}.js`);
	                this._workletProcessorsLoaded.add(processor);
	            }
	            catch (error) {
	                console.warn(`Failed to load worklet processor: ${processor}`, error);
	            }
	        }
	    }
	    /**
	     * Generate impulse responses for reverb effects
	     */
	    async generateReverbImpulses() {
	        const impulses = {
	            room: this.generateRoomImpulse(0.3, 0.5, 2.0),
	            hall: this.generateRoomImpulse(0.8, 0.2, 4.0),
	            cave: this.generateRoomImpulse(0.9, 0.1, 6.0),
	            plate: this.generatePlateImpulse(0.6, 0.3, 3.0),
	            spring: this.generateSpringImpulse(0.4, 0.4, 1.5)
	        };
	        Object.entries(impulses).forEach(([name, buffer]) => {
	            this._convolutionBuffers.set(name, buffer);
	        });
	    }
	    /**
	     * Generate room impulse response
	     */
	    generateRoomImpulse(size, damping, duration) {
	        const sampleRate = this._context.sampleRate;
	        const length = Math.floor(sampleRate * duration);
	        const buffer = this._context.createBuffer(2, length, sampleRate);
	        for (let channel = 0; channel < 2; channel++) {
	            const channelData = buffer.getChannelData(channel);
	            for (let i = 0; i < length; i++) {
	                const time = i / sampleRate;
	                const decay = Math.pow(1 - damping, time * 10);
	                const noise = (Math.random() * 2 - 1) * decay;
	                // Add early reflections
	                const earlyReflection = this.calculateEarlyReflection(time, size, channel);
	                channelData[i] = (noise + earlyReflection) * 0.5;
	            }
	        }
	        return buffer;
	    }
	    /**
	     * Calculate early reflection for reverb
	     */
	    calculateEarlyReflection(time, roomSize, channel) {
	        const reflections = [
	            { delay: 0.01 * roomSize, gain: 0.8 },
	            { delay: 0.02 * roomSize, gain: 0.6 },
	            { delay: 0.03 * roomSize, gain: 0.4 },
	            { delay: 0.05 * roomSize, gain: 0.3 },
	            { delay: 0.08 * roomSize, gain: 0.2 }
	        ];
	        let reflection = 0;
	        reflections.forEach((ref, index) => {
	            if (Math.abs(time - ref.delay) < 0.001) {
	                // Stereo spread
	                const stereoGain = channel === 0 ?
	                    ref.gain * (1 - index * 0.1) :
	                    ref.gain * (1 + index * 0.1);
	                reflection += (Math.random() * 2 - 1) * stereoGain;
	            }
	        });
	        return reflection;
	    }
	    /**
	     * Generate plate reverb impulse response
	     */
	    generatePlateImpulse(decay, diffusion, duration) {
	        const sampleRate = this._context.sampleRate;
	        const length = Math.floor(sampleRate * duration);
	        const buffer = this._context.createBuffer(2, length, sampleRate);
	        for (let channel = 0; channel < 2; channel++) {
	            const channelData = buffer.getChannelData(channel);
	            for (let i = 0; i < length; i++) {
	                const time = i / sampleRate;
	                const envelope = Math.exp(-time * (1 / decay));
	                // Plate characteristics: metallic resonance
	                const resonance = Math.sin(time * 2000 * Math.PI) * 0.1 * envelope;
	                const noise = (Math.random() * 2 - 1) * envelope * diffusion;
	                channelData[i] = (resonance + noise) * 0.3;
	            }
	        }
	        return buffer;
	    }
	    /**
	     * Generate spring reverb impulse response
	     */
	    generateSpringImpulse(tension, damping, duration) {
	        const sampleRate = this._context.sampleRate;
	        const length = Math.floor(sampleRate * duration);
	        const buffer = this._context.createBuffer(2, length, sampleRate);
	        for (let channel = 0; channel < 2; channel++) {
	            const channelData = buffer.getChannelData(channel);
	            for (let i = 0; i < length; i++) {
	                const time = i / sampleRate;
	                const envelope = Math.exp(-time * (1 / damping));
	                // Spring characteristics: bouncy resonance
	                const spring = Math.sin(time * 150 * tension * Math.PI) * envelope;
	                const flutter = Math.sin(time * 30 * Math.PI) * 0.1 * envelope;
	                channelData[i] = (spring + flutter) * 0.4;
	            }
	        }
	        return buffer;
	    }
	    // Effect management
	    createEffect(name, type, config) {
	        if (this._effects.has(name)) {
	            throw new Error(`Effect '${name}' already exists`);
	        }
	        let effectNode;
	        switch (type) {
	            case 'reverb':
	                effectNode = this.createReverbEffect(config);
	                break;
	            case 'delay':
	                effectNode = this.createDelayEffect(config);
	                break;
	            case 'filter':
	                effectNode = this.createFilterEffect(config);
	                break;
	            case 'distortion':
	                effectNode = this.createDistortionEffect(config);
	                break;
	            case 'compressor':
	                effectNode = this.createCompressorEffect(config);
	                break;
	            case 'limiter':
	                effectNode = this.createLimiterEffect(config);
	                break;
	            case 'chorus':
	                effectNode = this.createChorusEffect(config);
	                break;
	            case 'flanger':
	                effectNode = this.createFlangerEffect(config);
	                break;
	            case 'phaser':
	                effectNode = this.createPhaserEffect(config);
	                break;
	            default:
	                throw new Error(`Unknown effect type: ${type}`);
	        }
	        this._effects.set(name, effectNode);
	        this.emit('effect:created', {
	            name,
	            type,
	            node: effectNode
	        });
	        return effectNode;
	    }
	    /**
	     * Create reverb effect using convolution
	     */
	    createReverbEffect(config) {
	        if (!config.reverb) {
	            throw new Error('Reverb configuration required');
	        }
	        const convolver = this._context.createConvolver();
	        const wetGain = this._context.createGain();
	        const dryGain = this._context.createGain();
	        const mixer = this._context.createGain();
	        // Set wet/dry mix
	        wetGain.gain.value = config.reverb.wetness;
	        dryGain.gain.value = config.reverb.dryness;
	        // Load appropriate impulse response
	        const roomSize = config.reverb.roomSize;
	        let impulseName = 'room';
	        if (roomSize > 0.7)
	            impulseName = 'hall';
	        else if (roomSize > 0.5)
	            impulseName = 'room';
	        else
	            impulseName = 'room';
	        const impulse = this._convolutionBuffers.get(impulseName);
	        if (impulse) {
	            convolver.buffer = impulse;
	        }
	        // Connect wet signal
	        convolver.connect(wetGain);
	        wetGain.connect(mixer);
	        // Dry signal bypasses convolver
	        dryGain.connect(mixer);
	        // Create custom node that handles both wet and dry
	        const reverbNode = this._context.createGain();
	        reverbNode.connect(convolver);
	        reverbNode.connect(dryGain);
	        return mixer;
	    }
	    /**
	     * Create delay effect
	     */
	    createDelayEffect(config) {
	        if (!config.delay) {
	            throw new Error('Delay configuration required');
	        }
	        const delay = this._context.createDelay(1); // Max 1 second
	        const feedback = this._context.createGain();
	        const wetGain = this._context.createGain();
	        const dryGain = this._context.createGain();
	        const mixer = this._context.createGain();
	        // Configure delay
	        delay.delayTime.value = config.delay.delayTime;
	        feedback.gain.value = config.delay.feedback;
	        wetGain.gain.value = config.delay.wetness;
	        dryGain.gain.value = 1 - config.delay.wetness;
	        // Create feedback loop
	        delay.connect(feedback);
	        feedback.connect(delay);
	        // Mix wet and dry signals
	        delay.connect(wetGain);
	        wetGain.connect(mixer);
	        dryGain.connect(mixer);
	        // Input connects to both delay and dry path
	        const inputNode = this._context.createGain();
	        inputNode.connect(delay);
	        inputNode.connect(dryGain);
	        // Return mixer as the effect node
	        mixer._inputNode = inputNode;
	        return mixer;
	    }
	    /**
	     * Create filter effect
	     */
	    createFilterEffect(config) {
	        if (!config.filter) {
	            throw new Error('Filter configuration required');
	        }
	        const filter = this._context.createBiquadFilter();
	        filter.type = config.filter.type;
	        filter.frequency.value = config.filter.frequency;
	        filter.Q.value = config.filter.Q;
	        if (config.filter.gain !== undefined) {
	            filter.gain.value = config.filter.gain;
	        }
	        return filter;
	    }
	    /**
	     * Create distortion effect
	     */
	    createDistortionEffect(config) {
	        if (!config.distortion) {
	            throw new Error('Distortion configuration required');
	        }
	        const waveshaper = this._context.createWaveShaper();
	        waveshaper.curve = this.createDistortionCurve(config.distortion.amount);
	        waveshaper.oversample = config.distortion.oversample;
	        return waveshaper;
	    }
	    /**
	     * Create distortion curve
	     */
	    createDistortionCurve(amount) {
	        const samples = 44100;
	        const curve = new Float32Array(samples);
	        const deg = Math.PI / 180;
	        for (let i = 0; i < samples; i++) {
	            const x = (i * 2) / samples - 1;
	            curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
	        }
	        return curve;
	    }
	    /**
	     * Create compressor effect
	     */
	    createCompressorEffect(config) {
	        if (!config.compressor) {
	            throw new Error('Compressor configuration required');
	        }
	        const compressor = this._context.createDynamicsCompressor();
	        compressor.threshold.value = config.compressor.threshold;
	        compressor.knee.value = config.compressor.knee;
	        compressor.ratio.value = config.compressor.ratio;
	        compressor.attack.value = config.compressor.attack;
	        compressor.release.value = config.compressor.release;
	        return compressor;
	    }
	    /**
	     * Create limiter effect
	     */
	    createLimiterEffect(config) {
	        if (!config.limiter) {
	            throw new Error('Limiter configuration required');
	        }
	        const limiter = this._context.createDynamicsCompressor();
	        limiter.threshold.value = config.limiter.threshold;
	        limiter.knee.value = 0; // Hard knee for limiting
	        limiter.ratio.value = 20; // High ratio for limiting
	        limiter.attack.value = config.limiter.lookAhead;
	        limiter.release.value = config.limiter.release;
	        return limiter;
	    }
	    /**
	     * Create chorus effect
	     */
	    createChorusEffect(config) {
	        const delay1 = this._context.createDelay(0.05);
	        const delay2 = this._context.createDelay(0.05);
	        const lfo1 = this._context.createOscillator();
	        const lfo2 = this._context.createOscillator();
	        const lfoGain1 = this._context.createGain();
	        const lfoGain2 = this._context.createGain();
	        const mixer = this._context.createGain();
	        const dryGain = this._context.createGain();
	        const wetGain = this._context.createGain();
	        // Configure LFOs
	        lfo1.frequency.value = 0.8;
	        lfo2.frequency.value = 1.2;
	        lfoGain1.gain.value = 0.002;
	        lfoGain2.gain.value = 0.003;
	        // Configure delays
	        delay1.delayTime.value = 0.02;
	        delay2.delayTime.value = 0.03;
	        // Connect LFOs to delay times
	        lfo1.connect(lfoGain1);
	        lfo2.connect(lfoGain2);
	        lfoGain1.connect(delay1.delayTime);
	        lfoGain2.connect(delay2.delayTime);
	        // Mix wet and dry
	        wetGain.gain.value = 0.5;
	        dryGain.gain.value = 0.7;
	        delay1.connect(wetGain);
	        delay2.connect(wetGain);
	        wetGain.connect(mixer);
	        dryGain.connect(mixer);
	        // Start LFOs
	        lfo1.start();
	        lfo2.start();
	        // Create input node
	        const inputNode = this._context.createGain();
	        inputNode.connect(delay1);
	        inputNode.connect(delay2);
	        inputNode.connect(dryGain);
	        mixer._inputNode = inputNode;
	        return mixer;
	    }
	    /**
	     * Create flanger effect
	     */
	    createFlangerEffect(config) {
	        const delay = this._context.createDelay(0.02);
	        const lfo = this._context.createOscillator();
	        const lfoGain = this._context.createGain();
	        const feedback = this._context.createGain();
	        const mixer = this._context.createGain();
	        const dryGain = this._context.createGain();
	        const wetGain = this._context.createGain();
	        // Configure LFO for flanging sweep
	        lfo.frequency.value = 0.5;
	        lfoGain.gain.value = 0.005;
	        delay.delayTime.value = 0.005;
	        // Configure feedback and mix
	        feedback.gain.value = 0.6;
	        wetGain.gain.value = 0.5;
	        dryGain.gain.value = 0.7;
	        // Connect LFO to delay time
	        lfo.connect(lfoGain);
	        lfoGain.connect(delay.delayTime);
	        // Create feedback loop
	        delay.connect(feedback);
	        feedback.connect(delay);
	        // Mix signals
	        delay.connect(wetGain);
	        wetGain.connect(mixer);
	        dryGain.connect(mixer);
	        lfo.start();
	        const inputNode = this._context.createGain();
	        inputNode.connect(delay);
	        inputNode.connect(dryGain);
	        mixer._inputNode = inputNode;
	        return mixer;
	    }
	    /**
	     * Create phaser effect
	     */
	    createPhaserEffect(config) {
	        const stages = 4; // Number of all-pass filters
	        const allPasses = [];
	        const lfo = this._context.createOscillator();
	        const lfoGain = this._context.createGain();
	        const mixer = this._context.createGain();
	        const dryGain = this._context.createGain();
	        const wetGain = this._context.createGain();
	        // Create all-pass filters
	        for (let i = 0; i < stages; i++) {
	            const allPass = this._context.createBiquadFilter();
	            allPass.type = 'allpass';
	            allPass.frequency.value = 1000;
	            allPasses.push(allPass);
	        }
	        // Configure LFO
	        lfo.frequency.value = 0.3;
	        lfoGain.gain.value = 800;
	        // Connect LFO to all-pass frequencies
	        lfo.connect(lfoGain);
	        allPasses.forEach(filter => {
	            lfoGain.connect(filter.frequency);
	        });
	        // Chain all-pass filters
	        for (let i = 1; i < stages; i++) {
	            allPasses[i - 1].connect(allPasses[i]);
	        }
	        // Mix wet and dry
	        wetGain.gain.value = 0.5;
	        dryGain.gain.value = 0.7;
	        allPasses[stages - 1].connect(wetGain);
	        wetGain.connect(mixer);
	        dryGain.connect(mixer);
	        lfo.start();
	        const inputNode = this._context.createGain();
	        inputNode.connect(allPasses[0]);
	        inputNode.connect(dryGain);
	        mixer._inputNode = inputNode;
	        return mixer;
	    }
	    connectEffect(name, input, output) {
	        const effect = this._effects.get(name);
	        if (!effect) {
	            throw new Error(`Effect '${name}' not found`);
	        }
	        // Handle effects with custom input nodes
	        const inputNode = effect._inputNode || effect;
	        input.connect(inputNode);
	        effect.connect(output);
	    }
	    disconnectEffect(name) {
	        const effect = this._effects.get(name);
	        if (effect) {
	            effect.disconnect();
	        }
	    }
	    updateEffect(name, config) {
	        const effect = this._effects.get(name);
	        if (!effect) {
	            throw new Error(`Effect '${name}' not found`);
	        }
	        // Update effect parameters based on type
	        this.updateEffectParameters(effect, config);
	        this.emit('effect:updated', {
	            name,
	            config
	        });
	    }
	    /**
	     * Update effect parameters
	     */
	    updateEffectParameters(effect, config) {
	        if (config.filter && 'frequency' in effect) {
	            const filter = effect;
	            if (config.filter.frequency !== undefined) {
	                filter.frequency.value = config.filter.frequency;
	            }
	            if (config.filter.Q !== undefined) {
	                filter.Q.value = config.filter.Q;
	            }
	            if (config.filter.gain !== undefined && 'gain' in filter) {
	                filter.gain.value = config.filter.gain;
	            }
	        }
	        if (config.compressor && 'threshold' in effect) {
	            const compressor = effect;
	            if (config.compressor.threshold !== undefined) {
	                compressor.threshold.value = config.compressor.threshold;
	            }
	            // Update other compressor parameters...
	        }
	        // Add more parameter updates for other effect types...
	    }
	    // Preset management
	    loadPreset(name, config) {
	        this._presets.set(name, config);
	        this.emit('preset:loaded', {
	            name,
	            config
	        });
	    }
	    applyPreset(name, target) {
	        const preset = this._presets.get(name);
	        if (!preset) {
	            throw new Error(`Preset '${name}' not found`);
	        }
	        // Apply preset configuration to target
	        this.updateEffectParameters(target, preset);
	    }
	    savePreset(name, config) {
	        this.loadPreset(name, config);
	        // In a real implementation, you might save to localStorage or server
	        localStorage.setItem(`gamebyte-audio-preset-${name}`, JSON.stringify(config));
	    }
	    // Analysis
	    createAnalyzer(fftSize = 2048) {
	        const analyzer = this._context.createAnalyser();
	        analyzer.fftSize = fftSize;
	        analyzer.smoothingTimeConstant = 0.8;
	        const analyzerId = `analyzer-${Date.now()}`;
	        this._analyzers.set(analyzerId, analyzer);
	        return analyzer;
	    }
	    getFrequencyData(analyzer) {
	        const bufferLength = analyzer.frequencyBinCount;
	        const dataArray = new Uint8Array(bufferLength);
	        analyzer.getByteFrequencyData(dataArray);
	        return dataArray;
	    }
	    getTimeDomainData(analyzer) {
	        const bufferLength = analyzer.frequencyBinCount;
	        const dataArray = new Uint8Array(bufferLength);
	        analyzer.getByteTimeDomainData(dataArray);
	        return dataArray;
	    }
	    /**
	     * Get available effect presets
	     */
	    getAvailablePresets() {
	        return Array.from(this._presets.keys());
	    }
	    /**
	     * Get preset configuration
	     */
	    getPreset(name) {
	        return this._presets.get(name) || null;
	    }
	    /**
	     * Clean up resources
	     */
	    destroy() {
	        // Disconnect all effects
	        this._effects.forEach(effect => effect.disconnect());
	        this._effects.clear();
	        // Disconnect analyzers
	        this._analyzers.forEach(analyzer => analyzer.disconnect());
	        this._analyzers.clear();
	        // Disconnect worklets
	        this._worklets.forEach(worklet => worklet.disconnect());
	        this._worklets.clear();
	        // Clear collections
	        this._presets.clear();
	        this._convolutionBuffers.clear();
	        this._workletProcessorsLoaded.clear();
	        this.removeAllListeners();
	    }
	}

	/**
	 * Noise generation types for procedural audio
	 */
	var NoiseType;
	(function (NoiseType) {
	    NoiseType["WHITE"] = "white";
	    NoiseType["PINK"] = "pink";
	    NoiseType["BROWN"] = "brown";
	    NoiseType["BLUE"] = "blue";
	})(NoiseType || (NoiseType = {}));
	/**
	 * GameByte Procedural Audio Generator
	 *
	 * Features:
	 * - Real-time synthesis of tones, noise, and effects
	 * - Granular synthesis for advanced audio manipulation
	 * - Impulse response generation for reverb effects
	 * - Custom audio worklet processors
	 * - Mathematical audio synthesis functions
	 * - Mobile-optimized performance
	 */
	class GameByteProceduralAudioGenerator extends EventEmitter {
	    constructor(context) {
	        super();
	        this._workletNodes = new Map();
	        this._workletProcessors = new Set();
	        this._context = context;
	        // Generate wavetable lookups for performance
	        this.generateWavetables();
	    }
	    get context() {
	        return this._context;
	    }
	    /**
	     * Initialize the procedural audio generator
	     */
	    async initialize() {
	        try {
	            // Load audio worklet processors
	            await this.loadWorkletProcessors();
	            this.emit('procedural:initialized', {});
	        }
	        catch (error) {
	            console.warn('Some procedural audio features may not be available:', error);
	        }
	    }
	    /**
	     * Generate optimized wavetable lookups
	     */
	    generateWavetables() {
	        const tableSize = 4096;
	        this._sineTable = new Float32Array(tableSize);
	        this._triangleTable = new Float32Array(tableSize);
	        this._sawtoothTable = new Float32Array(tableSize);
	        this._squareTable = new Float32Array(tableSize);
	        for (let i = 0; i < tableSize; i++) {
	            const phase = (i / tableSize) * Math.PI * 2;
	            // Sine wave
	            this._sineTable[i] = Math.sin(phase);
	            // Triangle wave
	            this._triangleTable[i] = Math.asin(Math.sin(phase)) * (2 / Math.PI);
	            // Sawtooth wave
	            this._sawtoothTable[i] = (2 * (i / tableSize)) - 1;
	            // Square wave
	            this._squareTable[i] = Math.sin(phase) >= 0 ? 1 : -1;
	        }
	    }
	    /**
	     * Load audio worklet processors
	     */
	    async loadWorkletProcessors() {
	        const processors = [
	            'granular-processor',
	            'spectral-processor',
	            'fm-synthesizer',
	            'additive-synthesizer'
	        ];
	        for (const processor of processors) {
	            try {
	                // In production, load from actual worklet files
	                // await this._context.audioWorklet.addModule(`/worklets/${processor}.js`);
	                this._workletProcessors.add(processor);
	            }
	            catch (error) {
	                console.warn(`Failed to load worklet processor: ${processor}`, error);
	            }
	        }
	    }
	    // Synthesis methods
	    generateTone(frequency, duration, waveform = 'sine') {
	        const sampleRate = this._context.sampleRate;
	        const length = Math.floor(sampleRate * duration);
	        const buffer = this._context.createBuffer(1, length, sampleRate);
	        const channelData = buffer.getChannelData(0);
	        // Use wavetable lookup for performance
	        const wavetable = this.getWavetable(waveform);
	        const tableSize = wavetable.length;
	        const phaseIncrement = (frequency * tableSize) / sampleRate;
	        let phase = 0;
	        for (let i = 0; i < length; i++) {
	            // Apply envelope to prevent clicks
	            const envelope = this.calculateEnvelope(i, length, duration);
	            // Sample from wavetable with linear interpolation
	            const index = phase % tableSize;
	            const lowerIndex = Math.floor(index);
	            const upperIndex = (lowerIndex + 1) % tableSize;
	            const fraction = index - lowerIndex;
	            const sample = wavetable[lowerIndex] * (1 - fraction) + wavetable[upperIndex] * fraction;
	            channelData[i] = sample * envelope;
	            phase += phaseIncrement;
	        }
	        return buffer;
	    }
	    /**
	     * Get wavetable for specified waveform
	     */
	    getWavetable(waveform) {
	        switch (waveform) {
	            case 'sine': return this._sineTable;
	            case 'triangle': return this._triangleTable;
	            case 'sawtooth': return this._sawtoothTable;
	            case 'square': return this._squareTable;
	            default: return this._sineTable;
	        }
	    }
	    /**
	     * Calculate envelope for smooth tone generation
	     */
	    calculateEnvelope(sample, totalSamples, duration) {
	        const fadeTime = Math.min(0.05, duration * 0.1); // 5% fade or 50ms max
	        const fadeSamples = fadeTime * this._context.sampleRate;
	        if (sample < fadeSamples) {
	            // Fade in
	            return sample / fadeSamples;
	        }
	        else if (sample > totalSamples - fadeSamples) {
	            // Fade out
	            return (totalSamples - sample) / fadeSamples;
	        }
	        else {
	            // Sustain
	            return 1.0;
	        }
	    }
	    generateNoise(duration, type = NoiseType.WHITE) {
	        const sampleRate = this._context.sampleRate;
	        const length = Math.floor(sampleRate * duration);
	        const buffer = this._context.createBuffer(1, length, sampleRate);
	        const channelData = buffer.getChannelData(0);
	        switch (type) {
	            case NoiseType.WHITE:
	                this.generateWhiteNoise(channelData);
	                break;
	            case NoiseType.PINK:
	                this.generatePinkNoise(channelData);
	                break;
	            case NoiseType.BROWN:
	                this.generateBrownNoise(channelData);
	                break;
	            case NoiseType.BLUE:
	                this.generateBlueNoise(channelData);
	                break;
	        }
	        return buffer;
	    }
	    /**
	     * Generate white noise
	     */
	    generateWhiteNoise(channelData) {
	        for (let i = 0; i < channelData.length; i++) {
	            channelData[i] = Math.random() * 2 - 1;
	        }
	    }
	    /**
	     * Generate pink noise (1/f noise)
	     */
	    generatePinkNoise(channelData) {
	        let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
	        for (let i = 0; i < channelData.length; i++) {
	            const white = Math.random() * 2 - 1;
	            b0 = 0.99886 * b0 + white * 0.0555179;
	            b1 = 0.99332 * b1 + white * 0.0750759;
	            b2 = 0.96900 * b2 + white * 0.1538520;
	            b3 = 0.86650 * b3 + white * 0.3104856;
	            b4 = 0.55000 * b4 + white * 0.5329522;
	            b5 = -0.7616 * b5 - white * 0.0168980;
	            const pink = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
	            b6 = white * 0.115926;
	            channelData[i] = pink * 0.11;
	        }
	    }
	    /**
	     * Generate brown noise (Brownian noise)
	     */
	    generateBrownNoise(channelData) {
	        let lastOut = 0;
	        for (let i = 0; i < channelData.length; i++) {
	            const white = Math.random() * 2 - 1;
	            lastOut = (lastOut + (0.02 * white)) / 1.02;
	            channelData[i] = lastOut * 3.5; // Compensate for volume reduction
	        }
	    }
	    /**
	     * Generate blue noise (high-frequency emphasis)
	     */
	    generateBlueNoise(channelData) {
	        let lastOut = 0;
	        for (let i = 0; i < channelData.length; i++) {
	            const white = Math.random() * 2 - 1;
	            const blue = white - lastOut;
	            lastOut = white;
	            channelData[i] = blue * 0.5;
	        }
	    }
	    generateChirp(startFreq, endFreq, duration) {
	        const sampleRate = this._context.sampleRate;
	        const length = Math.floor(sampleRate * duration);
	        const buffer = this._context.createBuffer(1, length, sampleRate);
	        const channelData = buffer.getChannelData(0);
	        let phase = 0;
	        for (let i = 0; i < length; i++) {
	            const t = i / sampleRate;
	            const progress = t / duration;
	            // Linear frequency sweep
	            const frequency = startFreq + (endFreq - startFreq) * progress;
	            // Calculate phase increment
	            const phaseIncrement = (frequency * 2 * Math.PI) / sampleRate;
	            phase += phaseIncrement;
	            // Apply envelope
	            const envelope = this.calculateEnvelope(i, length, duration);
	            channelData[i] = Math.sin(phase) * envelope;
	        }
	        return buffer;
	    }
	    // Effects generation
	    generateReverb(roomSize, decay) {
	        const duration = Math.max(1, decay * 4); // Reverb tail duration
	        const sampleRate = this._context.sampleRate;
	        const length = Math.floor(sampleRate * duration);
	        const buffer = this._context.createBuffer(2, length, sampleRate);
	        // Generate stereo reverb impulse response
	        for (let channel = 0; channel < 2; channel++) {
	            const channelData = buffer.getChannelData(channel);
	            // Generate early reflections
	            this.generateEarlyReflections(channelData, roomSize, channel);
	            // Generate late reverb tail
	            this.generateReverbTail(channelData, decay, roomSize, channel);
	        }
	        return buffer;
	    }
	    /**
	     * Generate early reflections for reverb
	     */
	    generateEarlyReflections(channelData, roomSize, channel) {
	        const reflections = this.calculateReflectionTimes(roomSize);
	        const sampleRate = this._context.sampleRate;
	        reflections.forEach((reflection, index) => {
	            const delaySamples = Math.floor(reflection.delay * sampleRate);
	            const gain = reflection.gain * (channel === 0 ? reflection.leftGain : reflection.rightGain);
	            if (delaySamples < channelData.length) {
	                // Add impulse at reflection time
	                channelData[delaySamples] += gain;
	                // Add some dispersion around the reflection
	                for (let j = 1; j <= 5; j++) {
	                    if (delaySamples + j < channelData.length) {
	                        channelData[delaySamples + j] += gain * 0.1 * Math.random();
	                    }
	                    if (delaySamples - j >= 0) {
	                        channelData[delaySamples - j] += gain * 0.1 * Math.random();
	                    }
	                }
	            }
	        });
	    }
	    /**
	     * Calculate reflection times based on room size
	     */
	    calculateReflectionTimes(roomSize) {
	        const reflections = [];
	        const baseDelay = 0.01 * roomSize;
	        // Generate early reflections with varying delays and stereo positioning
	        for (let i = 0; i < 8; i++) {
	            reflections.push({
	                delay: baseDelay * (1 + i * 0.3 + Math.random() * 0.2),
	                gain: 0.8 / (i + 1),
	                leftGain: 0.5 + Math.random() * 0.5,
	                rightGain: 0.5 + Math.random() * 0.5
	            });
	        }
	        return reflections;
	    }
	    /**
	     * Generate reverb tail (late reflections)
	     */
	    generateReverbTail(channelData, decay, roomSize, channel) {
	        const sampleRate = this._context.sampleRate;
	        const startSample = Math.floor(0.05 * sampleRate); // Start after early reflections
	        for (let i = startSample; i < channelData.length; i++) {
	            const time = i / sampleRate;
	            const envelope = Math.exp(-time / decay);
	            const sample = (Math.random() * 2 - 1) * envelope * 0.1;
	            // Add frequency-dependent decay
	            const highFreqDecay = Math.exp(-time / (decay * 0.3));
	            const filteredSample = sample * (0.7 + 0.3 * highFreqDecay);
	            channelData[i] += filteredSample;
	        }
	    }
	    generateDelay(delayTime, feedback, duration) {
	        const sampleRate = this._context.sampleRate;
	        const length = Math.floor(sampleRate * duration);
	        const buffer = this._context.createBuffer(1, length, sampleRate);
	        const channelData = buffer.getChannelData(0);
	        const delaySamples = Math.floor(delayTime * sampleRate);
	        // Generate impulse with delay feedback
	        channelData[0] = 1.0; // Initial impulse
	        let currentFeedback = feedback;
	        let delayIndex = delaySamples;
	        while (delayIndex < length && currentFeedback > 0.001) {
	            channelData[delayIndex] += currentFeedback;
	            currentFeedback *= feedback;
	            delayIndex += delaySamples;
	        }
	        return buffer;
	    }
	    // Granular synthesis
	    createGranularProcessor(grainSize, overlap) {
	        if (!this._workletProcessors.has('granular-processor')) {
	            throw new Error('Granular processor not available');
	        }
	        try {
	            const workletNode = new AudioWorkletNode(this._context, 'granular-processor', {
	                processorOptions: {
	                    grainSize,
	                    overlap
	                }
	            });
	            const nodeId = `granular-${Date.now()}`;
	            this._workletNodes.set(nodeId, workletNode);
	            return workletNode;
	        }
	        catch (error) {
	            // Fallback to non-worklet implementation
	            console.warn('AudioWorklet not supported, using fallback granular synthesis');
	            return this.createFallbackGranularProcessor(grainSize, overlap);
	        }
	    }
	    /**
	     * Create fallback granular processor using ScriptProcessorNode
	     */
	    createFallbackGranularProcessor(grainSize, overlap) {
	        // This would be a fallback implementation using ScriptProcessorNode
	        // For brevity, returning a mock worklet node
	        const mockNode = this._context.createGain();
	        mockNode.grainSize = grainSize;
	        mockNode.overlap = overlap;
	        return mockNode;
	    }
	    processGranular(buffer, config) {
	        const sampleRate = this._context.sampleRate;
	        const grainSizeSamples = Math.floor((config.grainSize / 1000) * sampleRate);
	        const hopSizeSamples = Math.floor(grainSizeSamples * (1 - config.overlap));
	        // Calculate output buffer size based on time stretch
	        const outputLength = Math.floor(buffer.length * config.timeStretch);
	        const outputBuffer = this._context.createBuffer(buffer.numberOfChannels, outputLength, sampleRate);
	        // Process each channel
	        for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
	            const inputData = buffer.getChannelData(channel);
	            const outputData = outputBuffer.getChannelData(channel);
	            this.processGranularChannel(inputData, outputData, config, grainSizeSamples, hopSizeSamples);
	        }
	        return outputBuffer;
	    }
	    /**
	     * Process granular synthesis for a single channel
	     */
	    processGranularChannel(inputData, outputData, config, grainSizeSamples, hopSizeSamples) {
	        const grainEnvelope = this.generateGrainEnvelope(grainSizeSamples, config.envelope);
	        let outputPos = 0;
	        let inputPos = config.position * inputData.length;
	        while (outputPos < outputData.length - grainSizeSamples) {
	            // Add position randomization
	            const randomOffset = (Math.random() - 0.5) * config.positionRandom * inputData.length;
	            const grainStartPos = Math.floor(inputPos + randomOffset);
	            // Copy and process grain
	            for (let i = 0; i < grainSizeSamples && outputPos + i < outputData.length; i++) {
	                const inputIndex = (grainStartPos + Math.floor(i / config.pitch)) % inputData.length;
	                const sample = inputData[Math.max(0, Math.min(inputIndex, inputData.length - 1))];
	                outputData[outputPos + i] += sample * grainEnvelope[i];
	            }
	            // Advance positions
	            outputPos += hopSizeSamples;
	            inputPos += hopSizeSamples / config.timeStretch;
	            if (inputPos >= inputData.length) {
	                inputPos = 0; // Loop back to beginning
	            }
	        }
	    }
	    /**
	     * Generate grain envelope
	     */
	    generateGrainEnvelope(size, type) {
	        const envelope = new Float32Array(size);
	        switch (type) {
	            case 'hann':
	                for (let i = 0; i < size; i++) {
	                    envelope[i] = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (size - 1)));
	                }
	                break;
	            case 'gaussian':
	                const sigma = size / 6; // Standard deviation
	                const center = size / 2;
	                for (let i = 0; i < size; i++) {
	                    const x = i - center;
	                    envelope[i] = Math.exp(-(x * x) / (2 * sigma * sigma));
	                }
	                break;
	            case 'linear':
	                const half = size / 2;
	                for (let i = 0; i < size; i++) {
	                    envelope[i] = i < half ? i / half : (size - i) / half;
	                }
	                break;
	        }
	        return envelope;
	    }
	    // Real-time processing
	    createRealTimeProcessor(processor) {
	        try {
	            // In production, this would create a custom AudioWorkletNode
	            const mockNode = this._context.createGain();
	            mockNode.processor = processor;
	            return mockNode;
	        }
	        catch (error) {
	            throw new Error('Real-time processor creation failed');
	        }
	    }
	    addRealTimeEffect(name, processor) {
	        this._workletNodes.set(name, processor);
	        this.emit('realtime-effect:added', {
	            name,
	            processor
	        });
	    }
	    removeRealTimeEffect(name) {
	        const processor = this._workletNodes.get(name);
	        if (processor) {
	            processor.disconnect();
	            this._workletNodes.delete(name);
	            this.emit('realtime-effect:removed', {
	                name
	            });
	        }
	    }
	    /**
	     * Generate complex waveforms using additive synthesis
	     */
	    generateAdditiveWaveform(fundamentalFreq, harmonics, duration) {
	        const sampleRate = this._context.sampleRate;
	        const length = Math.floor(sampleRate * duration);
	        const buffer = this._context.createBuffer(1, length, sampleRate);
	        const channelData = buffer.getChannelData(0);
	        for (let i = 0; i < length; i++) {
	            const t = i / sampleRate;
	            let sample = 0;
	            // Add fundamental frequency
	            sample += Math.sin(2 * Math.PI * fundamentalFreq * t);
	            // Add harmonics
	            harmonics.forEach(harmonic => {
	                sample += harmonic.amplitude * Math.sin(2 * Math.PI * harmonic.frequency * t + harmonic.phase);
	            });
	            // Apply envelope
	            const envelope = this.calculateEnvelope(i, length, duration);
	            channelData[i] = sample * envelope * 0.1; // Scale down to prevent clipping
	        }
	        return buffer;
	    }
	    /**
	     * Generate frequency modulated (FM) synthesis
	     */
	    generateFMSynthesis(carrierFreq, modulatorFreq, modulationIndex, duration) {
	        const sampleRate = this._context.sampleRate;
	        const length = Math.floor(sampleRate * duration);
	        const buffer = this._context.createBuffer(1, length, sampleRate);
	        const channelData = buffer.getChannelData(0);
	        for (let i = 0; i < length; i++) {
	            const t = i / sampleRate;
	            // FM synthesis: carrier modulated by modulator
	            const modulator = Math.sin(2 * Math.PI * modulatorFreq * t);
	            const carrier = Math.sin(2 * Math.PI * carrierFreq * t + modulationIndex * modulator);
	            // Apply envelope
	            const envelope = this.calculateEnvelope(i, length, duration);
	            channelData[i] = carrier * envelope;
	        }
	        return buffer;
	    }
	    /**
	     * Clean up resources
	     */
	    destroy() {
	        // Disconnect all worklet nodes
	        this._workletNodes.forEach(node => node.disconnect());
	        this._workletNodes.clear();
	        // Clear processor registry
	        this._workletProcessors.clear();
	        this.removeAllListeners();
	    }
	}

	/**
	 * GameByte Audio Bus - Audio mixing and routing system
	 *
	 * Features:
	 * - Volume and mute control
	 * - Solo functionality
	 * - Audio effects processing
	 * - Send/return system
	 * - Real-time audio analysis
	 * - Source management
	 */
	class GameByteAudioBus extends EventEmitter {
	    constructor(context, config, masterGain) {
	        super();
	        this._effectNodes = new Map();
	        // Send/return system
	        this._sendGains = new Map();
	        // Bus state
	        this._volume = 1.0;
	        this._muted = false;
	        this._solo = false;
	        this._sources = new Set();
	        // Performance monitoring
	        this._rmsLevel = 0;
	        this._peakLevel = 0;
	        this._analysisInterval = null;
	        this._name = config.name;
	        this._type = config.type;
	        this._context = context;
	        this._masterGain = masterGain;
	        this._volume = config.volume;
	        this._muted = config.muted;
	        this._solo = config.solo;
	        this.createAudioNodes();
	        this.connectAudioNodes();
	        this.startAnalysis();
	        // Apply initial effects if provided
	        if (config.effects) {
	            Object.entries(config.effects).forEach(([name, effectConfig]) => {
	                this.addEffect(name, { [name]: effectConfig });
	            });
	        }
	        // Setup initial sends if provided
	        if (config.sends) {
	            config.sends.forEach(send => {
	                this.addSend(send.bus, send.amount);
	            });
	        }
	    }
	    get name() {
	        return this._name;
	    }
	    get type() {
	        return this._type;
	    }
	    get sources() {
	        return new Set(this._sources);
	    }
	    /**
	     * Create audio processing nodes
	     */
	    createAudioNodes() {
	        // Input gain for sources
	        this._inputGain = this._context.createGain();
	        this._inputGain.gain.value = 1.0;
	        // Mute control
	        this._muteGain = this._context.createGain();
	        this._muteGain.gain.value = this._muted ? 0 : 1;
	        // Solo control
	        this._soloGain = this._context.createGain();
	        this._soloGain.gain.value = this._solo ? 1 : 1; // Solo is handled at mixer level
	        // Output gain for volume control
	        this._outputGain = this._context.createGain();
	        this._outputGain.gain.value = this._volume;
	        // Analyzer for level monitoring
	        this._analyserNode = this._context.createAnalyser();
	        this._analyserNode.fftSize = 256;
	        this._analyserNode.smoothingTimeConstant = 0.8;
	    }
	    /**
	     * Connect audio nodes in processing chain
	     */
	    connectAudioNodes() {
	        let currentNode = this._inputGain;
	        // Connect effects chain
	        this._effectNodes.forEach(effectNode => {
	            currentNode.connect(effectNode);
	            currentNode = effectNode;
	        });
	        // Connect control chain
	        currentNode.connect(this._muteGain);
	        this._muteGain.connect(this._soloGain);
	        this._soloGain.connect(this._outputGain);
	        // Connect to analyzer and master output
	        this._outputGain.connect(this._analyserNode);
	        this._analyserNode.connect(this._masterGain);
	        // Connect sends
	        this._sendGains.forEach(sendGain => {
	            this._outputGain.connect(sendGain);
	        });
	    }
	    /**
	     * Disconnect all audio nodes
	     */
	    disconnectAudioNodes() {
	        this._inputGain.disconnect();
	        this._muteGain.disconnect();
	        this._soloGain.disconnect();
	        this._outputGain.disconnect();
	        this._analyserNode.disconnect();
	        this._effectNodes.forEach(node => node.disconnect());
	        this._sendGains.forEach(sendGain => sendGain.disconnect());
	    }
	    /**
	     * Start real-time audio analysis
	     */
	    startAnalysis() {
	        if (this._analysisInterval) {
	            clearInterval(this._analysisInterval);
	        }
	        this._analysisInterval = window.setInterval(() => {
	            this.updateAnalysis();
	        }, 100); // Update 10 times per second
	    }
	    /**
	     * Update audio level analysis
	     */
	    updateAnalysis() {
	        const bufferLength = this._analyserNode.frequencyBinCount;
	        const dataArray = new Uint8Array(bufferLength);
	        this._analyserNode.getByteFrequencyData(dataArray);
	        // Calculate RMS level
	        let sum = 0;
	        for (let i = 0; i < bufferLength; i++) {
	            sum += dataArray[i] * dataArray[i];
	        }
	        this._rmsLevel = Math.sqrt(sum / bufferLength) / 255;
	        // Calculate peak level
	        let peak = 0;
	        for (let i = 0; i < bufferLength; i++) {
	            peak = Math.max(peak, dataArray[i]);
	        }
	        this._peakLevel = peak / 255;
	    }
	    // Volume control
	    setVolume(volume, fadeTime = 0) {
	        const clampedVolume = Math.max(0, Math.min(2, volume)); // Allow up to 200% volume
	        this._volume = clampedVolume;
	        if (fadeTime > 0) {
	            this._outputGain.gain.exponentialRampToValueAtTime(Math.max(0.001, clampedVolume), this._context.currentTime + fadeTime);
	        }
	        else {
	            this._outputGain.gain.value = clampedVolume;
	        }
	        this.emit('audio:volume-change', {
	            source: null,
	            volume: clampedVolume
	        });
	    }
	    getVolume() {
	        return this._volume;
	    }
	    setMuted(muted) {
	        this._muted = muted;
	        this._muteGain.gain.value = muted ? 0 : 1;
	        this.emit('audio:mute-change', {
	            bus: this._name,
	            muted
	        });
	    }
	    isMuted() {
	        return this._muted;
	    }
	    setSolo(solo) {
	        this._solo = solo;
	        // Solo handling is typically managed at the mixer level
	        // This just tracks the solo state for the bus
	        this.emit('audio:solo-change', {
	            bus: this._name,
	            solo
	        });
	    }
	    isSolo() {
	        return this._solo;
	    }
	    // Source management
	    addSource(source) {
	        if (this._sources.has(source)) {
	            return;
	        }
	        this._sources.add(source);
	        // Connect source to bus input
	        // Cast to implementation type to access connectToNode method
	        const sourceImpl = source;
	        if (typeof sourceImpl.connectToNode === 'function') {
	            sourceImpl.connectToNode(this._inputGain);
	        }
	        this.emit('source:added', {
	            bus: this._name,
	            source
	        });
	    }
	    removeSource(source) {
	        if (!this._sources.has(source)) {
	            return;
	        }
	        this._sources.delete(source);
	        // Disconnect source from bus and reconnect to master
	        const sourceImpl = source;
	        if (typeof sourceImpl.reconnectToMaster === 'function') {
	            sourceImpl.reconnectToMaster();
	        }
	        this.emit('source:removed', {
	            bus: this._name,
	            source
	        });
	    }
	    removeAllSources() {
	        const sources = Array.from(this._sources);
	        sources.forEach(source => this.removeSource(source));
	    }
	    // Effects processing
	    addEffect(name, config) {
	        // Remove existing effect if it exists
	        this.removeEffect(name);
	        const effectNode = this.createEffectNode(config);
	        if (effectNode) {
	            this._effectNodes.set(name, effectNode);
	            // Reconnect audio chain with new effect
	            this.disconnectAudioNodes();
	            this.connectAudioNodes();
	            this.emit('effect:added', {
	                bus: this._name,
	                effect: name
	            });
	        }
	    }
	    removeEffect(name) {
	        const effectNode = this._effectNodes.get(name);
	        if (effectNode) {
	            effectNode.disconnect();
	            this._effectNodes.delete(name);
	            // Reconnect audio chain without removed effect
	            this.disconnectAudioNodes();
	            this.connectAudioNodes();
	            this.emit('effect:removed', {
	                bus: this._name,
	                effect: name
	            });
	        }
	    }
	    updateEffect(name, config) {
	        const effectNode = this._effectNodes.get(name);
	        if (effectNode) {
	            this.updateEffectNode(effectNode, config);
	            this.emit('effect:updated', {
	                bus: this._name,
	                effect: name
	            });
	        }
	    }
	    /**
	     * Create effect node based on configuration
	     */
	    createEffectNode(config) {
	        if (config.reverb) {
	            // Create reverb using convolution
	            const convolver = this._context.createConvolver();
	            // Note: Would need impulse response buffer for realistic reverb
	            return convolver;
	        }
	        if (config.delay) {
	            const delay = this._context.createDelay(1);
	            const feedback = this._context.createGain();
	            const wetGain = this._context.createGain();
	            const dryGain = this._context.createGain();
	            delay.delayTime.value = config.delay.delayTime;
	            feedback.gain.value = config.delay.feedback;
	            wetGain.gain.value = config.delay.wetness;
	            dryGain.gain.value = 1 - config.delay.wetness;
	            // Create delay feedback loop
	            delay.connect(feedback);
	            feedback.connect(delay);
	            // Create wet/dry mix
	            const mixer = this._context.createGain();
	            delay.connect(wetGain);
	            wetGain.connect(mixer);
	            dryGain.connect(mixer);
	            return delay;
	        }
	        if (config.filter) {
	            const filter = this._context.createBiquadFilter();
	            filter.type = config.filter.type;
	            filter.frequency.value = config.filter.frequency;
	            filter.Q.value = config.filter.Q;
	            if (config.filter.gain !== undefined) {
	                filter.gain.value = config.filter.gain;
	            }
	            return filter;
	        }
	        if (config.compressor) {
	            const compressor = this._context.createDynamicsCompressor();
	            compressor.threshold.value = config.compressor.threshold;
	            compressor.knee.value = config.compressor.knee;
	            compressor.ratio.value = config.compressor.ratio;
	            compressor.attack.value = config.compressor.attack;
	            compressor.release.value = config.compressor.release;
	            return compressor;
	        }
	        if (config.distortion) {
	            const waveshaper = this._context.createWaveShaper();
	            waveshaper.curve = this.createDistortionCurve(config.distortion.amount);
	            waveshaper.oversample = config.distortion.oversample;
	            return waveshaper;
	        }
	        return null;
	    }
	    /**
	     * Update effect node parameters
	     */
	    updateEffectNode(node, config) {
	        if (config.filter && 'frequency' in node) {
	            const filter = node;
	            if (config.filter.frequency !== undefined) {
	                filter.frequency.value = config.filter.frequency;
	            }
	            if (config.filter.Q !== undefined) {
	                filter.Q.value = config.filter.Q;
	            }
	            if (config.filter.gain !== undefined && 'gain' in filter) {
	                filter.gain.value = config.filter.gain;
	            }
	        }
	        if (config.delay && 'delayTime' in node) {
	            const delay = node;
	            if (config.delay.delayTime !== undefined) {
	                delay.delayTime.value = config.delay.delayTime;
	            }
	        }
	        if (config.compressor && 'threshold' in node) {
	            const compressor = node;
	            if (config.compressor.threshold !== undefined) {
	                compressor.threshold.value = config.compressor.threshold;
	            }
	            if (config.compressor.knee !== undefined) {
	                compressor.knee.value = config.compressor.knee;
	            }
	            if (config.compressor.ratio !== undefined) {
	                compressor.ratio.value = config.compressor.ratio;
	            }
	            if (config.compressor.attack !== undefined) {
	                compressor.attack.value = config.compressor.attack;
	            }
	            if (config.compressor.release !== undefined) {
	                compressor.release.value = config.compressor.release;
	            }
	        }
	    }
	    /**
	     * Create distortion curve for waveshaper
	     */
	    createDistortionCurve(amount) {
	        const samples = 44100;
	        const curve = new Float32Array(samples);
	        const deg = Math.PI / 180;
	        for (let i = 0; i < samples; i++) {
	            const x = (i * 2) / samples - 1;
	            curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
	        }
	        return curve;
	    }
	    // Send/return system
	    addSend(targetBus, amount) {
	        if (this._sendGains.has(targetBus)) {
	            this.updateSend(targetBus, amount);
	            return;
	        }
	        const sendGain = this._context.createGain();
	        sendGain.gain.value = Math.max(0, Math.min(1, amount));
	        this._sendGains.set(targetBus, sendGain);
	        // Connect send to output (would need reference to target bus)
	        this._outputGain.connect(sendGain);
	        this.emit('send:added', {
	            bus: this._name,
	            targetBus,
	            amount
	        });
	    }
	    removeSend(targetBus) {
	        const sendGain = this._sendGains.get(targetBus);
	        if (sendGain) {
	            sendGain.disconnect();
	            this._sendGains.delete(targetBus);
	            this.emit('send:removed', {
	                bus: this._name,
	                targetBus
	            });
	        }
	    }
	    updateSend(targetBus, amount) {
	        const sendGain = this._sendGains.get(targetBus);
	        if (sendGain) {
	            sendGain.gain.value = Math.max(0, Math.min(1, amount));
	            this.emit('send:updated', {
	                bus: this._name,
	                targetBus,
	                amount
	            });
	        }
	    }
	    // Analysis
	    getAnalyzer() {
	        return this._analyserNode;
	    }
	    getRMSLevel() {
	        return this._rmsLevel;
	    }
	    getPeakLevel() {
	        return this._peakLevel;
	    }
	    /**
	     * Get frequency data for visualization
	     */
	    getFrequencyData() {
	        const bufferLength = this._analyserNode.frequencyBinCount;
	        const dataArray = new Uint8Array(bufferLength);
	        this._analyserNode.getByteFrequencyData(dataArray);
	        return dataArray;
	    }
	    /**
	     * Get time domain data for waveform visualization
	     */
	    getTimeDomainData() {
	        const bufferLength = this._analyserNode.frequencyBinCount;
	        const dataArray = new Uint8Array(bufferLength);
	        this._analyserNode.getByteTimeDomainData(dataArray);
	        return dataArray;
	    }
	    /**
	     * Get input gain node for connecting sources
	     */
	    getInputNode() {
	        return this._inputGain;
	    }
	    /**
	     * Get output gain node for connecting to other buses or master
	     */
	    getOutputNode() {
	        return this._outputGain;
	    }
	    /**
	     * Clean up resources
	     */
	    destroy() {
	        // Stop analysis
	        if (this._analysisInterval) {
	            clearInterval(this._analysisInterval);
	            this._analysisInterval = null;
	        }
	        // Remove all sources
	        this.removeAllSources();
	        // Disconnect all nodes
	        this.disconnectAudioNodes();
	        // Clear collections
	        this._effectNodes.clear();
	        this._sendGains.clear();
	        this._sources.clear();
	        this.removeAllListeners();
	    }
	}

	/**
	 * Default mobile audio configuration
	 */
	const DEFAULT_MOBILE_CONFIG = {
	    batteryOptimization: true,
	    backgroundAudio: false,
	    interruptionHandling: true,
	    hardwareAcceleration: true,
	    adaptiveQuality: true,
	    maxConcurrentSounds: 32,
	    memoryLimit: 64, // 64MB
	    cpuLimit: 15 // 15% CPU usage limit
	};
	/**
	 * GameByte Audio Manager - Professional audio system for mobile games
	 *
	 * Features:
	 * - High-performance Web Audio API integration
	 * - Mobile-optimized audio processing
	 * - Comprehensive mixing system with buses
	 * - Spatial 3D audio with HRTF support
	 * - Adaptive music system
	 * - Battery and performance optimization
	 * - Analytics and player preference tracking
	 */
	class GameByteAudioManager extends EventEmitter {
	    constructor(config = {}) {
	        super();
	        this._context = null;
	        this._isInitialized = false;
	        this._performanceTier = exports.AudioPerformanceTier.MEDIUM;
	        this._buses = new Map();
	        this._loadedAudio = new Map();
	        this._performanceMonitorInterval = null;
	        // Master controls
	        this._masterVolume = 1.0;
	        this._masterMuted = false;
	        this._masterGain = null;
	        this._masterLimiter = null;
	        this._config = { ...DEFAULT_MOBILE_CONFIG, ...config };
	        // Initialize performance metrics
	        this._performanceMetrics = {
	            cpuUsage: 0,
	            memoryUsage: 0,
	            latency: 0,
	            activeSources: 0,
	            droppedFrames: 0,
	            contextState: 'suspended',
	            thermalState: 'nominal'
	        };
	        // Will be initialized in initialize() method
	        this._musicSystem = null;
	        this._sfxSystem = null;
	        this._spatialAudioSystem = null;
	        this._mobileManager = null;
	        this._analyticsSystem = null;
	        this._effectsProcessor = null;
	        this._proceduralGenerator = null;
	    }
	    get context() {
	        if (!this._context) {
	            throw new Error('AudioManager not initialized. Call initialize() first.');
	        }
	        return this._context;
	    }
	    get isInitialized() {
	        return this._isInitialized;
	    }
	    get performanceTier() {
	        return this._performanceTier;
	    }
	    get buses() {
	        return new Map(this._buses);
	    }
	    /**
	     * Initialize the audio system
	     */
	    async initialize(config = {}) {
	        if (this._isInitialized) {
	            return;
	        }
	        try {
	            // Update configuration
	            this._config = { ...this._config, ...config };
	            // Create audio context with mobile-optimized settings
	            await this.createAudioContext();
	            // Detect device performance tier
	            this._performanceTier = this.detectPerformanceTier();
	            // Create master audio chain
	            this.createMasterChain();
	            // Initialize subsystems
	            await this.initializeSubsystems();
	            // Create default audio buses
	            this.createDefaultBuses();
	            // Start performance monitoring
	            this.startPerformanceMonitoring();
	            // Handle iOS audio unlock
	            this.setupAudioUnlock();
	            this._isInitialized = true;
	            this.emit('audio:initialized', { manager: this });
	        }
	        catch (error) {
	            this.emit('audio:error', { source: null, error: error });
	            throw error;
	        }
	    }
	    /**
	     * Create and configure audio context
	     */
	    async createAudioContext() {
	        const AudioContextClass = window.AudioContext || window.webkitAudioContext;
	        if (!AudioContextClass) {
	            throw new Error('Web Audio API not supported');
	        }
	        // Create context with optimized settings
	        this._context = new AudioContextClass({
	            latencyHint: 'interactive',
	            sampleRate: this.getOptimalSampleRate()
	        });
	        // Update performance metrics
	        this._performanceMetrics.contextState = this._context.state;
	        this._performanceMetrics.latency = this._context.baseLatency || 0;
	        // Don't resume here - let setupAudioUnlock() handle it on user interaction
	        // This follows Web Audio API best practice: create context early but resume after user gesture
	    }
	    /**
	     * Get optimal sample rate based on device capabilities
	     */
	    getOptimalSampleRate() {
	        // Check if device supports high sample rates
	        const highQuality = this._config.adaptiveQuality &&
	            this._performanceTier === exports.AudioPerformanceTier.PREMIUM;
	        return highQuality ? 48000 : 44100;
	    }
	    /**
	     * Detect device performance tier using centralized DeviceDetector
	     */
	    detectPerformanceTier() {
	        if (!this._context)
	            return exports.AudioPerformanceTier.LOW;
	        const maxChannels = this._context.destination.maxChannelCount;
	        const sampleRate = this._context.sampleRate;
	        const baseLatency = this._context.baseLatency || 0;
	        // Use centralized DeviceDetector for hardware capabilities
	        const cpuCores = DeviceDetector.getCoreCount();
	        const memory = DeviceDetector.getDeviceMemory();
	        // Performance tier calculation
	        let score = 0;
	        // Audio context capabilities
	        if (maxChannels >= 8)
	            score += 3;
	        else if (maxChannels >= 6)
	            score += 2;
	        else if (maxChannels >= 2)
	            score += 1;
	        if (sampleRate >= 48000)
	            score += 2;
	        else if (sampleRate >= 44100)
	            score += 1;
	        if (baseLatency < 0.02)
	            score += 2; // < 20ms
	        else if (baseLatency < 0.05)
	            score += 1; // < 50ms
	        // Hardware capabilities
	        if (cpuCores >= 8)
	            score += 3;
	        else if (cpuCores >= 4)
	            score += 2;
	        else if (cpuCores >= 2)
	            score += 1;
	        if (memory >= 8)
	            score += 3;
	        else if (memory >= 4)
	            score += 2;
	        else if (memory >= 2)
	            score += 1;
	        // Determine tier
	        if (score >= 12)
	            return exports.AudioPerformanceTier.PREMIUM;
	        if (score >= 8)
	            return exports.AudioPerformanceTier.HIGH;
	        if (score >= 4)
	            return exports.AudioPerformanceTier.MEDIUM;
	        return exports.AudioPerformanceTier.LOW;
	    }
	    /**
	     * Create master audio processing chain
	     */
	    createMasterChain() {
	        if (!this._context)
	            return;
	        // Master gain node
	        this._masterGain = this._context.createGain();
	        this._masterGain.gain.value = this._masterVolume;
	        // Master limiter for preventing clipping
	        this._masterLimiter = this._context.createDynamicsCompressor();
	        this._masterLimiter.threshold.value = -3; // dB
	        this._masterLimiter.knee.value = 12;
	        this._masterLimiter.ratio.value = 20;
	        this._masterLimiter.attack.value = 0.003;
	        this._masterLimiter.release.value = 0.1;
	        // Connect master chain
	        this._masterGain.connect(this._masterLimiter);
	        this._masterLimiter.connect(this._context.destination);
	    }
	    /**
	     * Initialize audio subsystems
	     */
	    async initializeSubsystems() {
	        if (!this._context)
	            return;
	        // Initialize effects processor first (other systems depend on it)
	        this._effectsProcessor = new GameByteAudioEffectsProcessor(this._context);
	        await this._effectsProcessor.initialize(this._context);
	        // Initialize mobile manager
	        this._mobileManager = new GameByteMobileAudioManager(this._config, this);
	        await this._mobileManager.initialize(this);
	        // Initialize analytics system
	        this._analyticsSystem = new GameByteAudioAnalytics();
	        // Initialize spatial audio system
	        this._spatialAudioSystem = new GameByteSpatialAudioSystem(this._context, this._effectsProcessor);
	        await this._spatialAudioSystem.initialize(this._context);
	        // Initialize music system
	        this._musicSystem = new GameByteMusicSystem(this._context, this);
	        await this._musicSystem.initialize(this._context);
	        // Initialize SFX system
	        this._sfxSystem = new GameByteSFXSystem(this._context, this);
	        await this._sfxSystem.initialize(this._context);
	        // Initialize procedural audio generator
	        this._proceduralGenerator = new GameByteProceduralAudioGenerator(this._context);
	        await this._proceduralGenerator.initialize(this._context);
	    }
	    /**
	     * Create default audio buses
	     */
	    createDefaultBuses() {
	        // Master bus
	        this.createBus({
	            name: 'master',
	            type: exports.AudioBusType.MASTER,
	            volume: 1.0,
	            muted: false,
	            solo: false
	        });
	        // Music bus
	        this.createBus({
	            name: 'music',
	            type: exports.AudioBusType.MUSIC,
	            volume: 0.8,
	            muted: false,
	            solo: false
	        });
	        // SFX bus
	        this.createBus({
	            name: 'sfx',
	            type: exports.AudioBusType.SFX,
	            volume: 1.0,
	            muted: false,
	            solo: false
	        });
	        // Voice bus
	        this.createBus({
	            name: 'voice',
	            type: exports.AudioBusType.VOICE,
	            volume: 1.0,
	            muted: false,
	            solo: false
	        });
	        // UI bus
	        this.createBus({
	            name: 'ui',
	            type: exports.AudioBusType.UI,
	            volume: 0.7,
	            muted: false,
	            solo: false
	        });
	        // Ambient bus
	        this.createBus({
	            name: 'ambient',
	            type: exports.AudioBusType.AMBIENT,
	            volume: 0.6,
	            muted: false,
	            solo: false
	        });
	    }
	    /**
	     * Setup audio unlock for iOS devices
	     */
	    setupAudioUnlock() {
	        if (!this._context)
	            return;
	        const unlockAudio = async () => {
	            if (this._context && this._context.state === 'suspended') {
	                try {
	                    await this._context.resume();
	                    this._performanceMetrics.contextState = this._context.state;
	                    // Remove event listeners after successful unlock
	                    document.removeEventListener('touchstart', unlockAudio);
	                    document.removeEventListener('touchend', unlockAudio);
	                    document.removeEventListener('click', unlockAudio);
	                    document.removeEventListener('keydown', unlockAudio);
	                    this.emit('audio:unlocked', {});
	                }
	                catch (error) {
	                    console.warn('Failed to unlock audio context:', error);
	                }
	            }
	        };
	        // Add event listeners for user interaction
	        document.addEventListener('touchstart', unlockAudio, { passive: true });
	        document.addEventListener('touchend', unlockAudio, { passive: true });
	        document.addEventListener('click', unlockAudio);
	        document.addEventListener('keydown', unlockAudio);
	    }
	    /**
	     * Start performance monitoring
	     */
	    startPerformanceMonitoring() {
	        if (this._performanceMonitorInterval) {
	            clearInterval(this._performanceMonitorInterval);
	        }
	        this._performanceMonitorInterval = window.setInterval(() => {
	            this.updatePerformanceMetrics();
	        }, 1000); // Update every second
	    }
	    /**
	     * Update performance metrics
	     */
	    updatePerformanceMetrics() {
	        if (!this._context)
	            return;
	        // Update context state
	        this._performanceMetrics.contextState = this._context.state;
	        // Count active sources
	        this._performanceMetrics.activeSources = this._loadedAudio.size;
	        // Estimate memory usage (approximate)
	        let memoryUsage = 0;
	        this._loadedAudio.forEach(source => {
	            if (source.buffer) {
	                memoryUsage += source.buffer.length * source.buffer.numberOfChannels * 4; // Float32 = 4 bytes
	            }
	        });
	        this._performanceMetrics.memoryUsage = memoryUsage / (1024 * 1024); // Convert to MB
	        // Check for performance warnings
	        this.checkPerformanceWarnings();
	        // Adapt to performance if enabled
	        if (this._config.adaptiveQuality) {
	            this.adaptToPerformance();
	        }
	    }
	    /**
	     * Check for performance warnings
	     */
	    checkPerformanceWarnings() {
	        const metrics = this._performanceMetrics;
	        // Memory usage warning
	        if (metrics.memoryUsage > this._config.memoryLimit * 0.8) {
	            this.emit('audio:performance-warning', {
	                metric: 'memory',
	                value: metrics.memoryUsage,
	                threshold: this._config.memoryLimit * 0.8
	            });
	        }
	        // Active sources warning
	        if (metrics.activeSources > this._config.maxConcurrentSounds * 0.8) {
	            this.emit('audio:performance-warning', {
	                metric: 'sources',
	                value: metrics.activeSources,
	                threshold: this._config.maxConcurrentSounds * 0.8
	            });
	        }
	    }
	    // System access methods
	    getMusicSystem() {
	        return this._musicSystem;
	    }
	    getSFXSystem() {
	        return this._sfxSystem;
	    }
	    getSpatialAudioSystem() {
	        return this._spatialAudioSystem;
	    }
	    getMobileManager() {
	        return this._mobileManager;
	    }
	    getAnalyticsSystem() {
	        return this._analyticsSystem;
	    }
	    getEffectsProcessor() {
	        return this._effectsProcessor;
	    }
	    getProceduralGenerator() {
	        return this._proceduralGenerator;
	    }
	    // Bus management
	    createBus(config) {
	        if (this._buses.has(config.name)) {
	            throw new Error(`Audio bus '${config.name}' already exists`);
	        }
	        const bus = new GameByteAudioBus(this._context, config, this._masterGain);
	        this._buses.set(config.name, bus);
	        return bus;
	    }
	    getBus(name) {
	        return this._buses.get(name) || null;
	    }
	    removeBus(name) {
	        const bus = this._buses.get(name);
	        if (bus) {
	            // Remove all sources from bus
	            bus.removeAllSources();
	            this._buses.delete(name);
	        }
	    }
	    getMasterBus() {
	        const masterBus = this._buses.get('master');
	        if (!masterBus) {
	            throw new Error('Master bus not found');
	        }
	        return masterBus;
	    }
	    // Global controls
	    setMasterVolume(volume, fadeTime = 0) {
	        this._masterVolume = Math.max(0, Math.min(1, volume));
	        if (this._masterGain) {
	            if (fadeTime > 0) {
	                this._masterGain.gain.exponentialRampToValueAtTime(this._masterVolume, this._context.currentTime + fadeTime);
	            }
	            else {
	                this._masterGain.gain.value = this._masterVolume;
	            }
	        }
	        this.emit('audio:volume-change', {
	            source: null,
	            volume: this._masterVolume
	        });
	    }
	    getMasterVolume() {
	        return this._masterVolume;
	    }
	    setMasterMuted(muted) {
	        this._masterMuted = muted;
	        if (this._masterGain) {
	            this._masterGain.gain.value = muted ? 0 : this._masterVolume;
	        }
	    }
	    isMasterMuted() {
	        return this._masterMuted;
	    }
	    // Performance methods
	    getPerformanceMetrics() {
	        return { ...this._performanceMetrics };
	    }
	    optimizeForDevice() {
	        // Adjust settings based on performance tier
	        switch (this._performanceTier) {
	            case exports.AudioPerformanceTier.LOW:
	                this._config.maxConcurrentSounds = Math.min(this._config.maxConcurrentSounds, 16);
	                this._config.memoryLimit = Math.min(this._config.memoryLimit, 32);
	                break;
	            case exports.AudioPerformanceTier.MEDIUM:
	                this._config.maxConcurrentSounds = Math.min(this._config.maxConcurrentSounds, 32);
	                this._config.memoryLimit = Math.min(this._config.memoryLimit, 64);
	                break;
	            case exports.AudioPerformanceTier.HIGH:
	                this._config.maxConcurrentSounds = Math.min(this._config.maxConcurrentSounds, 64);
	                this._config.memoryLimit = Math.min(this._config.memoryLimit, 128);
	                break;
	            case exports.AudioPerformanceTier.PREMIUM:
	                // No limits for premium devices
	                break;
	        }
	        // Apply optimizations to subsystems
	        if (this._mobileManager) {
	            this._mobileManager.optimizeForDevice();
	        }
	    }
	    adaptToPerformance() {
	        const metrics = this._performanceMetrics;
	        // Reduce quality if memory usage is high
	        if (metrics.memoryUsage > this._config.memoryLimit * 0.9) {
	            // Stop least important sounds
	            this._sfxSystem?.stopLowPrioritySounds();
	        }
	        // Reduce concurrent sounds if CPU usage is high
	        if (metrics.cpuUsage > this._config.cpuLimit * 0.9) {
	            this._config.maxConcurrentSounds = Math.max(8, this._config.maxConcurrentSounds - 4);
	        }
	    }
	    // Asset management
	    async loadAudio(name, url, options = {}) {
	        if (this._loadedAudio.has(name)) {
	            return this._loadedAudio.get(name);
	        }
	        try {
	            const response = await fetch(url);
	            const arrayBuffer = await response.arrayBuffer();
	            const audioBuffer = await this._context.decodeAudioData(arrayBuffer);
	            const source = new GameByteAudioSource(name, audioBuffer, this._context, this._masterGain, options);
	            this._loadedAudio.set(name, source);
	            this.emit('audio:loaded', { source });
	            return source;
	        }
	        catch (error) {
	            this.emit('audio:error', { source: null, error: error });
	            throw error;
	        }
	    }
	    async preloadAudio(urls) {
	        const loadPromises = urls.map(({ name, url, options }) => this.loadAudio(name, url, options));
	        await Promise.all(loadPromises);
	    }
	    unloadAudio(name) {
	        const source = this._loadedAudio.get(name);
	        if (source) {
	            source.destroy();
	            this._loadedAudio.delete(name);
	        }
	    }
	    getLoadedAudio(name) {
	        return this._loadedAudio.get(name) || null;
	    }
	    /**
	     * Destroy the audio system and clean up resources
	     */
	    destroy() {
	        // Stop performance monitoring
	        if (this._performanceMonitorInterval) {
	            clearInterval(this._performanceMonitorInterval);
	            this._performanceMonitorInterval = null;
	        }
	        // Destroy all audio sources
	        this._loadedAudio.forEach(source => source.destroy());
	        this._loadedAudio.clear();
	        // Destroy all buses
	        this._buses.forEach(bus => {
	            if ('destroy' in bus && typeof bus.destroy === 'function') {
	                bus.destroy();
	            }
	        });
	        this._buses.clear();
	        // Destroy subsystems
	        if (this._musicSystem && 'destroy' in this._musicSystem) {
	            this._musicSystem.destroy();
	        }
	        if (this._sfxSystem && 'destroy' in this._sfxSystem) {
	            this._sfxSystem.destroy();
	        }
	        if (this._spatialAudioSystem && 'destroy' in this._spatialAudioSystem) {
	            this._spatialAudioSystem.destroy();
	        }
	        if (this._mobileManager && 'destroy' in this._mobileManager) {
	            this._mobileManager.destroy();
	        }
	        if (this._analyticsSystem && 'destroy' in this._analyticsSystem) {
	            this._analyticsSystem.destroy();
	        }
	        if (this._effectsProcessor && 'destroy' in this._effectsProcessor) {
	            this._effectsProcessor.destroy();
	        }
	        if (this._proceduralGenerator && 'destroy' in this._proceduralGenerator) {
	            this._proceduralGenerator.destroy();
	        }
	        // Close audio context
	        if (this._context && this._context.close) {
	            this._context.close();
	            this._context = null;
	        }
	        // Clean up master nodes
	        this._masterGain = null;
	        this._masterLimiter = null;
	        this._isInitialized = false;
	        this.removeAllListeners();
	        this.emit('audio:destroyed', {});
	    }
	}

	/**
	 * Audio Service Provider for GameByte Framework
	 *
	 * Registers and bootstraps the comprehensive audio system including:
	 * - Main audio manager with mobile optimization
	 * - Music system with adaptive layers
	 * - Sound effects system with pooling
	 * - Spatial 3D audio system
	 * - Mobile-specific optimizations
	 * - Audio analytics and performance monitoring
	 * - Procedural audio generation
	 * - Audio effects processing
	 */
	class AudioServiceProvider extends AbstractServiceProvider {
	    constructor() {
	        super(...arguments);
	        this.audioManager = null;
	    }
	    /**
	     * Register audio services in the container
	     */
	    register(app) {
	        // Register audio manager as singleton
	        app.singleton('audio.manager', () => {
	            // Get mobile configuration from app if available
	            const mobileConfig = this.getMobileAudioConfig(app);
	            this.audioManager = new GameByteAudioManager(mobileConfig);
	            return this.audioManager;
	        });
	        // Register audio manager with alias
	        app.bind('audio', () => app.make('audio.manager'));
	        // Register individual audio subsystems for direct access
	        app.bind('audio.music', () => {
	            const audioManager = app.make('audio.manager');
	            return audioManager.getMusicSystem();
	        });
	        app.bind('audio.sfx', () => {
	            const audioManager = app.make('audio.manager');
	            return audioManager.getSFXSystem();
	        });
	        app.bind('audio.spatial', () => {
	            const audioManager = app.make('audio.manager');
	            return audioManager.getSpatialAudioSystem();
	        });
	        app.bind('audio.effects', () => {
	            const audioManager = app.make('audio.manager');
	            return audioManager.getEffectsProcessor();
	        });
	        app.bind('audio.mobile', () => {
	            const audioManager = app.make('audio.manager');
	            return audioManager.getMobileManager();
	        });
	        app.bind('audio.analytics', () => {
	            const audioManager = app.make('audio.manager');
	            return audioManager.getAnalyticsSystem();
	        });
	        app.bind('audio.procedural', () => {
	            const audioManager = app.make('audio.manager');
	            return audioManager.getProceduralGenerator();
	        });
	    }
	    /**
	     * Bootstrap audio services after all providers are registered
	     */
	    async boot(app) {
	        try {
	            // Initialize the audio manager
	            const audioManager = app.make('audio.manager');
	            await audioManager.initialize();
	            // Setup framework event integration
	            this.setupFrameworkIntegration(app, audioManager);
	            // Setup performance integration
	            this.setupPerformanceIntegration(app, audioManager);
	            // Setup scene integration
	            this.setupSceneIntegration(app, audioManager);
	            // Optimize for detected device
	            audioManager.optimizeForDevice();
	            console.log(`GameByte Audio System initialized (Performance Tier: ${audioManager.performanceTier})`);
	        }
	        catch (error) {
	            console.error('Failed to initialize GameByte Audio System:', error);
	            throw error;
	        }
	    }
	    /**
	     * Get mobile audio configuration based on detected device.
	     * Uses centralized DeviceConfigurations for tier-based settings.
	     */
	    getMobileAudioConfig(app) {
	        // Try to get performance manager for device detection
	        let performanceTier = exports.AudioPerformanceTier.MEDIUM;
	        try {
	            if (app.getContainer().bound('performance.manager')) {
	                const performanceManager = app.make('performance.manager');
	                if (performanceManager && performanceManager.getDeviceCapabilities) {
	                    const capabilities = performanceManager.getDeviceCapabilities();
	                    performanceTier = mapToAudioPerformanceTier(capabilities.tier);
	                }
	            }
	        }
	        catch {
	            // Performance manager not available, use defaults
	        }
	        // Get tier-based configuration from centralized config
	        const tierConfig = getAudioConfigForTier(performanceTier);
	        // Base mobile-specific config
	        const baseConfig = {
	            batteryOptimization: true,
	            interruptionHandling: true,
	        };
	        return {
	            ...baseConfig,
	            maxConcurrentSounds: tierConfig.maxConcurrentSounds,
	            memoryLimit: tierConfig.memoryLimit,
	            cpuLimit: tierConfig.cpuLimit,
	            backgroundAudio: tierConfig.backgroundAudio,
	            adaptiveQuality: tierConfig.adaptiveQuality,
	            hardwareAcceleration: tierConfig.hardwareAcceleration,
	        };
	    }
	    /**
	     * Setup integration with framework events
	     */
	    setupFrameworkIntegration(app, audioManager) {
	        // Listen to framework lifecycle events
	        app.on('started', () => {
	            // Start audio analytics session when game starts
	            const analytics = audioManager.getAnalyticsSystem();
	            analytics.startSession();
	        });
	        app.on('stopped', () => {
	            // End audio analytics session when game stops
	            const analytics = audioManager.getAnalyticsSystem();
	            analytics.endSession();
	        });
	        app.on('destroyed', () => {
	            // Cleanup audio system when framework is destroyed
	            audioManager.destroy();
	        });
	        // Handle app state changes for mobile
	        if (typeof document !== 'undefined') {
	            document.addEventListener('visibilitychange', () => {
	                const mobileManager = audioManager.getMobileManager();
	                const state = document.hidden ? 'background' : 'active';
	                mobileManager.handleAppStateChange(state);
	            });
	        }
	    }
	    /**
	     * Setup integration with performance system
	     */
	    setupPerformanceIntegration(app, audioManager) {
	        try {
	            if (app.getContainer().bound('performance.manager')) {
	                const performanceManager = app.make('performance.manager');
	                if (performanceManager && performanceManager.on) {
	                    // Listen to performance warnings
	                    performanceManager.on('performance:warning', (data) => {
	                        if (data.metric === 'memory' || data.metric === 'cpu') {
	                            // Adapt audio quality when performance issues detected
	                            audioManager.adaptToPerformance();
	                        }
	                    });
	                    // Listen to device thermal state changes
	                    performanceManager.on('thermal:state-changed', (data) => {
	                        const mobileManager = audioManager.getMobileManager();
	                        if (data.state === 'serious' || data.state === 'critical') {
	                            // Enable aggressive optimization for thermal throttling
	                            mobileManager.setThermalThrottling(true);
	                        }
	                    });
	                }
	                // Share audio performance metrics with performance manager
	                audioManager.on('audio:performance-warning', (data) => {
	                    if (performanceManager && performanceManager.reportWarning) {
	                        performanceManager.reportWarning({
	                            system: 'audio',
	                            metric: data.metric,
	                            value: data.value,
	                            threshold: data.threshold
	                        });
	                    }
	                });
	            }
	        }
	        catch (error) {
	            // Performance integration not available, continue without it
	            console.warn('Audio-Performance integration not available:', error);
	        }
	    }
	    /**
	     * Setup integration with scene system
	     */
	    setupSceneIntegration(app, audioManager) {
	        try {
	            if (app.getContainer().bound('scene.manager')) {
	                const sceneManager = app.make('scene.manager');
	                if (sceneManager && sceneManager.on) {
	                    // Handle scene transitions
	                    sceneManager.on('scene:will-change', (data) => {
	                        // Fade out current music before scene change
	                        const musicSystem = audioManager.getMusicSystem();
	                        if (musicSystem.isPlaying) {
	                            // Quick fade out for scene transitions
	                            musicSystem.stopTrack(0.5);
	                        }
	                    });
	                    sceneManager.on('scene:changed', (fromScene, toScene) => {
	                        // Update spatial audio listener based on scene camera
	                        const spatialAudio = audioManager.getSpatialAudioSystem();
	                        // Reset audio zones for new scene
	                        spatialAudio.zones.forEach((zone, name) => {
	                            spatialAudio.removeZone(name);
	                        });
	                        // Scene-specific audio setup could be triggered here
	                        // Example: Load scene-specific audio assets
	                        // Note: scene:changed passes (fromScene, toScene) as separate params
	                        if (toScene && toScene.name) {
	                            this.loadSceneAudio(audioManager, toScene.name);
	                        }
	                    });
	                }
	            }
	        }
	        catch (error) {
	            console.warn('Audio-Scene integration not available:', error);
	        }
	    }
	    /**
	     * Load scene-specific audio assets
	     */
	    async loadSceneAudio(audioManager, sceneName) {
	        // Define scene-specific audio assets
	        const sceneAudioAssets = {
	            'main-menu': [
	                { name: 'menu-music', url: '/audio/music/menu-theme.mp3' },
	                { name: 'menu-click', url: '/audio/sfx/ui-click.mp3' },
	                { name: 'menu-hover', url: '/audio/sfx/ui-hover.mp3' }
	            ],
	            'gameplay': [
	                { name: 'game-music', url: '/audio/music/gameplay-theme.mp3' },
	                { name: 'jump-sound', url: '/audio/sfx/jump.mp3' },
	                { name: 'collect-sound', url: '/audio/sfx/collect.mp3' },
	                { name: 'ambient-forest', url: '/audio/ambient/forest.mp3' }
	            ],
	            'battle': [
	                { name: 'battle-music', url: '/audio/music/battle-theme.mp3' },
	                { name: 'sword-clash', url: '/audio/sfx/sword-clash.mp3' },
	                { name: 'magic-cast', url: '/audio/sfx/magic-cast.mp3' }
	            ]
	        };
	        const assets = sceneAudioAssets[sceneName];
	        if (assets) {
	            try {
	                // Preload scene-specific audio assets
	                await audioManager.preloadAudio(assets);
	                // Setup default music for scene
	                const musicSystem = audioManager.getMusicSystem();
	                const musicAsset = assets.find(asset => asset.name.includes('music'));
	                if (musicAsset) {
	                    // Load and configure scene music
	                    await musicSystem.loadTrack(sceneName, musicAsset.url, {
	                        loop: { enabled: true, seamless: true },
	                        crossfade: { enabled: true, duration: 1.0, curve: exports.AudioFadeType.LINEAR }
	                    });
	                    // Start playing scene music with fade in
	                    await musicSystem.playTrack(sceneName, 1.0);
	                }
	            }
	            catch (error) {
	                console.warn(`Failed to load audio assets for scene '${sceneName}':`, error);
	            }
	        }
	    }
	    /**
	     * Services provided by this provider
	     */
	    provides() {
	        return [
	            'audio.manager',
	            'audio',
	            'audio.music',
	            'audio.sfx',
	            'audio.spatial',
	            'audio.effects',
	            'audio.mobile',
	            'audio.analytics',
	            'audio.procedural'
	        ];
	    }
	    /**
	     * Get the audio manager instance
	     */
	    getAudioManager() {
	        return this.audioManager;
	    }
	    /**
	     * Create default audio buses configuration
	     */
	    static getDefaultBusConfiguration() {
	        return [
	            {
	                name: 'master',
	                type: exports.AudioBusType.MASTER,
	                volume: 1.0,
	                muted: false,
	                solo: false
	            },
	            {
	                name: 'music',
	                type: exports.AudioBusType.MUSIC,
	                volume: 0.8,
	                muted: false,
	                solo: false,
	                effects: {
	                    compressor: {
	                        threshold: -18,
	                        knee: 12,
	                        ratio: 4,
	                        attack: 0.01,
	                        release: 0.1
	                    }
	                }
	            },
	            {
	                name: 'sfx',
	                type: exports.AudioBusType.SFX,
	                volume: 1.0,
	                muted: false,
	                solo: false,
	                effects: {
	                    limiter: {
	                        threshold: -3,
	                        lookAhead: 0.005,
	                        release: 0.1
	                    }
	                }
	            },
	            {
	                name: 'voice',
	                type: exports.AudioBusType.VOICE,
	                volume: 1.0,
	                muted: false,
	                solo: false,
	                effects: {
	                    compressor: {
	                        threshold: -12,
	                        knee: 6,
	                        ratio: 6,
	                        attack: 0.005,
	                        release: 0.05
	                    },
	                    filter: {
	                        type: 'highpass',
	                        frequency: 80,
	                        Q: 1
	                    }
	                }
	            },
	            {
	                name: 'ui',
	                type: exports.AudioBusType.UI,
	                volume: 0.7,
	                muted: false,
	                solo: false
	            },
	            {
	                name: 'ambient',
	                type: exports.AudioBusType.AMBIENT,
	                volume: 0.6,
	                muted: false,
	                solo: false,
	                effects: {
	                    filter: {
	                        type: 'lowpass',
	                        frequency: 8000,
	                        Q: 1
	                    }
	                }
	            }
	        ];
	    }
	}

	/**
	 * Static Audio Facade for GameByte Framework
	 *
	 * Provides convenient static access to the audio system without needing
	 * to resolve services from the container manually.
	 *
	 * Usage:
	 * ```typescript
	 * import { Audio } from 'gamebyte-framework';
	 *
	 * // Play background music
	 * await Audio.music.playTrack('main-theme');
	 *
	 * // Play sound effect
	 * await Audio.sfx.play('jump-sound', { volume: 0.8 });
	 *
	 * // Set master volume
	 * Audio.setMasterVolume(0.7);
	 *
	 * // Create spatial audio source
	 * const spatialSound = await Audio.spatial.createSource('footsteps', { x: 10, y: 0, z: 5 });
	 * ```
	 */
	class Audio extends Facade {
	    /**
	     * Get the audio manager service name
	     */
	    static getFacadeAccessor() {
	        return 'audio.manager';
	    }
	    /**
	     * Get the audio manager instance
	     */
	    static getManager() {
	        return this.resolve();
	    }
	    // === CORE AUDIO MANAGEMENT ===
	    /**
	     * Initialize the audio system with optional configuration
	     */
	    static async initialize(config) {
	        return this.getManager().initialize(config);
	    }
	    /**
	     * Check if audio system is initialized
	     */
	    static isInitialized() {
	        return this.getManager().isInitialized;
	    }
	    /**
	     * Get current performance tier
	     */
	    static getPerformanceTier() {
	        return this.getManager().performanceTier;
	    }
	    /**
	     * Get performance metrics
	     */
	    static getPerformanceMetrics() {
	        return this.getManager().getPerformanceMetrics();
	    }
	    // === MASTER CONTROLS ===
	    /**
	     * Set master volume (0.0 to 1.0)
	     */
	    static setMasterVolume(volume, fadeTime = 0) {
	        this.getManager().setMasterVolume(volume, fadeTime);
	    }
	    /**
	     * Get master volume
	     */
	    static getMasterVolume() {
	        return this.getManager().getMasterVolume();
	    }
	    /**
	     * Mute or unmute all audio
	     */
	    static setMasterMuted(muted) {
	        this.getManager().setMasterMuted(muted);
	    }
	    /**
	     * Check if master audio is muted
	     */
	    static isMasterMuted() {
	        return this.getManager().isMasterMuted();
	    }
	    // === ASSET MANAGEMENT ===
	    /**
	     * Load an audio asset
	     */
	    static async loadAudio(name, url, options) {
	        return this.getManager().loadAudio(name, url, options);
	    }
	    /**
	     * Preload multiple audio assets
	     */
	    static async preloadAudio(urls) {
	        return this.getManager().preloadAudio(urls);
	    }
	    /**
	     * Unload an audio asset
	     */
	    static unloadAudio(name) {
	        this.getManager().unloadAudio(name);
	    }
	    /**
	     * Get a loaded audio asset
	     */
	    static getLoadedAudio(name) {
	        return this.getManager().getLoadedAudio(name);
	    }
	    // === BUS MANAGEMENT ===
	    /**
	     * Create an audio bus
	     */
	    static createBus(config) {
	        return this.getManager().createBus(config);
	    }
	    /**
	     * Get an audio bus by name
	     */
	    static getBus(name) {
	        return this.getManager().getBus(name);
	    }
	    /**
	     * Remove an audio bus
	     */
	    static removeBus(name) {
	        this.getManager().removeBus(name);
	    }
	    /**
	     * Get the master bus
	     */
	    static getMasterBus() {
	        return this.getManager().getMasterBus();
	    }
	    // === MUSIC SYSTEM ACCESS ===
	    /**
	     * Access to the music system
	     */
	    static get music() {
	        return new MusicSystemFacade(this.getManager().getMusicSystem());
	    }
	    // === SFX SYSTEM ACCESS ===
	    /**
	     * Access to the SFX system
	     */
	    static get sfx() {
	        return new SFXSystemFacade(this.getManager().getSFXSystem());
	    }
	    // === SPATIAL AUDIO ACCESS ===
	    /**
	     * Access to the spatial audio system
	     */
	    static get spatial() {
	        return new SpatialAudioFacade(this.getManager().getSpatialAudioSystem());
	    }
	    // === EFFECTS PROCESSOR ACCESS ===
	    /**
	     * Access to the effects processor
	     */
	    static get effects() {
	        return this.getManager().getEffectsProcessor();
	    }
	    // === MOBILE MANAGER ACCESS ===
	    /**
	     * Access to the mobile audio manager
	     */
	    static get mobile() {
	        return this.getManager().getMobileManager();
	    }
	    // === ANALYTICS ACCESS ===
	    /**
	     * Access to the analytics system
	     */
	    static get analytics() {
	        return this.getManager().getAnalyticsSystem();
	    }
	    // === PROCEDURAL AUDIO ACCESS ===
	    /**
	     * Access to the procedural audio generator
	     */
	    static get procedural() {
	        return this.getManager().getProceduralGenerator();
	    }
	    // === UTILITY METHODS ===
	    /**
	     * Optimize audio system for current device
	     */
	    static optimizeForDevice() {
	        this.getManager().optimizeForDevice();
	    }
	    /**
	     * Adapt audio system to current performance
	     */
	    static adaptToPerformance() {
	        this.getManager().adaptToPerformance();
	    }
	    /**
	     * Destroy the audio system
	     */
	    static destroy() {
	        this.getManager().destroy();
	    }
	}
	/**
	 * Music System Facade
	 */
	class MusicSystemFacade {
	    constructor(musicSystem) {
	        this.musicSystem = musicSystem;
	    }
	    /**
	     * Load a music track
	     */
	    async loadTrack(name, url, config) {
	        return this.musicSystem.loadTrack(name, url, config);
	    }
	    /**
	     * Play a music track
	     */
	    async playTrack(name, fadeTime) {
	        return this.musicSystem.playTrack(name, fadeTime);
	    }
	    /**
	     * Stop current track
	     */
	    async stopTrack(fadeTime) {
	        return this.musicSystem.stopTrack(fadeTime);
	    }
	    /**
	     * Pause current track
	     */
	    pauseTrack() {
	        this.musicSystem.pauseTrack();
	    }
	    /**
	     * Resume current track
	     */
	    resumeTrack() {
	        this.musicSystem.resumeTrack();
	    }
	    /**
	     * Crossfade to another track
	     */
	    async crossfadeTo(track, duration) {
	        return this.musicSystem.crossfadeTo(track, duration);
	    }
	    /**
	     * Enable a music layer
	     */
	    enableLayer(layer, fadeTime) {
	        this.musicSystem.enableLayer(layer, fadeTime);
	    }
	    /**
	     * Disable a music layer
	     */
	    disableLayer(layer, fadeTime) {
	        this.musicSystem.disableLayer(layer, fadeTime);
	    }
	    /**
	     * Set adaptive music parameter
	     */
	    setParameter(name, value) {
	        this.musicSystem.setParameter(name, value);
	    }
	    /**
	     * Get current track name
	     */
	    get currentTrack() {
	        return this.musicSystem.currentTrack;
	    }
	    /**
	     * Check if music is playing
	     */
	    get isPlaying() {
	        return this.musicSystem.isPlaying;
	    }
	}
	/**
	 * SFX System Facade
	 */
	class SFXSystemFacade {
	    constructor(sfxSystem) {
	        this.sfxSystem = sfxSystem;
	    }
	    /**
	     * Play a sound effect
	     */
	    async play(name, options) {
	        return this.sfxSystem.play(name, options);
	    }
	    /**
	     * Preload sound effects
	     */
	    async preload(sounds) {
	        return this.sfxSystem.preload(sounds);
	    }
	    /**
	     * Set pool size for a sound
	     */
	    setPoolSize(sound, size) {
	        this.sfxSystem.setPoolSize(sound, size);
	    }
	    /**
	     * Warm up the SFX system
	     */
	    warmUp() {
	        this.sfxSystem.warmUp();
	    }
	    /**
	     * Add sound variations
	     */
	    addVariation(baseName, variations) {
	        this.sfxSystem.addVariation(baseName, variations);
	    }
	    /**
	     * Play sound variation
	     */
	    async playVariation(baseName, options) {
	        return this.sfxSystem.playVariation(baseName, options);
	    }
	    /**
	     * Set sound priority
	     */
	    setPriority(sound, priority) {
	        this.sfxSystem.setPriority(sound, priority);
	    }
	    /**
	     * Set maximum concurrent instances
	     */
	    setMaxConcurrent(sound, max) {
	        this.sfxSystem.setMaxConcurrent(sound, max);
	    }
	}
	/**
	 * Spatial Audio System Facade
	 */
	class SpatialAudioFacade {
	    constructor(spatialSystem) {
	        this.spatialSystem = spatialSystem;
	    }
	    /**
	     * Set listener position
	     */
	    setListenerPosition(position) {
	        this.spatialSystem.setListenerPosition(position);
	    }
	    /**
	     * Get listener position
	     */
	    getListenerPosition() {
	        return this.spatialSystem.getListenerPosition();
	    }
	    /**
	     * Create an audio zone
	     */
	    createZone(config) {
	        return this.spatialSystem.createZone(config);
	    }
	    /**
	     * Remove an audio zone
	     */
	    removeZone(name) {
	        this.spatialSystem.removeZone(name);
	    }
	    /**
	     * Get an audio zone
	     */
	    getZone(name) {
	        return this.spatialSystem.getZone(name);
	    }
	    /**
	     * Update audio zones based on listener position
	     */
	    updateZones(listenerPosition) {
	        this.spatialSystem.updateZones(listenerPosition);
	    }
	    /**
	     * Enable or disable HRTF
	     */
	    enableHRTF(enabled) {
	        this.spatialSystem.enableHRTF(enabled);
	    }
	    /**
	     * Check if HRTF is enabled
	     */
	    isHRTFEnabled() {
	        return this.spatialSystem.isHRTFEnabled();
	    }
	    /**
	     * Set global audio environment
	     */
	    setGlobalEnvironment(environment) {
	        this.spatialSystem.setGlobalEnvironment(environment);
	    }
	    /**
	     * Get current zones
	     */
	    get zones() {
	        return this.spatialSystem.zones;
	    }
	}

	/**
	 * Service provider for rendering services.
	 * NOTE: GraphicsEngine initialization is handled by GameByte.initialize() directly
	 * to avoid race conditions and ensure consistent initialization order.
	 */
	class RenderingServiceProvider extends AbstractServiceProvider {
	    /**
	     * Register rendering services in the container.
	     */
	    register(app) {
	        // Register renderer factory
	        app.singleton('renderer.factory', () => RendererFactory);
	        // Register renderer (lazy-loaded)
	        app.bind('renderer', () => {
	            // Default to 2D rendering mode
	            const mode = exports.RenderingMode.RENDERER_2D;
	            return RendererFactory.create(mode);
	        }, true);
	        // Register renderer modes
	        app.bind('renderer.modes', () => ({
	            RENDERER_2D: exports.RenderingMode.RENDERER_2D,
	            RENDERER_3D: exports.RenderingMode.RENDERER_3D,
	            HYBRID: exports.RenderingMode.HYBRID
	        }));
	        // Helper method to create specific renderer
	        app.bind('renderer.create', () => (mode) => {
	            return RendererFactory.create(mode);
	        });
	        // Helper method to create renderer with fallback
	        app.bind('renderer.createWithFallback', () => (preferredMode, fallbackMode) => {
	            return RendererFactory.createWithFallback(preferredMode, fallbackMode);
	        });
	    }
	    /**
	     * Bootstrap rendering services.
	     */
	    boot(app) {
	        const container = app.getContainer();
	        // Register renderer event listeners if needed
	        if (container.bound('renderer')) {
	            const renderer = app.make('renderer');
	            renderer.on('error', (error) => {
	                app.emit('renderer:error', error);
	            });
	            renderer.on('resize', (width, height) => {
	                app.emit('renderer:resize', width, height);
	            });
	        }
	    }
	    /**
	     * Services provided by this provider.
	     */
	    provides() {
	        return [
	            'renderer',
	            'renderer.factory',
	            'renderer.modes',
	            'renderer.create',
	            'renderer.createWithFallback'
	        ];
	    }
	}

	var RenderingServiceProvider$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		RenderingServiceProvider: RenderingServiceProvider
	});

	/**
	 * Service provider for scene management services.
	 */
	class SceneServiceProvider extends AbstractServiceProvider {
	    /**
	     * Register scene services in the container.
	     */
	    register(app) {
	        // Register scene manager
	        app.singleton('scene.manager', () => new DefaultSceneManager());
	        // Alias for convenience
	        app.getContainer().alias('scenes', 'scene.manager');
	    }
	    /**
	     * Bootstrap scene services.
	     */
	    boot(app) {
	        const sceneManager = app.make('scene.manager');
	        // Set up scene manager event listeners
	        sceneManager.on('scene:changed', (fromScene, toScene) => {
	            app.emit('scene:changed', fromScene, toScene);
	        });
	        sceneManager.on('scene:transition:start', (transition) => {
	            app.emit('scene:transition:start', transition);
	        });
	        sceneManager.on('scene:transition:complete', (transition) => {
	            app.emit('scene:transition:complete', transition);
	        });
	    }
	    /**
	     * Services provided by this provider.
	     */
	    provides() {
	        return [
	            'scene.manager',
	            'scenes'
	        ];
	    }
	}

	var SceneServiceProvider$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		SceneServiceProvider: SceneServiceProvider
	});

	/**
	 * Plugin manager for registering and managing framework plugins.
	 */
	class PluginManager extends EventEmitter {
	    constructor(app) {
	        super();
	        this.plugins = new Map();
	        this.app = app;
	    }
	    /**
	     * Register a plugin with the framework.
	     */
	    register(config) {
	        if (this.plugins.has(config.name)) {
	            throw new Error(`Plugin '${config.name}' is already registered`);
	        }
	        // Check dependencies
	        if (config.dependencies) {
	            for (const dependency of config.dependencies) {
	                if (!this.plugins.has(dependency)) {
	                    throw new Error(`Plugin '${config.name}' requires '${dependency}' but it's not registered`);
	                }
	            }
	        }
	        const provider = new config.provider();
	        const entry = {
	            config,
	            provider,
	            loaded: false,
	            enabled: config.enabled !== false
	        };
	        this.plugins.set(config.name, entry);
	        this.emit('plugin:registered', config.name, entry);
	    }
	    /**
	     * Load a plugin by registering its service provider.
	     */
	    async load(pluginName) {
	        const entry = this.plugins.get(pluginName);
	        if (!entry) {
	            throw new Error(`Plugin '${pluginName}' not found`);
	        }
	        if (!entry.enabled) {
	            throw new Error(`Plugin '${pluginName}' is disabled`);
	        }
	        if (entry.loaded) {
	            return; // Already loaded
	        }
	        // Load dependencies first
	        if (entry.config.dependencies) {
	            for (const dependency of entry.config.dependencies) {
	                await this.load(dependency);
	            }
	        }
	        // Register the provider
	        this.app.register(entry.provider, pluginName);
	        entry.loaded = true;
	        this.emit('plugin:loaded', pluginName, entry);
	    }
	    /**
	     * Unload a plugin by removing its services.
	     */
	    unload(pluginName) {
	        const entry = this.plugins.get(pluginName);
	        if (!entry || !entry.loaded) {
	            return;
	        }
	        // Check if other plugins depend on this one
	        for (const [name, otherEntry] of this.plugins) {
	            if (otherEntry.loaded && otherEntry.config.dependencies?.includes(pluginName)) {
	                throw new Error(`Cannot unload '${pluginName}' because '${name}' depends on it`);
	            }
	        }
	        // Remove services provided by this plugin
	        if (entry.provider.provides) {
	            const services = entry.provider.provides();
	            for (const service of services) {
	                if (this.app.getContainer().bound(service)) {
	                    this.app.getContainer().unbind(service);
	                }
	            }
	        }
	        entry.loaded = false;
	        this.emit('plugin:unloaded', pluginName, entry);
	    }
	    /**
	     * Enable a plugin.
	     */
	    enable(pluginName) {
	        const entry = this.plugins.get(pluginName);
	        if (!entry) {
	            throw new Error(`Plugin '${pluginName}' not found`);
	        }
	        entry.enabled = true;
	        this.emit('plugin:enabled', pluginName, entry);
	    }
	    /**
	     * Disable a plugin.
	     */
	    disable(pluginName) {
	        const entry = this.plugins.get(pluginName);
	        if (!entry) {
	            throw new Error(`Plugin '${pluginName}' not found`);
	        }
	        if (entry.loaded) {
	            this.unload(pluginName);
	        }
	        entry.enabled = false;
	        this.emit('plugin:disabled', pluginName, entry);
	    }
	    /**
	     * Load all registered and enabled plugins.
	     */
	    async loadAll() {
	        const loadPromises = [];
	        for (const [name, entry] of this.plugins) {
	            if (entry.enabled && !entry.loaded) {
	                loadPromises.push(this.load(name));
	            }
	        }
	        await Promise.all(loadPromises);
	    }
	    /**
	     * Get plugin information.
	     */
	    getPlugin(pluginName) {
	        return this.plugins.get(pluginName) || null;
	    }
	    /**
	     * Get all registered plugins.
	     */
	    getAllPlugins() {
	        return new Map(this.plugins);
	    }
	    /**
	     * Get enabled plugins.
	     */
	    getEnabledPlugins() {
	        const enabled = new Map();
	        for (const [name, entry] of this.plugins) {
	            if (entry.enabled) {
	                enabled.set(name, entry);
	            }
	        }
	        return enabled;
	    }
	    /**
	     * Get loaded plugins.
	     */
	    getLoadedPlugins() {
	        const loaded = new Map();
	        for (const [name, entry] of this.plugins) {
	            if (entry.loaded) {
	                loaded.set(name, entry);
	            }
	        }
	        return loaded;
	    }
	    /**
	     * Check if a plugin is registered.
	     */
	    hasPlugin(pluginName) {
	        return this.plugins.has(pluginName);
	    }
	    /**
	     * Check if a plugin is loaded.
	     */
	    isLoaded(pluginName) {
	        const entry = this.plugins.get(pluginName);
	        return entry ? entry.loaded : false;
	    }
	    /**
	     * Check if a plugin is enabled.
	     */
	    isEnabled(pluginName) {
	        const entry = this.plugins.get(pluginName);
	        return entry ? entry.enabled : false;
	    }
	    /**
	     * Get plugin dependency graph for ordered loading.
	     */
	    getDependencyGraph() {
	        const graph = new Map();
	        for (const [name, entry] of this.plugins) {
	            graph.set(name, entry.config.dependencies || []);
	        }
	        return graph;
	    }
	}

	/**
	 * Service provider for plugin management services.
	 */
	class PluginServiceProvider extends AbstractServiceProvider {
	    /**
	     * Register plugin services in the container.
	     */
	    register(app) {
	        // Register plugin manager as singleton
	        app.singleton('plugin.manager', () => new PluginManager(app));
	        // Alias for convenience
	        app.getContainer().alias('plugins', 'plugin.manager');
	    }
	    /**
	     * Bootstrap plugin services.
	     */
	    boot(app) {
	        const pluginManager = app.make('plugin.manager');
	        // Forward plugin events to the main app
	        pluginManager.on('plugin:registered', (name, entry) => {
	            app.emit('plugin:registered', name, entry);
	        });
	        pluginManager.on('plugin:loaded', (name, entry) => {
	            app.emit('plugin:loaded', name, entry);
	        });
	        pluginManager.on('plugin:unloaded', (name, entry) => {
	            app.emit('plugin:unloaded', name, entry);
	        });
	        pluginManager.on('plugin:enabled', (name, entry) => {
	            app.emit('plugin:enabled', name, entry);
	        });
	        pluginManager.on('plugin:disabled', (name, entry) => {
	            app.emit('plugin:disabled', name, entry);
	        });
	    }
	    /**
	     * Services provided by this provider.
	     */
	    provides() {
	        return [
	            'plugin.manager',
	            'plugins'
	        ];
	    }
	}

	var PluginServiceProvider$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		PluginServiceProvider: PluginServiceProvider
	});

	/**
	 * Abstract base implementation of UI component with common functionality
	 */
	class BaseUIComponent extends EventEmitter {
	    constructor(id) {
	        super();
	        this.parent = null;
	        this.children = [];
	        // Transform properties
	        this.position = { x: 0, y: 0 };
	        this.size = { width: 0, height: 0 };
	        this.rotation = 0;
	        this.scale = { x: 1, y: 1 };
	        this.anchor = { x: 0.5, y: 0.5 };
	        // Appearance properties
	        this.visible = true;
	        this.alpha = 1;
	        this.interactive = false;
	        // Layout properties
	        this.margin = { top: 0, right: 0, bottom: 0, left: 0 };
	        this.padding = { top: 0, right: 0, bottom: 0, left: 0 };
	        this._autoSize = false;
	        // Internal state
	        this._needsLayout = true;
	        this._destroyed = false;
	        this._animations = new Map();
	        this.id = id || `ui_${Math.random().toString(36).substr(2, 9)}`;
	        // Default constraints
	        this.constraints = {
	            x: { type: 'fixed', value: 0 },
	            y: { type: 'fixed', value: 0 },
	            width: { type: 'wrap' },
	            height: { type: 'wrap' }
	        };
	    }
	    /**
	     * Initialize the component
	     */
	    initialize() {
	        this.emit('initialize');
	    }
	    /**
	     * Update the component
	     */
	    update(deltaTime) {
	        if (this._destroyed || !this.visible)
	            return;
	        // Update children
	        for (const child of this.children) {
	            child.update(deltaTime);
	        }
	        this.emit('update', deltaTime);
	    }
	    /**
	     * Destroy the component and clean up resources
	     */
	    destroy() {
	        if (this._destroyed)
	            return;
	        // Stop all animations
	        this.stopAllAnimations();
	        // Destroy children
	        for (const child of [...this.children]) {
	            child.destroy();
	        }
	        // Remove from parent
	        this.removeFromParent();
	        // Clean up
	        this.removeAllListeners();
	        this._destroyed = true;
	        this.emit('destroy');
	    }
	    /**
	     * Add a child component
	     */
	    addChild(child) {
	        if (child.parent) {
	            child.removeFromParent();
	        }
	        this.children.push(child);
	        child.parent = this;
	        this.requestLayout();
	        this.emit('child-added', child);
	        child.emit('added-to-parent', this);
	    }
	    /**
	     * Remove a child component
	     */
	    removeChild(child) {
	        const index = this.children.indexOf(child);
	        if (index === -1)
	            return;
	        this.children.splice(index, 1);
	        child.parent = null;
	        this.requestLayout();
	        this.emit('child-removed', child);
	        child.emit('removed-from-parent', this);
	    }
	    /**
	     * Remove this component from its parent
	     */
	    removeFromParent() {
	        if (this.parent) {
	            this.parent.removeChild(this);
	        }
	    }
	    /**
	     * Find a child component by ID
	     */
	    getChildById(id) {
	        for (const child of this.children) {
	            if (child.id === id) {
	                return child;
	            }
	            const found = child.getChildById(id);
	            if (found) {
	                return found;
	            }
	        }
	        return null;
	    }
	    /**
	     * Request a layout update
	     */
	    requestLayout() {
	        this._needsLayout = true;
	        if (this.parent) {
	            this.parent.requestLayout();
	        }
	    }
	    /**
	     * Perform layout calculations
	     */
	    layout() {
	        if (!this._needsLayout)
	            return;
	        this.updateLayout();
	        // Layout children
	        for (const child of this.children) {
	            child.layout();
	        }
	        this._needsLayout = false;
	        this.emit('layout');
	    }
	    /**
	     * Update this component's layout (to be overridden by subclasses)
	     */
	    updateLayout() {
	        // Base implementation - subclasses should override
	    }
	    /**
	     * Get the component's bounding rectangle
	     */
	    getBounds() {
	        return {
	            x: this.position.x - (this.size.width * this.anchor.x),
	            y: this.position.y - (this.size.height * this.anchor.y),
	            width: this.size.width,
	            height: this.size.height
	        };
	    }
	    /**
	     * Get the component's global position
	     */
	    getGlobalPosition() {
	        let globalPos = { ...this.position };
	        let current = this.parent;
	        while (current) {
	            globalPos.x += current.position.x;
	            globalPos.y += current.position.y;
	            current = current.parent;
	        }
	        return globalPos;
	    }
	    /**
	     * Hit test - check if a point intersects with this component
	     */
	    hitTest(point) {
	        if (!this.visible || !this.interactive || this.alpha <= 0) {
	            return null;
	        }
	        const bounds = this.getBounds();
	        const globalPos = this.getGlobalPosition();
	        // Adjust bounds to global position
	        bounds.x += globalPos.x - this.position.x;
	        bounds.y += globalPos.y - this.position.y;
	        // Check if point is within bounds
	        if (point.x >= bounds.x && point.x <= bounds.x + bounds.width &&
	            point.y >= bounds.y && point.y <= bounds.y + bounds.height) {
	            // Check children first (they're on top)
	            for (let i = this.children.length - 1; i >= 0; i--) {
	                const child = this.children[i];
	                const hit = child.hitTest(point);
	                if (hit) {
	                    return hit;
	                }
	            }
	            return this;
	        }
	        return null;
	    }
	    /**
	     * Animate component properties
	     */
	    async animate(properties, config) {
	        // This will be implemented by the animation system
	        // For now, just set properties immediately
	        Object.assign(this, properties);
	        if (config.onComplete) {
	            config.onComplete();
	        }
	    }
	    /**
	     * Stop all animations on this component
	     */
	    stopAllAnimations() {
	        this._animations.clear();
	    }
	    setPositionConstraint(xOrConstraint, y) {
	        if (y !== undefined) {
	            // Two parameter version
	            this.constraints.x = typeof xOrConstraint === 'string' ? { type: xOrConstraint } : xOrConstraint;
	            this.constraints.y = typeof y === 'string' ? { type: y } : y;
	        }
	        else {
	            // Single constraint parameter version
	            const constraint = typeof xOrConstraint === 'string' ? { type: xOrConstraint } : xOrConstraint;
	            this.constraints.x = constraint;
	            this.constraints.y = constraint;
	        }
	        this.requestLayout();
	        return this;
	    }
	    setSizeConstraint(widthOrConstraint, height) {
	        if (height !== undefined) {
	            // Two parameter version
	            this.constraints.width = typeof widthOrConstraint === 'string' ? { type: widthOrConstraint } : widthOrConstraint;
	            this.constraints.height = typeof height === 'string' ? { type: height } : height;
	        }
	        else {
	            // Single constraint parameter version
	            const constraint = typeof widthOrConstraint === 'string' ? { type: widthOrConstraint } : widthOrConstraint;
	            this.constraints.width = constraint;
	            this.constraints.height = constraint;
	        }
	        this.requestLayout();
	        return this;
	    }
	    /**
	     * Set margin
	     */
	    setMargin(margin) {
	        if (typeof margin === 'number') {
	            this.margin = { top: margin, right: margin, bottom: margin, left: margin };
	        }
	        else {
	            this.margin = { ...margin };
	        }
	        this.requestLayout();
	        return this;
	    }
	    /**
	     * Set padding
	     */
	    setPadding(padding) {
	        if (typeof padding === 'number') {
	            this.padding = { top: padding, right: padding, bottom: padding, left: padding };
	        }
	        else {
	            this.padding = { ...padding };
	        }
	        this.requestLayout();
	        return this;
	    }
	    /**
	     * Make component interactive
	     */
	    makeInteractive() {
	        this.interactive = true;
	        return this;
	    }
	    /**
	     * Set visibility
	     */
	    setVisible(visible) {
	        this.visible = visible;
	        this.emit('visibility-changed', visible);
	        return this;
	    }
	    /**
	     * Set alpha (opacity)
	     */
	    setAlpha(alpha) {
	        this.alpha = Math.max(0, Math.min(1, alpha));
	        this.emit('alpha-changed', this.alpha);
	        return this;
	    }
	    /**
	     * Set position
	     */
	    setPosition(x, y) {
	        this.position.x = x;
	        this.position.y = y;
	        this.emit('position-changed', this.position);
	        return this;
	    }
	    /**
	     * Set size
	     */
	    setSize(width, height) {
	        this.size.width = width;
	        this.size.height = height;
	        this.requestLayout();
	        this.emit('size-changed', this.size);
	        return this;
	    }
	    /**
	     * Set scale
	     */
	    setScale(x, y) {
	        this.scale.x = x;
	        this.scale.y = y ?? x;
	        this.emit('scale-changed', this.scale);
	        return this;
	    }
	    /**
	     * Set rotation (in radians)
	     */
	    setRotation(rotation) {
	        this.rotation = rotation;
	        this.emit('rotation-changed', this.rotation);
	        return this;
	    }
	    /**
	     * Set anchor point
	     */
	    setAnchor(x, y) {
	        if (typeof x === 'object') {
	            this.anchor.x = x.x;
	            this.anchor.y = x.y;
	        }
	        else {
	            this.anchor.x = x;
	            this.anchor.y = y ?? x;
	        }
	        this.emit('anchor-changed', this.anchor);
	        return this;
	    }
	}

	/**
	 * Basic container component that can hold other UI components
	 */
	class UIContainer extends BaseUIComponent {
	    constructor(id) {
	        super(id);
	        this.interactive = false; // Containers are not interactive by default
	    }
	    /**
	     * Render the container (typically just renders children)
	     */
	    render(renderer) {
	        if (!this.visible || this.alpha <= 0)
	            return;
	        // Container itself doesn't render anything visual
	        // Just render children
	        for (const child of this.children) {
	            child.render(renderer);
	        }
	    }
	    /**
	     * Update layout for container - arrange children
	     */
	    updateLayout() {
	        // Basic layout - just ensures children fit within bounds
	        ({
	            width: this.size.width - this.padding.left - this.padding.right,
	            height: this.size.height - this.padding.top - this.padding.bottom
	        });
	        // Apply padding offset to children positions
	        for (const child of this.children) {
	            // This is a basic implementation - more sophisticated layouts
	            // would be handled by specific layout managers
	            if (child.constraints.x.type === 'fixed' && child.constraints.y.type === 'fixed') {
	                // Add padding offset for fixed positioned children
	                const baseChild = child;
	                if (baseChild.position.x < this.padding.left) {
	                    baseChild.position.x += this.padding.left;
	                }
	                if (baseChild.position.y < this.padding.top) {
	                    baseChild.position.y += this.padding.top;
	                }
	            }
	        }
	    }
	    /**
	     * Auto-size container to fit content
	     */
	    autoSize() {
	        let maxWidth = 0;
	        let maxHeight = 0;
	        for (const child of this.children) {
	            const bounds = child.getBounds();
	            const rightEdge = bounds.x + bounds.width;
	            const bottomEdge = bounds.y + bounds.height;
	            if (rightEdge > maxWidth) {
	                maxWidth = rightEdge;
	            }
	            if (bottomEdge > maxHeight) {
	                maxHeight = bottomEdge;
	            }
	        }
	        // Add padding
	        maxWidth += this.padding.left + this.padding.right;
	        maxHeight += this.padding.top + this.padding.bottom;
	        this.setSize(maxWidth, maxHeight);
	        return this;
	    }
	    /**
	     * Arrange children in a vertical stack
	     */
	    arrangeVertically(spacing = 0) {
	        let currentY = this.padding.top;
	        for (const child of this.children) {
	            child.setPosition(this.padding.left, currentY);
	            currentY += child.size.height + spacing;
	        }
	        // Auto-resize container if needed
	        const totalHeight = currentY - spacing + this.padding.bottom;
	        if (totalHeight > this.size.height) {
	            this.setSize(this.size.width, totalHeight);
	        }
	        return this;
	    }
	    /**
	     * Arrange children in a horizontal row
	     */
	    arrangeHorizontally(spacing = 0) {
	        let currentX = this.padding.left;
	        for (const child of this.children) {
	            child.setPosition(currentX, this.padding.top);
	            currentX += child.size.width + spacing;
	        }
	        // Auto-resize container if needed
	        const totalWidth = currentX - spacing + this.padding.right;
	        if (totalWidth > this.size.width) {
	            this.setSize(totalWidth, this.size.height);
	        }
	        return this;
	    }
	    /**
	     * Center all children within the container
	     */
	    centerChildren() {
	        const centerX = this.size.width / 2;
	        const centerY = this.size.height / 2;
	        for (const child of this.children) {
	            child.setPosition(centerX, centerY);
	            child.setAnchor(0.5, 0.5);
	        }
	        return this;
	    }
	    /**
	     * Distribute children evenly horizontally
	     */
	    distributeHorizontally() {
	        if (this.children.length <= 1)
	            return this;
	        const availableWidth = this.size.width - this.padding.left - this.padding.right;
	        const spacing = availableWidth / (this.children.length - 1);
	        for (let i = 0; i < this.children.length; i++) {
	            const child = this.children[i];
	            const x = this.padding.left + (i * spacing);
	            child.setPosition(x, child.position.y);
	        }
	        return this;
	    }
	    /**
	     * Distribute children evenly vertically
	     */
	    distributeVertically() {
	        if (this.children.length <= 1)
	            return this;
	        const availableHeight = this.size.height - this.padding.top - this.padding.bottom;
	        const spacing = availableHeight / (this.children.length - 1);
	        for (let i = 0; i < this.children.length; i++) {
	            const child = this.children[i];
	            const y = this.padding.top + (i * spacing);
	            child.setPosition(child.position.x, y);
	        }
	        return this;
	    }
	}

	/**
	 * Default UI theme with modern, mobile-first design inspired by Rollic/Voodoo games
	 */
	class DefaultUITheme {
	    constructor() {
	        this.name = 'default';
	        // Modern color palette with vibrant accents
	        this.colors = {
	            // Primary brand colors
	            primary: { r: 0, g: 122, b: 255, a: 1 }, // iOS Blue
	            secondary: { r: 255, g: 59, b: 48, a: 1 }, // iOS Red
	            // Background colors
	            background: { r: 25, g: 35, b: 45, a: 1 }, // Dark blue-gray
	            surface: { r: 45, g: 55, b: 65, a: 1 }, // Lighter surface
	            // Text colors
	            text: { r: 255, g: 255, b: 255, a: 1 }, // White
	            textSecondary: { r: 200, g: 210, b: 220, a: 1 }, // Light gray
	            // Status colors
	            success: { r: 52, g: 199, b: 89, a: 1 }, // iOS Green
	            warning: { r: 255, g: 149, b: 0, a: 1 }, // iOS Orange
	            error: { r: 255, g: 59, b: 48, a: 1 }, // iOS Red
	            // Utility
	            overlay: { r: 0, g: 0, b: 0, a: 0.5 } // Semi-transparent black
	        };
	        // Typography scale
	        this.typography = {
	            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif',
	            sizes: {
	                small: 14,
	                medium: 16,
	                large: 20,
	                xlarge: 32
	            },
	            weights: {
	                normal: 400,
	                bold: 700
	            }
	        };
	        // Spacing scale (8px base unit)
	        this.spacing = {
	            xs: 4,
	            sm: 8,
	            md: 16,
	            lg: 24,
	            xl: 32
	        };
	        // Border radius scale
	        this.radius = {
	            sm: 4,
	            md: 8,
	            lg: 16,
	            full: 9999
	        };
	        // Shadow definitions
	        this.shadows = {
	            sm: '0 2px 4px rgba(0, 0, 0, 0.1)',
	            md: '0 4px 8px rgba(0, 0, 0, 0.15)',
	            lg: '0 8px 16px rgba(0, 0, 0, 0.2)'
	        };
	        // Animation timings
	        this.animations = {
	            fast: 150,
	            normal: 300,
	            slow: 500
	        };
	    }
	}
	/**
	 * Vibrant theme with bright colors (Voodoo-style)
	 */
	class VibrantUITheme {
	    constructor() {
	        this.name = 'vibrant';
	        this.colors = {
	            primary: { r: 255, g: 45, b: 85, a: 1 }, // Hot pink
	            secondary: { r: 0, g: 245, b: 255, a: 1 }, // Cyan
	            background: { r: 15, g: 15, b: 25, a: 1 }, // Very dark blue
	            surface: { r: 30, g: 30, b: 45, a: 1 },
	            text: { r: 255, g: 255, b: 255, a: 1 },
	            textSecondary: { r: 180, g: 180, b: 200, a: 1 },
	            success: { r: 0, g: 255, b: 127, a: 1 }, // Bright green
	            warning: { r: 255, g: 191, b: 0, a: 1 }, // Gold
	            error: { r: 255, g: 45, b: 85, a: 1 }, // Hot pink
	            overlay: { r: 0, g: 0, b: 0, a: 0.7 }
	        };
	        this.typography = {
	            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif',
	            sizes: { small: 14, medium: 16, large: 20, xlarge: 32 },
	            weights: { normal: 400, bold: 700 }
	        };
	        this.spacing = { xs: 4, sm: 8, md: 16, lg: 24, xl: 32 };
	        this.radius = { sm: 6, md: 12, lg: 20, full: 9999 };
	        this.shadows = {
	            sm: '0 2px 8px rgba(255, 45, 85, 0.3)',
	            md: '0 4px 16px rgba(255, 45, 85, 0.4)',
	            lg: '0 8px 32px rgba(255, 45, 85, 0.5)'
	        };
	        this.animations = { fast: 200, normal: 400, slow: 600 };
	    }
	}
	/**
	 * Minimalist theme with clean lines (Rollic-style)
	 */
	class MinimalUITheme {
	    constructor() {
	        this.name = 'minimal';
	        this.colors = {
	            primary: { r: 0, g: 0, b: 0, a: 1 }, // Black
	            secondary: { r: 100, g: 100, b: 100, a: 1 }, // Gray
	            background: { r: 248, g: 248, b: 248, a: 1 }, // Light gray
	            surface: { r: 255, g: 255, b: 255, a: 1 }, // White
	            text: { r: 0, g: 0, b: 0, a: 1 }, // Black
	            textSecondary: { r: 100, g: 100, b: 100, a: 1 }, // Gray
	            success: { r: 0, g: 150, b: 0, a: 1 }, // Green
	            warning: { r: 200, g: 150, b: 0, a: 1 }, // Orange
	            error: { r: 200, g: 0, b: 0, a: 1 }, // Red
	            overlay: { r: 0, g: 0, b: 0, a: 0.3 }
	        };
	        this.typography = {
	            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif',
	            sizes: { small: 12, medium: 14, large: 18, xlarge: 28 },
	            weights: { normal: 300, bold: 600 }
	        };
	        this.spacing = { xs: 2, sm: 4, md: 8, lg: 16, xl: 24 };
	        this.radius = { sm: 2, md: 4, lg: 8, full: 9999 };
	        this.shadows = {
	            sm: '0 1px 2px rgba(0, 0, 0, 0.05)',
	            md: '0 2px 4px rgba(0, 0, 0, 0.1)',
	            lg: '0 4px 8px rgba(0, 0, 0, 0.15)'
	        };
	        this.animations = { fast: 100, normal: 200, slow: 300 };
	    }
	}
	/**
	 * Dark theme optimized for mobile gaming
	 */
	class DarkGamingUITheme {
	    constructor() {
	        this.name = 'dark-gaming';
	        this.colors = {
	            primary: { r: 0, g: 255, b: 127, a: 1 }, // Neon green
	            secondary: { r: 255, g: 0, b: 255, a: 1 }, // Magenta
	            background: { r: 8, g: 8, b: 12, a: 1 }, // Very dark
	            surface: { r: 20, g: 20, b: 30, a: 1 }, // Dark surface
	            text: { r: 240, g: 240, b: 255, a: 1 }, // Off-white
	            textSecondary: { r: 160, g: 160, b: 180, a: 1 }, // Gray
	            success: { r: 0, g: 255, b: 127, a: 1 }, // Neon green
	            warning: { r: 255, g: 215, b: 0, a: 1 }, // Gold
	            error: { r: 255, g: 20, b: 147, a: 1 }, // Deep pink
	            overlay: { r: 0, g: 0, b: 0, a: 0.8 }
	        };
	        this.typography = {
	            fontFamily: '"Monaco", "Menlo", "Ubuntu Mono", monospace',
	            sizes: { small: 13, medium: 15, large: 19, xlarge: 30 },
	            weights: { normal: 400, bold: 700 }
	        };
	        this.spacing = { xs: 3, sm: 6, md: 12, lg: 20, xl: 28 };
	        this.radius = { sm: 3, md: 6, lg: 12, full: 9999 };
	        this.shadows = {
	            sm: '0 2px 4px rgba(0, 255, 127, 0.2)',
	            md: '0 4px 8px rgba(0, 255, 127, 0.3)',
	            lg: '0 8px 16px rgba(0, 255, 127, 0.4)'
	        };
	        this.animations = { fast: 120, normal: 250, slow: 400 };
	    }
	}
	/**
	 * Theme manager for switching between themes
	 */
	class UIThemeManager {
	    constructor() {
	        this.themes = new Map();
	        // Register default themes
	        this.registerTheme(new DefaultUITheme());
	        this.registerTheme(new VibrantUITheme());
	        this.registerTheme(new MinimalUITheme());
	        this.registerTheme(new DarkGamingUITheme());
	        // Set default theme
	        this.currentTheme = this.themes.get('default');
	    }
	    /**
	     * Register a custom theme
	     */
	    registerTheme(theme) {
	        this.themes.set(theme.name, theme);
	    }
	    /**
	     * Set the active theme
	     */
	    setTheme(themeName) {
	        const theme = this.themes.get(themeName);
	        if (theme) {
	            this.currentTheme = theme;
	            return true;
	        }
	        return false;
	    }
	    /**
	     * Get the current theme
	     */
	    getCurrentTheme() {
	        return this.currentTheme;
	    }
	    /**
	     * Get all available themes
	     */
	    getAvailableThemes() {
	        return Array.from(this.themes.keys());
	    }
	    /**
	     * Create a color variant (lighter/darker)
	     */
	    static adjustColor(color, factor) {
	        return {
	            r: Math.max(0, Math.min(255, color.r + (color.r * factor))),
	            g: Math.max(0, Math.min(255, color.g + (color.g * factor))),
	            b: Math.max(0, Math.min(255, color.b + (color.b * factor))),
	            a: color.a
	        };
	    }
	    /**
	     * Create a semi-transparent version of a color
	     */
	    static withAlpha(color, alpha) {
	        return {
	            ...color,
	            a: Math.max(0, Math.min(1, alpha))
	        };
	    }
	    /**
	     * Convert color to CSS rgba string
	     */
	    static colorToCSS(color) {
	        return `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;
	    }
	    /**
	     * Convert color to hex string
	     */
	    static colorToHex(color) {
	        const toHex = (c) => Math.round(c).toString(16).padStart(2, '0');
	        return `#${toHex(color.r)}${toHex(color.g)}${toHex(color.b)}`;
	    }
	    /**
	     * Create a gradient between two colors
	     */
	    static createGradient(startColor, endColor, steps) {
	        const gradient = [];
	        for (let i = 0; i < steps; i++) {
	            const factor = i / (steps - 1);
	            gradient.push({
	                r: startColor.r + (endColor.r - startColor.r) * factor,
	                g: startColor.g + (endColor.g - startColor.g) * factor,
	                b: startColor.b + (endColor.b - startColor.b) * factor,
	                a: startColor.a + (endColor.a - startColor.a) * factor
	            });
	        }
	        return gradient;
	    }
	}

	/**
	 * Main UI system manager that handles the entire UI layer
	 */
	class GameByteUIManager extends EventEmitter {
	    constructor(canvas) {
	        super();
	        // Internal state
	        this._screens = new Map();
	        this._currentScreen = null;
	        this._canvas = null;
	        this._animationFrameId = null;
	        this._lastTime = 0;
	        // Component registry
	        this._componentFactories = new Map();
	        this._canvas = canvas || null;
	        // Initialize device info
	        this.deviceInfo = this.detectDeviceInfo();
	        // Create root container
	        this.root = new UIContainer('ui-root');
	        this.root.setSize(this.deviceInfo.screenSize.width, this.deviceInfo.screenSize.height);
	        this.root.initialize();
	        // Set default theme
	        this._theme = new DefaultUITheme();
	        // Register default component types
	        this.registerDefaultComponents();
	        // Setup event listeners
	        this.setupEventListeners();
	        this.emit('initialized');
	    }
	    /**
	     * Show a screen by name
	     */
	    async showScreen(screenName, data) {
	        const screen = this._screens.get(screenName);
	        if (!screen) {
	            throw new Error(`Screen '${screenName}' not found`);
	        }
	        // Hide current screen if any
	        if (this._currentScreen) {
	            await this.hideScreen(this._currentScreen);
	        }
	        // Show new screen
	        this.root.addChild(screen);
	        await screen.onShow(data);
	        this._currentScreen = screenName;
	        this.emit('screen-shown', screenName, data);
	    }
	    /**
	     * Hide a screen by name
	     */
	    async hideScreen(screenName) {
	        const screen = this._screens.get(screenName);
	        if (!screen) {
	            return;
	        }
	        await screen.onHide();
	        screen.removeFromParent();
	        if (this._currentScreen === screenName) {
	            this._currentScreen = null;
	        }
	        this.emit('screen-hidden', screenName);
	    }
	    /**
	     * Get the current screen name
	     */
	    getCurrentScreen() {
	        return this._currentScreen;
	    }
	    /**
	     * Register a screen
	     */
	    registerScreen(screen) {
	        this._screens.set(screen.screenName, screen);
	        this.emit('screen-registered', screen.screenName);
	    }
	    /**
	     * Unregister a screen
	     */
	    unregisterScreen(screenName) {
	        const screen = this._screens.get(screenName);
	        if (screen) {
	            if (this._currentScreen === screenName) {
	                this.hideScreen(screenName);
	            }
	            this._screens.delete(screenName);
	            this.emit('screen-unregistered', screenName);
	        }
	    }
	    /**
	     * Create a component by type
	     */
	    createComponent(type, config) {
	        const factory = this._componentFactories.get(type);
	        if (!factory) {
	            throw new Error(`Component type '${type}' not registered`);
	        }
	        const component = factory();
	        // Apply configuration if provided
	        if (config) {
	            this.configureComponent(component, config);
	        }
	        component.initialize();
	        return component;
	    }
	    /**
	     * Register a component factory
	     */
	    registerComponent(type, factory) {
	        this._componentFactories.set(type, factory);
	        this.emit('component-registered', type);
	    }
	    /**
	     * Handle interaction events
	     */
	    handleInteraction(event) {
	        // Find the target component
	        const target = this.root.hitTest(event.position);
	        if (target) {
	            event.target = target;
	            // Emit event on the target
	            target.emit(`interaction-${event.type}`, event);
	            // Handle specific interaction types
	            switch (event.type) {
	                case 'down':
	                    target.emit('pointer-down', event);
	                    break;
	                case 'up':
	                    target.emit('pointer-up', event);
	                    target.emit('tap', event);
	                    break;
	                case 'move':
	                    target.emit('pointer-move', event);
	                    break;
	                case 'cancel':
	                    target.emit('pointer-cancel', event);
	                    break;
	            }
	        }
	        this.emit('interaction', event);
	    }
	    /**
	     * Request a layout update
	     */
	    requestLayout() {
	        this.root.layout();
	    }
	    /**
	     * Update layout immediately
	     */
	    updateLayout() {
	        this.root.layout();
	    }
	    /**
	     * Set the theme
	     */
	    setTheme(theme) {
	        this._theme = theme;
	        this.emit('theme-changed', theme);
	    }
	    /**
	     * Get the current theme
	     */
	    getTheme() {
	        return this._theme;
	    }
	    /**
	     * Update the UI system
	     */
	    update(deltaTime) {
	        this.root.update(deltaTime);
	        this.emit('update', deltaTime);
	    }
	    /**
	     * Render the UI system
	     */
	    render(renderer) {
	        this.root.render(renderer);
	        this.emit('render', renderer);
	    }
	    /**
	     * Destroy the UI system
	     */
	    destroy() {
	        // Stop animation loop
	        if (this._animationFrameId) {
	            cancelAnimationFrame(this._animationFrameId);
	            this._animationFrameId = null;
	        }
	        // Destroy all screens
	        for (const screen of this._screens.values()) {
	            screen.destroy();
	        }
	        this._screens.clear();
	        // Destroy root
	        this.root.destroy();
	        // Clean up event listeners
	        this.removeEventListeners();
	        this.removeAllListeners();
	        this.emit('destroyed');
	    }
	    /**
	     * Handle orientation change
	     */
	    handleOrientationChange(orientation) {
	        // Update device info
	        this.deviceInfo.orientation = orientation;
	        // Swap screen dimensions if needed
	        if (orientation === 'landscape') {
	            const { width, height } = this.deviceInfo.screenSize;
	            if (height > width) {
	                this.deviceInfo.screenSize.width = height;
	                this.deviceInfo.screenSize.height = width;
	            }
	        }
	        else {
	            const { width, height } = this.deviceInfo.screenSize;
	            if (width > height) {
	                this.deviceInfo.screenSize.width = height;
	                this.deviceInfo.screenSize.height = width;
	            }
	        }
	        // Update root size
	        this.root.setSize(this.deviceInfo.screenSize.width, this.deviceInfo.screenSize.height);
	        // Notify current screen
	        if (this._currentScreen) {
	            const screen = this._screens.get(this._currentScreen);
	            if (screen) {
	                screen.onOrientationChange(orientation);
	            }
	        }
	        // Request layout update
	        this.requestLayout();
	        this.emit('orientation-changed', orientation);
	    }
	    /**
	     * Detect device information
	     */
	    detectDeviceInfo() {
	        const canvas = this._canvas;
	        const screenSize = canvas ?
	            { width: canvas.width, height: canvas.height } :
	            { width: window.innerWidth, height: window.innerHeight };
	        const pixelRatio = window.devicePixelRatio || 1;
	        const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
	        // Detect orientation
	        const orientation = screenSize.width > screenSize.height ?
	            'landscape' : 'portrait';
	        // Detect safe area (simplified - in a real implementation, you'd use CSS env() variables)
	        const safeArea = {
	            top: 0,
	            right: 0,
	            bottom: 0,
	            left: 0
	        };
	        // Detect performance tier (simplified heuristic)
	        const performanceTier = this.detectPerformanceTier();
	        return {
	            screenSize,
	            pixelRatio,
	            orientation,
	            safeArea,
	            isTouch,
	            performanceTier
	        };
	    }
	    /**
	     * Detect device performance tier
	     */
	    detectPerformanceTier() {
	        // Simple heuristic based on common indicators
	        const memory = navigator.deviceMemory || 4;
	        const cores = navigator.hardwareConcurrency || 4;
	        const pixelRatio = window.devicePixelRatio || 1;
	        if (memory >= 8 && cores >= 6 && pixelRatio >= 2) {
	            return 'high';
	        }
	        else if (memory >= 4 && cores >= 4) {
	            return 'medium';
	        }
	        else {
	            return 'low';
	        }
	    }
	    /**
	     * Configure a component with the given config object
	     */
	    configureComponent(component, config) {
	        // Apply basic properties
	        if (config.position) {
	            component.setPosition(config.position.x, config.position.y);
	        }
	        if (config.size) {
	            component.setSize(config.size.width, config.size.height);
	        }
	        if (config.visible !== undefined) {
	            component.setVisible(config.visible);
	        }
	        if (config.alpha !== undefined) {
	            component.setAlpha(config.alpha);
	        }
	        if (config.interactive !== undefined) {
	            component.interactive = config.interactive;
	        }
	        if (config.margin) {
	            component.setMargin(config.margin);
	        }
	        if (config.padding) {
	            component.setPadding(config.padding);
	        }
	        // Apply constraints
	        if (config.constraints) {
	            if (config.constraints.position) {
	                component.setPositionConstraint(config.constraints.position.x, config.constraints.position.y);
	            }
	            if (config.constraints.size) {
	                component.setSizeConstraint(config.constraints.size.width, config.constraints.size.height);
	            }
	        }
	    }
	    /**
	     * Register default component factories
	     */
	    registerDefaultComponents() {
	        // This will be expanded as we create more components
	        this.registerComponent('container', () => new UIContainer());
	    }
	    /**
	     * Setup event listeners for device events
	     */
	    setupEventListeners() {
	        if (typeof window !== 'undefined') {
	            window.addEventListener('resize', this.handleResize.bind(this));
	            window.addEventListener('orientationchange', this.handleOrientationChangeEvent.bind(this));
	        }
	    }
	    /**
	     * Remove event listeners
	     */
	    removeEventListeners() {
	        if (typeof window !== 'undefined') {
	            window.removeEventListener('resize', this.handleResize.bind(this));
	            window.removeEventListener('orientationchange', this.handleOrientationChangeEvent.bind(this));
	        }
	    }
	    /**
	     * Handle window resize
	     */
	    handleResize() {
	        const canvas = this._canvas;
	        const newSize = canvas ?
	            { width: canvas.width, height: canvas.height } :
	            { width: window.innerWidth, height: window.innerHeight };
	        this.deviceInfo.screenSize = newSize;
	        this.root.setSize(newSize.width, newSize.height);
	        this.requestLayout();
	        this.emit('resize', newSize);
	    }
	    /**
	     * Handle orientation change event
	     */
	    handleOrientationChangeEvent() {
	        // Delay to allow browser to update dimensions
	        setTimeout(() => {
	            const newOrientation = this.deviceInfo.screenSize.width > this.deviceInfo.screenSize.height ?
	                'landscape' : 'portrait';
	            this.handleOrientationChange(newOrientation);
	        }, 100);
	    }
	}

	/**
	 * High-performance animation system with spring physics and mobile optimization
	 */
	class GameByteUIAnimationSystem extends EventEmitter {
	    constructor() {
	        super();
	        // Active animations
	        this.tweens = new Map();
	        this.springs = new Map();
	        this.timelines = new Set();
	        // Performance settings
	        this.targetFPS = 60;
	        this.frameTime = 1000 / 60;
	        this.lastUpdateTime = 0;
	        this.animationFrameId = null;
	        // State
	        this.paused = false;
	        this.globalTimeScale = 1;
	        this.startUpdateLoop();
	    }
	    /**
	     * Animate properties to target values
	     */
	    async to(target, properties, config) {
	        return new Promise((resolve, reject) => {
	            const tweenId = this.generateId();
	            const startValues = {};
	            // Capture start values
	            for (const key in properties) {
	                startValues[key] = this.getNestedProperty(target, key);
	            }
	            const tween = {
	                id: tweenId,
	                target,
	                startValues,
	                endValues: properties,
	                config,
	                startTime: Date.now() + (config.delay || 0),
	                duration: config.duration,
	                progress: 0,
	                resolve,
	                reject
	            };
	            this.tweens.set(tweenId, tween);
	            this.emit('tween-started', tween);
	        });
	    }
	    /**
	     * Animate properties from initial values
	     */
	    async from(target, properties, config) {
	        const currentValues = {};
	        // Capture current values as end values
	        for (const key in properties) {
	            currentValues[key] = this.getNestedProperty(target, key);
	        }
	        // Set initial values
	        for (const key in properties) {
	            this.setNestedProperty(target, key, properties[key]);
	        }
	        // Animate to current values
	        return this.to(target, currentValues, config);
	    }
	    /**
	     * Set properties immediately (no animation)
	     */
	    set(target, properties) {
	        for (const key in properties) {
	            this.setNestedProperty(target, key, properties[key]);
	        }
	    }
	    /**
	     * Create a new timeline
	     */
	    createTimeline() {
	        const timeline = new GameByteUITimeline(this);
	        this.timelines.add(timeline);
	        return timeline;
	    }
	    /**
	     * Spring animation with physics
	     */
	    async spring(target, properties, springConfig) {
	        return new Promise((resolve) => {
	            const springId = this.generateId();
	            const springProperties = {};
	            // Setup spring properties
	            for (const key in properties) {
	                const currentValue = this.getNestedProperty(target, key);
	                const targetValue = properties[key];
	                springProperties[key] = {
	                    current: currentValue,
	                    target: targetValue,
	                    velocity: springConfig.velocity || 0,
	                    config: { ...springConfig }
	                };
	            }
	            const spring = {
	                id: springId,
	                target,
	                properties: springProperties,
	                resolve,
	                onUpdate: springConfig.onUpdate
	            };
	            this.springs.set(springId, spring);
	            this.emit('spring-started', spring);
	        });
	    }
	    /**
	     * Kill all animations for a target
	     */
	    killTweensOf(target) {
	        // Kill tweens
	        for (const [id, tween] of this.tweens) {
	            if (tween.target === target) {
	                tween.reject(new Error('Animation killed'));
	                this.tweens.delete(id);
	            }
	        }
	        // Kill springs
	        for (const [id, spring] of this.springs) {
	            if (spring.target === target) {
	                this.springs.delete(id);
	            }
	        }
	        this.emit('tweens-killed', target);
	    }
	    /**
	     * Pause all animations
	     */
	    pauseAll() {
	        this.paused = true;
	        this.emit('paused');
	    }
	    /**
	     * Resume all animations
	     */
	    resumeAll() {
	        this.paused = false;
	        this.emit('resumed');
	    }
	    /**
	     * Set global time scale
	     */
	    setTimeScale(scale) {
	        this.globalTimeScale = Math.max(0, scale);
	    }
	    /**
	     * Update animation system
	     */
	    update(deltaTime) {
	        if (this.paused)
	            return;
	        const scaledDeltaTime = deltaTime * this.globalTimeScale;
	        const currentTime = Date.now();
	        // Update tweens
	        this.updateTweens(currentTime, scaledDeltaTime);
	        // Update springs
	        this.updateSprings(scaledDeltaTime);
	        // Update timelines
	        for (const timeline of this.timelines) {
	            timeline.update(scaledDeltaTime);
	        }
	        this.lastUpdateTime = currentTime;
	    }
	    /**
	     * Destroy animation system
	     */
	    destroy() {
	        if (this.animationFrameId) {
	            cancelAnimationFrame(this.animationFrameId);
	            this.animationFrameId = null;
	        }
	        // Cleanup all animations
	        for (const tween of this.tweens.values()) {
	            tween.reject(new Error('Animation system destroyed'));
	        }
	        this.tweens.clear();
	        this.springs.clear();
	        this.timelines.clear();
	        this.removeAllListeners();
	    }
	    /**
	     * Update tween animations
	     */
	    updateTweens(currentTime, deltaTime) {
	        for (const [id, tween] of this.tweens) {
	            if (currentTime < tween.startTime)
	                continue;
	            const elapsed = currentTime - tween.startTime;
	            const progress = Math.min(elapsed / tween.duration, 1);
	            const easedProgress = this.applyEasing(progress, tween.config.easing);
	            // Update properties
	            for (const key in tween.endValues) {
	                const startValue = tween.startValues[key];
	                const endValue = tween.endValues[key];
	                const currentValue = this.interpolateValue(startValue, endValue, easedProgress);
	                this.setNestedProperty(tween.target, key, currentValue);
	            }
	            // Update progress
	            tween.progress = progress;
	            // Call update callback
	            if (tween.config.onUpdate) {
	                tween.config.onUpdate(easedProgress);
	            }
	            // Check completion
	            if (progress >= 1) {
	                this.completeTween(id, tween);
	            }
	        }
	    }
	    /**
	     * Update spring animations
	     */
	    updateSprings(deltaTime) {
	        const dt = Math.min(deltaTime / 1000, 1 / 30); // Cap at 30fps minimum
	        for (const [id, spring] of this.springs) {
	            let allComplete = true;
	            let maxProgress = 0;
	            for (const key in spring.properties) {
	                const prop = spring.properties[key];
	                const config = prop.config;
	                // Spring physics constants
	                const tension = config.tension || 170;
	                const friction = config.friction || 26;
	                const mass = config.mass || 1;
	                const precision = config.precision || 0.01;
	                // Calculate spring forces
	                const displacement = prop.current - prop.target;
	                const springForce = -tension * displacement;
	                const dampingForce = -friction * prop.velocity;
	                const acceleration = (springForce + dampingForce) / mass;
	                // Update velocity and position
	                prop.velocity += acceleration * dt;
	                prop.current += prop.velocity * dt;
	                // Set the property
	                this.setNestedProperty(spring.target, key, prop.current);
	                // Check if spring has settled
	                const settled = Math.abs(displacement) < precision && Math.abs(prop.velocity) < precision;
	                if (!settled) {
	                    allComplete = false;
	                }
	                // Calculate progress (approximate)
	                const progress = 1 - Math.abs(displacement) / Math.abs(prop.current - prop.target + displacement);
	                maxProgress = Math.max(maxProgress, progress);
	            }
	            // Call update callback
	            if (spring.onUpdate) {
	                spring.onUpdate(maxProgress);
	            }
	            // Complete spring if all properties settled
	            if (allComplete) {
	                // Snap to target values
	                for (const key in spring.properties) {
	                    const prop = spring.properties[key];
	                    this.setNestedProperty(spring.target, key, prop.target);
	                }
	                spring.resolve();
	                this.springs.delete(id);
	                this.emit('spring-completed', spring);
	            }
	        }
	    }
	    /**
	     * Complete a tween animation
	     */
	    completeTween(id, tween) {
	        // Set final values
	        for (const key in tween.endValues) {
	            this.setNestedProperty(tween.target, key, tween.endValues[key]);
	        }
	        // Handle repeat
	        if (tween.config.repeat) {
	            if (tween.config.repeat === 'infinite' || tween.config.repeat > 1) {
	                // Reset tween
	                tween.startTime = Date.now();
	                tween.progress = 0;
	                if (tween.config.yoyo) {
	                    // Swap start and end values
	                    const temp = tween.startValues;
	                    tween.startValues = tween.endValues;
	                    tween.endValues = temp;
	                }
	                if (tween.config.repeat !== 'infinite') {
	                    tween.config.repeat--;
	                }
	                return; // Don't complete yet
	            }
	        }
	        // Complete animation
	        if (tween.config.onComplete) {
	            tween.config.onComplete();
	        }
	        tween.resolve();
	        this.tweens.delete(id);
	        this.emit('tween-completed', tween);
	    }
	    /**
	     * Apply easing function
	     */
	    applyEasing(progress, easing) {
	        switch (easing) {
	            case 'linear':
	                return progress;
	            case 'ease-in':
	                return progress * progress;
	            case 'ease-out':
	                return 1 - Math.pow(1 - progress, 2);
	            case 'ease-in-out':
	                return progress < 0.5
	                    ? 2 * progress * progress
	                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
	            case 'spring':
	                // Simplified spring easing
	                return 1 - Math.pow(1 - progress, 3) * Math.cos(progress * Math.PI * 4);
	            case 'bounce':
	                if (progress < 1 / 2.75) {
	                    return 7.5625 * progress * progress;
	                }
	                else if (progress < 2 / 2.75) {
	                    return 7.5625 * (progress -= 1.5 / 2.75) * progress + 0.75;
	                }
	                else if (progress < 2.5 / 2.75) {
	                    return 7.5625 * (progress -= 2.25 / 2.75) * progress + 0.9375;
	                }
	                else {
	                    return 7.5625 * (progress -= 2.625 / 2.75) * progress + 0.984375;
	                }
	            default:
	                return progress;
	        }
	    }
	    /**
	     * Interpolate between two values
	     */
	    interpolateValue(start, end, progress) {
	        if (typeof start === 'number' && typeof end === 'number') {
	            return start + (end - start) * progress;
	        }
	        if (typeof start === 'object' && typeof end === 'object') {
	            const result = {};
	            for (const key in end) {
	                if (key in start) {
	                    result[key] = this.interpolateValue(start[key], end[key], progress);
	                }
	                else {
	                    result[key] = end[key];
	                }
	            }
	            return result;
	        }
	        // For non-interpolatable values, use threshold
	        return progress > 0.5 ? end : start;
	    }
	    /**
	     * Get nested property value
	     */
	    getNestedProperty(obj, path) {
	        const keys = path.split('.');
	        let current = obj;
	        for (const key of keys) {
	            if (current && typeof current === 'object' && key in current) {
	                current = current[key];
	            }
	            else {
	                return undefined;
	            }
	        }
	        return current;
	    }
	    /**
	     * Set nested property value
	     */
	    setNestedProperty(obj, path, value) {
	        const keys = path.split('.');
	        let current = obj;
	        for (let i = 0; i < keys.length - 1; i++) {
	            const key = keys[i];
	            if (!(key in current) || typeof current[key] !== 'object') {
	                current[key] = {};
	            }
	            current = current[key];
	        }
	        current[keys[keys.length - 1]] = value;
	    }
	    /**
	     * Generate unique animation ID
	     */
	    generateId() {
	        return `anim_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
	    }
	    /**
	     * Start the update loop
	     */
	    startUpdateLoop() {
	        const update = (currentTime) => {
	            const deltaTime = currentTime - this.lastUpdateTime;
	            if (deltaTime >= this.frameTime) {
	                this.update(deltaTime);
	            }
	            this.animationFrameId = requestAnimationFrame(update);
	        };
	        this.animationFrameId = requestAnimationFrame(update);
	    }
	}
	/**
	 * Timeline for sequencing animations
	 */
	class GameByteUITimeline extends EventEmitter {
	    constructor(animationSystem) {
	        super();
	        this.actions = [];
	        this.currentIndex = 0;
	        this.playing = false;
	        this.paused = false;
	        this.reversed = false;
	        this.animationSystem = animationSystem;
	    }
	    /**
	     * Add a 'to' animation to the timeline
	     */
	    to(target, properties, config) {
	        this.actions.push({ type: 'to', target, properties, config });
	        return this;
	    }
	    /**
	     * Add a 'from' animation to the timeline
	     */
	    from(target, properties, config) {
	        this.actions.push({ type: 'from', target, properties, config });
	        return this;
	    }
	    /**
	     * Add a 'set' action to the timeline
	     */
	    set(target, properties) {
	        this.actions.push({ type: 'set', target, properties });
	        return this;
	    }
	    /**
	     * Add a delay to the timeline
	     */
	    delay(duration) {
	        this.actions.push({ type: 'delay', duration });
	        return this;
	    }
	    /**
	     * Add a callback to the timeline
	     */
	    call(callback) {
	        this.actions.push({ type: 'call', callback });
	        return this;
	    }
	    /**
	     * Play the timeline
	     */
	    async play() {
	        if (this.playing)
	            return;
	        this.playing = true;
	        this.paused = false;
	        this.currentIndex = this.reversed ? this.actions.length - 1 : 0;
	        try {
	            await this.executeActions();
	            this.emit('complete');
	        }
	        catch (error) {
	            this.emit('error', error);
	        }
	        finally {
	            this.playing = false;
	        }
	    }
	    /**
	     * Pause the timeline
	     */
	    pause() {
	        this.paused = true;
	        this.emit('paused');
	    }
	    /**
	     * Resume the timeline
	     */
	    resume() {
	        this.paused = false;
	        this.emit('resumed');
	    }
	    /**
	     * Reverse the timeline direction
	     */
	    reverse() {
	        this.reversed = !this.reversed;
	        this.emit('reversed');
	    }
	    /**
	     * Restart the timeline
	     */
	    restart() {
	        this.currentIndex = this.reversed ? this.actions.length - 1 : 0;
	        this.play();
	    }
	    /**
	     * Clear all actions
	     */
	    clear() {
	        this.actions = [];
	        this.currentIndex = 0;
	        this.playing = false;
	        this.paused = false;
	    }
	    /**
	     * Update timeline (called by animation system)
	     */
	    update(deltaTime) {
	        // Timeline updates are handled in executeActions
	    }
	    /**
	     * Execute timeline actions
	     */
	    async executeActions() {
	        while (this.hasMoreActions() && this.playing) {
	            if (this.paused) {
	                await new Promise(resolve => {
	                    const resumeHandler = () => {
	                        this.off('resumed', resumeHandler);
	                        resolve(undefined);
	                    };
	                    this.on('resumed', resumeHandler);
	                });
	            }
	            const action = this.getCurrentAction();
	            await this.executeAction(action);
	            this.advanceIndex();
	        }
	    }
	    /**
	     * Execute a single action
	     */
	    async executeAction(action) {
	        switch (action.type) {
	            case 'to':
	                await this.animationSystem.to(action.target, action.properties, action.config);
	                break;
	            case 'from':
	                await this.animationSystem.from(action.target, action.properties, action.config);
	                break;
	            case 'set':
	                this.animationSystem.set(action.target, action.properties);
	                break;
	            case 'delay':
	                await new Promise(resolve => setTimeout(resolve, action.duration));
	                break;
	            case 'call':
	                if (action.callback) {
	                    action.callback();
	                }
	                break;
	        }
	    }
	    /**
	     * Check if there are more actions to execute
	     */
	    hasMoreActions() {
	        if (this.reversed) {
	            return this.currentIndex >= 0;
	        }
	        else {
	            return this.currentIndex < this.actions.length;
	        }
	    }
	    /**
	     * Get the current action
	     */
	    getCurrentAction() {
	        return this.actions[this.currentIndex];
	    }
	    /**
	     * Advance to the next action
	     */
	    advanceIndex() {
	        if (this.reversed) {
	            this.currentIndex--;
	        }
	        else {
	            this.currentIndex++;
	        }
	    }
	}

	/**
	 * Mobile-optimized text component with advanced typography features
	 */
	class UIText extends BaseUIComponent {
	    constructor(config, id) {
	        super(id);
	        // Text properties
	        this.text = '';
	        this.fontSize = 16;
	        this.fontFamily = getFrameworkFontFamily();
	        this.fontWeight = 'normal';
	        this.color = { r: 0, g: 0, b: 0, a: 1 };
	        this.textAlign = 'left';
	        this.lineHeight = 1.2;
	        this.letterSpacing = 0;
	        this.wordWrap = false;
	        this.maxLines = 0; // 0 = unlimited
	        this.ellipsis = false;
	        // Internal state
	        this._lines = [];
	        this._measuredSize = { width: 0, height: 0 };
	        this._textMetrics = null;
	        this.interactive = false; // Text is not interactive by default
	        // Apply configuration
	        if (config) {
	            this.configure(config);
	        }
	        this.calculateTextLayout();
	    }
	    /**
	     * Configure text properties
	     */
	    configure(config) {
	        if (config.text !== undefined)
	            this.text = config.text;
	        if (config.fontSize !== undefined)
	            this.fontSize = config.fontSize;
	        if (config.fontFamily !== undefined)
	            this.fontFamily = config.fontFamily;
	        if (config.fontWeight !== undefined)
	            this.fontWeight = config.fontWeight;
	        if (config.color !== undefined)
	            this.color = config.color;
	        if (config.textAlign !== undefined)
	            this.textAlign = config.textAlign;
	        if (config.lineHeight !== undefined)
	            this.lineHeight = config.lineHeight;
	        if (config.letterSpacing !== undefined)
	            this.letterSpacing = config.letterSpacing;
	        if (config.wordWrap !== undefined)
	            this.wordWrap = config.wordWrap;
	        if (config.maxLines !== undefined)
	            this.maxLines = config.maxLines;
	        if (config.ellipsis !== undefined)
	            this.ellipsis = config.ellipsis;
	        if (config.shadow !== undefined)
	            this.shadow = config.shadow;
	        if (config.stroke !== undefined)
	            this.stroke = config.stroke;
	        this.calculateTextLayout();
	        return this;
	    }
	    /**
	     * Render the text
	     */
	    render(renderer) {
	        if (!this.visible || this.alpha <= 0 || !this.text)
	            return;
	        const bounds = this.getBounds();
	        this.getGlobalPosition();
	        const ctx = renderer.context || renderer;
	        if (!ctx || typeof ctx.fillText !== 'function')
	            return;
	        ctx.save();
	        // Set font properties
	        ctx.font = `${this.fontWeight} ${this.fontSize}px ${this.fontFamily}`;
	        ctx.textAlign = this.textAlign;
	        ctx.textBaseline = 'top';
	        ctx.globalAlpha = this.alpha;
	        // Apply letter spacing if supported
	        if (this.letterSpacing !== 0) {
	            ctx.letterSpacing = `${this.letterSpacing}px`;
	        }
	        // Calculate text position based on alignment
	        const startX = this.getTextStartX(bounds);
	        const startY = bounds.y;
	        const lineSpacing = this.fontSize * this.lineHeight;
	        // Render each line
	        for (let i = 0; i < this._lines.length; i++) {
	            const line = this._lines[i];
	            const y = startY + (i * lineSpacing);
	            // Render shadow if specified
	            if (this.shadow) {
	                ctx.save();
	                ctx.globalAlpha = this.alpha * this.shadow.color.a;
	                ctx.fillStyle = `rgba(${this.shadow.color.r}, ${this.shadow.color.g}, ${this.shadow.color.b}, 1)`;
	                if (this.shadow.blur > 0) {
	                    ctx.shadowColor = ctx.fillStyle;
	                    ctx.shadowBlur = this.shadow.blur;
	                    ctx.shadowOffsetX = this.shadow.offsetX;
	                    ctx.shadowOffsetY = this.shadow.offsetY;
	                }
	                ctx.fillText(line, startX + this.shadow.offsetX, y + this.shadow.offsetY);
	                ctx.restore();
	            }
	            // Render stroke if specified
	            if (this.stroke) {
	                ctx.save();
	                ctx.globalAlpha = this.alpha * this.stroke.color.a;
	                ctx.strokeStyle = `rgba(${this.stroke.color.r}, ${this.stroke.color.g}, ${this.stroke.color.b}, 1)`;
	                ctx.lineWidth = this.stroke.width;
	                ctx.strokeText(line, startX, y);
	                ctx.restore();
	            }
	            // Render main text
	            ctx.globalAlpha = this.alpha * this.color.a;
	            ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 1)`;
	            ctx.fillText(line, startX, y);
	        }
	        ctx.restore();
	        // Render children
	        for (const child of this.children) {
	            child.render(renderer);
	        }
	    }
	    /**
	     * Set text content
	     */
	    setText(text) {
	        this.text = text;
	        this.calculateTextLayout();
	        return this;
	    }
	    /**
	     * Set text style
	     */
	    setStyle(style) {
	        return this.configure(style);
	    }
	    /**
	     * Get measured text size
	     */
	    getMeasuredSize() {
	        return { ...this._measuredSize };
	    }
	    /**
	     * Auto-size component to fit text
	     */
	    autoSize() {
	        this.setSize(this._measuredSize.width, this._measuredSize.height);
	        return this;
	    }
	    /**
	     * Update layout when size changes
	     */
	    updateLayout() {
	        super.updateLayout();
	        this.calculateTextLayout();
	    }
	    /**
	     * Calculate text layout and line breaks
	     */
	    calculateTextLayout() {
	        if (!this.text) {
	            this._lines = [];
	            this._measuredSize = { width: 0, height: 0 };
	            return;
	        }
	        // Create a temporary canvas for text measurement
	        const canvas = this.createMeasurementCanvas();
	        const ctx = canvas.getContext('2d');
	        if (!ctx)
	            return;
	        // Set font for measurement
	        ctx.font = `${this.fontWeight} ${this.fontSize}px ${this.fontFamily}`;
	        // Split text into lines
	        this._lines = this.wordWrap ? this.wrapText(ctx, this.text) : [this.text];
	        // Apply max lines limit
	        if (this.maxLines > 0 && this._lines.length > this.maxLines) {
	            this._lines = this._lines.slice(0, this.maxLines);
	            // Add ellipsis to last line if enabled
	            if (this.ellipsis && this._lines.length > 0) {
	                const lastLine = this._lines[this._lines.length - 1];
	                this._lines[this._lines.length - 1] = this.addEllipsis(ctx, lastLine);
	            }
	        }
	        // Calculate total text size
	        this.calculateMeasuredSize(ctx);
	    }
	    /**
	     * Wrap text to fit within the component width
	     */
	    wrapText(ctx, text) {
	        const words = text.split(' ');
	        const lines = [];
	        let currentLine = '';
	        const maxWidth = this.size.width - this.padding.left - this.padding.right;
	        if (maxWidth <= 0) {
	            return [text]; // No wrapping if no width constraint
	        }
	        for (const word of words) {
	            const testLine = currentLine ? `${currentLine} ${word}` : word;
	            const metrics = ctx.measureText(testLine);
	            if (metrics.width <= maxWidth) {
	                currentLine = testLine;
	            }
	            else {
	                if (currentLine) {
	                    lines.push(currentLine);
	                    currentLine = word;
	                }
	                else {
	                    // Word is too long, break it
	                    lines.push(...this.breakLongWord(ctx, word, maxWidth));
	                    currentLine = '';
	                }
	            }
	        }
	        if (currentLine) {
	            lines.push(currentLine);
	        }
	        return lines.length > 0 ? lines : [''];
	    }
	    /**
	     * Break a long word that doesn't fit on a single line
	     */
	    breakLongWord(ctx, word, maxWidth) {
	        const lines = [];
	        let currentLine = '';
	        for (const char of word) {
	            const testLine = currentLine + char;
	            const metrics = ctx.measureText(testLine);
	            if (metrics.width <= maxWidth) {
	                currentLine = testLine;
	            }
	            else {
	                if (currentLine) {
	                    lines.push(currentLine);
	                }
	                currentLine = char;
	            }
	        }
	        if (currentLine) {
	            lines.push(currentLine);
	        }
	        return lines;
	    }
	    /**
	     * Add ellipsis to a line that's too long
	     */
	    addEllipsis(ctx, line) {
	        const maxWidth = this.size.width - this.padding.left - this.padding.right;
	        const ellipsis = '...';
	        if (ctx.measureText(line).width <= maxWidth) {
	            return line;
	        }
	        // Binary search for the right length
	        let left = 0;
	        let right = line.length;
	        let result = line;
	        while (left <= right) {
	            const mid = Math.floor((left + right) / 2);
	            const testText = line.substring(0, mid) + ellipsis;
	            const width = ctx.measureText(testText).width;
	            if (width <= maxWidth) {
	                result = testText;
	                left = mid + 1;
	            }
	            else {
	                right = mid - 1;
	            }
	        }
	        return result;
	    }
	    /**
	     * Calculate the measured size of the text
	     */
	    calculateMeasuredSize(ctx) {
	        let maxWidth = 0;
	        for (const line of this._lines) {
	            const metrics = ctx.measureText(line);
	            maxWidth = Math.max(maxWidth, metrics.width);
	        }
	        const totalHeight = this._lines.length * this.fontSize * this.lineHeight;
	        this._measuredSize = {
	            width: maxWidth + this.padding.left + this.padding.right,
	            height: totalHeight + this.padding.top + this.padding.bottom
	        };
	        // Auto-resize if using wrap constraints
	        if (this.constraints.width.type === 'wrap') {
	            this.size.width = this._measuredSize.width;
	        }
	        if (this.constraints.height.type === 'wrap') {
	            this.size.height = this._measuredSize.height;
	        }
	    }
	    /**
	     * Get the starting X position based on text alignment
	     */
	    getTextStartX(bounds) {
	        switch (this.textAlign) {
	            case 'left':
	                return bounds.x + this.padding.left;
	            case 'center':
	                return bounds.x + bounds.width / 2;
	            case 'right':
	                return bounds.x + bounds.width - this.padding.right;
	            default:
	                return bounds.x + this.padding.left;
	        }
	    }
	    /**
	     * Create a canvas for text measurement
	     */
	    createMeasurementCanvas() {
	        // In a real implementation, you might want to cache this
	        const canvas = document.createElement('canvas');
	        canvas.width = 1;
	        canvas.height = 1;
	        return canvas;
	    }
	}

	/**
	 * Versatile panel component for backgrounds, containers, and layouts
	 */
	class UIPanel extends BaseUIComponent {
	    constructor(config, id) {
	        super(id);
	        // Panel properties
	        this.backgroundColor = { r: 255, g: 255, b: 255, a: 1 };
	        this.borderColor = { r: 200, g: 200, b: 200, a: 1 };
	        this.borderWidth = 0;
	        this.borderRadius = 0;
	        this.backgroundSize = 'cover';
	        this.backgroundPosition = 'center';
	        // Internal state
	        this._backgroundImageLoaded = false;
	        this._backgroundImageElement = null;
	        this.interactive = false; // Panels are not interactive by default
	        // Apply configuration
	        if (config) {
	            this.configure(config);
	        }
	    }
	    /**
	     * Configure panel properties
	     */
	    configure(config) {
	        if (config.backgroundColor !== undefined)
	            this.backgroundColor = config.backgroundColor;
	        if (config.borderColor !== undefined)
	            this.borderColor = config.borderColor;
	        if (config.borderWidth !== undefined)
	            this.borderWidth = config.borderWidth;
	        if (config.borderRadius !== undefined)
	            this.borderRadius = config.borderRadius;
	        if (config.shadow !== undefined)
	            this.shadow = config.shadow;
	        if (config.gradient !== undefined)
	            this.gradient = config.gradient;
	        if (config.backgroundImage !== undefined)
	            this.setBackgroundImage(config.backgroundImage);
	        if (config.backgroundSize !== undefined)
	            this.backgroundSize = config.backgroundSize;
	        if (config.backgroundPosition !== undefined)
	            this.backgroundPosition = config.backgroundPosition;
	        if (config.opacity !== undefined)
	            this.alpha = config.opacity;
	        return this;
	    }
	    /**
	     * Render the panel
	     */
	    render(renderer) {
	        if (!this.visible || this.alpha <= 0)
	            return;
	        const bounds = this.getBounds();
	        this.getGlobalPosition();
	        const ctx = renderer.context || renderer;
	        if (!ctx)
	            return;
	        ctx.save();
	        ctx.globalAlpha = this.alpha;
	        // Create clipping path if border radius is set
	        if (this.borderRadius > 0) {
	            this.createRoundedPath(ctx, bounds);
	            ctx.clip();
	        }
	        // Render shadow
	        if (this.shadow) {
	            this.renderShadow(ctx, bounds);
	        }
	        // Render background
	        this.renderBackground(ctx, bounds);
	        // Render background image
	        if (this.backgroundImage && this._backgroundImageLoaded && this._backgroundImageElement) {
	            this.renderBackgroundImage(ctx, bounds);
	        }
	        ctx.restore();
	        // Render border (after restoring to avoid clipping)
	        if (this.borderWidth > 0) {
	            this.renderBorder(ctx, bounds);
	        }
	        // Render children
	        for (const child of this.children) {
	            child.render(renderer);
	        }
	    }
	    /**
	     * Set background color
	     */
	    setBackgroundColor(color) {
	        this.backgroundColor = color;
	        return this;
	    }
	    /**
	     * Set border style
	     */
	    setBorder(width, color, radius) {
	        this.borderWidth = width;
	        this.borderColor = color;
	        if (radius !== undefined) {
	            this.borderRadius = radius;
	        }
	        return this;
	    }
	    /**
	     * Set shadow
	     */
	    setShadow(shadow) {
	        this.shadow = shadow;
	        return this;
	    }
	    /**
	     * Set gradient background
	     */
	    setGradient(gradient) {
	        this.gradient = gradient;
	        return this;
	    }
	    /**
	     * Set background image
	     */
	    setBackgroundImage(imageUrl) {
	        this.backgroundImage = imageUrl;
	        this._backgroundImageLoaded = false;
	        if (imageUrl) {
	            this.loadBackgroundImage(imageUrl);
	        }
	        return this;
	    }
	    /**
	     * Make panel interactive (useful for click areas)
	     */
	    makeClickable() {
	        this.interactive = true;
	        return this;
	    }
	    /**
	     * Load background image
	     */
	    loadBackgroundImage(imageUrl) {
	        const img = new Image();
	        img.onload = () => {
	            this._backgroundImageElement = img;
	            this._backgroundImageLoaded = true;
	            this.emit('background-image-loaded', img);
	        };
	        img.onerror = () => {
	            this.emit('background-image-error', imageUrl);
	        };
	        img.src = imageUrl;
	    }
	    /**
	     * Create rounded rectangle path
	     */
	    createRoundedPath(ctx, bounds) {
	        const { x, y, width, height } = bounds;
	        const radius = Math.min(this.borderRadius, width / 2, height / 2);
	        ctx.beginPath();
	        ctx.moveTo(x + radius, y);
	        ctx.lineTo(x + width - radius, y);
	        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
	        ctx.lineTo(x + width, y + height - radius);
	        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
	        ctx.lineTo(x + radius, y + height);
	        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
	        ctx.lineTo(x, y + radius);
	        ctx.quadraticCurveTo(x, y, x + radius, y);
	        ctx.closePath();
	    }
	    /**
	     * Render shadow
	     */
	    renderShadow(ctx, bounds) {
	        if (!this.shadow)
	            return;
	        const { x, y, width, height } = bounds;
	        const { color, offsetX, offsetY, blur, spread = 0 } = this.shadow;
	        ctx.save();
	        // Create shadow path
	        const shadowBounds = {
	            x: x + offsetX - spread,
	            y: y + offsetY - spread,
	            width: width + (spread * 2),
	            height: height + (spread * 2)
	        };
	        ctx.shadowColor = `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;
	        ctx.shadowBlur = blur;
	        ctx.shadowOffsetX = offsetX;
	        ctx.shadowOffsetY = offsetY;
	        ctx.fillStyle = `rgba(${this.backgroundColor.r}, ${this.backgroundColor.g}, ${this.backgroundColor.b}, ${this.backgroundColor.a})`;
	        if (this.borderRadius > 0) {
	            this.createRoundedPath(ctx, shadowBounds);
	            ctx.fill();
	        }
	        else {
	            ctx.fillRect(shadowBounds.x, shadowBounds.y, shadowBounds.width, shadowBounds.height);
	        }
	        ctx.restore();
	    }
	    /**
	     * Render background
	     */
	    renderBackground(ctx, bounds) {
	        const { x, y, width, height } = bounds;
	        // Render gradient if specified
	        if (this.gradient) {
	            const gradient = this.createGradient(ctx, bounds);
	            ctx.fillStyle = gradient;
	        }
	        else {
	            // Solid color background
	            ctx.fillStyle = `rgba(${this.backgroundColor.r}, ${this.backgroundColor.g}, ${this.backgroundColor.b}, ${this.backgroundColor.a})`;
	        }
	        if (this.borderRadius > 0) {
	            this.createRoundedPath(ctx, bounds);
	            ctx.fill();
	        }
	        else {
	            ctx.fillRect(x, y, width, height);
	        }
	    }
	    /**
	     * Create gradient
	     */
	    createGradient(ctx, bounds) {
	        const { x, y, width, height } = bounds;
	        let gradient;
	        if (this.gradient.type === 'linear') {
	            const angle = (this.gradient.direction || 0) * Math.PI / 180;
	            const cos = Math.cos(angle);
	            const sin = Math.sin(angle);
	            const x1 = x + (width / 2) - (cos * width / 2);
	            const y1 = y + (height / 2) - (sin * height / 2);
	            const x2 = x + (width / 2) + (cos * width / 2);
	            const y2 = y + (height / 2) + (sin * height / 2);
	            gradient = ctx.createLinearGradient(x1, y1, x2, y2);
	        }
	        else {
	            // Radial gradient
	            const centerX = x + width / 2;
	            const centerY = y + height / 2;
	            const radius = Math.max(width, height) / 2;
	            gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
	        }
	        // Add color stops
	        for (const colorStop of this.gradient.colors) {
	            const { r, g, b, a } = colorStop.color;
	            gradient.addColorStop(colorStop.stop, `rgba(${r}, ${g}, ${b}, ${a})`);
	        }
	        return gradient;
	    }
	    /**
	     * Render background image
	     */
	    renderBackgroundImage(ctx, bounds) {
	        if (!this._backgroundImageElement)
	            return;
	        const { x, y, width, height } = bounds;
	        const img = this._backgroundImageElement;
	        let drawX = x;
	        let drawY = y;
	        let drawWidth = width;
	        let drawHeight = height;
	        let sourceX = 0;
	        let sourceY = 0;
	        let sourceWidth = img.width;
	        let sourceHeight = img.height;
	        // Calculate dimensions based on background size
	        switch (this.backgroundSize) {
	            case 'cover':
	                const scaleX = width / img.width;
	                const scaleY = height / img.height;
	                const scale = Math.max(scaleX, scaleY);
	                const scaledWidth = img.width * scale;
	                const scaledHeight = img.height * scale;
	                drawX = x + (width - scaledWidth) / 2;
	                drawY = y + (height - scaledHeight) / 2;
	                drawWidth = scaledWidth;
	                drawHeight = scaledHeight;
	                break;
	            case 'contain':
	                const containScaleX = width / img.width;
	                const containScaleY = height / img.height;
	                const containScale = Math.min(containScaleX, containScaleY);
	                const containScaledWidth = img.width * containScale;
	                const containScaledHeight = img.height * containScale;
	                drawX = x + (width - containScaledWidth) / 2;
	                drawY = y + (height - containScaledHeight) / 2;
	                drawWidth = containScaledWidth;
	                drawHeight = containScaledHeight;
	                break;
	        }
	        // Apply background position adjustments
	        switch (this.backgroundPosition) {
	            case 'top':
	                drawY = y;
	                break;
	            case 'bottom':
	                drawY = y + height - drawHeight;
	                break;
	            case 'left':
	                drawX = x;
	                break;
	            case 'right':
	                drawX = x + width - drawWidth;
	                break;
	        }
	        ctx.drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, drawX, drawY, drawWidth, drawHeight);
	    }
	    /**
	     * Render border
	     */
	    renderBorder(ctx, bounds) {
	        const { x, y, width, height } = bounds;
	        ctx.save();
	        ctx.globalAlpha = this.alpha;
	        ctx.strokeStyle = `rgba(${this.borderColor.r}, ${this.borderColor.g}, ${this.borderColor.b}, ${this.borderColor.a})`;
	        ctx.lineWidth = this.borderWidth;
	        if (this.borderRadius > 0) {
	            this.createRoundedPath(ctx, bounds);
	            ctx.stroke();
	        }
	        else {
	            ctx.strokeRect(x + this.borderWidth / 2, y + this.borderWidth / 2, width - this.borderWidth, height - this.borderWidth);
	        }
	        ctx.restore();
	    }
	}

	/**
	 * Mobile-optimized progress bar component with animations and customization
	 */
	class UIProgressBar extends BaseUIComponent {
	    constructor(config, id) {
	        super(id);
	        // Progress properties
	        this.value = 0; // 0-1
	        this.minValue = 0;
	        this.maxValue = 1;
	        this.backgroundColor = { r: 220, g: 220, b: 220, a: 1 };
	        this.fillColor = { r: 0, g: 122, b: 255, a: 1 };
	        this.borderColor = { r: 200, g: 200, b: 200, a: 1 };
	        this.borderWidth = 1;
	        this.borderRadius = 4;
	        this.direction = 'horizontal';
	        // Text properties
	        this.showText = false;
	        this.textColor = { r: 255, g: 255, b: 255, a: 1 };
	        this.fontSize = 14;
	        this.fontFamily = getFrameworkFontFamily();
	        this.textFormat = this.defaultTextFormat;
	        // Animation properties
	        this.animated = true;
	        this.animationDuration = 300;
	        // Internal state
	        this._displayValue = 0;
	        this._targetValue = 0;
	        this._animationStartTime = 0;
	        this._animating = false;
	        this._stripeOffset = 0;
	        this.interactive = false; // Progress bars are not interactive by default
	        // Set default size
	        this.setSize(200, 20);
	        // Apply configuration
	        if (config) {
	            this.configure(config);
	        }
	        this._displayValue = this.value;
	        this._targetValue = this.value;
	    }
	    /**
	     * Configure progress bar properties
	     */
	    configure(config) {
	        if (config.value !== undefined)
	            this.setValue(config.value);
	        if (config.minValue !== undefined)
	            this.minValue = config.minValue;
	        if (config.maxValue !== undefined)
	            this.maxValue = config.maxValue;
	        if (config.backgroundColor !== undefined)
	            this.backgroundColor = config.backgroundColor;
	        if (config.fillColor !== undefined)
	            this.fillColor = config.fillColor;
	        if (config.borderColor !== undefined)
	            this.borderColor = config.borderColor;
	        if (config.borderWidth !== undefined)
	            this.borderWidth = config.borderWidth;
	        if (config.borderRadius !== undefined)
	            this.borderRadius = config.borderRadius;
	        if (config.direction !== undefined)
	            this.direction = config.direction;
	        if (config.showText !== undefined)
	            this.showText = config.showText;
	        if (config.textColor !== undefined)
	            this.textColor = config.textColor;
	        if (config.fontSize !== undefined)
	            this.fontSize = config.fontSize;
	        if (config.fontFamily !== undefined)
	            this.fontFamily = config.fontFamily;
	        if (config.textFormat !== undefined)
	            this.textFormat = config.textFormat;
	        if (config.animated !== undefined)
	            this.animated = config.animated;
	        if (config.animationDuration !== undefined)
	            this.animationDuration = config.animationDuration;
	        if (config.gradient !== undefined)
	            this.gradient = config.gradient;
	        if (config.stripes !== undefined)
	            this.stripes = config.stripes;
	        return this;
	    }
	    /**
	     * Update progress bar animation
	     */
	    update(deltaTime) {
	        super.update(deltaTime);
	        // Update value animation
	        if (this._animating) {
	            const elapsed = Date.now() - this._animationStartTime;
	            const progress = Math.min(elapsed / this.animationDuration, 1);
	            // Easing function (ease-out)
	            const easedProgress = 1 - Math.pow(1 - progress, 3);
	            const startValue = this._displayValue;
	            this._displayValue = startValue + (this._targetValue - startValue) * easedProgress;
	            if (progress >= 1) {
	                this._displayValue = this._targetValue;
	                this._animating = false;
	                this.emit('animation-complete');
	            }
	        }
	        // Update stripe animation
	        if (this.stripes?.enabled && this.stripes.animated) {
	            this._stripeOffset += deltaTime * 0.1; // Adjust speed as needed
	            if (this._stripeOffset > (this.stripes.width || 10)) {
	                this._stripeOffset = 0;
	            }
	        }
	    }
	    /**
	     * Render the progress bar
	     */
	    render(renderer) {
	        if (!this.visible || this.alpha <= 0)
	            return;
	        const bounds = this.getBounds();
	        const ctx = renderer.context || renderer;
	        if (!ctx)
	            return;
	        ctx.save();
	        ctx.globalAlpha = this.alpha;
	        // Render background
	        this.renderBackground(ctx, bounds);
	        // Render fill
	        this.renderFill(ctx, bounds);
	        // Render border
	        if (this.borderWidth > 0) {
	            this.renderBorder(ctx, bounds);
	        }
	        // Render text
	        if (this.showText) {
	            this.renderText(ctx, bounds);
	        }
	        ctx.restore();
	        // Render children
	        for (const child of this.children) {
	            child.render(renderer);
	        }
	    }
	    /**
	     * Set progress value (0-1 or between min/max)
	     */
	    setValue(value, animate = this.animated) {
	        // Normalize value
	        const normalizedValue = Math.max(0, Math.min(1, (value - this.minValue) / (this.maxValue - this.minValue)));
	        this.value = normalizedValue;
	        this._targetValue = normalizedValue;
	        if (animate && this.animationDuration > 0) {
	            this._animationStartTime = Date.now();
	            this._animating = true;
	        }
	        else {
	            this._displayValue = normalizedValue;
	            this._animating = false;
	        }
	        this.emit('value-changed', value);
	        return this;
	    }
	    /**
	     * Get current progress value
	     */
	    getValue() {
	        return this.minValue + (this.value * (this.maxValue - this.minValue));
	    }
	    /**
	     * Set progress to minimum
	     */
	    setToMin(animate) {
	        return this.setValue(this.minValue, animate);
	    }
	    /**
	     * Set progress to maximum
	     */
	    setToMax(animate) {
	        return this.setValue(this.maxValue, animate);
	    }
	    /**
	     * Increment progress
	     */
	    increment(amount, animate) {
	        const currentValue = this.getValue();
	        return this.setValue(currentValue + amount, animate);
	    }
	    /**
	     * Set style
	     */
	    setStyle(style) {
	        return this.configure(style);
	    }
	    /**
	     * Enable/disable stripes
	     */
	    setStripes(enabled, config) {
	        this.stripes = {
	            enabled,
	            color: config?.color || { r: 255, g: 255, b: 255, a: 0.3 },
	            width: config?.width || 10,
	            animated: config?.animated || true
	        };
	        return this;
	    }
	    /**
	     * Default text format function
	     */
	    defaultTextFormat(value, min, max) {
	        const percentage = Math.round(((value - min) / (max - min)) * 100);
	        return `${percentage}%`;
	    }
	    /**
	     * Render background
	     */
	    renderBackground(ctx, bounds) {
	        const { x, y, width, height } = bounds;
	        ctx.fillStyle = `rgba(${this.backgroundColor.r}, ${this.backgroundColor.g}, ${this.backgroundColor.b}, ${this.backgroundColor.a})`;
	        if (this.borderRadius > 0) {
	            this.drawRoundedRect(ctx, x, y, width, height, this.borderRadius);
	            ctx.fill();
	        }
	        else {
	            ctx.fillRect(x, y, width, height);
	        }
	    }
	    /**
	     * Render fill
	     */
	    renderFill(ctx, bounds) {
	        const { x, y, width, height } = bounds;
	        const progress = this._displayValue;
	        if (progress <= 0)
	            return;
	        // Calculate fill dimensions
	        let fillX = x;
	        let fillY = y;
	        let fillWidth = width;
	        let fillHeight = height;
	        if (this.direction === 'horizontal') {
	            fillWidth = width * progress;
	        }
	        else {
	            fillHeight = height * progress;
	            fillY = y + height - fillHeight;
	        }
	        // Create fill style (gradient or solid)
	        if (this.gradient) {
	            ctx.fillStyle = this.createFillGradient(ctx, { x: fillX, y: fillY, width: fillWidth, height: fillHeight });
	        }
	        else {
	            ctx.fillStyle = `rgba(${this.fillColor.r}, ${this.fillColor.g}, ${this.fillColor.b}, ${this.fillColor.a})`;
	        }
	        // Draw fill
	        ctx.save();
	        // Clip to progress bar bounds
	        if (this.borderRadius > 0) {
	            this.drawRoundedRect(ctx, x, y, width, height, this.borderRadius);
	            ctx.clip();
	        }
	        ctx.fillRect(fillX, fillY, fillWidth, fillHeight);
	        // Draw stripes if enabled
	        if (this.stripes?.enabled) {
	            this.renderStripes(ctx, { x: fillX, y: fillY, width: fillWidth, height: fillHeight });
	        }
	        ctx.restore();
	    }
	    /**
	     * Render stripes
	     */
	    renderStripes(ctx, fillBounds) {
	        if (!this.stripes)
	            return;
	        const { x, y, width, height } = fillBounds;
	        const stripeWidth = this.stripes.width || 10;
	        const stripeColor = this.stripes.color || { r: 255, g: 255, b: 255, a: 0.3 };
	        ctx.save();
	        ctx.fillStyle = `rgba(${stripeColor.r}, ${stripeColor.g}, ${stripeColor.b}, ${stripeColor.a})`;
	        const offset = this.stripes.animated ? -this._stripeOffset : 0;
	        if (this.direction === 'horizontal') {
	            // Diagonal stripes for horizontal progress
	            for (let i = offset; i < width + height; i += stripeWidth * 2) {
	                ctx.beginPath();
	                ctx.moveTo(x + i, y);
	                ctx.lineTo(x + i + stripeWidth, y);
	                ctx.lineTo(x + i + stripeWidth - height, y + height);
	                ctx.lineTo(x + i - height, y + height);
	                ctx.closePath();
	                ctx.fill();
	            }
	        }
	        else {
	            // Horizontal stripes for vertical progress
	            for (let i = offset; i < height; i += stripeWidth * 2) {
	                ctx.fillRect(x, y + i, width, stripeWidth);
	            }
	        }
	        ctx.restore();
	    }
	    /**
	     * Create gradient for fill
	     */
	    createFillGradient(ctx, bounds) {
	        const { x, y, width, height } = bounds;
	        let gradient;
	        if (this.direction === 'horizontal') {
	            gradient = ctx.createLinearGradient(x, y, x + width, y);
	        }
	        else {
	            gradient = ctx.createLinearGradient(x, y + height, x, y);
	        }
	        if (this.gradient) {
	            for (const colorStop of this.gradient.colors) {
	                const { r, g, b, a } = colorStop.color;
	                gradient.addColorStop(colorStop.stop, `rgba(${r}, ${g}, ${b}, ${a})`);
	            }
	        }
	        return gradient;
	    }
	    /**
	     * Render border
	     */
	    renderBorder(ctx, bounds) {
	        const { x, y, width, height } = bounds;
	        ctx.strokeStyle = `rgba(${this.borderColor.r}, ${this.borderColor.g}, ${this.borderColor.b}, ${this.borderColor.a})`;
	        ctx.lineWidth = this.borderWidth;
	        if (this.borderRadius > 0) {
	            this.drawRoundedRect(ctx, x, y, width, height, this.borderRadius);
	            ctx.stroke();
	        }
	        else {
	            ctx.strokeRect(x + this.borderWidth / 2, y + this.borderWidth / 2, width - this.borderWidth, height - this.borderWidth);
	        }
	    }
	    /**
	     * Render text
	     */
	    renderText(ctx, bounds) {
	        const { x, y, width, height } = bounds;
	        const currentValue = this.minValue + (this._displayValue * (this.maxValue - this.minValue));
	        const text = this.textFormat(currentValue, this.minValue, this.maxValue);
	        ctx.save();
	        ctx.fillStyle = `rgba(${this.textColor.r}, ${this.textColor.g}, ${this.textColor.b}, ${this.textColor.a})`;
	        ctx.font = `${this.fontSize}px ${this.fontFamily}`;
	        ctx.textAlign = 'center';
	        ctx.textBaseline = 'middle';
	        const centerX = x + width / 2;
	        const centerY = y + height / 2;
	        // Draw text with outline for better visibility
	        ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
	        ctx.lineWidth = 1;
	        ctx.strokeText(text, centerX, centerY);
	        ctx.fillText(text, centerX, centerY);
	        ctx.restore();
	    }
	    /**
	     * Draw rounded rectangle
	     */
	    drawRoundedRect(ctx, x, y, width, height, radius) {
	        const r = Math.min(radius, width / 2, height / 2);
	        ctx.beginPath();
	        ctx.moveTo(x + r, y);
	        ctx.lineTo(x + width - r, y);
	        ctx.quadraticCurveTo(x + width, y, x + width, y + r);
	        ctx.lineTo(x + width, y + height - r);
	        ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
	        ctx.lineTo(x + r, y + height);
	        ctx.quadraticCurveTo(x, y + height, x, y + height - r);
	        ctx.lineTo(x, y + r);
	        ctx.quadraticCurveTo(x, y, x + r, y);
	        ctx.closePath();
	    }
	}

	/**
	 * Abstract base class for game screens
	 */
	class BaseUIScreen extends BaseUIComponent {
	    constructor(screenName, id) {
	        super(id || screenName);
	        // Screen lifecycle state
	        this._isShowing = false;
	        this._isVisible = false;
	        this._showData = null;
	        this.screenName = screenName;
	        // Screens fill the entire display by default
	        this.constraints = {
	            x: { type: 'fixed', value: 0 },
	            y: { type: 'fixed', value: 0 },
	            width: { type: 'fill' },
	            height: { type: 'fill' }
	        };
	    }
	    /**
	     * Called when screen is about to be shown
	     */
	    async onShow(data) {
	        this._showData = data;
	        this._isShowing = true;
	        this._isVisible = true;
	        this.setVisible(true);
	        // Animate in
	        await this.animateIn();
	        this.emit('shown', data);
	    }
	    /**
	     * Called when screen is about to be hidden
	     */
	    async onHide() {
	        this._isShowing = false;
	        // Animate out
	        await this.animateOut();
	        this._isVisible = false;
	        this.setVisible(false);
	        this._showData = null;
	        this.emit('hidden');
	    }
	    /**
	     * Called when device orientation changes
	     */
	    onOrientationChange(orientation) {
	        this.handleOrientationChange(orientation);
	        this.emit('orientation-changed', orientation);
	    }
	    /**
	     * Handle back button (return true if handled)
	     */
	    onBackButton() {
	        return this.handleBackButton();
	    }
	    /**
	     * Check if screen is currently showing
	     */
	    isShowing() {
	        return this._isShowing;
	    }
	    /**
	     * Get the data passed to onShow
	     */
	    getShowData() {
	        return this._showData;
	    }
	    /**
	     * Animate screen in (to be overridden by subclasses)
	     */
	    async animateIn() {
	        // Default fade in animation
	        this.setAlpha(0);
	        return this.animate({ alpha: 1 }, {
	            duration: 300,
	            easing: 'ease-out'
	        });
	    }
	    /**
	     * Animate screen out (to be overridden by subclasses)
	     */
	    async animateOut() {
	        // Default fade out animation
	        return this.animate({ alpha: 0 }, {
	            duration: 200,
	            easing: 'ease-in'
	        });
	    }
	    /**
	     * Handle orientation change (to be overridden by subclasses)
	     */
	    handleOrientationChange(orientation) {
	        // Default implementation - subclasses can override
	        this.requestLayout();
	    }
	    /**
	     * Handle back button (to be overridden by subclasses)
	     */
	    handleBackButton() {
	        // Default implementation - not handled
	        return false;
	    }
	    /**
	     * Create safe area padding based on device info
	     */
	    applySafeAreaPadding(deviceInfo) {
	        const safeArea = deviceInfo.safeArea;
	        this.setPadding({
	            top: safeArea.top,
	            right: safeArea.right,
	            bottom: safeArea.bottom,
	            left: safeArea.left
	        });
	    }
	    /**
	     * Create responsive design adjustments
	     */
	    applyResponsiveDesign(deviceInfo) {
	        // Adjust component sizes based on screen size and performance tier
	        const { screenSize, performanceTier } = deviceInfo;
	        const isSmallScreen = Math.min(screenSize.width, screenSize.height) < 400;
	        if (isSmallScreen) {
	            // Reduce sizes for small screens
	            this.emit('responsive-adjust', { type: 'small-screen', deviceInfo });
	        }
	        if (performanceTier === 'low') {
	            // Reduce visual effects for low-end devices
	            this.emit('responsive-adjust', { type: 'low-performance', deviceInfo });
	        }
	    }
	    /**
	     * Show loading overlay
	     */
	    showLoadingOverlay(message) {
	        // Implementation would create a loading overlay
	        this.emit('show-loading', message);
	    }
	    /**
	     * Hide loading overlay
	     */
	    hideLoadingOverlay() {
	        this.emit('hide-loading');
	    }
	    /**
	     * Show error message
	     */
	    showError(message, title) {
	        this.emit('show-error', { message, title });
	    }
	    /**
	     * Show success message
	     */
	    showSuccess(message, title) {
	        this.emit('show-success', { message, title });
	    }
	    /**
	     * Create a centered container for main content
	     */
	    createCenteredContainer() {
	        const container = new UIContainer('centered-container');
	        container.setPositionConstraint('center', 'center');
	        container.setSizeConstraint('wrap', 'wrap');
	        this.addChild(container);
	        return container;
	    }
	    /**
	     * Create a full-screen background
	     */
	    createBackground(config) {
	        const background = new UIPanel(config, 'screen-background');
	        background.setPositionConstraint('fixed', 'fixed');
	        background.setSizeConstraint('fill', 'fill');
	        background.setPosition(0, 0);
	        // Add background first so it renders behind other elements
	        this.children.unshift(background);
	        return background;
	    }
	    /**
	     * Create a header area
	     */
	    createHeader(height = 80) {
	        const header = new UIContainer('screen-header');
	        header.setPositionConstraint('fixed', 'fixed');
	        header.setSizeConstraint('fill', 'fixed');
	        header.setPosition(0, 0);
	        header.setSize(0, height);
	        this.addChild(header);
	        return header;
	    }
	    /**
	     * Create a footer area
	     */
	    createFooter(height = 80) {
	        const footer = new UIContainer('screen-footer');
	        footer.setPositionConstraint('fixed', 'fixed');
	        footer.setSizeConstraint('fill', 'fixed');
	        footer.setPosition(0, 0); // Will be positioned at bottom by constraint
	        footer.setSize(0, height);
	        // Position at bottom
	        footer.constraints.y = { type: 'fixed', value: -height };
	        this.addChild(footer);
	        return footer;
	    }
	    /**
	     * Handle common screen setup
	     */
	    setupScreen() {
	        // Override in subclasses for specific setup
	        this.emit('screen-setup');
	    }
	    /**
	     * Handle common screen cleanup
	     */
	    cleanupScreen() {
	        // Override in subclasses for specific cleanup
	        this.emit('screen-cleanup');
	    }
	    /**
	     * Initialize the screen
	     */
	    initialize() {
	        super.initialize();
	        this.setupScreen();
	    }
	    /**
	     * Destroy the screen
	     */
	    destroy() {
	        this.cleanupScreen();
	        super.destroy();
	    }
	}

	/**
	 * Professional splash screen with logo, branding, and loading indicator
	 */
	class SplashScreen extends BaseUIScreen {
	    constructor(config = {}) {
	        super('splash');
	        // Internal state
	        this._autoAdvanceTimer = null;
	        this._loadingProgress = 0;
	        this.config = {
	            brandName: 'GameByte',
	            backgroundColor: { r: 18, g: 18, b: 18, a: 1 }, // Dark background
	            textColor: { r: 255, g: 255, b: 255, a: 1 },
	            duration: 3000,
	            fadeInDuration: 800,
	            fadeOutDuration: 600,
	            showProgressBar: true,
	            loadingText: 'Loading...',
	            ...config
	        };
	        this.setupSplashScreen();
	    }
	    /**
	     * Setup splash screen components
	     */
	    setupSplashScreen() {
	        // Create background
	        this.background = this.createBackground({
	            backgroundColor: this.config.backgroundColor
	        });
	        // Create centered container for content
	        const contentContainer = this.createCenteredContainer();
	        // Create logo container
	        this.logoContainer = new UIPanel({
	            backgroundColor: { r: 0, g: 0, b: 0, a: 0 } // Transparent
	        }, 'logo-container');
	        if (this.config.logo) {
	            this.logoContainer.setBackgroundImage(this.config.logo);
	            this.logoContainer.setSize(200, 200);
	        }
	        else {
	            // Create a simple colored square as default logo
	            this.logoContainer.configure({
	                backgroundColor: { r: 0, g: 122, b: 255, a: 1 },
	                borderRadius: 20
	            });
	            this.logoContainer.setSize(120, 120);
	        }
	        contentContainer.addChild(this.logoContainer);
	        // Create brand name text
	        if (this.config.brandName) {
	            this.brandText = new UIText({
	                text: this.config.brandName,
	                fontSize: 32,
	                fontWeight: 'bold',
	                color: this.config.textColor,
	                textAlign: 'center'
	            }, 'brand-text');
	            this.brandText.setPosition(0, 40); // Below logo
	            this.brandText.autoSize();
	            contentContainer.addChild(this.brandText);
	        }
	        // Create loading text
	        this.loadingText = new UIText({
	            text: this.config.loadingText || 'Loading...',
	            fontSize: 16,
	            color: this.config.textColor,
	            textAlign: 'center'
	        }, 'loading-text');
	        this.loadingText.setPosition(0, this.config.brandName ? 100 : 60);
	        this.loadingText.autoSize();
	        contentContainer.addChild(this.loadingText);
	        // Create progress bar if enabled
	        if (this.config.showProgressBar) {
	            this.progressBar = new UIProgressBar({
	                backgroundColor: { r: 60, g: 60, b: 60, a: 1 },
	                fillColor: { r: 0, g: 122, b: 255, a: 1 },
	                borderRadius: 4,
	                value: 0
	            }, 'splash-progress');
	            this.progressBar.setSize(200, 4);
	            this.progressBar.setPosition(0, this.loadingText.position.y + 40);
	            contentContainer.addChild(this.progressBar);
	        }
	        // Auto-size content container
	        contentContainer.autoSize();
	    }
	    /**
	     * Animate screen in with logo animation
	     */
	    async animateIn() {
	        // Start with everything invisible
	        this.setAlpha(0);
	        this.logoContainer.setScale(0.5);
	        this.logoContainer.setAlpha(0);
	        if (this.brandText) {
	            this.brandText.setAlpha(0);
	        }
	        this.loadingText.setAlpha(0);
	        if (this.progressBar) {
	            this.progressBar.setAlpha(0);
	        }
	        // Fade in background
	        await this.animate({ alpha: 1 }, {
	            duration: this.config.fadeInDuration / 3,
	            easing: 'ease-out'
	        });
	        // Animate logo in with scale and fade
	        const logoPromises = [
	            this.logoContainer.animate({ scale: { x: 1, y: 1 } }, {
	                duration: this.config.fadeInDuration * 0.6,
	                easing: 'spring'
	            }),
	            this.logoContainer.animate({ alpha: 1 }, {
	                duration: this.config.fadeInDuration * 0.4,
	                easing: 'ease-out'
	            })
	        ];
	        await Promise.all(logoPromises);
	        // Animate text elements in sequence
	        if (this.brandText) {
	            await this.brandText.animate({ alpha: 1 }, {
	                duration: 400,
	                easing: 'ease-out'
	            });
	        }
	        await this.loadingText.animate({ alpha: 1 }, {
	            duration: 300,
	            easing: 'ease-out'
	        });
	        if (this.progressBar) {
	            await this.progressBar.animate({ alpha: 1 }, {
	                duration: 300,
	                easing: 'ease-out'
	            });
	        }
	        // Start auto-advance timer if specified
	        if (this.config.duration && this.config.duration > 0) {
	            this._autoAdvanceTimer = window.setTimeout(() => {
	                this.emit('auto-advance');
	            }, this.config.duration);
	        }
	    }
	    /**
	     * Animate screen out
	     */
	    async animateOut() {
	        // Clear auto-advance timer
	        if (this._autoAdvanceTimer) {
	            clearTimeout(this._autoAdvanceTimer);
	            this._autoAdvanceTimer = null;
	        }
	        // Animate logo out with scale and fade
	        const logoPromises = [
	            this.logoContainer.animate({ scale: { x: 1.2, y: 1.2 } }, {
	                duration: this.config.fadeOutDuration * 0.6,
	                easing: 'ease-in'
	            }),
	            this.logoContainer.animate({ alpha: 0 }, {
	                duration: this.config.fadeOutDuration * 0.8,
	                easing: 'ease-in'
	            })
	        ];
	        // Fade out text elements
	        const textPromises = [];
	        if (this.brandText) {
	            textPromises.push(this.brandText.animate({ alpha: 0 }, {
	                duration: this.config.fadeOutDuration * 0.5,
	                easing: 'ease-in'
	            }));
	        }
	        textPromises.push(this.loadingText.animate({ alpha: 0 }, {
	            duration: this.config.fadeOutDuration * 0.5,
	            easing: 'ease-in'
	        }));
	        if (this.progressBar) {
	            textPromises.push(this.progressBar.animate({ alpha: 0 }, {
	                duration: this.config.fadeOutDuration * 0.5,
	                easing: 'ease-in'
	            }));
	        }
	        // Wait for all animations
	        await Promise.all([...logoPromises, ...textPromises]);
	        // Fade out entire screen
	        await this.animate({ alpha: 0 }, {
	            duration: this.config.fadeOutDuration * 0.3,
	            easing: 'ease-in'
	        });
	    }
	    /**
	     * Set loading progress (0-1)
	     */
	    setLoadingProgress(progress) {
	        this._loadingProgress = Math.max(0, Math.min(1, progress));
	        if (this.progressBar) {
	            this.progressBar.setValue(this._loadingProgress, true);
	        }
	        this.emit('loading-progress', this._loadingProgress);
	    }
	    /**
	     * Set loading text
	     */
	    setLoadingText(text) {
	        this.loadingText.setText(text);
	    }
	    /**
	     * Show completion state
	     */
	    showComplete() {
	        this.setLoadingText('Complete!');
	        this.setLoadingProgress(1);
	        // Trigger completion animation
	        if (this.brandText) {
	            this.brandText.animate({ scale: { x: 1.05, y: 1.05 } }, {
	                duration: 200,
	                easing: 'ease-out',
	                yoyo: true
	            });
	        }
	    }
	    /**
	     * Manual advance (skip auto-timer)
	     */
	    advance() {
	        if (this._autoAdvanceTimer) {
	            clearTimeout(this._autoAdvanceTimer);
	            this._autoAdvanceTimer = null;
	        }
	        this.emit('advance');
	    }
	    /**
	     * Get current loading progress
	     */
	    getLoadingProgress() {
	        return this._loadingProgress;
	    }
	    /**
	     * Handle tap to skip (mobile-friendly)
	     */
	    setupTapToSkip() {
	        this.makeInteractive();
	        this.on('tap', () => {
	            this.advance();
	        });
	    }
	    /**
	     * Override render to add subtle animations
	     */
	    render(renderer) {
	        if (!this.visible || this.alpha <= 0)
	            return;
	        // Render all child components
	        for (const child of this.children) {
	            child.render(renderer);
	        }
	        // Add subtle breathing effect to logo
	        const time = Date.now() * 0.001;
	        const breathe = 1 + Math.sin(time * 2) * 0.02;
	        if (this.logoContainer && this._isShowing) {
	            // Apply subtle scale variation for breathing effect
	            const currentScale = this.logoContainer.scale.x;
	            if (Math.abs(currentScale - 1) < 0.1) { // Only if not animating
	                this.logoContainer.setScale(breathe);
	            }
	        }
	    }
	    /**
	     * Cleanup
	     */
	    destroy() {
	        if (this._autoAdvanceTimer) {
	            clearTimeout(this._autoAdvanceTimer);
	            this._autoAdvanceTimer = null;
	        }
	        super.destroy();
	    }
	}

	// MainMenuScreen temporarily disabled - needs refactoring to work with UIComponent
	// import { MainMenuScreen } from '../ui/screens/MainMenuScreen';
	/**
	 * Service provider for the UI system
	 */
	class UIServiceProvider extends AbstractServiceProvider {
	    /**
	     * Register UI services in the container
	     */
	    register(app) {
	        // Register UI Manager
	        app.singleton('ui.manager', () => {
	            const canvas = app.getCanvas();
	            return new GameByteUIManager(canvas || undefined);
	        });
	        // Register Animation System
	        app.singleton('ui.animations', () => {
	            return new GameByteUIAnimationSystem();
	        });
	        // Register Theme Manager
	        app.singleton('ui.themes', () => {
	            return new UIThemeManager();
	        });
	        // Register aliases for easier access
	        app.getContainer().alias('ui', 'ui.manager');
	        app.getContainer().alias('animations', 'ui.animations');
	        app.getContainer().alias('themes', 'ui.themes');
	    }
	    /**
	     * Boot the UI services
	     */
	    async boot(app) {
	        const uiManager = app.make('ui.manager');
	        const animationSystem = app.make('ui.animations');
	        const themeManager = app.make('ui.themes');
	        // Integrate animation system with UI manager
	        this.integrateAnimationSystem(uiManager, animationSystem);
	        // Set default theme
	        uiManager.setTheme(themeManager.getCurrentTheme());
	        // Register default component factories
	        this.registerComponentFactories(uiManager);
	        // Setup UI update loop integration
	        this.setupUpdateLoop(app, uiManager, animationSystem);
	        // Emit UI system ready event
	        app.emit('ui-system-ready', { uiManager, animationSystem, themeManager });
	    }
	    /**
	     * Integrate animation system with UI components
	     */
	    integrateAnimationSystem(uiManager, animationSystem) {
	        // Patch the BaseUIComponent animate method to use our animation system
	        if (BaseUIComponent.prototype) {
	            BaseUIComponent.prototype.animate = function (properties, config) {
	                return animationSystem.to(this, properties, config);
	            };
	            BaseUIComponent.prototype.stopAllAnimations = function () {
	                animationSystem.killTweensOf(this);
	            };
	        }
	    }
	    /**
	     * Register component factories with the UI manager
	     */
	    registerComponentFactories(uiManager) {
	        // Register core components
	        uiManager.registerComponent('container', () => new UIContainer());
	        // TODO: UIButton needs to extend UIComponent to be registered here
	        // Temporarily commented out until UIButton is refactored to match UIComponent interface
	        // uiManager.registerComponent('button', () =>
	        //   new UIButton()
	        // );
	        uiManager.registerComponent('text', () => new UIText());
	        uiManager.registerComponent('panel', () => new UIPanel());
	        uiManager.registerComponent('progress-bar', () => new UIProgressBar());
	        // Register screen components
	        uiManager.registerComponent('splash-screen', () => new SplashScreen());
	        // TODO: MainMenuScreen temporarily disabled - needs refactoring
	        // uiManager.registerComponent('main-menu-screen', () =>
	        //   new MainMenuScreen()
	        // );
	    }
	    /**
	     * Setup the update loop integration
	     */
	    setupUpdateLoop(app, uiManager, animationSystem) {
	        // Hook into the framework's update loop
	        let lastTime = Date.now();
	        const updateUI = () => {
	            if (!app.isRunning())
	                return;
	            const currentTime = Date.now();
	            const deltaTime = currentTime - lastTime;
	            lastTime = currentTime;
	            // Update UI system
	            uiManager.update(deltaTime);
	            // Update animation system
	            animationSystem.update(deltaTime);
	            // Continue loop
	            requestAnimationFrame(updateUI);
	        };
	        // Start the UI update loop when the app starts
	        app.on('started', () => {
	            lastTime = Date.now();
	            updateUI();
	        });
	        // Hook into renderer for UI rendering
	        app.on('initialized', () => {
	            const renderer = app.make('renderer');
	            // Override or extend the renderer's render method to include UI
	            const originalRender = renderer.render?.bind(renderer);
	            if (originalRender) {
	                renderer.render = (scene) => {
	                    // Render the game scene first
	                    originalRender(scene);
	                    // Then render the UI on top
	                    uiManager.render(renderer);
	                };
	            }
	            else {
	                // Fallback if no render method exists
	                renderer.renderUI = () => {
	                    uiManager.render(renderer);
	                };
	            }
	        });
	    }
	    /**
	     * Services this provider offers
	     */
	    provides() {
	        return [
	            'ui.manager',
	            'ui.animations',
	            'ui.themes',
	            'ui',
	            'animations',
	            'themes'
	        ];
	    }
	}

	var UIServiceProvider$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIServiceProvider: UIServiceProvider
	});

	/**
	 * Advanced touch input handler with gesture recognition and palm rejection
	 */
	class GameByteTouchInputHandler extends EventEmitter {
	    constructor() {
	        super();
	        this.element = null;
	        this.isInitialized = false;
	        // Touch tracking
	        this.activeTouches = new Map();
	        this.primaryTouchId = null;
	        // Gesture tracking
	        this.activeGestures = [];
	        this.lastTapTime = 0;
	        this.lastTapPosition = { x: 0, y: 0 };
	        this.longPressTimer = null;
	        // Configuration
	        this.sensitivity = 1.0;
	        this.palmRejectionEnabled = true;
	        this.gestureThresholds = {
	            tap: 10, // pixels
	            longPress: 500, // milliseconds
	            swipe: 50, // pixels
	            pinch: 0.2, // scale change
	            rotate: 15, // degrees
	            doubleTap: 300 // milliseconds between taps
	        };
	        // Touch and gesture tracking for update method
	        this.touchTracker = new Map();
	        this.gestureTimeout = 1000; // ms
	        this.gestureStartTime = 0;
	        // Palm rejection settings
	        this.palmRejectionThreshold = {
	            maxTouchSize: 30, // max touch radius to not be considered palm
	            minTouchDistance: 40, // min distance between touches
	            maxSimultaneousTouches: 5 // max touches before considering palm
	        };
	        // Performance tracking
	        this.gestureRecognitionTimes = [];
	    }
	    /**
	     * Initialize the touch handler with DOM element
	     */
	    async initialize(element) {
	        if (this.isInitialized) {
	            return;
	        }
	        this.element = element;
	        this.setupEventListeners();
	        this.isInitialized = true;
	        this.emit('initialized');
	    }
	    /**
	     * Destroy the touch handler and clean up resources
	     */
	    destroy() {
	        if (!this.isInitialized) {
	            return;
	        }
	        this.removeEventListeners();
	        this.clearAllTouches();
	        this.clearAllGestures();
	        if (this.longPressTimer) {
	            clearTimeout(this.longPressTimer);
	            this.longPressTimer = null;
	        }
	        this.element = null;
	        this.isInitialized = false;
	        this.emit('destroyed');
	        this.removeAllListeners();
	    }
	    /**
	     * Process touch event and return array of raw input events
	     */
	    processTouchEvent(event) {
	        const rawEvents = [];
	        const timestamp = performance.now();
	        // Process each changed touch
	        for (let i = 0; i < event.changedTouches.length; i++) {
	            const touch = event.changedTouches[i];
	            // Apply palm rejection
	            if (this.palmRejectionEnabled && this.isPalmTouch(touch, event)) {
	                continue;
	            }
	            const rawEvent = {
	                type: this.mapTouchEventType(event.type),
	                device: 'touch',
	                timestamp,
	                position: { x: touch.clientX, y: touch.clientY },
	                pointerId: touch.identifier,
	                pressure: touch.pressure || 1.0
	            };
	            rawEvents.push(rawEvent);
	            // Update touch tracking
	            this.updateTouchTracking(touch, event.type, timestamp);
	        }
	        // Update gesture recognition
	        this.updateGestureRecognition();
	        return rawEvents;
	    }
	    /**
	     * Process pointer event and return raw input event
	     */
	    processPointerEvent(event) {
	        const timestamp = performance.now();
	        const rawEvent = {
	            type: this.mapPointerEventType(event.type),
	            device: event.pointerType === 'touch' ? 'touch' : 'mouse',
	            timestamp,
	            position: { x: event.clientX, y: event.clientY },
	            pointerId: event.pointerId,
	            pressure: event.pressure
	        };
	        // Update touch tracking for touch pointers
	        if (event.pointerType === 'touch') {
	            this.updatePointerTracking(event, timestamp);
	        }
	        // Update gesture recognition
	        this.updateGestureRecognition();
	        return rawEvent;
	    }
	    /**
	     * Recognize current gesture based on active touches
	     */
	    recognizeGesture() {
	        const startTime = performance.now();
	        let recognizedGesture = null;
	        // Check for completed gestures
	        for (let i = this.activeGestures.length - 1; i >= 0; i--) {
	            const gesture = this.activeGestures[i];
	            if (gesture.completed) {
	                recognizedGesture = this.createGestureEvent(gesture);
	                this.activeGestures.splice(i, 1);
	                break;
	            }
	        }
	        // Track performance
	        const recognitionTime = performance.now() - startTime;
	        this.gestureRecognitionTimes.push(recognitionTime);
	        if (this.gestureRecognitionTimes.length > 100) {
	            this.gestureRecognitionTimes.shift();
	        }
	        return recognizedGesture;
	    }
	    /**
	     * Configure gesture recognition parameters
	     */
	    configureGesture(type, config) {
	        switch (type) {
	            case 'tap':
	                if (config.threshold !== undefined) {
	                    this.gestureThresholds.tap = config.threshold;
	                }
	                break;
	            case 'long-press':
	                if (config.duration !== undefined) {
	                    this.gestureThresholds.longPress = config.duration;
	                }
	                break;
	            case 'swipe':
	                if (config.threshold !== undefined) {
	                    this.gestureThresholds.swipe = config.threshold;
	                }
	                break;
	            case 'pinch':
	                if (config.threshold !== undefined) {
	                    this.gestureThresholds.pinch = config.threshold;
	                }
	                break;
	            case 'rotate':
	                if (config.threshold !== undefined) {
	                    this.gestureThresholds.rotate = config.threshold;
	                }
	                break;
	            case 'double-tap':
	                if (config.interval !== undefined) {
	                    this.gestureThresholds.doubleTap = config.interval;
	                }
	                break;
	        }
	    }
	    /**
	     * Get number of active touches
	     */
	    getTouchCount() {
	        return this.activeTouches.size;
	    }
	    /**
	     * Get touch by ID
	     */
	    getTouch(id) {
	        const touchData = this.activeTouches.get(id);
	        if (!touchData)
	            return null;
	        // Create a Touch-like object
	        return {
	            identifier: touchData.id,
	            clientX: touchData.currentPosition.x,
	            clientY: touchData.currentPosition.y,
	            screenX: touchData.currentPosition.x,
	            screenY: touchData.currentPosition.y,
	            pageX: touchData.currentPosition.x,
	            pageY: touchData.currentPosition.y,
	            radiusX: 10,
	            radiusY: 10,
	            rotationAngle: 0,
	            force: touchData.pressure,
	            target: this.element
	        };
	    }
	    /**
	     * Get primary touch (first touch)
	     */
	    getPrimaryTouch() {
	        if (this.primaryTouchId === null)
	            return null;
	        return this.getTouch(this.primaryTouchId);
	    }
	    /**
	     * Set touch sensitivity
	     */
	    setSensitivity(sensitivity) {
	        this.sensitivity = Math.max(0.1, Math.min(5.0, sensitivity));
	    }
	    /**
	     * Set gesture thresholds
	     */
	    setGestureThresholds(thresholds) {
	        this.gestureThresholds = { ...this.gestureThresholds, ...thresholds };
	    }
	    /**
	     * Enable or disable palm rejection
	     */
	    enablePalmRejection(enabled) {
	        this.palmRejectionEnabled = enabled;
	    }
	    /**
	     * Get average gesture recognition time
	     */
	    getAverageRecognitionTime() {
	        if (this.gestureRecognitionTimes.length === 0)
	            return 0;
	        const sum = this.gestureRecognitionTimes.reduce((a, b) => a + b, 0);
	        return sum / this.gestureRecognitionTimes.length;
	    }
	    /**
	     * Setup DOM event listeners
	     */
	    setupEventListeners() {
	        if (!this.element)
	            return;
	        // Touch events
	        this.element.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
	        this.element.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
	        this.element.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
	        this.element.addEventListener('touchcancel', this.handleTouchCancel.bind(this), { passive: false });
	        // Pointer events (fallback/enhancement)
	        if ('onpointerdown' in this.element) {
	            this.element.addEventListener('pointerdown', this.handlePointerDown.bind(this));
	            this.element.addEventListener('pointermove', this.handlePointerMove.bind(this));
	            this.element.addEventListener('pointerup', this.handlePointerUp.bind(this));
	            this.element.addEventListener('pointercancel', this.handlePointerCancel.bind(this));
	        }
	    }
	    /**
	     * Remove DOM event listeners
	     */
	    removeEventListeners() {
	        if (!this.element)
	            return;
	        this.element.removeEventListener('touchstart', this.handleTouchStart.bind(this));
	        this.element.removeEventListener('touchmove', this.handleTouchMove.bind(this));
	        this.element.removeEventListener('touchend', this.handleTouchEnd.bind(this));
	        this.element.removeEventListener('touchcancel', this.handleTouchCancel.bind(this));
	        this.element.removeEventListener('pointerdown', this.handlePointerDown.bind(this));
	        this.element.removeEventListener('pointermove', this.handlePointerMove.bind(this));
	        this.element.removeEventListener('pointerup', this.handlePointerUp.bind(this));
	        this.element.removeEventListener('pointercancel', this.handlePointerCancel.bind(this));
	    }
	    /**
	     * Handle touch start event
	     */
	    handleTouchStart(event) {
	        event.preventDefault();
	        const rawEvents = this.processTouchEvent(event);
	        for (const rawEvent of rawEvents) {
	            this.emit('raw-input', rawEvent);
	        }
	    }
	    /**
	     * Handle touch move event
	     */
	    handleTouchMove(event) {
	        event.preventDefault();
	        const rawEvents = this.processTouchEvent(event);
	        for (const rawEvent of rawEvents) {
	            this.emit('raw-input', rawEvent);
	        }
	    }
	    /**
	     * Handle touch end event
	     */
	    handleTouchEnd(event) {
	        event.preventDefault();
	        const rawEvents = this.processTouchEvent(event);
	        for (const rawEvent of rawEvents) {
	            this.emit('raw-input', rawEvent);
	        }
	    }
	    /**
	     * Handle touch cancel event
	     */
	    handleTouchCancel(event) {
	        event.preventDefault();
	        const rawEvents = this.processTouchEvent(event);
	        for (const rawEvent of rawEvents) {
	            this.emit('raw-input', rawEvent);
	        }
	    }
	    /**
	     * Handle pointer down event
	     */
	    handlePointerDown(event) {
	        if (event.pointerType === 'touch') {
	            event.preventDefault();
	        }
	        const rawEvent = this.processPointerEvent(event);
	        this.emit('raw-input', rawEvent);
	    }
	    /**
	     * Handle pointer move event
	     */
	    handlePointerMove(event) {
	        if (event.pointerType === 'touch') {
	            event.preventDefault();
	        }
	        const rawEvent = this.processPointerEvent(event);
	        this.emit('raw-input', rawEvent);
	    }
	    /**
	     * Handle pointer up event
	     */
	    handlePointerUp(event) {
	        if (event.pointerType === 'touch') {
	            event.preventDefault();
	        }
	        const rawEvent = this.processPointerEvent(event);
	        this.emit('raw-input', rawEvent);
	    }
	    /**
	     * Handle pointer cancel event
	     */
	    handlePointerCancel(event) {
	        if (event.pointerType === 'touch') {
	            event.preventDefault();
	        }
	        const rawEvent = this.processPointerEvent(event);
	        this.emit('raw-input', rawEvent);
	    }
	    /**
	     * Update touch tracking data
	     */
	    updateTouchTracking(touch, eventType, timestamp) {
	        const touchId = touch.identifier;
	        const position = { x: touch.clientX, y: touch.clientY };
	        const pressure = touch.pressure || 1.0;
	        if (eventType === 'touchstart') {
	            const touchData = {
	                id: touchId,
	                startPosition: position,
	                currentPosition: position,
	                previousPosition: position,
	                startTime: timestamp,
	                lastTime: timestamp,
	                pressure,
	                velocity: { x: 0, y: 0 },
	                isActive: true
	            };
	            this.activeTouches.set(touchId, touchData);
	            // Set primary touch if none exists
	            if (this.primaryTouchId === null) {
	                this.primaryTouchId = touchId;
	            }
	            // Start gesture tracking
	            this.startGestureTracking(touchData);
	        }
	        else if (eventType === 'touchmove') {
	            const touchData = this.activeTouches.get(touchId);
	            if (touchData) {
	                touchData.previousPosition = { ...touchData.currentPosition };
	                touchData.currentPosition = position;
	                // Calculate velocity
	                const deltaTime = timestamp - touchData.lastTime;
	                if (deltaTime > 0) {
	                    touchData.velocity = {
	                        x: (position.x - touchData.previousPosition.x) / deltaTime,
	                        y: (position.y - touchData.previousPosition.y) / deltaTime
	                    };
	                }
	                touchData.lastTime = timestamp;
	                touchData.pressure = pressure;
	            }
	        }
	        else if (eventType === 'touchend' || eventType === 'touchcancel') {
	            const touchData = this.activeTouches.get(touchId);
	            if (touchData) {
	                touchData.isActive = false;
	                touchData.currentPosition = position;
	                touchData.lastTime = timestamp;
	                // Handle tap gesture
	                if (eventType === 'touchend') {
	                    this.handlePotentialTap(touchData, timestamp);
	                }
	                // End gesture tracking
	                this.endGestureTracking(touchData);
	                this.activeTouches.delete(touchId);
	                // Update primary touch
	                if (this.primaryTouchId === touchId) {
	                    this.primaryTouchId = this.activeTouches.size > 0
	                        ? this.activeTouches.keys().next().value ?? null
	                        : null;
	                }
	            }
	        }
	    }
	    /**
	     * Update pointer tracking (similar to touch tracking)
	     */
	    updatePointerTracking(event, timestamp) {
	        const pointerId = event.pointerId;
	        const position = { x: event.clientX, y: event.clientY };
	        const pressure = event.pressure;
	        if (event.type === 'pointerdown') {
	            const touchData = {
	                id: pointerId,
	                startPosition: position,
	                currentPosition: position,
	                previousPosition: position,
	                startTime: timestamp,
	                lastTime: timestamp,
	                pressure,
	                velocity: { x: 0, y: 0 },
	                isActive: true
	            };
	            this.activeTouches.set(pointerId, touchData);
	            if (this.primaryTouchId === null) {
	                this.primaryTouchId = pointerId;
	            }
	            this.startGestureTracking(touchData);
	        }
	        else if (event.type === 'pointermove') {
	            const touchData = this.activeTouches.get(pointerId);
	            if (touchData) {
	                touchData.previousPosition = { ...touchData.currentPosition };
	                touchData.currentPosition = position;
	                const deltaTime = timestamp - touchData.lastTime;
	                if (deltaTime > 0) {
	                    touchData.velocity = {
	                        x: (position.x - touchData.previousPosition.x) / deltaTime,
	                        y: (position.y - touchData.previousPosition.y) / deltaTime
	                    };
	                }
	                touchData.lastTime = timestamp;
	                touchData.pressure = pressure;
	            }
	        }
	        else if (event.type === 'pointerup' || event.type === 'pointercancel') {
	            const touchData = this.activeTouches.get(pointerId);
	            if (touchData) {
	                touchData.isActive = false;
	                touchData.currentPosition = position;
	                touchData.lastTime = timestamp;
	                if (event.type === 'pointerup') {
	                    this.handlePotentialTap(touchData, timestamp);
	                }
	                this.endGestureTracking(touchData);
	                this.activeTouches.delete(pointerId);
	                if (this.primaryTouchId === pointerId) {
	                    this.primaryTouchId = this.activeTouches.size > 0
	                        ? this.activeTouches.keys().next().value ?? null
	                        : null;
	                }
	            }
	        }
	    }
	    /**
	     * Start tracking gestures for a new touch
	     */
	    startGestureTracking(touchData) {
	        // Clear any existing long press timer
	        if (this.longPressTimer) {
	            clearTimeout(this.longPressTimer);
	        }
	        // Start long press detection for single touch
	        if (this.activeTouches.size === 1) {
	            this.longPressTimer = window.setTimeout(() => {
	                this.completeGesture('long-press', touchData.startPosition);
	            }, this.gestureThresholds.longPress);
	        }
	        // Start multi-touch gesture tracking
	        if (this.activeTouches.size === 2) {
	            const touches = Array.from(this.activeTouches.values());
	            this.startMultiTouchGesture(touches);
	        }
	    }
	    /**
	     * End gesture tracking for a touch
	     */
	    endGestureTracking(touchData) {
	        // Clear long press timer
	        if (this.longPressTimer) {
	            clearTimeout(this.longPressTimer);
	            this.longPressTimer = null;
	        }
	        // Check for swipe gesture
	        const distance = this.calculateDistance(touchData.startPosition, touchData.currentPosition);
	        const duration = touchData.lastTime - touchData.startTime;
	        if (distance >= this.gestureThresholds.swipe && duration < 1000) {
	            this.completeSwipeGesture(touchData);
	        }
	        // Clean up multi-touch gestures
	        this.cleanupMultiTouchGestures();
	    }
	    /**
	     * Start multi-touch gesture tracking
	     */
	    startMultiTouchGesture(touches) {
	        if (touches.length !== 2)
	            return;
	        const distance = this.calculateDistance(touches[0].currentPosition, touches[1].currentPosition);
	        const angle = this.calculateAngle(touches[0].currentPosition, touches[1].currentPosition);
	        // Create pinch gesture tracker
	        const pinchGesture = {
	            type: 'pinch',
	            startTime: Math.max(touches[0].startTime, touches[1].startTime),
	            startPosition: this.calculateMidpoint(touches[0].startPosition, touches[1].startPosition),
	            currentPosition: this.calculateMidpoint(touches[0].currentPosition, touches[1].currentPosition),
	            touches: [...touches],
	            initialDistance: distance,
	            minDistance: distance,
	            maxDistance: distance,
	            completed: false
	        };
	        // Create rotate gesture tracker
	        const rotateGesture = {
	            type: 'rotate',
	            startTime: Math.max(touches[0].startTime, touches[1].startTime),
	            startPosition: this.calculateMidpoint(touches[0].startPosition, touches[1].startPosition),
	            currentPosition: this.calculateMidpoint(touches[0].currentPosition, touches[1].currentPosition),
	            touches: [...touches],
	            initialAngle: angle,
	            completed: false
	        };
	        this.activeGestures.push(pinchGesture, rotateGesture);
	    }
	    /**
	     * Update gesture recognition
	     */
	    updateGestureRecognition() {
	        for (const gesture of this.activeGestures) {
	            this.updateGestureProgress(gesture);
	        }
	    }
	    /**
	     * Update individual gesture progress
	     */
	    updateGestureProgress(gesture) {
	        if (gesture.completed || gesture.touches.length < 2)
	            return;
	        const touches = gesture.touches.filter(t => this.activeTouches.has(t.id));
	        if (touches.length < 2)
	            return;
	        const currentDistance = this.calculateDistance(touches[0].currentPosition, touches[1].currentPosition);
	        const currentAngle = this.calculateAngle(touches[0].currentPosition, touches[1].currentPosition);
	        if (gesture.type === 'pinch') {
	            gesture.minDistance = Math.min(gesture.minDistance, currentDistance);
	            gesture.maxDistance = Math.max(gesture.maxDistance, currentDistance);
	            const scaleChange = Math.abs(currentDistance - gesture.initialDistance) / gesture.initialDistance;
	            if (scaleChange >= this.gestureThresholds.pinch) {
	                gesture.completed = true;
	            }
	        }
	        else if (gesture.type === 'rotate') {
	            const angleDiff = Math.abs(currentAngle - gesture.initialAngle) * (180 / Math.PI);
	            if (angleDiff >= this.gestureThresholds.rotate) {
	                gesture.completed = true;
	            }
	        }
	        gesture.currentPosition = this.calculateMidpoint(touches[0].currentPosition, touches[1].currentPosition);
	    }
	    /**
	     * Handle potential tap gesture
	     */
	    handlePotentialTap(touchData, timestamp) {
	        const distance = this.calculateDistance(touchData.startPosition, touchData.currentPosition);
	        const duration = timestamp - touchData.startTime;
	        if (distance <= this.gestureThresholds.tap && duration < 300) {
	            // Check for double tap
	            const timeSinceLastTap = timestamp - this.lastTapTime;
	            const distanceFromLastTap = this.calculateDistance(touchData.currentPosition, this.lastTapPosition);
	            if (timeSinceLastTap < this.gestureThresholds.doubleTap &&
	                distanceFromLastTap < this.gestureThresholds.tap) {
	                this.completeGesture('double-tap', touchData.currentPosition);
	            }
	            else {
	                this.completeGesture('tap', touchData.currentPosition);
	            }
	            this.lastTapTime = timestamp;
	            this.lastTapPosition = { ...touchData.currentPosition };
	        }
	    }
	    /**
	     * Complete swipe gesture
	     */
	    completeSwipeGesture(touchData) {
	        const gestureEvent = {
	            type: 'swipe',
	            position: touchData.currentPosition,
	            startPosition: touchData.startPosition,
	            endPosition: touchData.currentPosition,
	            timestamp: touchData.lastTime,
	            duration: touchData.lastTime - touchData.startTime,
	            distance: this.calculateDistance(touchData.startPosition, touchData.currentPosition),
	            direction: this.getSwipeDirection(touchData.startPosition, touchData.currentPosition),
	            velocity: touchData.velocity,
	            fingers: 1
	        };
	        this.emit('gesture', gestureEvent);
	    }
	    /**
	     * Complete a simple gesture
	     */
	    completeGesture(type, position) {
	        const gestureEvent = {
	            type,
	            position,
	            timestamp: performance.now(),
	            fingers: type === 'pinch' || type === 'rotate' ? 2 : 1
	        };
	        this.emit('gesture', gestureEvent);
	    }
	    /**
	     * Create gesture event from tracker
	     */
	    createGestureEvent(gesture) {
	        const event = {
	            type: gesture.type,
	            position: gesture.currentPosition,
	            startPosition: gesture.startPosition,
	            timestamp: performance.now(),
	            duration: performance.now() - gesture.startTime,
	            fingers: gesture.touches.length
	        };
	        if (gesture.type === 'pinch' && gesture.minDistance && gesture.maxDistance && gesture.initialDistance) {
	            event.scale = gesture.maxDistance / gesture.initialDistance;
	        }
	        if (gesture.type === 'rotate' && gesture.initialAngle) {
	            const currentAngle = this.calculateAngle(gesture.touches[0].currentPosition, gesture.touches[1].currentPosition);
	            event.rotation = (currentAngle - gesture.initialAngle) * (180 / Math.PI);
	        }
	        return event;
	    }
	    /**
	     * Clean up completed multi-touch gestures
	     */
	    cleanupMultiTouchGestures() {
	        this.activeGestures = this.activeGestures.filter(gesture => {
	            const activeTouches = gesture.touches.filter(t => this.activeTouches.has(t.id));
	            return activeTouches.length >= 2 && !gesture.completed;
	        });
	    }
	    /**
	     * Clear all active touches
	     */
	    clearAllTouches() {
	        this.activeTouches.clear();
	        this.primaryTouchId = null;
	    }
	    /**
	     * Clear all active gestures
	     */
	    clearAllGestures() {
	        this.activeGestures = [];
	    }
	    /**
	     * Check if touch should be rejected as palm
	     */
	    isPalmTouch(touch, event) {
	        if (!this.palmRejectionEnabled)
	            return false;
	        // Check if too many touches are active
	        if (event.touches.length > this.palmRejectionThreshold.maxSimultaneousTouches) {
	            return true;
	        }
	        // Check touch size (if available)
	        const touchRadius = Math.max(touch.radiusX || 0, touch.radiusY || 0);
	        if (touchRadius > this.palmRejectionThreshold.maxTouchSize) {
	            return true;
	        }
	        // Check distance to other touches
	        for (let i = 0; i < event.touches.length; i++) {
	            const otherTouch = event.touches[i];
	            if (otherTouch.identifier === touch.identifier)
	                continue;
	            const distance = this.calculateDistance({ x: touch.clientX, y: touch.clientY }, { x: otherTouch.clientX, y: otherTouch.clientY });
	            if (distance < this.palmRejectionThreshold.minTouchDistance) {
	                return true;
	            }
	        }
	        return false;
	    }
	    /**
	     * Map touch event type to input event type
	     */
	    mapTouchEventType(type) {
	        switch (type) {
	            case 'touchstart': return 'down';
	            case 'touchmove': return 'move';
	            case 'touchend': return 'up';
	            case 'touchcancel': return 'cancel';
	            default: return 'move';
	        }
	    }
	    /**
	     * Map pointer event type to input event type
	     */
	    mapPointerEventType(type) {
	        switch (type) {
	            case 'pointerdown': return 'down';
	            case 'pointermove': return 'move';
	            case 'pointerup': return 'up';
	            case 'pointercancel': return 'cancel';
	            default: return 'move';
	        }
	    }
	    /**
	     * Calculate distance between two points
	     */
	    calculateDistance(point1, point2) {
	        const dx = point2.x - point1.x;
	        const dy = point2.y - point1.y;
	        return Math.sqrt(dx * dx + dy * dy);
	    }
	    /**
	     * Calculate angle between two points in radians
	     */
	    calculateAngle(point1, point2) {
	        return Math.atan2(point2.y - point1.y, point2.x - point1.x);
	    }
	    /**
	     * Calculate midpoint between two points
	     */
	    calculateMidpoint(point1, point2) {
	        return {
	            x: (point1.x + point2.x) / 2,
	            y: (point1.y + point2.y) / 2
	        };
	    }
	    /**
	     * Get swipe direction from start and end points
	     */
	    getSwipeDirection(start, end) {
	        const dx = end.x - start.x;
	        const dy = end.y - start.y;
	        if (Math.abs(dx) > Math.abs(dy)) {
	            return dx > 0 ? 'right' : 'left';
	        }
	        else {
	            return dy > 0 ? 'down' : 'up';
	        }
	    }
	    /**
	     * Handle input from InputHandler interface
	     */
	    handleInput(event) {
	        // TouchInputHandler processes events differently from other handlers
	        // It works with raw TouchEvent and PointerEvent objects
	        // This method is here for interface compatibility
	        console.warn('TouchInputHandler.handleInput() called directly - use processTouchEvent() or processPointerEvent() instead');
	    }
	    /**
	     * Check if handler is enabled (InputHandler interface)
	     */
	    isEnabled() {
	        return this.isInitialized;
	    }
	    /**
	     * Set handler enabled state (InputHandler interface)
	     */
	    setEnabled(enabled) {
	        if (enabled && !this.isInitialized) {
	            console.warn('Cannot enable TouchInputHandler - not initialized. Call initialize() first.');
	        }
	        else if (!enabled && this.isInitialized) {
	            this.destroy();
	        }
	    }
	    /**
	     * Update touch handler (called by input manager)
	     */
	    update(deltaTime) {
	        if (!this.isInitialized)
	            return;
	        // Update gesture recognition timeouts
	        const currentTime = performance.now();
	        // Clean up old touch tracking data
	        for (const [id, data] of this.touchTracker.entries()) {
	            if (currentTime - data.timestamp > 5000) { // 5 second timeout
	                this.touchTracker.delete(id);
	            }
	        }
	        // Update gesture timeouts
	        if (this.gestureTimeout && currentTime - this.gestureStartTime > this.gestureTimeout) {
	            this.resetGestureState();
	        }
	    }
	    /**
	     * Reset gesture state for timeout handling
	     */
	    resetGestureState() {
	        this.activeGestures = [];
	        this.gestureStartTime = 0;
	        if (this.longPressTimer) {
	            clearTimeout(this.longPressTimer);
	            this.longPressTimer = null;
	        }
	    }
	}

	/**
	 * Mobile-optimized virtual controls manager with DOM-based rendering
	 */
	class GameByteVirtualControlsManager extends EventEmitter {
	    constructor() {
	        super();
	        this.element = null;
	        this.containerElement = null;
	        this.isInitialized = false;
	        this.isVisible = true;
	        this.isEnabled = true;
	        // Control state tracking
	        this.controls = new Map();
	        this.joysticks = new Map();
	        this.activeTouch = null;
	        // Layout and sizing
	        this.screenSize = { width: window.innerWidth, height: window.innerHeight };
	        this.scaleFactor = 1;
	        // Configuration
	        this.hapticEnabled = true;
	        this.debugMode = false;
	        // Performance tracking
	        this.lastUpdateTime = 0;
	        this.updateFrequency = 60; // Target FPS
	        // Listen for orientation changes
	        window.addEventListener('orientationchange', this.handleOrientationChange.bind(this));
	        window.addEventListener('resize', this.handleResize.bind(this));
	    }
	    /**
	     * Initialize virtual controls manager
	     */
	    async initialize(element) {
	        if (this.isInitialized) {
	            return;
	        }
	        this.element = element;
	        this.createContainer();
	        this.setupEventListeners();
	        this.updateLayout(this.screenSize);
	        this.isInitialized = true;
	        this.emit('initialized');
	    }
	    /**
	     * Destroy virtual controls manager
	     */
	    destroy() {
	        if (!this.isInitialized) {
	            return;
	        }
	        this.removeEventListeners();
	        this.clearControls();
	        if (this.containerElement) {
	            this.containerElement.remove();
	            this.containerElement = null;
	        }
	        window.removeEventListener('orientationchange', this.handleOrientationChange.bind(this));
	        window.removeEventListener('resize', this.handleResize.bind(this));
	        this.element = null;
	        this.isInitialized = false;
	        this.emit('destroyed');
	        this.removeAllListeners();
	    }
	    /**
	     * Add virtual control
	     */
	    addControl(config) {
	        if (this.controls.has(config.id)) {
	            this.removeControl(config.id);
	        }
	        const element = this.createElement(config);
	        const state = {
	            config: { ...config },
	            element,
	            isPressed: false,
	            isDragging: false,
	            touchId: null,
	            currentValue: { x: 0, y: 0 },
	            startPosition: { x: 0, y: 0 },
	            lastUpdateTime: 0
	        };
	        this.controls.set(config.id, state);
	        if (config.type === 'joystick') {
	            this.createJoystick(config, state);
	        }
	        if (this.containerElement) {
	            this.containerElement.appendChild(element);
	        }
	        this.emit('control-added', config.id, config);
	    }
	    /**
	     * Remove virtual control
	     */
	    removeControl(id) {
	        const control = this.controls.get(id);
	        if (!control)
	            return;
	        control.element.remove();
	        this.controls.delete(id);
	        this.joysticks.delete(id);
	        this.emit('control-removed', id);
	    }
	    /**
	     * Update virtual control configuration
	     */
	    updateControl(id, config) {
	        const control = this.controls.get(id);
	        if (!control)
	            return;
	        // Update config
	        Object.assign(control.config, config);
	        // Update element styling
	        this.updateElementStyle(control.element, control.config);
	        // Update position
	        if (config.position) {
	            this.positionElement(control.element, config.position, control.config.size);
	        }
	        this.emit('control-updated', id, control.config);
	    }
	    /**
	     * Get virtual control configuration
	     */
	    getControl(id) {
	        const control = this.controls.get(id);
	        return control ? { ...control.config } : null;
	    }
	    /**
	     * Show all virtual controls
	     */
	    show() {
	        this.setVisible(true);
	    }
	    /**
	     * Hide all virtual controls
	     */
	    hide() {
	        this.setVisible(false);
	    }
	    /**
	     * Set visibility of virtual controls
	     */
	    setVisible(visible) {
	        this.isVisible = visible;
	        if (this.containerElement) {
	            this.containerElement.style.display = visible ? 'block' : 'none';
	        }
	        this.emit('visibility-changed', visible);
	    }
	    /**
	     * Enable or disable virtual controls
	     */
	    setEnabled(enabled) {
	        this.isEnabled = enabled;
	        if (this.containerElement) {
	            // Update pointer events for individual controls
	            for (const [id, control] of this.controls) {
	                control.element.style.pointerEvents = enabled ? 'auto' : 'none';
	                control.element.style.opacity = enabled ? control.config.alpha.toString() : '0.3';
	            }
	        }
	        this.emit('enabled-changed', enabled);
	    }
	    /**
	     * Update layout for screen size changes
	     */
	    updateLayout(screenSize) {
	        this.screenSize = screenSize;
	        // Calculate scale factor based on screen size
	        const baseWidth = 390; // iPhone 12 Pro width as reference
	        this.scaleFactor = Math.min(screenSize.width / baseWidth, 1.5);
	        // Update container size
	        if (this.containerElement) {
	            this.containerElement.style.width = `${screenSize.width}px`;
	            this.containerElement.style.height = `${screenSize.height}px`;
	        }
	        // Update all control positions and sizes
	        for (const [id, control] of this.controls) {
	            this.updateControlLayout(control);
	        }
	        this.emit('layout-updated', screenSize);
	    }
	    /**
	     * Process touch input and return associated game action
	     */
	    processTouch(position, type) {
	        if (!this.isEnabled) {
	            return null;
	        }
	        let handledAction = null;
	        for (const [id, control] of this.controls) {
	            if (this.isPointInControl(position, control)) {
	                handledAction = this.handleControlTouch(control, position, type);
	                if (handledAction)
	                    break;
	            }
	        }
	        // Handle joystick drag outside bounds
	        if (type === 'move' && this.activeTouch !== null) {
	            for (const [id, joystick] of this.joysticks) {
	                if (joystick.touchId === this.activeTouch) {
	                    this.updateJoystick(joystick, position);
	                    break;
	                }
	            }
	        }
	        return handledAction;
	    }
	    /**
	     * Get joystick value by ID
	     */
	    getJoystickValue(id) {
	        const joystick = this.joysticks.get(id);
	        if (!joystick)
	            return { x: 0, y: 0 };
	        return { ...joystick.currentValue };
	    }
	    /**
	     * Check if button is pressed
	     */
	    isButtonPressed(id) {
	        const control = this.controls.get(id);
	        return control ? control.isPressed : false;
	    }
	    /**
	     * Set control style
	     */
	    setStyle(id, style) {
	        const control = this.controls.get(id);
	        if (!control)
	            return;
	        if (control.config.style) {
	            Object.assign(control.config.style, style);
	        }
	        else {
	            control.config.style = { ...style };
	        }
	        this.updateElementStyle(control.element, control.config);
	    }
	    /**
	     * Enable or disable haptic feedback
	     */
	    enableHaptics(enabled) {
	        this.hapticEnabled = enabled;
	    }
	    /**
	     * Clear all controls
	     */
	    clearControls() {
	        for (const [id, control] of this.controls) {
	            control.element.remove();
	        }
	        this.controls.clear();
	        this.joysticks.clear();
	        this.emit('controls-cleared');
	    }
	    /**
	     * Render virtual controls (support multiple signatures for compatibility)
	     */
	    render(context) {
	        // DOM-based rendering doesn't need canvas context
	        // This method exists for interface compatibility
	        this.updateVisualFeedback();
	    }
	    /**
	     * Create container element for virtual controls
	     */
	    createContainer() {
	        this.containerElement = document.createElement('div');
	        this.containerElement.id = 'gamebyte-virtual-controls';
	        this.containerElement.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 1000;
      overflow: hidden;
    `;
	        document.body.appendChild(this.containerElement);
	    }
	    /**
	     * Create DOM element for virtual control
	     */
	    createElement(config) {
	        const element = document.createElement('div');
	        element.id = `virtual-control-${config.id}`;
	        element.style.position = 'absolute';
	        element.style.pointerEvents = 'auto';
	        element.style.userSelect = 'none';
	        element.style.touchAction = 'none';
	        this.updateElementStyle(element, config);
	        this.positionElement(element, config.position, config.size);
	        return element;
	    }
	    /**
	     * Create joystick-specific elements
	     */
	    createJoystick(config, state) {
	        const knobElement = document.createElement('div');
	        knobElement.style.cssText = `
      position: absolute;
      width: 40%;
      height: 40%;
      border-radius: 50%;
      background: ${config.style?.knobColor || '#ffffff'};
      border: 2px solid ${config.style?.borderColor || '#000000'};
      pointer-events: none;
      transition: transform 0.1s ease-out;
    `;
	        // Center the knob
	        knobElement.style.left = '30%';
	        knobElement.style.top = '30%';
	        state.element.appendChild(knobElement);
	        const joystickState = {
	            ...state,
	            knobElement,
	            centerPosition: {
	                x: config.position.x + config.size.width / 2,
	                y: config.position.y + config.size.height / 2
	            },
	            maxDistance: Math.min(config.size.width, config.size.height) / 2 * 0.8
	        };
	        this.joysticks.set(config.id, joystickState);
	    }
	    /**
	     * Update element styling
	     */
	    updateElementStyle(element, config) {
	        const style = config.style || {};
	        const scaledSize = {
	            width: config.size.width * this.scaleFactor,
	            height: config.size.height * this.scaleFactor
	        };
	        element.style.width = `${scaledSize.width}px`;
	        element.style.height = `${scaledSize.height}px`;
	        element.style.opacity = config.alpha.toString();
	        element.style.transform = `scale(${config.scale})`;
	        element.style.visibility = config.visible ? 'visible' : 'hidden';
	        // Apply control type specific styling
	        switch (config.type) {
	            case 'joystick':
	                element.style.borderRadius = '50%';
	                element.style.background = style.backgroundColor || 'rgba(255, 255, 255, 0.3)';
	                element.style.border = style.border || '2px solid rgba(255, 255, 255, 0.5)';
	                break;
	            case 'button':
	                element.style.borderRadius = `${style.borderRadius || 10}px`;
	                element.style.background = style.backgroundColor || 'rgba(255, 255, 255, 0.3)';
	                element.style.border = style.border || '2px solid rgba(255, 255, 255, 0.5)';
	                element.style.display = 'flex';
	                element.style.alignItems = 'center';
	                element.style.justifyContent = 'center';
	                element.style.fontSize = `${12 * this.scaleFactor}px`;
	                element.style.color = style.activeColor || '#ffffff';
	                element.textContent = config.action || '';
	                break;
	            case 'dpad':
	                element.style.background = style.backgroundColor || 'rgba(255, 255, 255, 0.3)';
	                element.style.border = style.border || '2px solid rgba(255, 255, 255, 0.5)';
	                this.createDpadElements(element, style);
	                break;
	        }
	    }
	    /**
	     * Create D-pad sub-elements
	     */
	    createDpadElements(element, style) {
	        const directions = ['up', 'down', 'left', 'right'];
	        const positions = [
	            { x: '33%', y: '0%', width: '34%', height: '33%' }, // up
	            { x: '33%', y: '67%', width: '34%', height: '33%' }, // down
	            { x: '0%', y: '33%', width: '33%', height: '34%' }, // left
	            { x: '67%', y: '33%', width: '33%', height: '34%' } // right
	        ];
	        directions.forEach((direction, index) => {
	            const buttonElement = document.createElement('div');
	            const pos = positions[index];
	            buttonElement.style.cssText = `
        position: absolute;
        left: ${pos.x};
        top: ${pos.y};
        width: ${pos.width};
        height: ${pos.height};
        background: ${style.activeColor || 'rgba(255, 255, 255, 0.5)'};
        border: 1px solid ${style.borderColor || '#ffffff'};
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        color: white;
        cursor: pointer;
      `;
	            buttonElement.textContent = direction.charAt(0).toUpperCase();
	            buttonElement.dataset.direction = direction;
	            element.appendChild(buttonElement);
	        });
	    }
	    /**
	     * Position element on screen
	     */
	    positionElement(element, position, size) {
	        ({
	            width: size.width * this.scaleFactor,
	            height: size.height * this.scaleFactor
	        });
	        element.style.left = `${position.x}px`;
	        element.style.top = `${position.y}px`;
	    }
	    /**
	     * Setup event listeners
	     */
	    setupEventListeners() {
	        if (!this.containerElement)
	            return;
	        // Touch events
	        this.containerElement.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
	        this.containerElement.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
	        this.containerElement.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
	        this.containerElement.addEventListener('touchcancel', this.handleTouchCancel.bind(this), { passive: false });
	        // Mouse events for desktop testing
	        this.containerElement.addEventListener('mousedown', this.handleMouseDown.bind(this));
	        this.containerElement.addEventListener('mousemove', this.handleMouseMove.bind(this));
	        this.containerElement.addEventListener('mouseup', this.handleMouseUp.bind(this));
	    }
	    /**
	     * Remove event listeners
	     */
	    removeEventListeners() {
	        if (!this.containerElement)
	            return;
	        this.containerElement.removeEventListener('touchstart', this.handleTouchStart.bind(this));
	        this.containerElement.removeEventListener('touchmove', this.handleTouchMove.bind(this));
	        this.containerElement.removeEventListener('touchend', this.handleTouchEnd.bind(this));
	        this.containerElement.removeEventListener('touchcancel', this.handleTouchCancel.bind(this));
	        this.containerElement.removeEventListener('mousedown', this.handleMouseDown.bind(this));
	        this.containerElement.removeEventListener('mousemove', this.handleMouseMove.bind(this));
	        this.containerElement.removeEventListener('mouseup', this.handleMouseUp.bind(this));
	    }
	    /**
	     * Handle touch start event
	     */
	    handleTouchStart(event) {
	        event.preventDefault();
	        for (let i = 0; i < event.changedTouches.length; i++) {
	            const touch = event.changedTouches[i];
	            const position = { x: touch.clientX, y: touch.clientY };
	            const action = this.processTouch(position, 'start');
	            if (action) {
	                this.activeTouch = touch.identifier;
	            }
	        }
	    }
	    /**
	     * Handle touch move event
	     */
	    handleTouchMove(event) {
	        event.preventDefault();
	        for (let i = 0; i < event.changedTouches.length; i++) {
	            const touch = event.changedTouches[i];
	            if (touch.identifier === this.activeTouch) {
	                const position = { x: touch.clientX, y: touch.clientY };
	                this.processTouch(position, 'move');
	            }
	        }
	    }
	    /**
	     * Handle touch end event
	     */
	    handleTouchEnd(event) {
	        event.preventDefault();
	        for (let i = 0; i < event.changedTouches.length; i++) {
	            const touch = event.changedTouches[i];
	            if (touch.identifier === this.activeTouch) {
	                const position = { x: touch.clientX, y: touch.clientY };
	                this.processTouch(position, 'end');
	                this.activeTouch = null;
	            }
	        }
	    }
	    /**
	     * Handle touch cancel event
	     */
	    handleTouchCancel(event) {
	        this.handleTouchEnd(event);
	    }
	    /**
	     * Handle mouse down event (for desktop testing)
	     */
	    handleMouseDown(event) {
	        const position = { x: event.clientX, y: event.clientY };
	        const action = this.processTouch(position, 'start');
	        if (action) {
	            this.activeTouch = 0; // Use 0 as mouse identifier
	        }
	    }
	    /**
	     * Handle mouse move event
	     */
	    handleMouseMove(event) {
	        if (this.activeTouch === 0) {
	            const position = { x: event.clientX, y: event.clientY };
	            this.processTouch(position, 'move');
	        }
	    }
	    /**
	     * Handle mouse up event
	     */
	    handleMouseUp(event) {
	        if (this.activeTouch === 0) {
	            const position = { x: event.clientX, y: event.clientY };
	            this.processTouch(position, 'end');
	            this.activeTouch = null;
	        }
	    }
	    /**
	     * Check if point is within control bounds
	     */
	    isPointInControl(position, control) {
	        const rect = control.element.getBoundingClientRect();
	        return position.x >= rect.left &&
	            position.x <= rect.right &&
	            position.y >= rect.top &&
	            position.y <= rect.bottom;
	    }
	    /**
	     * Handle touch interaction with control
	     */
	    handleControlTouch(control, position, type) {
	        const now = performance.now();
	        switch (type) {
	            case 'start':
	                control.isPressed = true;
	                control.startPosition = position;
	                control.lastUpdateTime = now;
	                if (control.config.type === 'joystick') {
	                    this.startJoystickDrag(control.config.id, position);
	                }
	                this.triggerHapticFeedback();
	                this.updateVisualFeedback(control);
	                this.emit('control-activated', control.config.id, control.config.action);
	                return control.config.action || null;
	            case 'move':
	                if (control.isPressed && control.config.type === 'joystick') {
	                    const joystick = this.joysticks.get(control.config.id);
	                    if (joystick) {
	                        this.updateJoystick(joystick, position);
	                    }
	                }
	                break;
	            case 'end':
	                control.isPressed = false;
	                control.currentValue = { x: 0, y: 0 };
	                if (control.config.type === 'joystick') {
	                    this.resetJoystick(control.config.id);
	                }
	                this.updateVisualFeedback(control);
	                this.emit('control-deactivated', control.config.id, control.config.action);
	                break;
	        }
	        return null;
	    }
	    /**
	     * Start joystick drag interaction
	     */
	    startJoystickDrag(id, position) {
	        const joystick = this.joysticks.get(id);
	        if (!joystick)
	            return;
	        joystick.isDragging = true;
	        joystick.touchId = this.activeTouch;
	        this.updateJoystick(joystick, position);
	    }
	    /**
	     * Update joystick position and value
	     */
	    updateJoystick(joystick, position) {
	        const centerX = joystick.centerPosition.x;
	        const centerY = joystick.centerPosition.y;
	        const deltaX = position.x - centerX;
	        const deltaY = position.y - centerY;
	        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
	        // Apply dead zone
	        const deadZone = joystick.config.deadZone || 0.1;
	        const deadZonePixels = joystick.maxDistance * deadZone;
	        if (distance < deadZonePixels) {
	            joystick.currentValue = { x: 0, y: 0 };
	            this.positionKnob(joystick, { x: 0, y: 0 });
	            return;
	        }
	        // Clamp to max distance
	        const clampedDistance = Math.min(distance, joystick.maxDistance);
	        const normalizedX = (deltaX / distance) * clampedDistance;
	        const normalizedY = (deltaY / distance) * clampedDistance;
	        // Calculate normalized value (-1 to 1)
	        joystick.currentValue = {
	            x: normalizedX / joystick.maxDistance,
	            y: normalizedY / joystick.maxDistance
	        };
	        // Position knob visually
	        this.positionKnob(joystick, { x: normalizedX, y: normalizedY });
	        // Emit joystick value change
	        this.emit('joystick-changed', joystick.config.id, joystick.currentValue);
	    }
	    /**
	     * Position joystick knob element
	     */
	    positionKnob(joystick, offset) {
	        const centerPercent = 30; // knob is 40% of joystick, centered at 30%
	        const maxOffsetPercent = 25; // max offset from center
	        const offsetXPercent = (offset.x / joystick.maxDistance) * maxOffsetPercent;
	        const offsetYPercent = (offset.y / joystick.maxDistance) * maxOffsetPercent;
	        joystick.knobElement.style.left = `${centerPercent + offsetXPercent}%`;
	        joystick.knobElement.style.top = `${centerPercent + offsetYPercent}%`;
	    }
	    /**
	     * Reset joystick to center position
	     */
	    resetJoystick(id) {
	        const joystick = this.joysticks.get(id);
	        if (!joystick)
	            return;
	        joystick.isDragging = false;
	        joystick.touchId = null;
	        joystick.currentValue = { x: 0, y: 0 };
	        // Reset knob position with animation
	        joystick.knobElement.style.transition = 'left 0.2s ease-out, top 0.2s ease-out';
	        this.positionKnob(joystick, { x: 0, y: 0 });
	        // Remove transition after animation
	        setTimeout(() => {
	            joystick.knobElement.style.transition = '';
	        }, 200);
	        this.emit('joystick-reset', id);
	    }
	    /**
	     * Update visual feedback for control state
	     */
	    updateVisualFeedback(control) {
	        if (control) {
	            const activeStyle = control.config.style?.activeColor || 'rgba(255, 255, 255, 0.8)';
	            const normalStyle = control.config.style?.backgroundColor || 'rgba(255, 255, 255, 0.3)';
	            control.element.style.background = control.isPressed ? activeStyle : normalStyle;
	        }
	        else {
	            // Update all controls
	            for (const [id, control] of this.controls) {
	                this.updateVisualFeedback(control);
	            }
	        }
	    }
	    /**
	     * Update control layout for screen changes
	     */
	    updateControlLayout(control) {
	        this.positionElement(control.element, control.config.position, control.config.size);
	        this.updateElementStyle(control.element, control.config);
	        // Update joystick center position
	        if (control.config.type === 'joystick') {
	            const joystick = this.joysticks.get(control.config.id);
	            if (joystick) {
	                joystick.centerPosition = {
	                    x: control.config.position.x + control.config.size.width / 2,
	                    y: control.config.position.y + control.config.size.height / 2
	                };
	            }
	        }
	    }
	    /**
	     * Trigger haptic feedback if supported and enabled
	     */
	    triggerHapticFeedback() {
	        if (this.hapticEnabled && 'vibrate' in navigator) {
	            navigator.vibrate(10); // Short vibration
	        }
	    }
	    /**
	     * Handle orientation change
	     */
	    handleOrientationChange() {
	        setTimeout(() => {
	            this.updateLayout({
	                width: window.innerWidth,
	                height: window.innerHeight
	            });
	        }, 100);
	    }
	    /**
	     * Handle window resize
	     */
	    handleResize() {
	        this.updateLayout({
	            width: window.innerWidth,
	            height: window.innerHeight
	        });
	    }
	    /**
	     * Update virtual controls (called by input manager)
	     */
	    update(deltaTime) {
	        if (!this.isInitialized || !this.isVisible)
	            return;
	        // Update joystick smoothing and animations
	        for (const joystick of this.joysticks.values()) {
	            // Update joystick animations if any
	            const currentTime = performance.now();
	            joystick.lastUpdateTime = currentTime;
	        }
	        // Update control animations and states
	        for (const control of this.controls.values()) {
	            // Update control states if needed
	            control.lastUpdateTime = performance.now();
	        }
	    }
	}

	/**
	 * Input mapping manager for handling input profiles and context switching
	 */
	class GameByteInputMappingManager {
	    constructor() {
	        this.mappings = new Map();
	        this.profiles = new Map();
	        this.activeContext = 'menu';
	        this.currentProfile = null;
	        this.initializeDefaultMappings();
	        this.createBuiltInProfiles();
	    }
	    /**
	     * Add input mapping for a specific context
	     */
	    addMapping(context, input, action) {
	        if (!this.mappings.has(context)) {
	            this.mappings.set(context, new Map());
	        }
	        const contextMappings = this.mappings.get(context);
	        contextMappings.set(input, action);
	    }
	    /**
	     * Remove input mapping
	     */
	    removeMapping(context, input) {
	        const contextMappings = this.mappings.get(context);
	        if (contextMappings) {
	            contextMappings.delete(input);
	        }
	    }
	    /**
	     * Get action mapped to input in current or specified context
	     */
	    getMapping(context, input) {
	        const contextMappings = this.mappings.get(context);
	        return contextMappings?.get(input) || null;
	    }
	    /**
	     * Map a raw input event to a game action based on context
	     */
	    mapInput(event, context) {
	        // Generate input key from event
	        let inputKey;
	        switch (event.device) {
	            case 'keyboard':
	                inputKey = `key:${event.key}`;
	                break;
	            case 'mouse':
	                inputKey = `mouse:button${event.button}`;
	                break;
	            case 'gamepad':
	                if (event.type === 'gamepad-button-down' || event.type === 'gamepad-button-up') {
	                    inputKey = `gamepad:${event.gamepadIndex}:button${event.button}`;
	                }
	                else if (event.type === 'gamepad-axis') {
	                    inputKey = `gamepad:${event.gamepadIndex}:axis${event.axisIndex}`;
	                }
	                else {
	                    return null;
	                }
	                break;
	            case 'touch':
	                inputKey = `touch:${event.type}`;
	                break;
	            default:
	                return null;
	        }
	        return this.getMapping(context, inputKey);
	    }
	    /**
	     * Create new input profile
	     */
	    createProfile(id, name) {
	        const profile = {
	            id,
	            name,
	            description: `Custom input profile: ${name}`,
	            mappings: [],
	            virtualControls: [],
	            settings: {
	                touchSensitivity: 1.0,
	                gestureThresholds: {
	                    tap: 10,
	                    longPress: 500,
	                    swipe: 50,
	                    pinch: 0.2
	                },
	                deadZones: {
	                    joystick: 0.1,
	                    gamepad: 0.15
	                },
	                hapticEnabled: true,
	                inputPrediction: false
	            }
	        };
	        this.profiles.set(id, profile);
	        return { ...profile };
	    }
	    /**
	     * Save input profile
	     */
	    saveProfile(profile) {
	        this.profiles.set(profile.id, { ...profile });
	        // Save to localStorage for persistence
	        try {
	            const serializedProfile = JSON.stringify(profile, this.profileReplacer);
	            localStorage.setItem(`gamebyte-input-profile-${profile.id}`, serializedProfile);
	        }
	        catch (error) {
	            console.warn('Failed to save input profile to localStorage:', error);
	        }
	    }
	    /**
	     * Load input profile
	     */
	    loadProfile(id) {
	        // Try to load from memory first
	        let profile = this.profiles.get(id);
	        // If not in memory, try localStorage
	        if (!profile) {
	            try {
	                const serializedProfile = localStorage.getItem(`gamebyte-input-profile-${id}`);
	                if (serializedProfile) {
	                    profile = JSON.parse(serializedProfile, this.profileReviver);
	                    if (profile) {
	                        this.profiles.set(id, profile);
	                    }
	                }
	            }
	            catch (error) {
	                console.warn('Failed to load input profile from localStorage:', error);
	            }
	        }
	        return profile ? { ...profile } : null;
	    }
	    /**
	     * Delete input profile
	     */
	    deleteProfile(id) {
	        this.profiles.delete(id);
	        try {
	            localStorage.removeItem(`gamebyte-input-profile-${id}`);
	        }
	        catch (error) {
	            console.warn('Failed to remove input profile from localStorage:', error);
	        }
	    }
	    /**
	     * List all available profiles
	     */
	    listProfiles() {
	        return Array.from(this.profiles.values()).map(profile => ({ ...profile }));
	    }
	    /**
	     * Set active input context
	     */
	    setActiveContext(context) {
	        this.activeContext = context;
	    }
	    /**
	     * Get active input context
	     */
	    getActiveContext() {
	        return this.activeContext;
	    }
	    /**
	     * Get current profile
	     */
	    getCurrentProfile() {
	        return this.currentProfile ? { ...this.currentProfile } : null;
	    }
	    /**
	     * Get available profile names
	     */
	    getAvailableProfiles() {
	        return Array.from(this.profiles.keys());
	    }
	    /**
	     * Load saved profile by name (alias for loadProfile for facade compatibility)
	     */
	    loadSavedProfile(name) {
	        const profile = this.loadProfile(name);
	        if (profile) {
	            this.currentProfile = profile;
	            return true;
	        }
	        return false;
	    }
	    /**
	     * Set mapping from InputMapping object
	     */
	    setMapping(mapping) {
	        for (const [input, action] of mapping.mappings) {
	            this.addMapping(mapping.context, input, action);
	        }
	    }
	    /**
	     * Get platformer-optimized input profile
	     */
	    getPlatformerProfile() {
	        const profile = this.profiles.get('platformer');
	        if (!profile) {
	            throw new Error('Platformer profile not found');
	        }
	        return { ...profile };
	    }
	    /**
	     * Get top-down game input profile
	     */
	    getTopDownProfile() {
	        const profile = this.profiles.get('top-down');
	        if (!profile) {
	            throw new Error('Top-down profile not found');
	        }
	        return { ...profile };
	    }
	    /**
	     * Get menu navigation input profile
	     */
	    getMenuProfile() {
	        const profile = this.profiles.get('menu');
	        if (!profile) {
	            throw new Error('Menu profile not found');
	        }
	        return { ...profile };
	    }
	    /**
	     * Initialize default input mappings for all contexts
	     */
	    initializeDefaultMappings() {
	        // Menu context mappings
	        this.addMapping('menu', 'key:ArrowUp', 'menu-navigate');
	        this.addMapping('menu', 'key:ArrowDown', 'menu-navigate');
	        this.addMapping('menu', 'key:ArrowLeft', 'menu-navigate');
	        this.addMapping('menu', 'key:ArrowRight', 'menu-navigate');
	        this.addMapping('menu', 'key:Enter', 'menu-select');
	        this.addMapping('menu', 'key:Escape', 'menu-back');
	        this.addMapping('menu', 'key: ', 'menu-select');
	        this.addMapping('menu', 'touch:down', 'menu-select');
	        // Gameplay context mappings
	        this.addMapping('gameplay', 'key:ArrowLeft', 'move-left');
	        this.addMapping('gameplay', 'key:ArrowRight', 'move-right');
	        this.addMapping('gameplay', 'key:ArrowUp', 'move-up');
	        this.addMapping('gameplay', 'key:ArrowDown', 'move-down');
	        this.addMapping('gameplay', 'key:a', 'move-left');
	        this.addMapping('gameplay', 'key:d', 'move-right');
	        this.addMapping('gameplay', 'key:w', 'move-up');
	        this.addMapping('gameplay', 'key:s', 'move-down');
	        this.addMapping('gameplay', 'key: ', 'jump');
	        this.addMapping('gameplay', 'key:Shift', 'run');
	        this.addMapping('gameplay', 'key:Control', 'crouch');
	        this.addMapping('gameplay', 'key:e', 'interact');
	        this.addMapping('gameplay', 'key:f', 'attack');
	        this.addMapping('gameplay', 'key:Escape', 'pause');
	        // Pause context mappings
	        this.addMapping('pause', 'key:Escape', 'menu-back');
	        this.addMapping('pause', 'key:Enter', 'menu-select');
	        this.addMapping('pause', 'key: ', 'menu-select');
	        // Settings context mappings
	        this.addMapping('settings', 'key:ArrowUp', 'menu-navigate');
	        this.addMapping('settings', 'key:ArrowDown', 'menu-navigate');
	        this.addMapping('settings', 'key:ArrowLeft', 'menu-navigate');
	        this.addMapping('settings', 'key:ArrowRight', 'menu-navigate');
	        this.addMapping('settings', 'key:Enter', 'menu-select');
	        this.addMapping('settings', 'key:Escape', 'menu-back');
	        // Camera controls (for applicable contexts)
	        this.addMapping('gameplay', 'mouse:button0', 'camera-pan');
	        this.addMapping('gameplay', 'key:q', 'camera-zoom');
	        this.addMapping('gameplay', 'key:e', 'camera-zoom');
	        this.addMapping('gameplay', 'key:r', 'camera-rotate');
	        // Gamepad mappings
	        this.addMapping('gameplay', 'gamepad:0:button0', 'jump'); // A button
	        this.addMapping('gameplay', 'gamepad:0:button1', 'attack'); // B button
	        this.addMapping('gameplay', 'gamepad:0:button2', 'run'); // X button
	        this.addMapping('gameplay', 'gamepad:0:button3', 'interact'); // Y button
	        this.addMapping('menu', 'gamepad:0:button0', 'menu-select');
	        this.addMapping('menu', 'gamepad:0:button1', 'menu-back');
	    }
	    /**
	     * Create built-in input profiles
	     */
	    createBuiltInProfiles() {
	        // Platformer profile
	        const platformerProfile = {
	            id: 'platformer',
	            name: 'Platformer',
	            description: 'Optimized for 2D platformer games with precise jumping and movement',
	            mappings: [
	                {
	                    context: 'gameplay',
	                    mappings: new Map([
	                        ['key:ArrowLeft', 'move-left'],
	                        ['key:ArrowRight', 'move-right'],
	                        ['key:a', 'move-left'],
	                        ['key:d', 'move-right'],
	                        ['key: ', 'jump'],
	                        ['key:Shift', 'run'],
	                        ['key:Control', 'crouch'],
	                        ['touch:down', 'jump'],
	                        ['gamepad:0:button0', 'jump']
	                    ]),
	                    priority: 1,
	                    enabled: true
	                }
	            ],
	            virtualControls: [
	                {
	                    id: 'movement-stick',
	                    type: 'joystick',
	                    position: { x: 50, y: window.innerHeight - 150 },
	                    size: { width: 100, height: 100 },
	                    visible: true,
	                    alpha: 0.7,
	                    scale: 1.0,
	                    deadZone: 0.15,
	                    style: {
	                        backgroundColor: 'rgba(255, 255, 255, 0.3)',
	                        borderColor: 'rgba(255, 255, 255, 0.6)',
	                        knobColor: 'rgba(255, 255, 255, 0.8)'
	                    },
	                    hapticFeedback: true
	                },
	                {
	                    id: 'jump-button',
	                    type: 'button',
	                    position: { x: window.innerWidth - 100, y: window.innerHeight - 150 },
	                    size: { width: 80, height: 80 },
	                    action: 'jump',
	                    visible: true,
	                    alpha: 0.7,
	                    scale: 1.0,
	                    style: {
	                        backgroundColor: 'rgba(255, 255, 255, 0.3)',
	                        borderColor: 'rgba(255, 255, 255, 0.6)',
	                        activeColor: 'rgba(255, 255, 255, 0.8)',
	                        borderRadius: 40
	                    },
	                    hapticFeedback: true
	                }
	            ],
	            settings: {
	                touchSensitivity: 1.2,
	                gestureThresholds: {
	                    tap: 8,
	                    longPress: 400,
	                    swipe: 40,
	                    pinch: 0.2
	                },
	                deadZones: {
	                    joystick: 0.15,
	                    gamepad: 0.1
	                },
	                hapticEnabled: true,
	                inputPrediction: true
	            }
	        };
	        // Top-down profile
	        const topDownProfile = {
	            id: 'top-down',
	            name: 'Top-Down',
	            description: 'Optimized for top-down games with 8-directional movement',
	            mappings: [
	                {
	                    context: 'gameplay',
	                    mappings: new Map([
	                        ['key:ArrowLeft', 'move-left'],
	                        ['key:ArrowRight', 'move-right'],
	                        ['key:ArrowUp', 'move-up'],
	                        ['key:ArrowDown', 'move-down'],
	                        ['key:a', 'move-left'],
	                        ['key:d', 'move-right'],
	                        ['key:w', 'move-up'],
	                        ['key:s', 'move-down'],
	                        ['key: ', 'attack'],
	                        ['key:Shift', 'run'],
	                        ['key:e', 'interact'],
	                        ['mouse:button0', 'attack'],
	                        ['gamepad:0:button0', 'attack']
	                    ]),
	                    priority: 1,
	                    enabled: true
	                }
	            ],
	            virtualControls: [
	                {
	                    id: 'movement-stick',
	                    type: 'joystick',
	                    position: { x: 50, y: window.innerHeight - 150 },
	                    size: { width: 120, height: 120 },
	                    visible: true,
	                    alpha: 0.7,
	                    scale: 1.0,
	                    deadZone: 0.1,
	                    style: {
	                        backgroundColor: 'rgba(255, 255, 255, 0.3)',
	                        borderColor: 'rgba(255, 255, 255, 0.6)',
	                        knobColor: 'rgba(255, 255, 255, 0.8)'
	                    },
	                    hapticFeedback: true
	                },
	                {
	                    id: 'attack-button',
	                    type: 'button',
	                    position: { x: window.innerWidth - 100, y: window.innerHeight - 150 },
	                    size: { width: 80, height: 80 },
	                    action: 'attack',
	                    visible: true,
	                    alpha: 0.7,
	                    scale: 1.0,
	                    style: {
	                        backgroundColor: 'rgba(255, 100, 100, 0.3)',
	                        borderColor: 'rgba(255, 100, 100, 0.6)',
	                        activeColor: 'rgba(255, 100, 100, 0.8)',
	                        borderRadius: 40
	                    },
	                    hapticFeedback: true
	                },
	                {
	                    id: 'interact-button',
	                    type: 'button',
	                    position: { x: window.innerWidth - 200, y: window.innerHeight - 150 },
	                    size: { width: 60, height: 60 },
	                    action: 'interact',
	                    visible: true,
	                    alpha: 0.7,
	                    scale: 1.0,
	                    style: {
	                        backgroundColor: 'rgba(100, 255, 100, 0.3)',
	                        borderColor: 'rgba(100, 255, 100, 0.6)',
	                        activeColor: 'rgba(100, 255, 100, 0.8)',
	                        borderRadius: 30
	                    },
	                    hapticFeedback: true
	                }
	            ],
	            settings: {
	                touchSensitivity: 1.0,
	                gestureThresholds: {
	                    tap: 10,
	                    longPress: 500,
	                    swipe: 50,
	                    pinch: 0.2
	                },
	                deadZones: {
	                    joystick: 0.1,
	                    gamepad: 0.15
	                },
	                hapticEnabled: true,
	                inputPrediction: false
	            }
	        };
	        // Menu profile
	        const menuProfile = {
	            id: 'menu',
	            name: 'Menu Navigation',
	            description: 'Optimized for menu navigation and UI interaction',
	            mappings: [
	                {
	                    context: 'menu',
	                    mappings: new Map([
	                        ['key:ArrowUp', 'menu-navigate'],
	                        ['key:ArrowDown', 'menu-navigate'],
	                        ['key:ArrowLeft', 'menu-navigate'],
	                        ['key:ArrowRight', 'menu-navigate'],
	                        ['key:Enter', 'menu-select'],
	                        ['key: ', 'menu-select'],
	                        ['key:Escape', 'menu-back'],
	                        ['touch:down', 'menu-select'],
	                        ['gamepad:0:button0', 'menu-select'],
	                        ['gamepad:0:button1', 'menu-back']
	                    ]),
	                    priority: 1,
	                    enabled: true
	                }
	            ],
	            virtualControls: [],
	            settings: {
	                touchSensitivity: 1.0,
	                gestureThresholds: {
	                    tap: 15,
	                    longPress: 600,
	                    swipe: 60,
	                    pinch: 0.3
	                },
	                deadZones: {
	                    joystick: 0.2,
	                    gamepad: 0.2
	                },
	                hapticEnabled: false,
	                inputPrediction: false
	            }
	        };
	        this.profiles.set('platformer', platformerProfile);
	        this.profiles.set('top-down', topDownProfile);
	        this.profiles.set('menu', menuProfile);
	    }
	    /**
	     * JSON serialization replacer for Map objects
	     */
	    profileReplacer(key, value) {
	        if (value instanceof Map) {
	            return {
	                __type: 'Map',
	                entries: Array.from(value.entries())
	            };
	        }
	        return value;
	    }
	    /**
	     * JSON deserialization reviver for Map objects
	     */
	    profileReviver(key, value) {
	        if (typeof value === 'object' && value !== null && value.__type === 'Map') {
	            return new Map(value.entries);
	        }
	        return value;
	    }
	}

	/**
	 * Input performance manager with optimization and monitoring capabilities
	 */
	class GameByteInputPerformanceManager {
	    constructor() {
	        this.isInitialized = false;
	        this.isMonitoring = false;
	        this.metricsUpdateInterval = null;
	        this.metricsUpdateFrequency = 1000; // Update every second
	        this.batchSize = 10;
	        this.updateFrequency = 60; // Target 60 FPS
	        this.performanceTarget = 'balanced';
	        // Adaptive performance
	        this.adaptivePerformanceEnabled = false;
	        this.lastPerformanceCheck = 0;
	        this.performanceCheckInterval = 5000; // Check every 5 seconds
	        this.performanceHistory = [];
	        // Battery optimization
	        this.batteryOptimizationEnabled = false;
	        this.batteryLevel = 1.0;
	        this.batteryMonitoringSupported = false;
	        this.performanceData = {
	            inputLatencies: [],
	            gestureRecognitionTimes: [],
	            eventCounts: [],
	            memoryUsages: [],
	            frameRates: [],
	            lastResetTime: performance.now()
	        };
	        this.inputPrediction = {
	            enabled: false,
	            lookAheadTime: 16, // One frame at 60fps
	            confidence: 0.7,
	            predictedEvents: []
	        };
	        this.eventPool = {
	            enabled: true,
	            maxSize: 100,
	            pool: [],
	            activeCount: 0
	        };
	        // Check for battery API support
	        if ('getBattery' in navigator) {
	            this.batteryMonitoringSupported = true;
	            this.initializeBatteryMonitoring();
	        }
	    }
	    /**
	     * Initialize performance manager
	     */
	    async initialize() {
	        if (this.isInitialized) {
	            return;
	        }
	        this.setupPerformanceMonitoring();
	        this.initializeEventPool();
	        this.applyPerformanceTarget();
	        this.isInitialized = true;
	    }
	    /**
	     * Destroy performance manager
	     */
	    destroy() {
	        this.stopMonitoring();
	        this.clearEventPool();
	        this.isInitialized = false;
	    }
	    /**
	     * Start performance monitoring
	     */
	    startMonitoring() {
	        if (this.isMonitoring) {
	            return;
	        }
	        this.isMonitoring = true;
	        this.performanceData.lastResetTime = performance.now();
	        // Start metrics update interval
	        this.metricsUpdateInterval = window.setInterval(() => {
	            this.updateMetrics();
	            if (this.adaptivePerformanceEnabled) {
	                this.checkAdaptivePerformance();
	            }
	        }, this.metricsUpdateFrequency);
	    }
	    /**
	     * Stop performance monitoring
	     */
	    stopMonitoring() {
	        if (!this.isMonitoring) {
	            return;
	        }
	        this.isMonitoring = false;
	        if (this.metricsUpdateInterval) {
	            clearInterval(this.metricsUpdateInterval);
	            this.metricsUpdateInterval = null;
	        }
	    }
	    /**
	     * Get current performance metrics
	     */
	    getMetrics() {
	        const now = performance.now();
	        now - this.performanceData.lastResetTime;
	        // Calculate averages
	        const avgLatency = this.calculateAverage(this.performanceData.inputLatencies);
	        const avgGestureTime = this.calculateAverage(this.performanceData.gestureRecognitionTimes);
	        const avgFrameRate = this.calculateAverage(this.performanceData.frameRates);
	        const totalEvents = this.performanceData.eventCounts.reduce((sum, count) => sum + count, 0);
	        // Estimate memory usage
	        const estimatedMemory = this.estimateMemoryUsage();
	        // Calculate battery impact
	        const batteryImpact = this.calculateBatteryImpact();
	        return {
	            averageLatency: avgLatency,
	            inputEventCount: totalEvents,
	            gestureRecognitionTime: avgGestureTime,
	            memoryUsage: estimatedMemory,
	            droppedInputs: 0, // This would be tracked by InputManager
	            frameRate: avgFrameRate,
	            batteryImpact
	        };
	    }
	    /**
	     * Reset performance metrics
	     */
	    resetMetrics() {
	        this.performanceData = {
	            inputLatencies: [],
	            gestureRecognitionTimes: [],
	            eventCounts: [],
	            memoryUsages: [],
	            frameRates: [],
	            lastResetTime: performance.now()
	        };
	    }
	    /**
	     * Enable or disable input prediction
	     */
	    enableInputPrediction(enabled) {
	        this.inputPrediction.enabled = enabled;
	        if (!enabled) {
	            this.inputPrediction.predictedEvents = [];
	        }
	    }
	    /**
	     * Set batch size for input processing
	     */
	    setBatchSize(size) {
	        this.batchSize = Math.max(1, Math.min(100, size));
	    }
	    /**
	     * Set update frequency for input processing
	     */
	    setUpdateFrequency(frequency) {
	        this.updateFrequency = Math.max(30, Math.min(120, frequency));
	    }
	    /**
	     * Enable or disable adaptive performance
	     */
	    enableAdaptivePerformance(enabled) {
	        this.adaptivePerformanceEnabled = enabled;
	        if (enabled) {
	            this.performanceHistory = [];
	            this.lastPerformanceCheck = performance.now();
	        }
	    }
	    /**
	     * Set performance target mode
	     */
	    setPerformanceTarget(target) {
	        this.performanceTarget = target;
	        this.applyPerformanceTarget();
	    }
	    /**
	     * Set performance mode (alias for setPerformanceTarget for facade compatibility)
	     */
	    setPerformanceMode(mode) {
	        this.setPerformanceTarget(mode);
	    }
	    /**
	     * Enable input prediction (alias for enableInputPrediction for facade compatibility)
	     */
	    enablePrediction(enabled) {
	        this.enableInputPrediction(enabled);
	    }
	    /**
	     * Process input event with prediction optimization
	     */
	    processWithPrediction(event) {
	        if (!this.inputPrediction.enabled) {
	            return event;
	        }
	        // Apply prediction if possible
	        const predictedEvent = this.predictInput(event, 16); // 16ms delta time for 60fps
	        if (predictedEvent) {
	            // Use predicted event for smoother input
	            return predictedEvent;
	        }
	        return event;
	    }
	    /**
	     * Optimize for battery life
	     */
	    optimizeForBattery() {
	        this.setPerformanceTarget('battery');
	        this.batteryOptimizationEnabled = true;
	        this.adjustForBatteryLevel();
	    }
	    /**
	     * Optimize for performance
	     */
	    optimizeForPerformance() {
	        this.setPerformanceTarget('performance');
	        this.batteryOptimizationEnabled = false;
	    }
	    /**
	     * Enable or disable event pooling
	     */
	    enableEventPooling(enabled) {
	        this.eventPool.enabled = enabled;
	        if (!enabled) {
	            this.clearEventPool();
	        }
	        else {
	            this.initializeEventPool();
	        }
	    }
	    /**
	     * Set maximum pool size for event pooling
	     */
	    setMaxPoolSize(size) {
	        this.eventPool.maxSize = Math.max(10, Math.min(1000, size));
	        // Trim pool if necessary
	        if (this.eventPool.pool.length > this.eventPool.maxSize) {
	            this.eventPool.pool = this.eventPool.pool.slice(0, this.eventPool.maxSize);
	        }
	    }
	    /**
	     * Clean up memory by clearing caches and pools
	     */
	    cleanupMemory() {
	        // Clear event pool
	        this.clearEventPool();
	        this.initializeEventPool();
	        // Clear prediction data
	        this.inputPrediction.predictedEvents = [];
	        // Trim performance data arrays
	        this.trimPerformanceArrays();
	        // Force garbage collection if available
	        if ('gc' in window && typeof window.gc === 'function') {
	            window.gc();
	        }
	    }
	    /**
	     * Update performance tracking (called by InputManager)
	     */
	    update() {
	        if (!this.isMonitoring) {
	            return;
	        }
	        // Track frame rate
	        const now = performance.now();
	        if (this.performanceData.frameRates.length > 0) {
	            const lastFrameTime = this.performanceData.frameRates[this.performanceData.frameRates.length - 1];
	            const frameTime = now - lastFrameTime;
	            const fps = 1000 / frameTime;
	            this.performanceData.frameRates.push(fps);
	        }
	        else {
	            this.performanceData.frameRates.push(60); // Initial estimate
	        }
	        // Limit array sizes
	        this.trimPerformanceArrays();
	    }
	    /**
	     * Record input latency (called by InputManager)
	     */
	    recordInputLatency(latency) {
	        if (this.isMonitoring) {
	            this.performanceData.inputLatencies.push(latency);
	        }
	    }
	    /**
	     * Record gesture recognition time (called by TouchInputHandler)
	     */
	    recordGestureTime(time) {
	        if (this.isMonitoring) {
	            this.performanceData.gestureRecognitionTimes.push(time);
	        }
	    }
	    /**
	     * Get event from pool or create new one
	     */
	    getPooledEvent() {
	        if (!this.eventPool.enabled || this.eventPool.pool.length === 0) {
	            return {};
	        }
	        const event = this.eventPool.pool.pop();
	        this.eventPool.activeCount++;
	        return event;
	    }
	    /**
	     * Return event to pool
	     */
	    returnPooledEvent(event) {
	        if (!this.eventPool.enabled || this.eventPool.pool.length >= this.eventPool.maxSize) {
	            return;
	        }
	        // Clear event properties
	        for (const key in event) {
	            delete event[key];
	        }
	        this.eventPool.pool.push(event);
	        this.eventPool.activeCount = Math.max(0, this.eventPool.activeCount - 1);
	    }
	    /**
	     * Predict next input based on current patterns
	     */
	    predictInput(currentEvent, deltaTime) {
	        if (!this.inputPrediction.enabled) {
	            return null;
	        }
	        // Simple prediction based on velocity and patterns
	        // This is a basic implementation - more sophisticated ML-based prediction could be added
	        const now = performance.now();
	        const lookAhead = now + this.inputPrediction.lookAheadTime;
	        // For now, just predict continuation of movement
	        if (currentEvent.type === 'move' && currentEvent.velocity) {
	            const predictedPosition = {
	                x: currentEvent.position.x + (currentEvent.velocity.x * this.inputPrediction.lookAheadTime),
	                y: currentEvent.position.y + (currentEvent.velocity.y * this.inputPrediction.lookAheadTime)
	            };
	            const predictedEvent = {
	                ...currentEvent,
	                position: predictedPosition,
	                timestamp: lookAhead,
	                predicted: true
	            };
	            this.inputPrediction.predictedEvents.push({
	                timestamp: lookAhead,
	                event: predictedEvent,
	                confidence: this.inputPrediction.confidence
	            });
	            return predictedEvent;
	        }
	        return null;
	    }
	    /**
	     * Setup performance monitoring
	     */
	    setupPerformanceMonitoring() {
	        // Monitor memory usage if supported
	        if ('memory' in performance) {
	            const memoryInfo = performance.memory;
	            this.performanceData.memoryUsages.push(memoryInfo.usedJSHeapSize);
	        }
	    }
	    /**
	     * Initialize event pool
	     */
	    initializeEventPool() {
	        if (!this.eventPool.enabled) {
	            return;
	        }
	        this.eventPool.pool = [];
	        this.eventPool.activeCount = 0;
	        // Pre-populate pool
	        for (let i = 0; i < Math.min(this.eventPool.maxSize, 20); i++) {
	            this.eventPool.pool.push({});
	        }
	    }
	    /**
	     * Clear event pool
	     */
	    clearEventPool() {
	        this.eventPool.pool = [];
	        this.eventPool.activeCount = 0;
	    }
	    /**
	     * Apply performance target settings
	     */
	    applyPerformanceTarget() {
	        switch (this.performanceTarget) {
	            case 'battery':
	                this.updateFrequency = 30;
	                this.batchSize = 5;
	                this.inputPrediction.enabled = false;
	                this.batteryOptimizationEnabled = true;
	                break;
	            case 'performance':
	                this.updateFrequency = 120;
	                this.batchSize = 20;
	                this.inputPrediction.enabled = true;
	                this.batteryOptimizationEnabled = false;
	                break;
	            case 'balanced':
	                this.updateFrequency = 60;
	                this.batchSize = 10;
	                this.inputPrediction.enabled = false;
	                this.batteryOptimizationEnabled = false;
	                break;
	        }
	    }
	    /**
	     * Initialize battery monitoring
	     */
	    async initializeBatteryMonitoring() {
	        if (!this.batteryMonitoringSupported) {
	            return;
	        }
	        try {
	            const battery = await navigator.getBattery();
	            this.batteryLevel = battery.level;
	            battery.addEventListener('levelchange', () => {
	                this.batteryLevel = battery.level;
	                this.adjustForBatteryLevel();
	            });
	            battery.addEventListener('chargingchange', () => {
	                this.adjustForBatteryLevel();
	            });
	        }
	        catch (error) {
	            console.warn('Battery monitoring not available:', error);
	            this.batteryMonitoringSupported = false;
	        }
	    }
	    /**
	     * Adjust performance based on battery level
	     */
	    adjustForBatteryLevel() {
	        if (!this.batteryOptimizationEnabled) {
	            return;
	        }
	        if (this.batteryLevel < 0.2) {
	            // Low battery - aggressive optimization
	            this.updateFrequency = Math.min(this.updateFrequency, 30);
	            this.batchSize = Math.min(this.batchSize, 5);
	            this.inputPrediction.enabled = false;
	        }
	        else if (this.batteryLevel < 0.5) {
	            // Medium battery - moderate optimization
	            this.updateFrequency = Math.min(this.updateFrequency, 45);
	            this.batchSize = Math.min(this.batchSize, 8);
	        }
	    }
	    /**
	     * Update performance metrics
	     */
	    updateMetrics() {
	        // Record current memory usage
	        if ('memory' in performance) {
	            const memoryInfo = performance.memory;
	            this.performanceData.memoryUsages.push(memoryInfo.usedJSHeapSize);
	        }
	        // Trim arrays to prevent memory leaks
	        this.trimPerformanceArrays();
	    }
	    /**
	     * Check adaptive performance and adjust settings
	     */
	    checkAdaptivePerformance() {
	        const now = performance.now();
	        if (now - this.lastPerformanceCheck < this.performanceCheckInterval) {
	            return;
	        }
	        this.lastPerformanceCheck = now;
	        // Calculate recent average frame rate
	        const recentFrameRates = this.performanceData.frameRates.slice(-60); // Last 60 samples
	        const avgFrameRate = this.calculateAverage(recentFrameRates);
	        this.performanceHistory.push(avgFrameRate);
	        if (this.performanceHistory.length > 10) {
	            this.performanceHistory.shift();
	        }
	        // Adjust settings based on performance
	        if (avgFrameRate < 45) {
	            // Performance is poor - reduce quality
	            this.updateFrequency = Math.max(30, this.updateFrequency - 5);
	            this.batchSize = Math.max(3, this.batchSize - 1);
	            this.inputPrediction.enabled = false;
	        }
	        else if (avgFrameRate > 55 && this.performanceTarget === 'performance') {
	            // Performance is good - can increase quality
	            this.updateFrequency = Math.min(120, this.updateFrequency + 5);
	            this.batchSize = Math.min(20, this.batchSize + 1);
	            this.inputPrediction.enabled = true;
	        }
	    }
	    /**
	     * Calculate average of number array
	     */
	    calculateAverage(values) {
	        if (values.length === 0)
	            return 0;
	        const sum = values.reduce((acc, val) => acc + val, 0);
	        return sum / values.length;
	    }
	    /**
	     * Estimate memory usage of input system
	     */
	    estimateMemoryUsage() {
	        let estimated = 0;
	        // Estimate based on tracked data
	        estimated += this.performanceData.inputLatencies.length * 8; // 8 bytes per number
	        estimated += this.performanceData.gestureRecognitionTimes.length * 8;
	        estimated += this.performanceData.frameRates.length * 8;
	        estimated += this.eventPool.pool.length * 100; // Rough estimate per event object
	        estimated += this.inputPrediction.predictedEvents.length * 200; // Larger objects
	        return estimated;
	    }
	    /**
	     * Calculate battery impact based on current settings
	     */
	    calculateBatteryImpact() {
	        let score = 0;
	        // Factor in update frequency
	        if (this.updateFrequency > 90)
	            score += 2;
	        else if (this.updateFrequency > 60)
	            score += 1;
	        // Factor in input prediction
	        if (this.inputPrediction.enabled)
	            score += 1;
	        // Factor in batch size
	        if (this.batchSize > 15)
	            score += 1;
	        // Factor in event pooling (reduces impact)
	        if (this.eventPool.enabled)
	            score -= 1;
	        if (score <= 0)
	            return 'low';
	        else if (score <= 2)
	            return 'medium';
	        else
	            return 'high';
	    }
	    /**
	     * Trim performance data arrays to prevent memory leaks
	     */
	    trimPerformanceArrays() {
	        const maxLength = 1000;
	        if (this.performanceData.inputLatencies.length > maxLength) {
	            this.performanceData.inputLatencies = this.performanceData.inputLatencies.slice(-maxLength);
	        }
	        if (this.performanceData.gestureRecognitionTimes.length > maxLength) {
	            this.performanceData.gestureRecognitionTimes = this.performanceData.gestureRecognitionTimes.slice(-maxLength);
	        }
	        if (this.performanceData.frameRates.length > maxLength) {
	            this.performanceData.frameRates = this.performanceData.frameRates.slice(-maxLength);
	        }
	        if (this.performanceData.memoryUsages.length > maxLength) {
	            this.performanceData.memoryUsages = this.performanceData.memoryUsages.slice(-maxLength);
	        }
	        // Clean up old predictions
	        const now = performance.now();
	        this.inputPrediction.predictedEvents = this.inputPrediction.predictedEvents.filter(prediction => now - prediction.timestamp < 1000 // Keep predictions for 1 second
	        );
	    }
	}

	/**
	 * Main input manager for the GameByte Framework
	 * Provides unified input handling for touch, mouse, keyboard, and gamepad inputs
	 */
	class GameByteInputManager extends EventEmitter {
	    constructor() {
	        super();
	        this._isInitialized = false;
	        this._currentContext = 'menu';
	        this._contextStack = [];
	        // Input state
	        this.element = null;
	        this.actionCallbacks = new Map();
	        this.currentActions = new Map();
	        this.previousActions = new Map();
	        this.actionValues = new Map();
	        this.enabled = true;
	        this.inputHandlers = new Map();
	        this.settings = {
	            touchEnabled: true,
	            mouseEnabled: true,
	            keyboardEnabled: true,
	            gamepadEnabled: true,
	            sensitivity: 1.0,
	            deadZone: 0.1
	        };
	        // Input queuing for performance
	        this.inputQueue = [];
	        this.maxQueueSize = 100;
	        this.processingInputs = false;
	        // Debug mode
	        this.debugMode = false;
	        this.debugOverlay = null;
	        // Initialize device capabilities
	        this._deviceCapabilities = this.detectDeviceCapabilities();
	        // Initialize performance metrics
	        this._performanceMetrics = {
	            averageLatency: 0,
	            inputEventCount: 0,
	            gestureRecognitionTime: 0,
	            memoryUsage: 0,
	            droppedInputs: 0,
	            frameRate: 60,
	            batteryImpact: 'low'
	        };
	        // Create handlers
	        this.touchHandler = new GameByteTouchInputHandler();
	        this.virtualControls = new GameByteVirtualControlsManager();
	        this.mappingManager = new GameByteInputMappingManager();
	        this.performanceManager = new GameByteInputPerformanceManager();
	        // Bind event handlers once (prevents memory leak from creating new bindings)
	        this.boundPointerHandler = this.handlePointerEvent.bind(this);
	        this.boundKeydownHandler = this.handleKeyboardEvent.bind(this);
	        this.boundKeyupHandler = this.handleKeyboardEvent.bind(this);
	        this.boundGamepadConnectedHandler = this.handleGamepadEvent.bind(this);
	        this.boundGamepadDisconnectedHandler = this.handleGamepadEvent.bind(this);
	        this.boundContextMenuHandler = this.preventDefault.bind(this);
	        // Setup handler event forwarding
	        this.setupHandlerEvents();
	    }
	    // Getters for readonly properties
	    get isInitialized() {
	        return this._isInitialized;
	    }
	    get currentContext() {
	        return this._currentContext;
	    }
	    get deviceCapabilities() {
	        return { ...this._deviceCapabilities };
	    }
	    get performanceMetrics() {
	        return { ...this._performanceMetrics };
	    }
	    /**
	     * Initialize the input manager with optional DOM element
	     */
	    async initialize(element) {
	        if (this._isInitialized) {
	            return;
	        }
	        // Use provided element or default to document.body
	        this.element = element || document.body;
	        if (!this.element) {
	            throw new Error('InputManager: No valid DOM element provided for input capture');
	        }
	        // Initialize handlers
	        await this.touchHandler.initialize(this.element);
	        await this.virtualControls.initialize(this.element);
	        await this.performanceManager.initialize();
	        // Setup DOM event listeners
	        this.setupEventListeners();
	        // Start performance monitoring
	        this.performanceManager.startMonitoring();
	        // Setup update loop
	        this.setupUpdateLoop();
	        // Apply device-specific optimizations
	        this.optimizeForDevice();
	        this._isInitialized = true;
	        this.emit('initialized', this._deviceCapabilities);
	    }
	    /**
	     * Enable or disable input processing
	     */
	    setEnabled(enabled) {
	        this.enabled = enabled;
	        if (!enabled) {
	            // Clear current actions when disabled
	            this.currentActions.clear();
	            this.previousActions.clear();
	        }
	    }
	    /**
	     * Add input handler
	     */
	    addHandler(handler) {
	        // Use a name based on the handler's constructor name or a provided name
	        const handlerName = handler.constructor.name || `handler-${this.inputHandlers.size}`;
	        this.inputHandlers.set(handlerName, handler);
	    }
	    /**
	     * Remove input handler by name
	     */
	    removeHandler(handlerName) {
	        this.inputHandlers.delete(handlerName);
	    }
	    /**
	     * Get input handler by name
	     */
	    getHandler(handlerName) {
	        return this.inputHandlers.get(handlerName) || null;
	    }
	    /**
	     * Configure input settings
	     */
	    configure(settings) {
	        Object.assign(this.settings, settings);
	        // Apply settings immediately if initialized
	        if (this._isInitialized) {
	            this.applySettings();
	        }
	    }
	    /**
	     * Get current input settings
	     */
	    getSettings() {
	        return { ...this.settings };
	    }
	    /**
	     * Destroy the input manager and clean up resources
	     */
	    destroy() {
	        if (!this._isInitialized) {
	            return;
	        }
	        // Stop performance monitoring
	        this.performanceManager.stopMonitoring();
	        // Remove event listeners
	        this.removeEventListeners();
	        // Destroy handlers
	        this.touchHandler.destroy();
	        this.virtualControls.destroy();
	        this.performanceManager.destroy();
	        // Clear input state
	        this.inputQueue.length = 0;
	        this.actionCallbacks.clear();
	        this.currentActions.clear();
	        this.previousActions.clear();
	        this.actionValues.clear();
	        // Remove debug overlay
	        if (this.debugOverlay) {
	            this.debugOverlay.remove();
	            this.debugOverlay = null;
	        }
	        this.element = null;
	        this._isInitialized = false;
	        this.emit('destroyed');
	        this.removeAllListeners();
	    }
	    /**
	     * Set the current input context
	     */
	    setContext(context) {
	        const previousContext = this._currentContext;
	        this._currentContext = context;
	        this.mappingManager.setActiveContext(context);
	        this.emit('context-changed', { previous: previousContext, current: context });
	    }
	    /**
	     * Push a new context onto the stack
	     */
	    pushContext(context) {
	        this._contextStack.push(this._currentContext);
	        this.setContext(context);
	    }
	    /**
	     * Pop the previous context from the stack
	     */
	    popContext() {
	        const previousContext = this._contextStack.pop();
	        if (previousContext) {
	            this.setContext(previousContext);
	            return previousContext;
	        }
	        return null;
	    }
	    /**
	     * Process a raw input event and convert it to a processed event
	     */
	    processInput(event) {
	        const startTime = performance.now();
	        // Check if input is enabled
	        if (!this.enabled) {
	            const processedEvent = {
	                rawEvent: event,
	                action: undefined,
	                context: this._currentContext,
	                consumed: true,
	                value: 0,
	                normalized: true
	            };
	            return processedEvent;
	        }
	        // Get action mapping for this input
	        const action = this.mappingManager.getMapping(this._currentContext, this.getInputKey(event));
	        // Create processed event
	        const processedEvent = {
	            rawEvent: event,
	            action: action || undefined,
	            context: this._currentContext,
	            consumed: false,
	            value: this.getInputValue(event),
	            vector: this.getInputVector(event),
	            normalized: true
	        };
	        // Update action state
	        if (action) {
	            this.updateActionState(action, processedEvent);
	        }
	        // Emit processed event
	        this.emit('input-processed', processedEvent);
	        // Update performance metrics
	        const processingTime = performance.now() - startTime;
	        this.updatePerformanceMetrics(processingTime);
	        return processedEvent;
	    }
	    /**
	     * Register callback for specific game action
	     */
	    onAction(action, callback) {
	        if (!this.actionCallbacks.has(action)) {
	            this.actionCallbacks.set(action, new Set());
	        }
	        this.actionCallbacks.get(action).add(callback);
	    }
	    /**
	     * Unregister callback for specific game action
	     */
	    offAction(action, callback) {
	        const callbacks = this.actionCallbacks.get(action);
	        if (callbacks) {
	            if (callback) {
	                callbacks.delete(callback);
	            }
	            else {
	                callbacks.clear();
	            }
	        }
	    }
	    /**
	     * Add virtual control
	     */
	    addVirtualControl(config) {
	        this.virtualControls.addControl(config);
	    }
	    /**
	     * Remove virtual control
	     */
	    removeVirtualControl(id) {
	        this.virtualControls.removeControl(id);
	    }
	    /**
	     * Show virtual controls
	     */
	    showVirtualControls() {
	        this.virtualControls.show();
	    }
	    /**
	     * Hide virtual controls
	     */
	    hideVirtualControls() {
	        this.virtualControls.hide();
	    }
	    /**
	     * Set input profile
	     */
	    setProfile(profile) {
	        // Apply mappings
	        for (const mapping of profile.mappings) {
	            this.mappingManager.setMapping(mapping);
	        }
	        // Apply virtual controls
	        this.virtualControls.clearControls();
	        for (const controlConfig of profile.virtualControls) {
	            this.virtualControls.addControl(controlConfig);
	        }
	        // Apply settings
	        this.applyProfileSettings(profile.settings);
	        this.emit('profile-changed', profile);
	    }
	    /**
	     * Get current profile
	     */
	    getProfile() {
	        return this.mappingManager.getCurrentProfile();
	    }
	    /**
	     * Save input profile
	     */
	    saveProfile(profile) {
	        this.mappingManager.saveProfile(profile);
	    }
	    /**
	     * Load input profile
	     */
	    loadProfile(id) {
	        const profile = this.mappingManager.loadProfile(id);
	        if (profile) {
	            this.setProfile(profile);
	        }
	        return profile;
	    }
	    /**
	     * Get movement vector from input
	     */
	    getMovementVector() {
	        const left = this.isActionPressed('move-left') ? -1 : 0;
	        const right = this.isActionPressed('move-right') ? 1 : 0;
	        const up = this.isActionPressed('move-up') ? -1 : 0;
	        const down = this.isActionPressed('move-down') ? 1 : 0;
	        // Check for virtual joystick input
	        const joystickValue = this.virtualControls.getJoystickValue('movement-stick');
	        if (joystickValue && (Math.abs(joystickValue.x) > 0.1 || Math.abs(joystickValue.y) > 0.1)) {
	            return joystickValue;
	        }
	        let x = left + right;
	        let y = up + down;
	        // Normalize diagonal movement
	        if (x !== 0 && y !== 0) {
	            const length = Math.sqrt(x * x + y * y);
	            x /= length;
	            y /= length;
	        }
	        return { x, y };
	    }
	    /**
	     * Check if action is currently pressed
	     */
	    isActionPressed(action) {
	        return this.currentActions.get(action) || false;
	    }
	    /**
	     * Check if action was just pressed this frame
	     */
	    isActionJustPressed(action) {
	        const current = this.currentActions.get(action) || false;
	        const previous = this.previousActions.get(action) || false;
	        return current && !previous;
	    }
	    /**
	     * Check if action was just released this frame
	     */
	    isActionJustReleased(action) {
	        const current = this.currentActions.get(action) || false;
	        const previous = this.previousActions.get(action) || false;
	        return !current && previous;
	    }
	    /**
	     * Enable or disable debug mode
	     */
	    enableDebugMode(enabled) {
	        this.debugMode = enabled;
	        if (enabled) {
	            this.createDebugOverlay();
	        }
	        else if (this.debugOverlay) {
	            this.debugOverlay.remove();
	            this.debugOverlay = null;
	        }
	    }
	    /**
	     * Get performance metrics
	     */
	    getPerformanceMetrics() {
	        return this.performanceManager.getMetrics();
	    }
	    /**
	     * Optimize input system for current device.
	     * Uses centralized DeviceConfigurations for tier-based settings.
	     */
	    optimizeForDevice() {
	        const caps = this._deviceCapabilities;
	        // Get tier-based configuration from centralized config
	        const inputConfig = getInputConfigForTier(caps.performanceTier);
	        // Apply configuration
	        this.maxQueueSize = inputConfig.maxQueueSize;
	        this.performanceManager.setPerformanceTarget(inputConfig.performanceTarget);
	        // Enable input prediction based on tier config
	        if (inputConfig.enableInputPrediction) {
	            this.performanceManager.enableInputPrediction(true);
	        }
	        // Adjust virtual controls for touch devices
	        if (caps.hasTouchScreen) {
	            this.virtualControls.updateLayout(caps.screenSize);
	        }
	        this.emit('optimized', caps);
	    }
	    /**
	     * Update input system (called by framework update loop)
	     */
	    update(deltaTime) {
	        if (!this._isInitialized)
	            return;
	        // Update performance tracking
	        this.performanceManager.update();
	        // Update virtual controls
	        this.virtualControls.update(deltaTime);
	        // Update touch handler
	        this.touchHandler.update(deltaTime);
	        // Clean up old events from queue if needed
	        if (this.inputQueue.length > this.maxQueueSize * 0.8) {
	            this.inputQueue.splice(0, Math.floor(this.inputQueue.length * 0.2));
	        }
	    }
	    /**
	     * Render input system overlays (virtual controls, debug info)
	     */
	    render(renderer) {
	        if (!this._isInitialized)
	            return;
	        // Render virtual controls
	        this.virtualControls.render(renderer);
	        // Render debug overlay if enabled
	        if (this.debugMode && this.debugOverlay) {
	            // Debug overlay is rendered as DOM element, not through renderer
	            this.updateDebugOverlay();
	        }
	        // Render any input-specific UI elements from handlers
	        for (const handler of this.inputHandlers.values()) {
	            if ('render' in handler && typeof handler.render === 'function') {
	                handler.render(renderer);
	            }
	        }
	    }
	    /**
	     * Apply current settings to the input system
	     */
	    applySettings() {
	        // Apply sensitivity settings
	        this.touchHandler.setSensitivity(this.settings.sensitivity);
	        // Enable/disable input types based on settings
	        if (!this.settings.touchEnabled) ;
	        if (!this.settings.mouseEnabled) ;
	        if (!this.settings.keyboardEnabled) ;
	        if (!this.settings.gamepadEnabled) ;
	    }
	    /**
	     * Detect device capabilities.
	     * Uses centralized DeviceDetectionUtils.
	     */
	    detectDeviceCapabilities() {
	        const hasTouch = hasTouchScreen();
	        const hasKeyboard = !hasTouch || window.innerWidth > 768; // Heuristic for keyboard availability
	        const hasMouse = window.matchMedia('(pointer: fine)').matches;
	        const hasGamepad = 'getGamepads' in navigator;
	        const screenInfo = getScreenInfo();
	        // Detect performance tier based on centralized utilities
	        const hardwareConcurrency = getHardwareConcurrency();
	        const deviceMemory = estimateDeviceMemory();
	        let performanceTier = 'medium';
	        if (hardwareConcurrency >= 8 && deviceMemory >= 4) {
	            performanceTier = 'high';
	        }
	        else if (hardwareConcurrency <= 2 || deviceMemory < 1) {
	            performanceTier = 'low';
	        }
	        return {
	            hasTouchScreen: hasTouch,
	            hasTouch: hasTouch, // Alias for compatibility
	            hasKeyboard,
	            hasMouse,
	            hasGamepad,
	            maxTouchPoints: navigator.maxTouchPoints || (hasTouch ? 10 : 0),
	            supportsPressure: hasTouch, // Modern touch devices usually support pressure
	            supportsHaptics: supportsHaptics(),
	            performanceTier,
	            screenSize: {
	                width: window.innerWidth,
	                height: window.innerHeight,
	            },
	            pixelRatio: screenInfo.pixelRatio,
	        };
	    }
	    /**
	     * Setup event listeners for different input types
	     */
	    setupEventListeners() {
	        if (!this.element)
	            return;
	        // Touch/Pointer events (using pre-bound handlers for proper cleanup)
	        this.element.addEventListener('pointerdown', this.boundPointerHandler);
	        this.element.addEventListener('pointermove', this.boundPointerHandler);
	        this.element.addEventListener('pointerup', this.boundPointerHandler);
	        this.element.addEventListener('pointercancel', this.boundPointerHandler);
	        // Keyboard events
	        window.addEventListener('keydown', this.boundKeydownHandler);
	        window.addEventListener('keyup', this.boundKeyupHandler);
	        // Gamepad events
	        window.addEventListener('gamepadconnected', this.boundGamepadConnectedHandler);
	        window.addEventListener('gamepaddisconnected', this.boundGamepadDisconnectedHandler);
	        // Prevent context menu and default behaviors
	        this.element.addEventListener('contextmenu', this.boundContextMenuHandler);
	    }
	    /**
	     * Remove event listeners
	     */
	    removeEventListeners() {
	        if (!this.element)
	            return;
	        // Remove using same handler references (fixes memory leak)
	        this.element.removeEventListener('pointerdown', this.boundPointerHandler);
	        this.element.removeEventListener('pointermove', this.boundPointerHandler);
	        this.element.removeEventListener('pointerup', this.boundPointerHandler);
	        this.element.removeEventListener('pointercancel', this.boundPointerHandler);
	        window.removeEventListener('keydown', this.boundKeydownHandler);
	        window.removeEventListener('keyup', this.boundKeyupHandler);
	        window.removeEventListener('gamepadconnected', this.boundGamepadConnectedHandler);
	        window.removeEventListener('gamepaddisconnected', this.boundGamepadDisconnectedHandler);
	        this.element.removeEventListener('contextmenu', this.boundContextMenuHandler);
	    }
	    /**
	     * Handle pointer events (touch, mouse, pen)
	     */
	    handlePointerEvent(event) {
	        event.preventDefault();
	        const rawEvent = {
	            type: this.mapPointerEventType(event.type),
	            device: event.pointerType === 'touch' ? 'touch' : 'mouse',
	            timestamp: performance.now(),
	            position: { x: event.clientX, y: event.clientY },
	            pointerId: event.pointerId,
	            button: event.button,
	            pressure: event.pressure
	        };
	        this.queueInput(rawEvent);
	    }
	    /**
	     * Handle keyboard events
	     */
	    handleKeyboardEvent(event) {
	        const rawEvent = {
	            type: event.type === 'keydown' ? 'key-down' : 'key-up',
	            device: 'keyboard',
	            timestamp: performance.now(),
	            key: event.key,
	            keyCode: event.keyCode
	        };
	        this.queueInput(rawEvent);
	    }
	    /**
	     * Handle gamepad events
	     */
	    handleGamepadEvent(event) {
	        const rawEvent = {
	            type: event.type === 'gamepadconnected' ? 'gamepad-connected' : 'gamepad-disconnected',
	            device: 'gamepad',
	            timestamp: performance.now(),
	            gamepadIndex: event.gamepad.index
	        };
	        this.queueInput(rawEvent);
	    }
	    /**
	     * Queue input event for processing
	     */
	    queueInput(event) {
	        if (this.inputQueue.length >= this.maxQueueSize) {
	            // Drop oldest input if queue is full
	            this.inputQueue.shift();
	            this._performanceMetrics.droppedInputs++;
	        }
	        this.inputQueue.push(event);
	    }
	    /**
	     * Process queued input events
	     */
	    processQueuedInputs() {
	        if (this.processingInputs || this.inputQueue.length === 0) {
	            return;
	        }
	        this.processingInputs = true;
	        // Process all queued inputs
	        const eventsToProcess = [...this.inputQueue];
	        this.inputQueue.length = 0;
	        for (const rawEvent of eventsToProcess) {
	            const processedEvent = this.processInput(rawEvent);
	            // Trigger action callbacks
	            if (processedEvent.action && !processedEvent.consumed) {
	                const callbacks = this.actionCallbacks.get(processedEvent.action);
	                if (callbacks) {
	                    for (const callback of callbacks) {
	                        try {
	                            callback(processedEvent);
	                        }
	                        catch (error) {
	                            console.error('Error in input action callback:', error);
	                        }
	                    }
	                }
	            }
	        }
	        this.processingInputs = false;
	    }
	    /**
	     * Setup handler event forwarding
	     */
	    setupHandlerEvents() {
	        // Forward touch handler events
	        this.touchHandler.on('gesture', (gesture) => {
	            this.emit('gesture', gesture);
	        });
	        // Forward virtual controls events
	        this.virtualControls.on('control-activated', (controlId, action) => {
	            if (action) {
	                const processedEvent = {
	                    rawEvent: {
	                        type: 'down',
	                        device: 'touch',
	                        timestamp: performance.now()
	                    },
	                    action,
	                    context: this._currentContext,
	                    consumed: false,
	                    value: 1
	                };
	                this.updateActionState(action, processedEvent);
	                this.triggerActionCallbacks(action, processedEvent);
	            }
	        });
	        this.virtualControls.on('control-deactivated', (controlId, action) => {
	            if (action) {
	                const processedEvent = {
	                    rawEvent: {
	                        type: 'up',
	                        device: 'touch',
	                        timestamp: performance.now()
	                    },
	                    action,
	                    context: this._currentContext,
	                    consumed: false,
	                    value: 0
	                };
	                this.updateActionState(action, processedEvent);
	                this.triggerActionCallbacks(action, processedEvent);
	            }
	        });
	    }
	    /**
	     * Setup update loop for input processing
	     */
	    setupUpdateLoop() {
	        const update = () => {
	            if (!this._isInitialized)
	                return;
	            // Copy current actions to previous
	            this.previousActions.clear();
	            for (const [action, pressed] of this.currentActions) {
	                this.previousActions.set(action, pressed);
	            }
	            // Process queued inputs
	            this.processQueuedInputs();
	            // Update gamepad input
	            this.updateGamepadInput();
	            // Update performance metrics
	            this.performanceManager.update();
	            // Update debug overlay
	            if (this.debugMode && this.debugOverlay) {
	                this.updateDebugOverlay();
	            }
	            requestAnimationFrame(update);
	        };
	        requestAnimationFrame(update);
	    }
	    /**
	     * Update gamepad input state
	     */
	    updateGamepadInput() {
	        if (!this._deviceCapabilities.hasGamepad)
	            return;
	        const gamepads = navigator.getGamepads();
	        for (let i = 0; i < gamepads.length; i++) {
	            const gamepad = gamepads[i];
	            if (!gamepad)
	                continue;
	            // Process gamepad buttons
	            for (let j = 0; j < gamepad.buttons.length; j++) {
	                const button = gamepad.buttons[j];
	                if (button.pressed !== this.getGamepadButtonState(i, j)) {
	                    const rawEvent = {
	                        type: button.pressed ? 'gamepad-button-down' : 'gamepad-button-up',
	                        device: 'gamepad',
	                        timestamp: performance.now(),
	                        gamepadIndex: i,
	                        button: j,
	                        pressure: button.value
	                    };
	                    this.processInput(rawEvent);
	                }
	            }
	            // Process gamepad axes
	            for (let j = 0; j < gamepad.axes.length; j++) {
	                const axisValue = gamepad.axes[j];
	                if (Math.abs(axisValue - this.getGamepadAxisValue(i, j)) > 0.1) {
	                    const rawEvent = {
	                        type: 'gamepad-axis',
	                        device: 'gamepad',
	                        timestamp: performance.now(),
	                        gamepadIndex: i,
	                        axisIndex: j,
	                        axisValue
	                    };
	                    this.processInput(rawEvent);
	                }
	            }
	        }
	    }
	    /**
	     * Get input key string from raw event
	     */
	    getInputKey(event) {
	        switch (event.device) {
	            case 'keyboard':
	                return `key:${event.key}`;
	            case 'mouse':
	                return `mouse:button${event.button}`;
	            case 'gamepad':
	                return `gamepad:${event.gamepadIndex}:button${event.button}`;
	            case 'touch':
	                return `touch:${event.type}`;
	            default:
	                return 'unknown';
	        }
	    }
	    /**
	     * Get input value from raw event
	     */
	    getInputValue(event) {
	        if (event.pressure !== undefined) {
	            return event.pressure;
	        }
	        if (event.axisValue !== undefined) {
	            return event.axisValue;
	        }
	        return event.type === 'down' || event.type === 'key-down' || event.type === 'gamepad-button-down' ? 1 : 0;
	    }
	    /**
	     * Get input vector from raw event
	     */
	    getInputVector(event) {
	        if (event.position) {
	            return event.position;
	        }
	        return undefined;
	    }
	    /**
	     * Map pointer event type to input event type
	     */
	    mapPointerEventType(type) {
	        switch (type) {
	            case 'pointerdown': return 'down';
	            case 'pointermove': return 'move';
	            case 'pointerup': return 'up';
	            case 'pointercancel': return 'cancel';
	            default: return 'move';
	        }
	    }
	    /**
	     * Update action state
	     */
	    updateActionState(action, event) {
	        const isPressed = event.rawEvent.type === 'down' ||
	            event.rawEvent.type === 'key-down' ||
	            event.rawEvent.type === 'gamepad-button-down' ||
	            (event.value !== undefined && event.value > 0.1);
	        this.currentActions.set(action, isPressed);
	        if (event.value !== undefined) {
	            this.actionValues.set(action, event.value);
	        }
	    }
	    /**
	     * Trigger action callbacks
	     */
	    triggerActionCallbacks(action, event) {
	        const callbacks = this.actionCallbacks.get(action);
	        if (callbacks) {
	            for (const callback of callbacks) {
	                try {
	                    callback(event);
	                }
	                catch (error) {
	                    console.error('Error in input action callback:', error);
	                }
	            }
	        }
	    }
	    /**
	     * Apply profile settings
	     */
	    applyProfileSettings(settings) {
	        // Apply touch sensitivity
	        this.touchHandler.setSensitivity(settings.touchSensitivity);
	        // Apply gesture thresholds
	        this.touchHandler.setGestureThresholds(settings.gestureThresholds);
	        // Apply virtual control settings
	        this.virtualControls.enableHaptics(settings.hapticEnabled);
	        // Apply performance settings
	        if (settings.inputPrediction) {
	            this.performanceManager.enableInputPrediction(true);
	        }
	    }
	    /**
	     * Update performance metrics
	     */
	    updatePerformanceMetrics(processingTime) {
	        this._performanceMetrics.inputEventCount++;
	        this._performanceMetrics.averageLatency =
	            (this._performanceMetrics.averageLatency + processingTime) / 2;
	    }
	    /**
	     * Create debug overlay
	     */
	    createDebugOverlay() {
	        if (this.debugOverlay)
	            return;
	        this.debugOverlay = document.createElement('div');
	        this.debugOverlay.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      font-family: monospace;
      font-size: 12px;
      padding: 10px;
      border-radius: 5px;
      z-index: 10000;
      pointer-events: none;
      max-width: 300px;
    `;
	        document.body.appendChild(this.debugOverlay);
	    }
	    /**
	     * Update debug overlay
	     */
	    updateDebugOverlay() {
	        if (!this.debugOverlay)
	            return;
	        const metrics = this.getPerformanceMetrics();
	        const activeActions = Array.from(this.currentActions.entries())
	            .filter(([_, pressed]) => pressed)
	            .map(([action, _]) => action);
	        this.debugOverlay.innerHTML = `
      <div><strong>Input Debug</strong></div>
      <div>Context: ${this._currentContext}</div>
      <div>Active Actions: ${activeActions.join(', ') || 'None'}</div>
      <div>Input Events: ${metrics.inputEventCount}</div>
      <div>Avg Latency: ${metrics.averageLatency.toFixed(2)}ms</div>
      <div>Dropped Inputs: ${metrics.droppedInputs}</div>
      <div>Queue Size: ${this.inputQueue.length}</div>
      <div>Device: ${this._deviceCapabilities.performanceTier}</div>
    `;
	    }
	    /**
	     * Get gamepad button state (for comparison)
	     */
	    getGamepadButtonState(gamepadIndex, buttonIndex) {
	        // This would typically be stored in a gamepad state cache
	        return false;
	    }
	    /**
	     * Get gamepad axis value (for comparison)
	     */
	    getGamepadAxisValue(gamepadIndex, axisIndex) {
	        // This would typically be stored in a gamepad state cache
	        return 0;
	    }
	    /**
	     * Prevent default event behavior
	     */
	    preventDefault(event) {
	        event.preventDefault();
	    }
	}

	/**
	 * Specialized input handler for platformer games
	 * Handles movement, jumping with coyote time, jump buffering, and variable jump height
	 */
	class GameBytePlatformerInputHandler extends EventEmitter {
	    constructor(config) {
	        super();
	        this.name = 'platformer-input';
	        this.priority = 90;
	        this.supportedContexts = ['gameplay'];
	        this.active = false;
	        this.context = 'gameplay';
	        // Input tracking
	        this.pressedKeys = new Set();
	        this.frameCounter = 0;
	        this.lastUpdateTime = 0;
	        // Smoothing
	        this.targetHorizontalMovement = 0;
	        this.smoothedHorizontalMovement = 0;
	        this.config = {
	            jumpBufferFrames: 6,
	            coyoteTimeFrames: 6,
	            variableJumpHeight: true,
	            maxJumpHoldTime: 300, // milliseconds
	            runSpeedMultiplier: 1.5,
	            inputSmoothing: true,
	            smoothingFactor: 0.15,
	            ...config
	        };
	        this.state = {
	            horizontalMovement: 0,
	            isJumpPressed: false,
	            wasJumpJustPressed: false,
	            isRunPressed: false,
	            jumpHoldDuration: 0,
	            jumpStartTime: 0,
	            framesSinceJumpPressed: 0,
	            coyoteTime: 0,
	            jumpBufferTime: 0
	        };
	    }
	    /**
	     * Process raw input event
	     */
	    handleInput(event) {
	        if (!this.active)
	            return;
	        // Set deviceType for compatibility
	        if (!event.deviceType) {
	            event.deviceType = event.device;
	        }
	        // Process different input types
	        switch (event.deviceType || event.device) {
	            case 'keyboard':
	                this.handleKeyboardInput(event);
	                break;
	            case 'touch':
	                this.handleTouchInput(event);
	                break;
	            case 'mouse':
	                this.handleMouseInput(event);
	                break;
	            case 'gamepad':
	                this.handleGamepadInput(event);
	                break;
	        }
	        // Map to game actions
	        const action = this.getActionFromInput(event);
	        if (action) {
	            this.emit('action', action, event);
	        }
	    }
	    /**
	     * Get horizontal movement input (-1 to 1)
	     */
	    getHorizontalMovement() {
	        return this.config.inputSmoothing ? this.smoothedHorizontalMovement : this.state.horizontalMovement;
	    }
	    /**
	     * Get horizontal input (alias for interface compatibility)
	     */
	    getHorizontalInput() {
	        return this.getHorizontalMovement();
	    }
	    /**
	     * Check if jump action is active
	     */
	    isJumpPressed() {
	        return this.state.isJumpPressed;
	    }
	    /**
	     * Check if jump was just pressed this frame
	     */
	    wasJumpJustPressed() {
	        return this.state.wasJumpJustPressed;
	    }
	    /**
	     * Check if jump was just pressed (alias for interface compatibility)
	     */
	    isJumpJustPressed() {
	        return this.wasJumpJustPressed();
	    }
	    /**
	     * Check if run action is active
	     */
	    isRunPressed() {
	        return this.state.isRunPressed;
	    }
	    /**
	     * Get jump hold duration
	     */
	    getJumpHoldDuration() {
	        return this.state.jumpHoldDuration;
	    }
	    /**
	     * Check if jump is buffered (pressed recently but not processed)
	     */
	    isJumpBuffered() {
	        return this.state.jumpBufferTime > 0;
	    }
	    /**
	     * Consume jump buffer (call when jump is processed)
	     */
	    consumeJumpBuffer() {
	        this.state.jumpBufferTime = 0;
	        this.state.wasJumpJustPressed = false;
	    }
	    /**
	     * Check if in coyote time (recently left ground)
	     */
	    isInCoyoteTime() {
	        return this.state.coyoteTime > 0;
	    }
	    /**
	     * Consume coyote time (call when jump is processed)
	     */
	    consumeCoyoteTime() {
	        this.state.coyoteTime = 0;
	    }
	    /**
	     * Notify that player has landed (resets coyote time)
	     */
	    onPlayerLanded() {
	        this.state.coyoteTime = this.config.coyoteTimeFrames;
	    }
	    /**
	     * Notify that player has left ground
	     */
	    onPlayerLeftGround() {
	        // Coyote time starts counting down when leaving ground
	        if (this.state.coyoteTime === 0) {
	            this.state.coyoteTime = this.config.coyoteTimeFrames;
	        }
	    }
	    /**
	     * Set movement smoothing factor
	     */
	    setMovementSmoothing(smoothing) {
	        this.config.smoothingFactor = smoothing;
	    }
	    /**
	     * Set jump buffering enabled/disabled
	     */
	    setJumpBuffering(enabled) {
	        if (enabled) {
	            this.config.jumpBufferFrames = 6; // Default buffer frames
	        }
	        else {
	            this.config.jumpBufferFrames = 0;
	        }
	    }
	    /**
	     * Set coyote time frames
	     */
	    setCoyoteTime(time) {
	        this.config.coyoteTimeFrames = Math.max(0, time);
	    }
	    /**
	     * Check if player can jump
	     */
	    canJump() {
	        return this.isInCoyoteTime() || this.isJumpBuffered();
	    }
	    /**
	     * Check if player is grounded (simplified implementation)
	     */
	    isGrounded() {
	        return this.state.coyoteTime > 0;
	    }
	    /**
	     * Set grounded state
	     */
	    setGrounded(grounded) {
	        if (grounded) {
	            this.onPlayerLanded();
	        }
	        else {
	            this.onPlayerLeftGround();
	        }
	    }
	    /**
	     * Check if handler is enabled (InputHandler interface)
	     */
	    isEnabled() {
	        return this.active;
	    }
	    /**
	     * Set handler enabled state (InputHandler interface)
	     */
	    setEnabled(enabled) {
	        this.active = enabled;
	        if (!enabled) {
	            this.resetState();
	        }
	    }
	    /**
	     * Update handler state
	     */
	    update(deltaTime) {
	        if (!this.active)
	            return;
	        this.frameCounter++;
	        this.lastUpdateTime = performance.now();
	        // Update input states
	        this.updateMovementState();
	        this.updateJumpState();
	        this.updateTimers();
	        // Apply input smoothing
	        if (this.config.inputSmoothing) {
	            this.applyInputSmoothing(deltaTime);
	        }
	        // Reset frame-specific flags
	        this.state.wasJumpJustPressed = false;
	    }
	    /**
	     * Check if handler can process this event
	     */
	    canHandle(event, context) {
	        return this.active && this.supportedContexts.includes(context);
	    }
	    /**
	     * Activate handler for context
	     */
	    activate(context) {
	        this.active = true;
	        this.context = context;
	        this.resetState();
	        this.emit('activated', context);
	    }
	    /**
	     * Deactivate handler
	     */
	    deactivate() {
	        this.active = false;
	        this.resetState();
	        this.emit('deactivated');
	    }
	    /**
	     * Cleanup resources
	     */
	    destroy() {
	        this.deactivate();
	        this.removeAllListeners();
	    }
	    /**
	     * Configure handler settings
	     */
	    configure(config) {
	        this.config = { ...this.config, ...config };
	    }
	    /**
	     * Handle keyboard input
	     */
	    handleKeyboardInput(event) {
	        if (!event.key)
	            return;
	        const key = event.key;
	        if (event.type === 'key-down') {
	            this.pressedKeys.add(key);
	            // Jump input
	            if (this.isJumpKey(key)) {
	                this.onJumpPressed();
	            }
	            // Run input
	            if (this.isRunKey(key)) {
	                this.state.isRunPressed = true;
	            }
	        }
	        else if (event.type === 'key-up') {
	            this.pressedKeys.delete(key);
	            // Jump input
	            if (this.isJumpKey(key)) {
	                this.onJumpReleased();
	            }
	            // Run input
	            if (this.isRunKey(key)) {
	                this.state.isRunPressed = false;
	            }
	        }
	    }
	    /**
	     * Handle touch input (usually from virtual controls)
	     */
	    handleTouchInput(event) {
	        // Touch input is typically handled by virtual controls
	        // which translate to game actions
	    }
	    /**
	     * Handle mouse input
	     */
	    handleMouseInput(event) {
	        if (event.type === 'down') {
	            if (event.button === 0) { // Left click
	                this.onJumpPressed();
	            }
	        }
	        else if (event.type === 'up') {
	            if (event.button === 0) {
	                this.onJumpReleased();
	            }
	        }
	    }
	    /**
	     * Handle gamepad input
	     */
	    handleGamepadInput(event) {
	        if (event.type === 'gamepad-button-down' || event.type === 'gamepad-button-up') {
	            const button = event.gamepadButton;
	            if (button === 0) { // A button (jump)
	                if (event.type === 'gamepad-button-down') {
	                    this.onJumpPressed();
	                }
	                else {
	                    this.onJumpReleased();
	                }
	            }
	        }
	        else if (event.type === 'gamepad-axis') {
	            const axis = event.gamepadAxis;
	            if (axis === 0) { // Left stick X
	                this.targetHorizontalMovement = event.axisValue || 0;
	            }
	        }
	    }
	    /**
	     * Update movement state based on pressed keys
	     */
	    updateMovementState() {
	        let movement = 0;
	        // Check for movement keys
	        if (this.pressedKeys.has('ArrowLeft') || this.pressedKeys.has('KeyA')) {
	            movement -= 1;
	        }
	        if (this.pressedKeys.has('ArrowRight') || this.pressedKeys.has('KeyD')) {
	            movement += 1;
	        }
	        this.targetHorizontalMovement = movement;
	        if (!this.config.inputSmoothing) {
	            this.state.horizontalMovement = movement;
	        }
	    }
	    /**
	     * Update jump state
	     */
	    updateJumpState() {
	        // Update jump hold duration
	        if (this.state.isJumpPressed && this.state.jumpStartTime > 0) {
	            this.state.jumpHoldDuration = this.lastUpdateTime - this.state.jumpStartTime;
	            // Limit jump hold time
	            if (this.config.variableJumpHeight &&
	                this.state.jumpHoldDuration > this.config.maxJumpHoldTime) {
	                this.state.isJumpPressed = false;
	            }
	        }
	    }
	    /**
	     * Update frame-based timers
	     */
	    updateTimers() {
	        // Update jump buffer
	        if (this.state.jumpBufferTime > 0) {
	            this.state.jumpBufferTime--;
	        }
	        // Update coyote time
	        if (this.state.coyoteTime > 0) {
	            this.state.coyoteTime--;
	        }
	        // Update frames since jump pressed
	        if (this.state.framesSinceJumpPressed < 999) {
	            this.state.framesSinceJumpPressed++;
	        }
	    }
	    /**
	     * Apply input smoothing to movement
	     */
	    applyInputSmoothing(deltaTime) {
	        const smoothingFactor = this.config.smoothingFactor;
	        const frameSmoothing = Math.min(smoothingFactor * (deltaTime / 16.67), 1); // Normalize to 60fps
	        this.smoothedHorizontalMovement = this.lerp(this.smoothedHorizontalMovement, this.targetHorizontalMovement, frameSmoothing);
	        // Snap to target when very close
	        if (Math.abs(this.smoothedHorizontalMovement - this.targetHorizontalMovement) < 0.01) {
	            this.smoothedHorizontalMovement = this.targetHorizontalMovement;
	        }
	        this.state.horizontalMovement = this.smoothedHorizontalMovement;
	    }
	    /**
	     * Handle jump pressed
	     */
	    onJumpPressed() {
	        if (!this.state.isJumpPressed) {
	            this.state.isJumpPressed = true;
	            this.state.wasJumpJustPressed = true;
	            this.state.jumpStartTime = this.lastUpdateTime;
	            this.state.jumpHoldDuration = 0;
	            this.state.framesSinceJumpPressed = 0;
	            this.state.jumpBufferTime = this.config.jumpBufferFrames;
	            this.emit('jump-pressed');
	        }
	    }
	    /**
	     * Handle jump released
	     */
	    onJumpReleased() {
	        if (this.state.isJumpPressed) {
	            this.state.isJumpPressed = false;
	            this.emit('jump-released', this.state.jumpHoldDuration);
	        }
	    }
	    /**
	     * Check if key is a jump key
	     */
	    isJumpKey(key) {
	        return ['Space', 'ArrowUp', 'KeyW', 'KeyZ'].includes(key);
	    }
	    /**
	     * Check if key is a run key
	     */
	    isRunKey(key) {
	        return ['ShiftLeft', 'ShiftRight', 'KeyX'].includes(key);
	    }
	    /**
	     * Get action from input event
	     */
	    getActionFromInput(event) {
	        if (event.deviceType === 'keyboard' && event.key) {
	            if (this.isJumpKey(event.key) && event.type === 'key-down') {
	                return 'jump';
	            }
	            if (['ArrowLeft', 'KeyA'].includes(event.key)) {
	                return 'move-left';
	            }
	            if (['ArrowRight', 'KeyD'].includes(event.key)) {
	                return 'move-right';
	            }
	        }
	        return null;
	    }
	    /**
	     * Reset handler state
	     */
	    resetState() {
	        this.state = {
	            horizontalMovement: 0,
	            isJumpPressed: false,
	            wasJumpJustPressed: false,
	            isRunPressed: false,
	            jumpHoldDuration: 0,
	            jumpStartTime: 0,
	            framesSinceJumpPressed: 0,
	            coyoteTime: 0,
	            jumpBufferTime: 0
	        };
	        this.pressedKeys.clear();
	        this.targetHorizontalMovement = 0;
	        this.smoothedHorizontalMovement = 0;
	    }
	    /**
	     * Linear interpolation utility
	     */
	    lerp(start, end, factor) {
	        return start + (end - start) * factor;
	    }
	}

	/**
	 * Specialized input handler for camera controls
	 * Supports pan, zoom, rotation with mouse, touch, and gamepad input
	 */
	class GameByteCameraInputHandler extends EventEmitter {
	    constructor(config) {
	        super();
	        this.name = 'camera-input';
	        this.priority = 80;
	        this.supportedContexts = ['gameplay', 'menu'];
	        this.active = false;
	        this.context = 'gameplay';
	        // Input tracking
	        this.pressedKeys = new Set();
	        this.pressedMouseButtons = new Set();
	        this.activeTouches = new Map();
	        // Smoothing
	        this.targetPanDelta = { x: 0, y: 0 };
	        this.targetZoomDelta = 0;
	        this.targetRotationDelta = 0;
	        this.config = {
	            panSensitivity: 1.0,
	            zoomSensitivity: 1.0,
	            rotationSensitivity: 1.0,
	            panEnabled: true,
	            zoomEnabled: true,
	            rotationEnabled: true,
	            invertPanX: false,
	            invertPanY: false,
	            invertZoom: false,
	            invertRotation: false,
	            smoothing: true,
	            smoothingFactor: 0.1,
	            minZoom: 0.1,
	            maxZoom: 10.0,
	            panDeadZone: 0.05,
	            zoomDeadZone: 0.01,
	            rotationDeadZone: 0.01,
	            touchGestureEnabled: true,
	            mouseWheelZoom: true,
	            rightClickPan: true,
	            middleClickPan: true,
	            ...config
	        };
	        this.state = {
	            panDelta: { x: 0, y: 0 },
	            zoomDelta: 0,
	            rotationDelta: 0,
	            isPanning: false,
	            isZooming: false,
	            isRotating: false,
	            lastMousePosition: { x: 0, y: 0 },
	            lastTouchPositions: [],
	            lastPinchDistance: 0,
	            lastRotationAngle: 0
	        };
	    }
	    /**
	     * Process raw input event
	     */
	    handleInput(event) {
	        if (!this.active)
	            return;
	        // Set deviceType for compatibility
	        if (!event.deviceType) {
	            event.deviceType = event.device;
	        }
	        // Process different input types
	        switch (event.deviceType || event.device) {
	            case 'keyboard':
	                this.handleKeyboardInput(event);
	                break;
	            case 'mouse':
	                this.handleMouseInput(event);
	                break;
	            case 'touch':
	                this.handleTouchInput(event);
	                break;
	            case 'gamepad':
	                this.handleGamepadInput(event);
	                break;
	        }
	        // Map to game actions
	        const action = this.getActionFromInput(event);
	        if (action) {
	            this.emit('action', action, event);
	        }
	    }
	    /**
	     * Get camera pan delta
	     */
	    getPanDelta() {
	        return { ...this.state.panDelta };
	    }
	    /**
	     * Get camera zoom delta
	     */
	    getZoomDelta() {
	        return this.state.zoomDelta;
	    }
	    /**
	     * Get camera rotation delta
	     */
	    getRotationDelta() {
	        return this.state.rotationDelta;
	    }
	    /**
	     * Check if camera is currently panning
	     */
	    isPanning() {
	        return this.state.isPanning;
	    }
	    /**
	     * Check if camera is currently zooming
	     */
	    isZooming() {
	        return this.state.isZooming;
	    }
	    /**
	     * Check if camera is currently rotating
	     */
	    isRotating() {
	        return this.state.isRotating;
	    }
	    /**
	     * Set pan sensitivity
	     */
	    setPanSensitivity(sensitivity) {
	        this.config.panSensitivity = sensitivity;
	    }
	    /**
	     * Set zoom sensitivity
	     */
	    setZoomSensitivity(sensitivity) {
	        this.config.zoomSensitivity = sensitivity;
	    }
	    /**
	     * Set rotation sensitivity
	     */
	    setRotationSensitivity(sensitivity) {
	        this.config.rotationSensitivity = sensitivity;
	    }
	    /**
	     * Set invert controls
	     */
	    setInvertControls(pan, zoom, rotation) {
	        this.config.invertPanX = pan;
	        this.config.invertPanY = pan;
	        this.config.invertZoom = zoom;
	        this.config.invertRotation = rotation;
	    }
	    /**
	     * Set pan limits
	     */
	    setPanLimits(bounds) {
	        // Store pan limits in config (would need to extend config interface)
	        // For now, just emit event to notify about limits
	        this.emit('pan-limits-set', bounds);
	    }
	    /**
	     * Set zoom limits
	     */
	    setZoomLimits(min, max) {
	        this.config.minZoom = min;
	        this.config.maxZoom = max;
	    }
	    /**
	     * Set rotation limits
	     */
	    setRotationLimits(min, max) {
	        // Store rotation limits (would need to extend config interface)
	        // For now, just emit event to notify about limits
	        this.emit('rotation-limits-set', { min, max });
	    }
	    /**
	     * Check if handler is enabled (InputHandler interface)
	     */
	    isEnabled() {
	        return this.active;
	    }
	    /**
	     * Set camera sensitivity
	     */
	    setSensitivity(pan, zoom, rotation) {
	        this.config.panSensitivity = pan;
	        this.config.zoomSensitivity = zoom;
	        this.config.rotationSensitivity = rotation;
	    }
	    /**
	     * Set handler enabled state (InputHandler interface)
	     */
	    setEnabled(enabled) {
	        this.active = enabled;
	        if (!enabled) {
	            this.resetState();
	        }
	    }
	    /**
	     * Enable/disable camera controls
	     */
	    setEnabledControls(pan, zoom, rotation) {
	        this.config.panEnabled = pan;
	        this.config.zoomEnabled = zoom;
	        this.config.rotationEnabled = rotation;
	    }
	    /**
	     * Update handler state
	     */
	    update(deltaTime) {
	        if (!this.active)
	            return;
	        // Update camera controls based on input
	        this.updateKeyboardControls();
	        this.updateGamepadControls();
	        // Apply smoothing
	        if (this.config.smoothing) {
	            this.applySmoothing(deltaTime);
	        }
	        else {
	            this.state.panDelta = { ...this.targetPanDelta };
	            this.state.zoomDelta = this.targetZoomDelta;
	            this.state.rotationDelta = this.targetRotationDelta;
	        }
	        // Apply dead zones
	        this.applyDeadZones();
	        // Apply sensitivity and inversion
	        this.applySensitivityAndInversion();
	        // Emit camera events if there's movement
	        this.emitCameraEvents();
	        // Reset deltas for next frame
	        this.resetTargetDeltas();
	    }
	    /**
	     * Check if handler can process this event
	     */
	    canHandle(event, context) {
	        return this.active && this.supportedContexts.includes(context);
	    }
	    /**
	     * Activate handler for context
	     */
	    activate(context) {
	        this.active = true;
	        this.context = context;
	        this.resetState();
	        this.emit('activated', context);
	    }
	    /**
	     * Deactivate handler
	     */
	    deactivate() {
	        this.active = false;
	        this.resetState();
	        this.emit('deactivated');
	    }
	    /**
	     * Cleanup resources
	     */
	    destroy() {
	        this.deactivate();
	        this.removeAllListeners();
	    }
	    /**
	     * Configure handler settings
	     */
	    configure(config) {
	        this.config = { ...this.config, ...config };
	    }
	    /**
	     * Handle keyboard input
	     */
	    handleKeyboardInput(event) {
	        if (!event.key)
	            return;
	        const key = event.key;
	        if (event.type === 'key-down') {
	            this.pressedKeys.add(key);
	        }
	        else if (event.type === 'key-up') {
	            this.pressedKeys.delete(key);
	        }
	    }
	    /**
	     * Handle mouse input
	     */
	    handleMouseInput(event) {
	        if (!event.position)
	            return;
	        const position = event.position;
	        switch (event.type) {
	            case 'down':
	                if (event.button !== undefined) {
	                    this.pressedMouseButtons.add(event.button);
	                    this.state.lastMousePosition = { ...position };
	                    if (event.button === 2 && this.config.rightClickPan) { // Right click
	                        this.state.isPanning = true;
	                    }
	                    else if (event.button === 1 && this.config.middleClickPan) { // Middle click
	                        this.state.isPanning = true;
	                    }
	                }
	                break;
	            case 'up':
	                if (event.button !== undefined) {
	                    this.pressedMouseButtons.delete(event.button);
	                    if (event.button === 2 || event.button === 1) {
	                        this.state.isPanning = false;
	                    }
	                }
	                break;
	            case 'move':
	                if (this.state.isPanning && this.config.panEnabled) {
	                    const deltaX = position.x - this.state.lastMousePosition.x;
	                    const deltaY = position.y - this.state.lastMousePosition.y;
	                    this.targetPanDelta.x += deltaX;
	                    this.targetPanDelta.y += deltaY;
	                }
	                this.state.lastMousePosition = { ...position };
	                break;
	            default:
	                // Handle wheel events for zoom
	                if (event.delta && this.config.mouseWheelZoom && this.config.zoomEnabled) {
	                    this.targetZoomDelta += event.delta.y * 0.001;
	                }
	                break;
	        }
	    }
	    /**
	     * Handle touch input
	     */
	    handleTouchInput(event) {
	        if (!event.position || event.pointerId === undefined)
	            return;
	        const touchId = event.pointerId;
	        const position = event.position;
	        switch (event.type) {
	            case 'down':
	                this.activeTouches.set(touchId, position);
	                this.updateTouchGestures();
	                break;
	            case 'move':
	                if (this.activeTouches.has(touchId)) {
	                    this.activeTouches.set(touchId, position);
	                    this.updateTouchGestures();
	                }
	                break;
	            case 'up':
	            case 'cancel':
	                this.activeTouches.delete(touchId);
	                this.updateTouchGestures();
	                break;
	        }
	    }
	    /**
	     * Handle gamepad input
	     */
	    handleGamepadInput(event) {
	        if (event.type === 'gamepad-axis' && event.gamepadAxis !== undefined && event.axisValue !== undefined) {
	            const axis = event.gamepadAxis;
	            const value = event.axisValue;
	            switch (axis) {
	                case 2: // Right stick X - Camera pan X
	                    if (this.config.panEnabled) {
	                        this.targetPanDelta.x += value * 2; // Scale for gamepad
	                    }
	                    break;
	                case 3: // Right stick Y - Camera pan Y  
	                    if (this.config.panEnabled) {
	                        this.targetPanDelta.y += value * 2;
	                    }
	                    break;
	                case 4: // Left trigger - Zoom out
	                    if (this.config.zoomEnabled && value > 0.1) {
	                        this.targetZoomDelta += value * 0.02;
	                    }
	                    break;
	                case 5: // Right trigger - Zoom in
	                    if (this.config.zoomEnabled && value > 0.1) {
	                        this.targetZoomDelta -= value * 0.02;
	                    }
	                    break;
	            }
	        }
	    }
	    /**
	     * Update keyboard-based camera controls
	     */
	    updateKeyboardControls() {
	        if (!this.config.panEnabled)
	            return;
	        let panX = 0;
	        let panY = 0;
	        // Pan controls
	        if (this.pressedKeys.has('ArrowLeft') || this.pressedKeys.has('KeyA')) {
	            panX -= 1;
	        }
	        if (this.pressedKeys.has('ArrowRight') || this.pressedKeys.has('KeyD')) {
	            panX += 1;
	        }
	        if (this.pressedKeys.has('ArrowUp') || this.pressedKeys.has('KeyW')) {
	            panY -= 1;
	        }
	        if (this.pressedKeys.has('ArrowDown') || this.pressedKeys.has('KeyS')) {
	            panY += 1;
	        }
	        this.targetPanDelta.x += panX * 2; // Scale for keyboard
	        this.targetPanDelta.y += panY * 2;
	        // Zoom controls
	        if (this.config.zoomEnabled) {
	            if (this.pressedKeys.has('Equal') || this.pressedKeys.has('NumpadAdd')) {
	                this.targetZoomDelta -= 0.02;
	            }
	            if (this.pressedKeys.has('Minus') || this.pressedKeys.has('NumpadSubtract')) {
	                this.targetZoomDelta += 0.02;
	            }
	        }
	        // Rotation controls
	        if (this.config.rotationEnabled) {
	            if (this.pressedKeys.has('KeyQ')) {
	                this.targetRotationDelta -= 0.02;
	            }
	            if (this.pressedKeys.has('KeyE')) {
	                this.targetRotationDelta += 0.02;
	            }
	        }
	    }
	    /**
	     * Update gamepad-based camera controls
	     */
	    updateGamepadControls() {
	        // Gamepad controls are handled in handleGamepadInput
	        // This method could be used for additional gamepad processing
	    }
	    /**
	     * Update touch gesture recognition
	     */
	    updateTouchGestures() {
	        if (!this.config.touchGestureEnabled)
	            return;
	        const touches = Array.from(this.activeTouches.values());
	        if (touches.length === 1) {
	            // Single touch pan
	            if (this.config.panEnabled && this.state.lastTouchPositions.length === 1) {
	                const lastTouch = this.state.lastTouchPositions[0];
	                const currentTouch = touches[0];
	                this.targetPanDelta.x += currentTouch.x - lastTouch.x;
	                this.targetPanDelta.y += currentTouch.y - lastTouch.y;
	            }
	        }
	        else if (touches.length === 2) {
	            // Two finger gestures
	            const touch1 = touches[0];
	            const touch2 = touches[1];
	            // Pinch to zoom
	            if (this.config.zoomEnabled) {
	                const currentDistance = this.calculateDistance(touch1, touch2);
	                if (this.state.lastTouchPositions.length === 2) {
	                    const lastDistance = this.state.lastPinchDistance;
	                    const zoomDelta = (currentDistance - lastDistance) * 0.01;
	                    this.targetZoomDelta -= zoomDelta; // Invert for natural pinch
	                }
	                this.state.lastPinchDistance = currentDistance;
	            }
	            // Two finger rotation
	            if (this.config.rotationEnabled) {
	                const currentAngle = this.calculateAngle(touch1, touch2);
	                if (this.state.lastTouchPositions.length === 2) {
	                    const lastAngle = this.state.lastRotationAngle;
	                    let rotationDelta = currentAngle - lastAngle;
	                    // Handle angle wrap-around
	                    if (rotationDelta > Math.PI)
	                        rotationDelta -= 2 * Math.PI;
	                    if (rotationDelta < -Math.PI)
	                        rotationDelta += 2 * Math.PI;
	                    this.targetRotationDelta += rotationDelta;
	                }
	                this.state.lastRotationAngle = currentAngle;
	            }
	        }
	        // Store current touch positions for next frame
	        this.state.lastTouchPositions = [...touches];
	    }
	    /**
	     * Apply smoothing to camera deltas
	     */
	    applySmoothing(deltaTime) {
	        const smoothingFactor = this.config.smoothingFactor;
	        const frameSmoothing = Math.min(smoothingFactor * (deltaTime / 16.67), 1);
	        this.state.panDelta.x = this.lerp(this.state.panDelta.x, this.targetPanDelta.x, frameSmoothing);
	        this.state.panDelta.y = this.lerp(this.state.panDelta.y, this.targetPanDelta.y, frameSmoothing);
	        this.state.zoomDelta = this.lerp(this.state.zoomDelta, this.targetZoomDelta, frameSmoothing);
	        this.state.rotationDelta = this.lerp(this.state.rotationDelta, this.targetRotationDelta, frameSmoothing);
	    }
	    /**
	     * Apply dead zones to prevent jitter
	     */
	    applyDeadZones() {
	        // Pan dead zone
	        if (Math.abs(this.state.panDelta.x) < this.config.panDeadZone) {
	            this.state.panDelta.x = 0;
	        }
	        if (Math.abs(this.state.panDelta.y) < this.config.panDeadZone) {
	            this.state.panDelta.y = 0;
	        }
	        // Zoom dead zone
	        if (Math.abs(this.state.zoomDelta) < this.config.zoomDeadZone) {
	            this.state.zoomDelta = 0;
	        }
	        // Rotation dead zone
	        if (Math.abs(this.state.rotationDelta) < this.config.rotationDeadZone) {
	            this.state.rotationDelta = 0;
	        }
	    }
	    /**
	     * Apply sensitivity and inversion settings
	     */
	    applySensitivityAndInversion() {
	        // Apply sensitivity
	        this.state.panDelta.x *= this.config.panSensitivity;
	        this.state.panDelta.y *= this.config.panSensitivity;
	        this.state.zoomDelta *= this.config.zoomSensitivity;
	        this.state.rotationDelta *= this.config.rotationSensitivity;
	        // Apply inversion
	        if (this.config.invertPanX) {
	            this.state.panDelta.x *= -1;
	        }
	        if (this.config.invertPanY) {
	            this.state.panDelta.y *= -1;
	        }
	        if (this.config.invertZoom) {
	            this.state.zoomDelta *= -1;
	        }
	        if (this.config.invertRotation) {
	            this.state.rotationDelta *= -1;
	        }
	    }
	    /**
	     * Emit camera events if there's significant movement
	     */
	    emitCameraEvents() {
	        if (this.state.panDelta.x !== 0 || this.state.panDelta.y !== 0) {
	            this.emit('camera-pan', this.state.panDelta);
	        }
	        if (this.state.zoomDelta !== 0) {
	            this.emit('camera-zoom', this.state.zoomDelta);
	        }
	        if (this.state.rotationDelta !== 0) {
	            this.emit('camera-rotate', this.state.rotationDelta);
	        }
	    }
	    /**
	     * Reset target deltas for next frame
	     */
	    resetTargetDeltas() {
	        if (!this.config.smoothing) {
	            this.targetPanDelta = { x: 0, y: 0 };
	            this.targetZoomDelta = 0;
	            this.targetRotationDelta = 0;
	        }
	    }
	    /**
	     * Get action from input event
	     */
	    getActionFromInput(event) {
	        // Camera actions are typically not mapped to specific game actions
	        // Instead they emit custom events like 'camera-pan', 'camera-zoom', etc.
	        return null;
	    }
	    /**
	     * Reset handler state
	     */
	    resetState() {
	        this.state = {
	            panDelta: { x: 0, y: 0 },
	            zoomDelta: 0,
	            rotationDelta: 0,
	            isPanning: false,
	            isZooming: false,
	            isRotating: false,
	            lastMousePosition: { x: 0, y: 0 },
	            lastTouchPositions: [],
	            lastPinchDistance: 0,
	            lastRotationAngle: 0
	        };
	        this.pressedKeys.clear();
	        this.pressedMouseButtons.clear();
	        this.activeTouches.clear();
	        this.targetPanDelta = { x: 0, y: 0 };
	        this.targetZoomDelta = 0;
	        this.targetRotationDelta = 0;
	    }
	    /**
	     * Calculate distance between two points
	     */
	    calculateDistance(point1, point2) {
	        const dx = point2.x - point1.x;
	        const dy = point2.y - point1.y;
	        return Math.sqrt(dx * dx + dy * dy);
	    }
	    /**
	     * Calculate angle between two points
	     */
	    calculateAngle(point1, point2) {
	        return Math.atan2(point2.y - point1.y, point2.x - point1.x);
	    }
	    /**
	     * Linear interpolation utility
	     */
	    lerp(start, end, factor) {
	        return start + (end - start) * factor;
	    }
	}

	/**
	 * Specialized input handler for UI navigation
	 * Handles menu navigation, focus management, and UI interactions
	 */
	class GameByteUINavigationHandler extends EventEmitter {
	    constructor(config) {
	        super();
	        this.name = 'ui-navigation';
	        this.priority = 95; // High priority for UI
	        this.supportedContexts = [
	            'menu', 'pause', 'inventory', 'settings', 'dialogue'
	        ];
	        this.active = false;
	        this.context = 'menu';
	        // Input tracking
	        this.pressedKeys = new Set();
	        this.pressedGamepadButtons = new Set();
	        this.config = {
	            navigationSensitivity: 1.0,
	            repeatDelay: 500, // 500ms initial delay
	            repeatRate: 150, // 150ms between repeats
	            analogDeadZone: 0.3,
	            touchNavigationEnabled: true,
	            gestureNavigationEnabled: true,
	            focusWrapAround: true,
	            ...config
	        };
	        this.state = {
	            navigationDirection: { x: 0, y: 0 },
	            confirmPressed: false,
	            cancelPressed: false,
	            wasConfirmJustPressed: false,
	            wasCancelJustPressed: false,
	            lastNavigationTime: 0,
	            repeatTimer: null,
	            currentRepeatDirection: { x: 0, y: 0 }
	        };
	    }
	    /**
	     * Process raw input event
	     */
	    handleInput(event) {
	        if (!this.active)
	            return;
	        // Set deviceType for compatibility
	        if (!event.deviceType) {
	            event.deviceType = event.device;
	        }
	        // Process different input types
	        switch (event.deviceType || event.device) {
	            case 'keyboard':
	                this.handleKeyboardInput(event);
	                break;
	            case 'mouse':
	                this.handleMouseInput(event);
	                break;
	            case 'touch':
	                this.handleTouchInput(event);
	                break;
	            case 'gamepad':
	                this.handleGamepadInput(event);
	                break;
	        }
	        // Map to game actions
	        const action = this.getActionFromInput(event);
	        if (action) {
	            this.emit('action', action, event);
	        }
	    }
	    /**
	     * Get navigation direction
	     */
	    getNavigationDirection() {
	        const dir = this.state.navigationDirection;
	        if (dir.y < 0)
	            return 'up';
	        if (dir.y > 0)
	            return 'down';
	        if (dir.x < 0)
	            return 'left';
	        if (dir.x > 0)
	            return 'right';
	        return null;
	    }
	    /**
	     * Get navigation direction as Point (for internal use)
	     */
	    getNavigationDirectionPoint() {
	        return { ...this.state.navigationDirection };
	    }
	    /**
	     * Check if confirm action was pressed
	     */
	    wasConfirmPressed() {
	        return this.state.wasConfirmJustPressed;
	    }
	    /**
	     * Check if cancel action was pressed
	     */
	    wasCancelPressed() {
	        return this.state.wasCancelJustPressed;
	    }
	    /**
	     * Check if confirm is pressed (interface compatibility)
	     */
	    isConfirmPressed() {
	        return this.state.confirmPressed;
	    }
	    /**
	     * Check if cancel is pressed (interface compatibility)
	     */
	    isCancelPressed() {
	        return this.state.cancelPressed;
	    }
	    /**
	     * Move focus in a direction
	     */
	    moveFocus(direction) {
	        let dir;
	        switch (direction) {
	            case 'up':
	                dir = { x: 0, y: -1 };
	                break;
	            case 'down':
	                dir = { x: 0, y: 1 };
	                break;
	            case 'left':
	                dir = { x: -1, y: 0 };
	                break;
	            case 'right':
	                dir = { x: 1, y: 0 };
	                break;
	        }
	        this.handleNavigationInput(dir);
	        this.emit('focus-move', direction);
	    }
	    /**
	     * Confirm current selection
	     */
	    confirmSelection() {
	        this.state.confirmPressed = true;
	        this.state.wasConfirmJustPressed = true;
	        this.emit('confirm');
	    }
	    /**
	     * Cancel current selection
	     */
	    cancelSelection() {
	        this.state.cancelPressed = true;
	        this.state.wasCancelJustPressed = true;
	        this.emit('cancel');
	    }
	    /**
	     * Set repeat delay
	     */
	    setRepeatDelay(delay) {
	        this.config.repeatDelay = Math.max(0, delay);
	    }
	    /**
	     * Set repeat rate
	     */
	    setRepeatRate(rate) {
	        this.config.repeatRate = Math.max(50, rate); // Minimum 50ms
	    }
	    /**
	     * Set navigation sensitivity
	     */
	    setNavigationSensitivity(sensitivity) {
	        this.config.navigationSensitivity = sensitivity;
	    }
	    /**
	     * Check if handler is enabled (InputHandler interface)
	     */
	    isEnabled() {
	        return this.active;
	    }
	    /**
	     * Set handler enabled state (InputHandler interface)
	     */
	    setEnabled(enabled) {
	        this.active = enabled;
	        if (!enabled) {
	            this.resetState();
	            this.clearRepeatTimer();
	        }
	    }
	    /**
	     * Update handler state
	     */
	    update(deltaTime) {
	        if (!this.active)
	            return;
	        // Update navigation based on input
	        this.updateNavigationState();
	        // Handle navigation repeat
	        this.updateNavigationRepeat();
	        // Emit navigation events
	        this.emitNavigationEvents();
	        // Reset frame-specific flags
	        this.state.wasConfirmJustPressed = false;
	        this.state.wasCancelJustPressed = false;
	    }
	    /**
	     * Check if handler can process this event
	     */
	    canHandle(event, context) {
	        return this.active && this.supportedContexts.includes(context);
	    }
	    /**
	     * Activate handler for context
	     */
	    activate(context) {
	        this.active = true;
	        this.context = context;
	        this.resetState();
	        this.emit('activated', context);
	    }
	    /**
	     * Deactivate handler
	     */
	    deactivate() {
	        this.active = false;
	        this.resetState();
	        this.clearRepeatTimer();
	        this.emit('deactivated');
	    }
	    /**
	     * Cleanup resources
	     */
	    destroy() {
	        this.deactivate();
	        this.removeAllListeners();
	    }
	    /**
	     * Configure handler settings
	     */
	    configure(config) {
	        this.config = { ...this.config, ...config };
	    }
	    /**
	     * Handle keyboard input
	     */
	    handleKeyboardInput(event) {
	        if (!event.key)
	            return;
	        const key = event.key;
	        if (event.type === 'key-down') {
	            this.pressedKeys.add(key);
	            // Navigation keys
	            if (this.isNavigationKey(key)) {
	                this.handleNavigationKeyPressed(key);
	            }
	            // Confirm keys
	            if (this.isConfirmKey(key)) {
	                this.state.confirmPressed = true;
	                this.state.wasConfirmJustPressed = true;
	            }
	            // Cancel keys
	            if (this.isCancelKey(key)) {
	                this.state.cancelPressed = true;
	                this.state.wasCancelJustPressed = true;
	            }
	        }
	        else if (event.type === 'key-up') {
	            this.pressedKeys.delete(key);
	            // Confirm keys
	            if (this.isConfirmKey(key)) {
	                this.state.confirmPressed = false;
	            }
	            // Cancel keys
	            if (this.isCancelKey(key)) {
	                this.state.cancelPressed = false;
	            }
	            // Stop navigation repeat when key released
	            if (this.isNavigationKey(key)) {
	                this.clearRepeatTimer();
	            }
	        }
	    }
	    /**
	     * Handle mouse input
	     */
	    handleMouseInput(event) {
	        switch (event.type) {
	            case 'down':
	                if (event.button === 0) { // Left click
	                    this.state.confirmPressed = true;
	                    this.state.wasConfirmJustPressed = true;
	                }
	                else if (event.button === 2) { // Right click
	                    this.state.cancelPressed = true;
	                    this.state.wasCancelJustPressed = true;
	                }
	                break;
	            case 'up':
	                if (event.button === 0) {
	                    this.state.confirmPressed = false;
	                }
	                else if (event.button === 2) {
	                    this.state.cancelPressed = false;
	                }
	                break;
	            default:
	                // Handle wheel events for navigation
	                if (event.delta) {
	                    if (Math.abs(event.delta.y) > Math.abs(event.delta.x)) {
	                        // Vertical scrolling
	                        this.state.navigationDirection.y = event.delta.y > 0 ? 1 : -1;
	                    }
	                    else {
	                        // Horizontal scrolling
	                        this.state.navigationDirection.x = event.delta.x > 0 ? 1 : -1;
	                    }
	                    this.state.lastNavigationTime = performance.now();
	                }
	                break;
	        }
	    }
	    /**
	     * Handle touch input
	     */
	    handleTouchInput(event) {
	        if (!this.config.touchNavigationEnabled)
	            return;
	        switch (event.type) {
	            case 'down':
	                this.state.confirmPressed = true;
	                this.state.wasConfirmJustPressed = true;
	                break;
	            case 'up':
	                this.state.confirmPressed = false;
	                break;
	        }
	        // Touch gestures would be handled here if gestureNavigationEnabled
	        if (this.config.gestureNavigationEnabled) ;
	    }
	    /**
	     * Handle gamepad input
	     */
	    handleGamepadInput(event) {
	        if (event.type === 'gamepad-button-down' || event.type === 'gamepad-button-up') {
	            const button = event.gamepadButton;
	            const pressed = event.type === 'gamepad-button-down';
	            if (pressed && !this.pressedGamepadButtons.has(button)) {
	                this.pressedGamepadButtons.add(button);
	                // D-pad navigation
	                if (button === 12) { // D-pad up
	                    this.handleNavigationInput({ x: 0, y: -1 });
	                }
	                else if (button === 13) { // D-pad down
	                    this.handleNavigationInput({ x: 0, y: 1 });
	                }
	                else if (button === 14) { // D-pad left
	                    this.handleNavigationInput({ x: -1, y: 0 });
	                }
	                else if (button === 15) { // D-pad right
	                    this.handleNavigationInput({ x: 1, y: 0 });
	                }
	                // Action buttons
	                if (button === 0) { // A button
	                    this.state.confirmPressed = true;
	                    this.state.wasConfirmJustPressed = true;
	                }
	                else if (button === 1) { // B button
	                    this.state.cancelPressed = true;
	                    this.state.wasCancelJustPressed = true;
	                }
	            }
	            else if (!pressed) {
	                this.pressedGamepadButtons.delete(button);
	                if (button === 0) {
	                    this.state.confirmPressed = false;
	                }
	                else if (button === 1) {
	                    this.state.cancelPressed = false;
	                }
	                // Clear repeat for D-pad
	                if (button >= 12 && button <= 15) {
	                    this.clearRepeatTimer();
	                }
	            }
	        }
	        else if (event.type === 'gamepad-axis') {
	            const axis = event.gamepadAxis;
	            const value = event.axisValue || 0;
	            // Left stick navigation
	            if (axis === 0) { // Left stick X
	                if (Math.abs(value) > this.config.analogDeadZone) {
	                    this.state.navigationDirection.x = value > 0 ? 1 : -1;
	                }
	                else {
	                    this.state.navigationDirection.x = 0;
	                }
	            }
	            else if (axis === 1) { // Left stick Y
	                if (Math.abs(value) > this.config.analogDeadZone) {
	                    this.state.navigationDirection.y = value > 0 ? 1 : -1;
	                }
	                else {
	                    this.state.navigationDirection.y = 0;
	                }
	            }
	        }
	    }
	    /**
	     * Handle navigation key pressed
	     */
	    handleNavigationKeyPressed(key) {
	        let direction = { x: 0, y: 0 };
	        switch (key) {
	            case 'ArrowUp':
	                direction = { x: 0, y: -1 };
	                break;
	            case 'ArrowDown':
	                direction = { x: 0, y: 1 };
	                break;
	            case 'ArrowLeft':
	                direction = { x: -1, y: 0 };
	                break;
	            case 'ArrowRight':
	                direction = { x: 1, y: 0 };
	                break;
	            case 'Tab':
	                direction = { x: 1, y: 0 }; // Tab moves to next element
	                break;
	        }
	        this.handleNavigationInput(direction);
	    }
	    /**
	     * Handle navigation input
	     */
	    handleNavigationInput(direction) {
	        this.state.navigationDirection = { ...direction };
	        this.state.lastNavigationTime = performance.now();
	        // Setup repeat timer
	        this.setupNavigationRepeat(direction);
	    }
	    /**
	     * Update navigation state
	     */
	    updateNavigationState() {
	        // Clear navigation direction if no recent input
	        const timeSinceLastNavigation = performance.now() - this.state.lastNavigationTime;
	        if (timeSinceLastNavigation > 100) { // 100ms timeout
	            if (!this.state.repeatTimer) {
	                this.state.navigationDirection = { x: 0, y: 0 };
	            }
	        }
	    }
	    /**
	     * Update navigation repeat
	     */
	    updateNavigationRepeat() {
	        // Navigation repeat is handled by the repeat timer
	    }
	    /**
	     * Setup navigation repeat
	     */
	    setupNavigationRepeat(direction) {
	        this.clearRepeatTimer();
	        this.state.currentRepeatDirection = { ...direction };
	        // Initial delay before repeat starts
	        this.state.repeatTimer = window.setTimeout(() => {
	            // Start repeating
	            const repeatInterval = window.setInterval(() => {
	                if (this.active) {
	                    this.state.navigationDirection = { ...this.state.currentRepeatDirection };
	                    this.state.lastNavigationTime = performance.now();
	                    this.emit('navigation-repeat', this.state.currentRepeatDirection);
	                }
	                else {
	                    clearInterval(repeatInterval);
	                }
	            }, this.config.repeatRate);
	            // Store interval ID in repeatTimer
	            this.state.repeatTimer = repeatInterval;
	        }, this.config.repeatDelay);
	    }
	    /**
	     * Clear navigation repeat timer
	     */
	    clearRepeatTimer() {
	        if (this.state.repeatTimer !== null) {
	            window.clearTimeout(this.state.repeatTimer);
	            window.clearInterval(this.state.repeatTimer);
	            this.state.repeatTimer = null;
	        }
	        this.state.currentRepeatDirection = { x: 0, y: 0 };
	    }
	    /**
	     * Emit navigation events
	     */
	    emitNavigationEvents() {
	        if (this.state.navigationDirection.x !== 0 || this.state.navigationDirection.y !== 0) {
	            this.emit('navigation', this.state.navigationDirection);
	        }
	        if (this.state.wasConfirmJustPressed) {
	            this.emit('confirm');
	        }
	        if (this.state.wasCancelJustPressed) {
	            this.emit('cancel');
	        }
	    }
	    /**
	     * Check if key is a navigation key
	     */
	    isNavigationKey(key) {
	        return ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Tab'].includes(key);
	    }
	    /**
	     * Check if key is a confirm key
	     */
	    isConfirmKey(key) {
	        return ['Enter', 'Space'].includes(key);
	    }
	    /**
	     * Check if key is a cancel key
	     */
	    isCancelKey(key) {
	        return ['Escape', 'Backspace'].includes(key);
	    }
	    /**
	     * Get action from input event
	     */
	    getActionFromInput(event) {
	        if (event.deviceType === 'keyboard' && event.key && event.type === 'key-down') {
	            if (this.isConfirmKey(event.key)) {
	                return 'ui-confirm';
	            }
	            if (this.isCancelKey(event.key)) {
	                return 'ui-cancel';
	            }
	            if (this.isNavigationKey(event.key)) {
	                return 'ui-navigate';
	            }
	        }
	        if (event.deviceType === 'mouse' && event.type === 'down') {
	            if (event.button === 0) {
	                return 'ui-confirm';
	            }
	            if (event.button === 2) {
	                return 'ui-cancel';
	            }
	        }
	        return null;
	    }
	    /**
	     * Reset handler state
	     */
	    resetState() {
	        this.state = {
	            navigationDirection: { x: 0, y: 0 },
	            confirmPressed: false,
	            cancelPressed: false,
	            wasConfirmJustPressed: false,
	            wasCancelJustPressed: false,
	            lastNavigationTime: 0,
	            repeatTimer: null,
	            currentRepeatDirection: { x: 0, y: 0 }
	        };
	        this.pressedKeys.clear();
	        this.pressedGamepadButtons.clear();
	    }
	}

	/**
	 * Specialized input handler for player movement
	 * Supports various movement types and input methods
	 */
	class GameBytePlayerMovementHandler extends EventEmitter {
	    constructor(config) {
	        super();
	        this.name = 'player-movement';
	        this.priority = 85;
	        this.supportedContexts = ['gameplay'];
	        this.active = false;
	        this.context = 'gameplay';
	        // Input tracking
	        this.pressedKeys = new Set();
	        this.gamepadLeftStick = { x: 0, y: 0 };
	        this.touchMovement = { x: 0, y: 0 };
	        // Movement calculation
	        this.rawMovementInput = { x: 0, y: 0 };
	        this.config = {
	            movementType: '2d',
	            inputSmoothing: true,
	            smoothingFactor: 0.12,
	            deadZone: 0.1,
	            maxSpeed: 1.0,
	            acceleration: 0.15,
	            deceleration: 0.2,
	            analogMovement: true,
	            eightDirectional: false,
	            normalizeMovement: true,
	            ...config
	        };
	        this.state = {
	            movementVector: { x: 0, y: 0 },
	            targetVector: { x: 0, y: 0 },
	            currentSpeed: 0,
	            speedMultiplier: 1.0,
	            isMoving: false,
	            movementDirection: 0,
	            lastInputTime: 0
	        };
	    }
	    /**
	     * Process raw input event
	     */
	    handleInput(event) {
	        if (!this.active)
	            return;
	        // Set deviceType for compatibility
	        if (!event.deviceType) {
	            event.deviceType = event.device;
	        }
	        // Process different input types
	        switch (event.deviceType || event.device) {
	            case 'keyboard':
	                this.handleKeyboardInput(event);
	                break;
	            case 'touch':
	                this.handleTouchInput(event);
	                break;
	            case 'gamepad':
	                this.handleGamepadInput(event);
	                break;
	        }
	        // Update raw movement input
	        this.updateRawMovementInput();
	        // Map to game actions
	        const action = this.getActionFromInput(event);
	        if (action) {
	            this.emit('action', action, event);
	        }
	    }
	    /**
	     * Get movement vector
	     */
	    getMovementVector() {
	        return { ...this.state.movementVector };
	    }
	    /**
	     * Get movement vector in 3D space
	     */
	    getMovementVector3D() {
	        return {
	            x: this.state.movementVector.x,
	            y: this.state.movementVector.y,
	            z: 0 // Default Z for 2D movement
	        };
	    }
	    /**
	     * Get movement speed multiplier
	     */
	    getSpeedMultiplier() {
	        return this.state.speedMultiplier;
	    }
	    /**
	     * Check if player is trying to move
	     */
	    isMoving() {
	        return this.state.isMoving;
	    }
	    /**
	     * Get movement direction in radians
	     */
	    getMovementDirection() {
	        return this.state.movementDirection;
	    }
	    /**
	     * Set speed multiplier (for running, walking, etc.)
	     */
	    setSpeedMultiplier(multiplier) {
	        this.state.speedMultiplier = Math.max(0, multiplier);
	    }
	    /**
	     * Set analog mode enabled/disabled
	     */
	    setAnalogMode(enabled) {
	        this.config.analogMovement = enabled;
	    }
	    /**
	     * Check if analog mode is enabled
	     */
	    isAnalogMode() {
	        return this.config.analogMovement;
	    }
	    /**
	     * Set dead zone for analog inputs
	     */
	    setDeadZone(deadZone) {
	        this.config.deadZone = Math.max(0, Math.min(1, deadZone));
	    }
	    /**
	     * Set movement smoothing factor
	     */
	    setMovementSmoothing(smoothing) {
	        this.config.smoothingFactor = Math.max(0, Math.min(1, smoothing));
	    }
	    /**
	     * Set movement sensitivity
	     */
	    setSensitivity(sensitivity) {
	        this.config.maxSpeed = Math.max(0, sensitivity);
	    }
	    /**
	     * Get movement speed
	     */
	    getMovementSpeed() {
	        return this.state.currentSpeed;
	    }
	    /**
	     * Check if handler is enabled (InputHandler interface)
	     */
	    isEnabled() {
	        return this.active;
	    }
	    /**
	     * Set handler enabled state (InputHandler interface)
	     */
	    setEnabled(enabled) {
	        this.active = enabled;
	        if (!enabled) {
	            this.resetState();
	        }
	    }
	    /**
	     * Update handler state
	     */
	    update(deltaTime) {
	        if (!this.active)
	            return;
	        // Calculate target movement vector
	        this.calculateTargetMovement();
	        // Apply smoothing and acceleration
	        this.applyMovementSmoothing(deltaTime);
	        // Update movement state
	        this.updateMovementState();
	        // Emit movement events
	        this.emitMovementEvents();
	    }
	    /**
	     * Check if handler can process this event
	     */
	    canHandle(event, context) {
	        return this.active && this.supportedContexts.includes(context);
	    }
	    /**
	     * Activate handler for context
	     */
	    activate(context) {
	        this.active = true;
	        this.context = context;
	        this.resetState();
	        this.emit('activated', context);
	    }
	    /**
	     * Deactivate handler
	     */
	    deactivate() {
	        this.active = false;
	        this.resetState();
	        this.emit('deactivated');
	    }
	    /**
	     * Cleanup resources
	     */
	    destroy() {
	        this.deactivate();
	        this.removeAllListeners();
	    }
	    /**
	     * Configure handler settings
	     */
	    configure(config) {
	        this.config = { ...this.config, ...config };
	    }
	    /**
	     * Handle keyboard input
	     */
	    handleKeyboardInput(event) {
	        if (!event.key)
	            return;
	        const key = event.key;
	        if (event.type === 'key-down') {
	            this.pressedKeys.add(key);
	        }
	        else if (event.type === 'key-up') {
	            this.pressedKeys.delete(key);
	        }
	        this.state.lastInputTime = performance.now();
	    }
	    /**
	     * Handle touch input (from virtual controls)
	     */
	    handleTouchInput(event) {
	        // Touch movement would typically come from virtual joystick
	        // This would be handled through the virtual controls manager
	        // For now, we'll just update the timestamp
	        this.state.lastInputTime = performance.now();
	    }
	    /**
	     * Handle gamepad input
	     */
	    handleGamepadInput(event) {
	        if (event.type === 'gamepad-axis' && event.gamepadAxis !== undefined && event.axisValue !== undefined) {
	            const axis = event.gamepadAxis;
	            const value = event.axisValue;
	            if (axis === 0) { // Left stick X
	                this.gamepadLeftStick.x = Math.abs(value) > this.config.deadZone ? value : 0;
	            }
	            else if (axis === 1) { // Left stick Y
	                this.gamepadLeftStick.y = Math.abs(value) > this.config.deadZone ? value : 0;
	            }
	            this.state.lastInputTime = performance.now();
	        }
	    }
	    /**
	     * Update raw movement input from all sources
	     */
	    updateRawMovementInput() {
	        let x = 0;
	        let y = 0;
	        // Keyboard input
	        if (this.pressedKeys.has('ArrowLeft') || this.pressedKeys.has('KeyA')) {
	            x -= 1;
	        }
	        if (this.pressedKeys.has('ArrowRight') || this.pressedKeys.has('KeyD')) {
	            x += 1;
	        }
	        if (this.pressedKeys.has('ArrowUp') || this.pressedKeys.has('KeyW')) {
	            y -= 1;
	        }
	        if (this.pressedKeys.has('ArrowDown') || this.pressedKeys.has('KeyS')) {
	            y += 1;
	        }
	        // Gamepad input
	        if (Math.abs(this.gamepadLeftStick.x) > Math.abs(x)) {
	            x = this.gamepadLeftStick.x;
	        }
	        if (Math.abs(this.gamepadLeftStick.y) > Math.abs(y)) {
	            y = this.gamepadLeftStick.y;
	        }
	        // Touch input (would be set by virtual controls)
	        if (Math.abs(this.touchMovement.x) > Math.abs(x)) {
	            x = this.touchMovement.x;
	        }
	        if (Math.abs(this.touchMovement.y) > Math.abs(y)) {
	            y = this.touchMovement.y;
	        }
	        this.rawMovementInput = { x, y };
	    }
	    /**
	     * Calculate target movement vector
	     */
	    calculateTargetMovement() {
	        let { x, y } = this.rawMovementInput;
	        // Apply dead zone
	        if (Math.abs(x) < this.config.deadZone)
	            x = 0;
	        if (Math.abs(y) < this.config.deadZone)
	            y = 0;
	        // Handle different movement types
	        if (this.config.eightDirectional) {
	            // Snap to 8 directions for top-down games
	            x = x > 0.5 ? 1 : x < -0.5 ? -1 : 0;
	            y = y > 0.5 ? 1 : y < -0.5 ? -1 : 0;
	        }
	        else if (!this.config.analogMovement) {
	            // Digital movement (on/off)
	            x = x > 0 ? 1 : x < 0 ? -1 : 0;
	            y = y > 0 ? 1 : y < 0 ? -1 : 0;
	        }
	        // Normalize diagonal movement if enabled
	        if (this.config.normalizeMovement && x !== 0 && y !== 0) {
	            const length = Math.sqrt(x * x + y * y);
	            if (length > 1) {
	                x /= length;
	                y /= length;
	            }
	        }
	        // Apply movement type constraints
	        switch (this.config.movementType) {
	                    }
	        this.state.targetVector = { x, y };
	    }
	    /**
	     * Apply movement smoothing and acceleration
	     */
	    applyMovementSmoothing(deltaTime) {
	        const target = this.state.targetVector;
	        const current = this.state.movementVector;
	        if (this.config.inputSmoothing) {
	            // Smooth interpolation
	            const smoothingFactor = this.config.smoothingFactor;
	            const frameSmoothing = Math.min(smoothingFactor * (deltaTime / 16.67), 1);
	            this.state.movementVector.x = this.lerp(current.x, target.x, frameSmoothing);
	            this.state.movementVector.y = this.lerp(current.y, target.y, frameSmoothing);
	            // Snap to target when very close
	            if (Math.abs(this.state.movementVector.x - target.x) < 0.01) {
	                this.state.movementVector.x = target.x;
	            }
	            if (Math.abs(this.state.movementVector.y - target.y) < 0.01) {
	                this.state.movementVector.y = target.y;
	            }
	        }
	        else {
	            // Direct assignment
	            this.state.movementVector = { ...target };
	        }
	        // Apply acceleration/deceleration
	        const targetSpeed = Math.sqrt(target.x * target.x + target.y * target.y);
	        if (targetSpeed > 0) {
	            // Accelerating
	            this.state.currentSpeed = Math.min(this.state.currentSpeed + this.config.acceleration * (deltaTime / 16.67), targetSpeed * this.config.maxSpeed);
	        }
	        else {
	            // Decelerating
	            this.state.currentSpeed = Math.max(this.state.currentSpeed - this.config.deceleration * (deltaTime / 16.67), 0);
	        }
	        // Apply speed to movement vector
	        const movementLength = Math.sqrt(this.state.movementVector.x * this.state.movementVector.x +
	            this.state.movementVector.y * this.state.movementVector.y);
	        if (movementLength > 0) {
	            const speedRatio = this.state.currentSpeed / movementLength;
	            this.state.movementVector.x *= speedRatio;
	            this.state.movementVector.y *= speedRatio;
	        }
	        // Apply speed multiplier
	        this.state.movementVector.x *= this.state.speedMultiplier;
	        this.state.movementVector.y *= this.state.speedMultiplier;
	    }
	    /**
	     * Update movement state
	     */
	    updateMovementState() {
	        const vector = this.state.movementVector;
	        // Update isMoving
	        this.state.isMoving = Math.abs(vector.x) > 0.01 || Math.abs(vector.y) > 0.01;
	        // Update movement direction
	        if (this.state.isMoving) {
	            this.state.movementDirection = Math.atan2(vector.y, vector.x);
	        }
	    }
	    /**
	     * Emit movement events
	     */
	    emitMovementEvents() {
	        if (this.state.isMoving) {
	            this.emit('player-move', {
	                vector: this.state.movementVector,
	                speed: this.state.currentSpeed,
	                direction: this.state.movementDirection,
	                multiplier: this.state.speedMultiplier
	            });
	        }
	        else {
	            this.emit('player-stop');
	        }
	    }
	    /**
	     * Set touch movement input (called by virtual controls)
	     */
	    setTouchMovement(movement) {
	        this.touchMovement = { ...movement };
	        this.state.lastInputTime = performance.now();
	    }
	    /**
	     * Get action from input event
	     */
	    getActionFromInput(event) {
	        if (event.deviceType === 'keyboard' && event.key && event.type === 'key-down') {
	            if (['ArrowLeft', 'KeyA'].includes(event.key)) {
	                return 'move-left';
	            }
	            if (['ArrowRight', 'KeyD'].includes(event.key)) {
	                return 'move-right';
	            }
	            if (['ArrowUp', 'KeyW'].includes(event.key)) {
	                return 'move-up';
	            }
	            if (['ArrowDown', 'KeyS'].includes(event.key)) {
	                return 'move-down';
	            }
	        }
	        return null;
	    }
	    /**
	     * Reset handler state
	     */
	    resetState() {
	        this.state = {
	            movementVector: { x: 0, y: 0 },
	            targetVector: { x: 0, y: 0 },
	            currentSpeed: 0,
	            speedMultiplier: 1.0,
	            isMoving: false,
	            movementDirection: 0,
	            lastInputTime: 0
	        };
	        this.pressedKeys.clear();
	        this.gamepadLeftStick = { x: 0, y: 0 };
	        this.touchMovement = { x: 0, y: 0 };
	        this.rawMovementInput = { x: 0, y: 0 };
	    }
	    /**
	     * Linear interpolation utility
	     */
	    lerp(start, end, factor) {
	        return start + (end - start) * factor;
	    }
	}

	/**
	 * Service provider for the input system
	 * Registers all input-related services and sets up the input system integration
	 */
	class InputServiceProvider extends AbstractServiceProvider {
	    /**
	     * Register input services in the container
	     */
	    register(app) {
	        // Register core input manager
	        app.singleton('input.manager', () => {
	            return new GameByteInputManager();
	        });
	        // Register touch input handler
	        app.singleton('input.handlers.touch', () => {
	            return new GameByteTouchInputHandler();
	        });
	        // Register virtual controls manager
	        app.singleton('input.virtualControls', () => {
	            return new GameByteVirtualControlsManager();
	        });
	        // Register input mapping manager
	        app.singleton('input.mapping', () => {
	            return new GameByteInputMappingManager();
	        });
	        // Register performance manager
	        app.singleton('input.performance', () => {
	            return new GameByteInputPerformanceManager();
	        });
	        // Register game-specific handlers
	        app.singleton('input.handlers.platformer', () => {
	            return new GameBytePlatformerInputHandler();
	        });
	        app.singleton('input.handlers.camera', () => {
	            return new GameByteCameraInputHandler();
	        });
	        app.singleton('input.handlers.uiNavigation', () => {
	            return new GameByteUINavigationHandler();
	        });
	        app.singleton('input.handlers.playerMovement', () => {
	            return new GameBytePlayerMovementHandler();
	        });
	        // Register convenience aliases
	        app.getContainer().alias('input', 'input.manager');
	        app.getContainer().alias('virtualControls', 'input.virtualControls');
	        app.getContainer().alias('inputMapping', 'input.mapping');
	    }
	    /**
	     * Boot the input services
	     */
	    async boot(app) {
	        const inputManager = app.make('input.manager');
	        const touchHandler = app.make('input.handlers.touch');
	        const virtualControls = app.make('input.virtualControls');
	        const inputMapping = app.make('input.mapping');
	        const performanceManager = app.make('input.performance');
	        // Game-specific handlers
	        const platformerHandler = app.make('input.handlers.platformer');
	        const cameraHandler = app.make('input.handlers.camera');
	        const uiNavigationHandler = app.make('input.handlers.uiNavigation');
	        const playerMovementHandler = app.make('input.handlers.playerMovement');
	        // Initialize input system with canvas
	        const canvas = app.getCanvas();
	        if (canvas) {
	            inputManager.initialize(canvas);
	        }
	        // Add core handlers to input manager
	        inputManager.addHandler(touchHandler);
	        // Add game-specific handlers
	        inputManager.addHandler(platformerHandler);
	        inputManager.addHandler(cameraHandler);
	        inputManager.addHandler(uiNavigationHandler);
	        inputManager.addHandler(playerMovementHandler);
	        // Connect virtual controls to input manager
	        this.connectVirtualControls(inputManager, virtualControls);
	        // Connect input mapping to input manager
	        this.connectInputMapping(inputManager, inputMapping);
	        // Connect performance manager to input manager
	        this.connectPerformanceManager(inputManager, performanceManager);
	        // Setup default virtual controls for mobile devices
	        this.setupDefaultVirtualControls(virtualControls, inputManager);
	        // Setup input system integration with other framework systems
	        this.setupFrameworkIntegration(app, inputManager);
	        // Setup input context management
	        this.setupContextManagement(app, inputManager);
	        // Setup input recording and debugging (development mode)
	        // Check if in development mode (browser-safe check)
	        const isDevelopment = typeof process !== 'undefined' && process.env?.NODE_ENV === 'development';
	        if (isDevelopment) {
	            this.setupInputDebugging(inputManager);
	        }
	        // Emit input system ready event
	        app.emit('input-system-ready', {
	            inputManager,
	            virtualControls,
	            inputMapping,
	            performanceManager
	        });
	    }
	    /**
	     * Connect virtual controls to input manager
	     */
	    connectVirtualControls(inputManager, virtualControls) {
	        // Listen for virtual control actions
	        virtualControls.on('action', (action, data) => {
	            inputManager.emit('action', action, data, 'virtual-controls');
	        });
	        // Update virtual controls layout when screen size changes
	        window.addEventListener('resize', () => {
	            virtualControls.updateLayout({
	                width: window.innerWidth,
	                height: window.innerHeight
	            });
	        });
	        // Initialize with current screen size
	        virtualControls.updateLayout({
	            width: window.innerWidth,
	            height: window.innerHeight
	        });
	    }
	    /**
	     * Connect input mapping to input manager
	     */
	    connectInputMapping(inputManager, inputMapping) {
	        // Listen for raw input events and apply mapping
	        inputManager.on('raw-input', (event) => {
	            const action = inputMapping.mapInput(event, inputManager.currentContext);
	            if (action) {
	                inputManager.emit('mapped-action', action, event);
	            }
	        });
	    }
	    /**
	     * Connect performance manager to input manager
	     */
	    connectPerformanceManager(inputManager, performanceManager) {
	        // Apply performance optimizations to input processing
	        inputManager.on('raw-input', (event) => {
	            performanceManager.processWithPrediction(event);
	            // The optimized event would be used instead of the raw event
	        });
	        // Monitor performance metrics
	        inputManager.on('performance-warning', (metrics) => {
	            console.warn('Input performance warning:', metrics);
	            // Automatically optimize for better performance
	            if (metrics.frameRate < 30) {
	                performanceManager.optimizeForPerformance();
	            }
	        });
	    }
	    /**
	     * Setup default virtual controls for mobile devices
	     */
	    setupDefaultVirtualControls(virtualControls, inputManager) {
	        // Only add virtual controls on touch devices
	        if (inputManager.deviceCapabilities.hasTouch && !inputManager.deviceCapabilities.hasKeyboard) {
	            // Add virtual joystick for movement
	            virtualControls.addControl({
	                id: 'movement-joystick',
	                type: 'joystick',
	                position: { x: 60, y: window.innerHeight - 140 }, // Bottom left
	                size: { width: 120, height: 120 },
	                visible: true,
	                alpha: 0.7,
	                deadZone: 0.15,
	                returnToCenter: true,
	                maxDistance: 50
	            });
	            // Add jump button
	            virtualControls.addControl({
	                id: 'jump-button',
	                type: 'button',
	                position: { x: window.innerWidth - 120, y: window.innerHeight - 140 }, // Bottom right
	                size: { width: 80, height: 80 },
	                visible: true,
	                alpha: 0.7,
	                action: 'jump'
	            });
	            // Add attack button
	            virtualControls.addControl({
	                id: 'attack-button',
	                type: 'button',
	                position: { x: window.innerWidth - 220, y: window.innerHeight - 100 }, // Bottom right, offset
	                size: { width: 60, height: 60 },
	                visible: true,
	                alpha: 0.7,
	                action: 'attack'
	            });
	        }
	    }
	    /**
	     * Setup framework integration
	     */
	    setupFrameworkIntegration(app, inputManager) {
	        // Integrate with renderer for input visualization
	        app.on('initialized', () => {
	            const renderer = app.make('renderer');
	            // Override or extend the renderer's render method to include input rendering
	            const originalRender = renderer.render?.bind(renderer);
	            if (originalRender) {
	                renderer.render = (scene) => {
	                    // Render the game scene first
	                    originalRender(scene);
	                    // Then render input system overlays (virtual controls, debug info)
	                    inputManager.render(renderer);
	                };
	            }
	            else {
	                // Fallback if no render method exists
	                renderer.renderInput = () => {
	                    inputManager.render(renderer);
	                };
	            }
	        });
	        // Integrate with UI system
	        app.on('ui-system-ready', (uiData) => {
	            const uiManager = uiData.uiManager;
	            // Connect input system to UI input handling
	            inputManager.on('action', (action, data) => {
	                if (action.startsWith('ui-')) {
	                    // Forward UI actions to the UI system
	                    uiManager.handleInteraction({
	                        type: action.replace('ui-', ''),
	                        position: data.position || { x: 0, y: 0 },
	                        target: null,
	                        timestamp: Date.now(),
	                        pointerID: data.pointerId || 0
	                    });
	                }
	            });
	        });
	        // Integrate with scene system for context switching
	        app.on('scene-changed', (sceneData) => {
	            const sceneName = sceneData.current;
	            // Map scene names to input contexts
	            let inputContext = 'gameplay';
	            switch (sceneName) {
	                case 'menu':
	                case 'main-menu':
	                    inputContext = 'menu';
	                    break;
	                case 'pause':
	                    inputContext = 'pause';
	                    break;
	                case 'inventory':
	                    inputContext = 'inventory';
	                    break;
	                case 'settings':
	                    inputContext = 'settings';
	                    break;
	                case 'gameplay':
	                case 'game':
	                default:
	                    inputContext = 'gameplay';
	                    break;
	            }
	            inputManager.setContext(inputContext);
	        });
	        // Setup update loop integration
	        this.setupUpdateLoop(app, inputManager);
	    }
	    /**
	     * Setup context management
	     */
	    setupContextManagement(app, inputManager) {
	        // Listen for context change requests
	        app.on('input-context-change', (context) => {
	            inputManager.setContext(context);
	        });
	        // Automatically manage context based on app state
	        app.on('paused', () => {
	            inputManager.setContext('pause');
	        });
	        app.on('resumed', () => {
	            inputManager.setContext('gameplay');
	        });
	        // Handle focus/blur events for mobile apps
	        window.addEventListener('blur', () => {
	            inputManager.setEnabled(false);
	        });
	        window.addEventListener('focus', () => {
	            inputManager.setEnabled(true);
	        });
	    }
	    /**
	     * Setup input debugging for development
	     */
	    setupInputDebugging(inputManager) {
	        // Log input events for debugging
	        inputManager.on('raw-input', (event) => {
	            console.log('Raw Input:', event);
	        });
	        inputManager.on('action', (action, data, source) => {
	            console.log(`Action: ${action} from ${source}`, data);
	        });
	        // Add debug overlay for input visualization
	        const debugOverlay = document.createElement('div');
	        debugOverlay.id = 'input-debug-overlay';
	        debugOverlay.style.cssText = `
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px;
      font-family: monospace;
      font-size: 12px;
      z-index: 9999;
      border-radius: 4px;
      max-width: 300px;
      pointer-events: none;
    `;
	        document.body.appendChild(debugOverlay);
	        // Update debug info
	        setInterval(() => {
	            const metrics = inputManager.getPerformanceMetrics();
	            const context = inputManager.currentContext;
	            debugOverlay.innerHTML = `
        <strong>Input Debug</strong><br>
        Context: ${context}<br>
        FPS: ${metrics.frameRate.toFixed(1)}<br>
        Input Events/s: ${metrics.inputEventCount}<br>
        Avg Latency: ${metrics.averageLatency.toFixed(1)}ms<br>
        Memory: ${metrics.memoryUsage.toFixed(1)}MB<br>
        Battery Impact: ${metrics.batteryImpact}
      `;
	        }, 1000);
	    }
	    /**
	     * Setup the update loop integration
	     */
	    setupUpdateLoop(app, inputManager) {
	        let lastTime = Date.now();
	        const updateInput = () => {
	            if (!app.isRunning())
	                return;
	            const currentTime = Date.now();
	            const deltaTime = currentTime - lastTime;
	            lastTime = currentTime;
	            // Update input system
	            inputManager.update(deltaTime);
	            // Continue loop
	            requestAnimationFrame(updateInput);
	        };
	        // Start the input update loop when the app starts
	        app.on('started', () => {
	            lastTime = Date.now();
	            updateInput();
	        });
	    }
	    /**
	     * Services this provider offers
	     */
	    provides() {
	        return [
	            'input.manager',
	            'input.handlers.touch',
	            'input.virtualControls',
	            'input.mapping',
	            'input.performance',
	            'input.handlers.platformer',
	            'input.handlers.camera',
	            'input.handlers.uiNavigation',
	            'input.handlers.playerMovement',
	            'input',
	            'virtualControls',
	            'inputMapping'
	        ];
	    }
	}

	/**
	 * Matter.js 2D physics body implementation
	 */
	class Matter2DBody extends EventEmitter {
	    // Public getters for readonly access
	    get isStatic() {
	        return this._isStatic;
	    }
	    get isSensor() {
	        return this._isSensor;
	    }
	    constructor(engine, config) {
	        super();
	        this.dimension = '2d';
	        this._userData = null;
	        this._gravityScale = 1;
	        this.engine = engine;
	        this.id = config.id || `body_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
	        this.type = config.type;
	        this._isStatic = config.isStatic || config.type === 'static';
	        this._isSensor = config.isSensor || false;
	        this._material = config.material || engine.getDefaultMaterial();
	        this._userData = config.userData;
	        this.body = this.createMatterBody(config);
	        this.applyConfiguration(config);
	    }
	    /**
	     * Get if body is active (not sleeping)
	     */
	    get isActive() {
	        return !this.body.isSleeping;
	    }
	    /**
	     * Get if body is sleeping
	     */
	    get isSleeping() {
	        return this.body.isSleeping;
	    }
	    /**
	     * Get/set position
	     */
	    get position() {
	        return { x: this.body.position.x, y: this.body.position.y };
	    }
	    set position(position) {
	        const pos = position;
	        Matter.Body.setPosition(this.body, pos);
	        this.emit('position-changed', pos);
	    }
	    /**
	     * Get/set rotation (angle in radians)
	     */
	    get rotation() {
	        return this.body.angle;
	    }
	    set rotation(rotation) {
	        const angle = typeof rotation === 'number' ? rotation : 0; // For 2D, ignore quaternion
	        Matter.Body.setAngle(this.body, angle);
	        this.emit('rotation-changed', angle);
	    }
	    /**
	     * Get/set velocity
	     */
	    get velocity() {
	        return { x: this.body.velocity.x, y: this.body.velocity.y };
	    }
	    set velocity(velocity) {
	        const vel = velocity;
	        Matter.Body.setVelocity(this.body, vel);
	        this.emit('velocity-changed', vel);
	    }
	    /**
	     * Get/set angular velocity
	     */
	    get angularVelocity() {
	        return this.body.angularVelocity;
	    }
	    set angularVelocity(angularVelocity) {
	        const angVel = typeof angularVelocity === 'number' ? angularVelocity : 0;
	        Matter.Body.setAngularVelocity(this.body, angVel);
	        this.emit('angular-velocity-changed', angVel);
	    }
	    /**
	     * Get/set mass
	     */
	    get mass() {
	        return this.body.mass;
	    }
	    set mass(mass) {
	        Matter.Body.setMass(this.body, mass);
	        this.emit('mass-changed', mass);
	    }
	    /**
	     * Get/set material
	     */
	    get material() {
	        return this._material;
	    }
	    set material(material) {
	        this._material = material;
	        this.applyMaterial(material);
	        this.emit('material-changed', material);
	    }
	    /**
	     * Get/set gravity scale
	     */
	    get gravityScale() {
	        return this._gravityScale;
	    }
	    set gravityScale(scale) {
	        // Matter.js doesn't have built-in gravity scale, so we store it privately
	        this._gravityScale = scale;
	        this.emit('gravity-scale-changed', scale);
	    }
	    /**
	     * Get/set linear damping
	     */
	    get linearDamping() {
	        return this.body.frictionAir;
	    }
	    set linearDamping(damping) {
	        this.body.frictionAir = damping;
	        this.emit('linear-damping-changed', damping);
	    }
	    /**
	     * Get/set angular damping
	     */
	    get angularDamping() {
	        return this.body.frictionAir; // Matter.js uses same value for both
	    }
	    set angularDamping(damping) {
	        this.body.frictionAir = damping;
	        this.emit('angular-damping-changed', damping);
	    }
	    /**
	     * Get/set collision group
	     */
	    get collisionGroup() {
	        return this.body.collisionFilter.group || 0;
	    }
	    set collisionGroup(group) {
	        this.body.collisionFilter.group = group;
	        this.emit('collision-group-changed', group);
	    }
	    /**
	     * Get/set collision mask
	     */
	    get collisionMask() {
	        return this.body.collisionFilter.mask || 0xFFFFFFFF;
	    }
	    set collisionMask(mask) {
	        this.body.collisionFilter.mask = mask;
	        this.emit('collision-mask-changed', mask);
	    }
	    /**
	     * Get body bounds
	     */
	    get bounds() {
	        return {
	            min: { x: this.body.bounds.min.x, y: this.body.bounds.min.y },
	            max: { x: this.body.bounds.max.x, y: this.body.bounds.max.y }
	        };
	    }
	    /**
	     * Get/set user data
	     */
	    get userData() {
	        return this._userData;
	    }
	    set userData(data) {
	        this._userData = data;
	        this.emit('user-data-changed', data);
	    }
	    /**
	     * Apply force at a point
	     */
	    applyForce(force, point) {
	        const f = force;
	        const p = point ? point : this.body.position;
	        Matter.Body.applyForce(this.body, p, f);
	        this.emit('force-applied', { force: f, point: p });
	    }
	    /**
	     * Apply impulse at a point
	     */
	    applyImpulse(impulse, point) {
	        const imp = impulse;
	        const p = point ? point : this.body.position;
	        // Convert impulse to force (impulse = force * deltaTime, assuming 1/60 deltaTime)
	        const force = { x: imp.x * 60, y: imp.y * 60 };
	        Matter.Body.applyForce(this.body, p, force);
	        this.emit('impulse-applied', { impulse: imp, point: p });
	    }
	    /**
	     * Apply torque
	     */
	    applyTorque(torque) {
	        const t = typeof torque === 'number' ? torque : 0;
	        // Apply torque by applying forces at the edges
	        const radius = Math.max(this.body.bounds.max.x - this.body.bounds.min.x, this.body.bounds.max.y - this.body.bounds.min.y) / 2;
	        const force = t / radius;
	        const offset = { x: 0, y: radius };
	        const forcePoint1 = { x: this.body.position.x + offset.x, y: this.body.position.y + offset.y };
	        const forcePoint2 = { x: this.body.position.x - offset.x, y: this.body.position.y - offset.y };
	        Matter.Body.applyForce(this.body, forcePoint1, { x: force, y: 0 });
	        Matter.Body.applyForce(this.body, forcePoint2, { x: -force, y: 0 });
	        this.emit('torque-applied', t);
	    }
	    /**
	     * Set body as static/dynamic
	     */
	    setStatic(isStatic) {
	        Matter.Body.setStatic(this.body, isStatic);
	        this._isStatic = isStatic;
	        this.emit('static-changed', isStatic);
	    }
	    /**
	     * Set body as sensor
	     */
	    setSensor(isSensor) {
	        this.body.isSensor = isSensor;
	        this._isSensor = isSensor;
	        this.emit('sensor-changed', isSensor);
	    }
	    /**
	     * Set body active state
	     */
	    setActive(active) {
	        if (active) {
	            this.wakeUp();
	        }
	        else {
	            this.sleep();
	        }
	    }
	    /**
	     * Wake up the body
	     */
	    wakeUp() {
	        Matter.Sleeping.set(this.body, false);
	        this.emit('wake-up');
	    }
	    /**
	     * Put body to sleep
	     */
	    sleep() {
	        Matter.Sleeping.set(this.body, true);
	        this.emit('sleep');
	    }
	    /**
	     * Add a shape to the body
	     */
	    addShape(config) {
	        // For Matter.js, we would need to create a compound body
	        // This is a simplified implementation
	        console.warn('addShape not fully implemented for Matter2DBody');
	        this.emit('shape-added', config);
	    }
	    /**
	     * Remove a shape from the body
	     */
	    removeShape(index) {
	        // For Matter.js, this would require reconstructing the body
	        console.warn('removeShape not fully implemented for Matter2DBody');
	        this.emit('shape-removed', index);
	    }
	    /**
	     * Update transform (force bounds recalculation)
	     */
	    updateTransform() {
	        // Update the body's bounds and properties
	        Matter.Body.update(this.body, 1000 / 60, 1, 1); // deltaTime, timeScale, correction
	        this.emit('transform-updated');
	    }
	    /**
	     * Destroy the body
	     */
	    destroy() {
	        this.emit('destroy');
	        this.removeAllListeners();
	    }
	    /**
	     * Get the native Matter.js body
	     */
	    getNativeBody() {
	        return this.body;
	    }
	    /**
	     * Create the Matter.js body from configuration
	     */
	    createMatterBody(config) {
	        let body;
	        // Use the first shape to create the body
	        const primaryShape = config.shapes[0];
	        if (!primaryShape) {
	            throw new Error('Body must have at least one shape');
	        }
	        const position = config.position;
	        const options = {
	            isStatic: this.isStatic,
	            isSensor: this.isSensor,
	            angle: typeof config.rotation === 'number' ? config.rotation : 0,
	            frictionAir: config.linearDamping || 0.01,
	            friction: this._material.friction,
	            restitution: this._material.restitution,
	            density: this._material.density,
	            sleepThreshold: config.sleepSpeedLimit || 60
	        };
	        // Create body based on shape type
	        switch (primaryShape.type) {
	            case 'box':
	                const dimensions = primaryShape.dimensions;
	                body = Matter.Bodies.rectangle(position.x, position.y, dimensions.x, dimensions.y, options);
	                break;
	            case 'circle':
	                const radius = primaryShape.radius || primaryShape.dimensions.x / 2;
	                body = Matter.Bodies.circle(position.x, position.y, radius, options);
	                break;
	            default:
	                // Default to box
	                body = Matter.Bodies.rectangle(position.x, position.y, 32, 32, options);
	                break;
	        }
	        // Set initial velocity if provided
	        if (config.velocity) {
	            const vel = config.velocity;
	            Matter.Body.setVelocity(body, vel);
	        }
	        // Set initial angular velocity if provided
	        if (config.angularVelocity) {
	            const angVel = typeof config.angularVelocity === 'number' ? config.angularVelocity : 0;
	            Matter.Body.setAngularVelocity(body, angVel);
	        }
	        // Set collision filtering
	        if (config.collisionGroup !== undefined || config.collisionMask !== undefined) {
	            body.collisionFilter = {
	                category: 0x0001,
	                mask: config.collisionMask || 0xFFFFFFFF,
	                group: config.collisionGroup || 0
	            };
	        }
	        return body;
	    }
	    /**
	     * Apply configuration to the body
	     */
	    applyConfiguration(config) {
	        // Set mass if provided
	        if (config.mass !== undefined) {
	            this.mass = config.mass;
	        }
	        // Set gravity scale if provided
	        if (config.gravityScale !== undefined) {
	            this.gravityScale = config.gravityScale;
	        }
	        // Set damping values
	        if (config.linearDamping !== undefined) {
	            this.linearDamping = config.linearDamping;
	        }
	        if (config.angularDamping !== undefined) {
	            this.angularDamping = config.angularDamping;
	        }
	        // Set fixed rotation
	        if (config.fixedRotation) {
	            this.body.inertia = Infinity;
	        }
	        // Configure sleeping
	        if (config.allowSleep !== undefined) {
	            // Matter.js bodies can sleep by default, so we don't need to do anything special
	            if (!config.allowSleep) {
	                this.body.sleepThreshold = Infinity;
	            }
	        }
	    }
	    /**
	     * Apply material properties to the body
	     */
	    applyMaterial(material) {
	        this.body.friction = material.friction;
	        this.body.restitution = material.restitution;
	        this.body.density = material.density;
	        if (material.frictionAir !== undefined) {
	            this.body.frictionAir = material.frictionAir;
	        }
	        // Update mass based on new density
	        Matter.Body.setMass(this.body, this.body.area * material.density);
	    }
	}

	/**
	 * Matter.js 2D physics constraint implementation
	 */
	class Matter2DConstraint extends EventEmitter {
	    constructor(config, bodyA, bodyB) {
	        super();
	        this._userData = null;
	        this.id = config.id || `constraint_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
	        this.type = config.type;
	        this.bodyA = bodyA;
	        this.bodyB = bodyB;
	        this._userData = config.userData;
	        this.constraint = this.createMatterConstraint(config, bodyA, bodyB);
	    }
	    /**
	     * Get/set stiffness
	     */
	    get stiffness() {
	        return this.constraint.stiffness;
	    }
	    set stiffness(stiffness) {
	        this.constraint.stiffness = Math.max(0, Math.min(1, stiffness));
	        this.emit('stiffness-changed', stiffness);
	    }
	    /**
	     * Get/set damping
	     */
	    get damping() {
	        return this.constraint.damping;
	    }
	    set damping(damping) {
	        this.constraint.damping = Math.max(0, Math.min(1, damping));
	        this.emit('damping-changed', damping);
	    }
	    /**
	     * Get/set motor speed (for motorized constraints)
	     */
	    get motorSpeed() {
	        // Matter.js doesn't have built-in motors, so we store this in userData
	        return this.constraint.render?.motorSpeed || 0;
	    }
	    set motorSpeed(speed) {
	        if (!this.constraint.render) {
	            this.constraint.render = {};
	        }
	        this.constraint.render.motorSpeed = speed;
	        this.emit('motor-speed-changed', speed);
	    }
	    /**
	     * Get/set motor force (for motorized constraints)
	     */
	    get motorForce() {
	        return this.constraint.render?.motorForce || 0;
	    }
	    set motorForce(force) {
	        if (!this.constraint.render) {
	            this.constraint.render = {};
	        }
	        this.constraint.render.motorForce = force;
	        this.emit('motor-force-changed', force);
	    }
	    /**
	     * Get motor enabled state
	     */
	    get isMotorEnabled() {
	        return this.constraint.render?.motorEnabled || false;
	    }
	    /**
	     * Get/set user data
	     */
	    get userData() {
	        return this._userData;
	    }
	    set userData(data) {
	        this._userData = data;
	        this.emit('user-data-changed', data);
	    }
	    /**
	     * Set stiffness
	     */
	    setStiffness(stiffness) {
	        this.stiffness = stiffness;
	    }
	    /**
	     * Set damping
	     */
	    setDamping(damping) {
	        this.damping = damping;
	    }
	    /**
	     * Set motor speed
	     */
	    setMotorSpeed(speed) {
	        this.motorSpeed = speed;
	    }
	    /**
	     * Set motor force
	     */
	    setMotorForce(force) {
	        this.motorForce = force;
	    }
	    /**
	     * Enable or disable motor
	     */
	    enableMotor(enabled) {
	        if (!this.constraint.render) {
	            this.constraint.render = {};
	        }
	        this.constraint.render.motorEnabled = enabled;
	        this.emit('motor-enabled-changed', enabled);
	    }
	    /**
	     * Destroy the constraint
	     */
	    destroy() {
	        this.emit('destroy');
	        this.removeAllListeners();
	    }
	    /**
	     * Get the native Matter.js constraint
	     */
	    getNativeConstraint() {
	        return this.constraint;
	    }
	    /**
	     * Create the Matter.js constraint from configuration
	     */
	    createMatterConstraint(config, bodyA, bodyB) {
	        const nativeBodyA = bodyA.getNativeBody();
	        const nativeBodyB = bodyB.getNativeBody();
	        let constraint;
	        const options = {
	            bodyA: nativeBodyA,
	            bodyB: nativeBodyB,
	            stiffness: config.stiffness || 0.8,
	            damping: config.damping || 0.1,
	            length: config.length
	        };
	        // Set anchor points if provided
	        if (config.anchorA) {
	            const anchor = config.anchorA;
	            options.pointA = { x: anchor.x, y: anchor.y };
	        }
	        if (config.anchorB) {
	            const anchor = config.anchorB;
	            options.pointB = { x: anchor.x, y: anchor.y };
	        }
	        switch (config.type) {
	            case 'distance':
	                // Standard distance constraint
	                if (config.length === undefined) {
	                    // Calculate distance between bodies if not specified
	                    const dx = nativeBodyB.position.x - nativeBodyA.position.x;
	                    const dy = nativeBodyB.position.y - nativeBodyA.position.y;
	                    options.length = Math.sqrt(dx * dx + dy * dy);
	                }
	                constraint = Matter.Constraint.create(options);
	                break;
	            case 'spring':
	                // Spring constraint with higher stiffness
	                options.stiffness = config.stiffness || 0.02;
	                options.damping = config.damping || 0.05;
	                constraint = Matter.Constraint.create(options);
	                break;
	            case 'revolute':
	                // Pin constraint (revolute joint)
	                options.length = 0;
	                options.stiffness = 1;
	                constraint = Matter.Constraint.create(options);
	                break;
	            case 'fixed':
	                // Fixed constraint
	                options.length = 0;
	                options.stiffness = 1;
	                options.damping = 0;
	                constraint = Matter.Constraint.create(options);
	                break;
	            case 'rope':
	                // Rope constraint (distance with no compression)
	                constraint = Matter.Constraint.create(options);
	                // Note: Matter.js doesn't have built-in rope physics, 
	                // this would need custom implementation
	                break;
	            case 'mouse':
	                // Mouse constraint for dragging
	                options.stiffness = 0.2;
	                options.length = 0;
	                constraint = Matter.Constraint.create(options);
	                break;
	            case 'prismatic':
	            case 'gear':
	            case 'pulley':
	                // These constraint types are not directly supported by Matter.js
	                // Fall back to distance constraint
	                console.warn(`Constraint type '${config.type}' not fully supported in Matter.js, using distance constraint`);
	                constraint = Matter.Constraint.create(options);
	                break;
	            default:
	                // Default to distance constraint
	                constraint = Matter.Constraint.create(options);
	                break;
	        }
	        // Apply limits if specified
	        if (config.lowerLimit !== undefined || config.upperLimit !== undefined) {
	            // Matter.js doesn't have built-in constraint limits
	            // This would need custom implementation
	            console.warn('Constraint limits not supported in Matter.js');
	        }
	        // Apply motor settings if specified
	        if (config.motorSpeed !== undefined || config.motorForce !== undefined) {
	            // Store motor settings in render object for later use
	            constraint.render = constraint.render || {};
	            constraint.render.motorSpeed = config.motorSpeed || 0;
	            constraint.render.motorForce = config.motorForce || 0;
	            constraint.render.motorEnabled = config.enableMotor || false;
	        }
	        return constraint;
	    }
	}

	/**
	 * Matter.js 2D physics world implementation
	 */
	class Matter2DWorld extends EventEmitter {
	    // Public getter for readonly access
	    get isRunning() {
	        return this._isRunning;
	    }
	    constructor(engine, config) {
	        super();
	        this.dimension = '2d';
	        this.engineType = 'matter';
	        // Private backing field for mutable state
	        this._isRunning = false;
	        this.runner = null;
	        this.bodies = new Map();
	        this.constraints = new Map();
	        this.lastStepTime = 0;
	        this.paused = false;
	        this.engine = engine;
	        this.config = { ...config };
	        const nativeEngine = engine.getNativeEngine();
	        if (!nativeEngine) {
	            throw new Error('Engine is not initialized');
	        }
	        this.world = nativeEngine.world;
	        this.initializeWorld();
	        this.setupCollisionEvents();
	    }
	    /**
	     * Get current body count
	     */
	    get bodyCount() {
	        return this.bodies.size;
	    }
	    /**
	     * Get current constraint count
	     */
	    get constraintCount() {
	        return this.constraints.size;
	    }
	    /**
	     * Get current gravity
	     */
	    get gravity() {
	        return {
	            x: this.world.gravity.x,
	            y: this.world.gravity.y
	        };
	    }
	    /**
	     * Set gravity
	     */
	    set gravity(gravity) {
	        const point = gravity;
	        this.world.gravity.x = point.x;
	        this.world.gravity.y = point.y;
	        this.emit('gravity-changed', gravity);
	    }
	    /**
	     * Get time step
	     */
	    get timeStep() {
	        return this.config.timeStep || 1 / 60;
	    }
	    /**
	     * Set time step
	     */
	    set timeStep(timeStep) {
	        this.config.timeStep = timeStep;
	    }
	    /**
	     * Get solver iterations
	     */
	    get iterations() {
	        const nativeEngine = this.engine.getNativeEngine();
	        if (!nativeEngine) {
	            return { velocity: 4, position: 3 };
	        }
	        return {
	            velocity: nativeEngine.velocityIterations,
	            position: nativeEngine.positionIterations
	        };
	    }
	    /**
	     * Set solver iterations
	     */
	    set iterations(iterations) {
	        const nativeEngine = this.engine.getNativeEngine();
	        if (nativeEngine) {
	            nativeEngine.velocityIterations = iterations.velocity;
	            nativeEngine.positionIterations = iterations.position;
	        }
	    }
	    /**
	     * Step the physics simulation
	     */
	    step(deltaTime) {
	        if (this.paused)
	            return;
	        const startTime = performance.now();
	        const nativeEngine = this.engine.getNativeEngine();
	        if (nativeEngine) {
	            // Update engine timing
	            nativeEngine.timing.timestamp += deltaTime * 1000;
	            // Step the engine
	            Matter.Engine.update(nativeEngine, deltaTime * 1000);
	            // Update performance metrics
	            const stepTime = performance.now() - startTime;
	            this.engine.updatePerformanceMetrics(deltaTime, stepTime);
	            this.lastStepTime = stepTime;
	        }
	        this.emit('step', deltaTime);
	    }
	    /**
	     * Start the physics simulation
	     * Note: We don't use Matter.Runner here - PhysicsManager controls the update loop
	     * via the step() method for better integration with the game loop
	     */
	    start() {
	        if (this.isRunning)
	            return;
	        this._isRunning = true;
	        this.emit('started');
	    }
	    /**
	     * Stop the physics simulation
	     */
	    stop() {
	        if (!this.isRunning)
	            return;
	        this._isRunning = false;
	        this.emit('stopped');
	    }
	    /**
	     * Pause the physics simulation
	     */
	    pause() {
	        this.paused = true;
	        this.emit('paused');
	    }
	    /**
	     * Resume the physics simulation
	     */
	    resume() {
	        this.paused = false;
	        this.emit('resumed');
	    }
	    /**
	     * Clear all bodies and constraints
	     */
	    clear() {
	        // Remove all bodies
	        for (const [id, body] of this.bodies) {
	            this.removeBody(body);
	        }
	        // Remove all constraints
	        for (const [id, constraint] of this.constraints) {
	            this.removeConstraint(constraint);
	        }
	        this.emit('cleared');
	    }
	    /**
	     * Create a physics body
	     */
	    createBody(config) {
	        const body = new Matter2DBody(this.engine, config);
	        this.addBody(body);
	        return body;
	    }
	    /**
	     * Add a body to the world
	     */
	    addBody(body) {
	        if (!(body instanceof Matter2DBody)) {
	            throw new Error('Body must be a Matter2DBody');
	        }
	        this.bodies.set(body.id, body);
	        Matter.World.add(this.world, body.getNativeBody());
	        // Setup collision events for this body
	        this.setupBodyCollisionEvents(body);
	        this.emit('body-added', body);
	    }
	    /**
	     * Remove a body from the world
	     */
	    removeBody(body) {
	        const bodyId = typeof body === 'string' ? body : body.id;
	        const bodyInstance = this.bodies.get(bodyId);
	        if (bodyInstance) {
	            Matter.World.remove(this.world, bodyInstance.getNativeBody());
	            this.bodies.delete(bodyId);
	            // Return to pool if possible
	            this.engine.returnBodyToPool(bodyInstance.getNativeBody());
	            this.emit('body-removed', bodyInstance);
	        }
	    }
	    /**
	     * Get a body by ID
	     */
	    getBody(id) {
	        return this.bodies.get(id) || null;
	    }
	    /**
	     * Get all bodies
	     */
	    getAllBodies() {
	        return Array.from(this.bodies.values());
	    }
	    /**
	     * Get active bodies (not sleeping)
	     */
	    getActiveBodies() {
	        return Array.from(this.bodies.values()).filter(body => !body.isSleeping);
	    }
	    /**
	     * Get sleeping bodies
	     */
	    getSleepingBodies() {
	        return Array.from(this.bodies.values()).filter(body => body.isSleeping);
	    }
	    /**
	     * Create a constraint
	     */
	    createConstraint(config) {
	        const bodyA = this.getBody(config.bodyA);
	        const bodyB = this.getBody(config.bodyB);
	        if (!bodyA || !bodyB) {
	            throw new Error('Both bodies must exist in the world');
	        }
	        const constraint = new Matter2DConstraint(config, bodyA, bodyB);
	        this.addConstraint(constraint);
	        return constraint;
	    }
	    /**
	     * Add a constraint to the world
	     */
	    addConstraint(constraint) {
	        if (!(constraint instanceof Matter2DConstraint)) {
	            throw new Error('Constraint must be a Matter2DConstraint');
	        }
	        this.constraints.set(constraint.id, constraint);
	        Matter.World.add(this.world, constraint.getNativeConstraint());
	        this.emit('constraint-added', constraint);
	    }
	    /**
	     * Remove a constraint from the world
	     */
	    removeConstraint(constraint) {
	        const constraintId = typeof constraint === 'string' ? constraint : constraint.id;
	        const constraintInstance = this.constraints.get(constraintId);
	        if (constraintInstance) {
	            Matter.World.remove(this.world, constraintInstance.getNativeConstraint());
	            this.constraints.delete(constraintId);
	            this.emit('constraint-removed', constraintInstance);
	        }
	    }
	    /**
	     * Get a constraint by ID
	     */
	    getConstraint(id) {
	        return this.constraints.get(id) || null;
	    }
	    /**
	     * Get all constraints
	     */
	    getAllConstraints() {
	        return Array.from(this.constraints.values());
	    }
	    /**
	     * Perform a raycast
	     */
	    raycast(options) {
	        const results = [];
	        const allBodies = this.world.bodies;
	        for (const body of allBodies) {
	            // Simple ray-body intersection test
	            const hit = this.rayIntersectBody(options.from, options.to, body);
	            if (hit.hit) {
	                const physicsBody = this.findPhysicsBody(body);
	                if (physicsBody) {
	                    results.push({
	                        hit: true,
	                        body: physicsBody,
	                        point: hit.point,
	                        normal: hit.normal,
	                        distance: hit.distance,
	                        fraction: hit.fraction
	                    });
	                }
	            }
	        }
	        // Sort by distance
	        results.sort((a, b) => (a.distance || 0) - (b.distance || 0));
	        return results;
	    }
	    /**
	     * Query bodies in AABB
	     */
	    queryAABB(min, max) {
	        const minPoint = min;
	        const maxPoint = max;
	        const results = [];
	        for (const [id, body] of this.bodies) {
	            const bounds = body.bounds;
	            const bodyMin = bounds.min;
	            const bodyMax = bounds.max;
	            // Check AABB overlap
	            if (bodyMin.x <= maxPoint.x && bodyMax.x >= minPoint.x &&
	                bodyMin.y <= maxPoint.y && bodyMax.y >= minPoint.y) {
	                results.push(body);
	            }
	        }
	        return results;
	    }
	    /**
	     * Query bodies at point
	     */
	    queryPoint(point) {
	        const p = point;
	        const results = [];
	        for (const [id, body] of this.bodies) {
	            const nativeBody = body.getNativeBody();
	            if (Matter.Bounds.contains(nativeBody.bounds, p)) {
	                // More precise point-in-body test could be added here
	                results.push(body);
	            }
	        }
	        return results;
	    }
	    /**
	     * Check collision between two bodies
	     */
	    checkCollision(bodyA, bodyB) {
	        if (!(bodyA instanceof Matter2DBody) || !(bodyB instanceof Matter2DBody)) {
	            return false;
	        }
	        const nativeA = bodyA.getNativeBody();
	        const nativeB = bodyB.getNativeBody();
	        // Check bounds overlap first
	        if (!Matter.Bounds.overlaps(nativeA.bounds, nativeB.bounds)) {
	            return false;
	        }
	        // Use Matter.js collision detection
	        const collision = Matter.SAT.collides(nativeA, nativeB);
	        return collision.collided;
	    }
	    /**
	     * Get performance metrics
	     */
	    getPerformanceMetrics() {
	        const metrics = this.engine.getPerformanceMetrics();
	        metrics.contactCount = this.world.bodies.length; // Simplified
	        return metrics;
	    }
	    /**
	     * Enable debug drawing
	     */
	    enableDebugDraw(enabled) {
	        // Debug drawing would be implemented here
	        this.emit('debug-draw-changed', enabled);
	    }
	    /**
	     * Set gravity
	     */
	    setGravity(gravity) {
	        this.gravity = gravity;
	    }
	    /**
	     * Set time step
	     */
	    setTimeStep(timeStep) {
	        this.timeStep = timeStep;
	    }
	    /**
	     * Optimize for mobile devices
	     */
	    optimizeForMobile() {
	        // Enable sleeping for better performance
	        const nativeEngine = this.engine.getNativeEngine();
	        if (nativeEngine) {
	            nativeEngine.enableSleeping = true;
	            // Reduce solver iterations for mobile
	            nativeEngine.constraintIterations = 1;
	            nativeEngine.velocityIterations = 3;
	            nativeEngine.positionIterations = 2;
	        }
	        this.emit('mobile-optimized');
	    }
	    /**
	     * Destroy the world
	     */
	    destroy() {
	        this.stop();
	        this.clear();
	        this.bodies.clear();
	        this.constraints.clear();
	        this.emit('destroyed');
	    }
	    /**
	     * Get the native Matter.js world
	     */
	    getNativeWorld() {
	        return this.world;
	    }
	    /**
	     * Initialize world properties
	     */
	    initializeWorld() {
	        // Set gravity
	        if (this.config.gravity) {
	            this.setGravity(this.config.gravity);
	        }
	        // Configure sleeping if specified
	        const nativeEngine = this.engine.getNativeEngine();
	        if (nativeEngine && this.config.allowSleep !== undefined) {
	            nativeEngine.enableSleeping = this.config.allowSleep;
	        }
	        // Configure solver iterations
	        if (this.config.iterations && nativeEngine) {
	            nativeEngine.velocityIterations = this.config.iterations.velocity;
	            nativeEngine.positionIterations = this.config.iterations.position;
	        }
	    }
	    /**
	     * Setup collision event handlers
	     */
	    setupCollisionEvents() {
	        const nativeEngine = this.engine.getNativeEngine();
	        if (!nativeEngine)
	            return;
	        // Collision start
	        Matter.Events.on(nativeEngine, 'collisionStart', (event) => {
	            for (const pair of event.pairs) {
	                const bodyA = this.findPhysicsBody(pair.bodyA);
	                const bodyB = this.findPhysicsBody(pair.bodyB);
	                if (bodyA && bodyB) {
	                    const collisionEvent = {
	                        type: 'collision-start',
	                        bodyA,
	                        bodyB,
	                        contactPoint: { x: pair.collision.supports[0].x, y: pair.collision.supports[0].y },
	                        contactNormal: { x: pair.collision.normal.x, y: pair.collision.normal.y },
	                        timestamp: Date.now()
	                    };
	                    this.emit('collision-start', collisionEvent);
	                    bodyA.emit('collision-start', collisionEvent);
	                    bodyB.emit('collision-start', collisionEvent);
	                }
	            }
	        });
	        // Collision end
	        Matter.Events.on(nativeEngine, 'collisionEnd', (event) => {
	            for (const pair of event.pairs) {
	                const bodyA = this.findPhysicsBody(pair.bodyA);
	                const bodyB = this.findPhysicsBody(pair.bodyB);
	                if (bodyA && bodyB) {
	                    const collisionEvent = {
	                        type: 'collision-end',
	                        bodyA,
	                        bodyB,
	                        timestamp: Date.now()
	                    };
	                    this.emit('collision-end', collisionEvent);
	                    bodyA.emit('collision-end', collisionEvent);
	                    bodyB.emit('collision-end', collisionEvent);
	                }
	            }
	        });
	        // Collision active
	        Matter.Events.on(nativeEngine, 'collisionActive', (event) => {
	            for (const pair of event.pairs) {
	                const bodyA = this.findPhysicsBody(pair.bodyA);
	                const bodyB = this.findPhysicsBody(pair.bodyB);
	                if (bodyA && bodyB) {
	                    const collisionEvent = {
	                        type: 'collision-active',
	                        bodyA,
	                        bodyB,
	                        contactPoint: { x: pair.collision.supports[0].x, y: pair.collision.supports[0].y },
	                        contactNormal: { x: pair.collision.normal.x, y: pair.collision.normal.y },
	                        timestamp: Date.now()
	                    };
	                    this.emit('collision-active', collisionEvent);
	                    bodyA.emit('collision-active', collisionEvent);
	                    bodyB.emit('collision-active', collisionEvent);
	                }
	            }
	        });
	    }
	    /**
	     * Setup collision events for a specific body
	     */
	    setupBodyCollisionEvents(body) {
	        // Additional body-specific collision setup could be added here
	    }
	    /**
	     * Find the PhysicsBody wrapper for a native Matter body
	     */
	    findPhysicsBody(nativeBody) {
	        for (const [id, body] of this.bodies) {
	            if (body.getNativeBody() === nativeBody) {
	                return body;
	            }
	        }
	        return null;
	    }
	    /**
	     * Perform ray-body intersection test
	     */
	    rayIntersectBody(from, to, body) {
	        // Simple bounds check first
	        if (!this.rayIntersectBounds(from, to, body.bounds)) {
	            return { hit: false };
	        }
	        // For now, just return bounds intersection
	        // More precise shape intersection could be implemented
	        const centerX = (body.bounds.min.x + body.bounds.max.x) / 2;
	        const centerY = (body.bounds.min.y + body.bounds.max.y) / 2;
	        const dx = centerX - from.x;
	        const dy = centerY - from.y;
	        const distance = Math.sqrt(dx * dx + dy * dy);
	        return {
	            hit: true,
	            point: { x: centerX, y: centerY },
	            normal: { x: dx / distance, y: dy / distance },
	            distance,
	            fraction: distance / Math.sqrt((to.x - from.x) ** 2 + (to.y - from.y) ** 2)
	        };
	    }
	    /**
	     * Check if ray intersects bounds
	     */
	    rayIntersectBounds(from, to, bounds) {
	        // Simple AABB ray intersection
	        const dx = to.x - from.x;
	        const dy = to.y - from.y;
	        const txMin = (bounds.min.x - from.x) / dx;
	        const txMax = (bounds.max.x - from.x) / dx;
	        const tyMin = (bounds.min.y - from.y) / dy;
	        const tyMax = (bounds.max.y - from.y) / dy;
	        const tMin = Math.max(Math.min(txMin, txMax), Math.min(tyMin, tyMax));
	        const tMax = Math.min(Math.max(txMin, txMax), Math.max(tyMin, tyMax));
	        return tMax >= 0 && tMin <= tMax && tMin <= 1;
	    }
	}

	/**
	 * Matter.js 2D physics engine wrapper optimized for mobile games
	 */
	class Matter2DEngine extends EventEmitter {
	    // Public getter for readonly access
	    get isInitialized() {
	        return this._isInitialized;
	    }
	    constructor() {
	        super();
	        this.engineType = 'matter';
	        this.dimension = '2d';
	        // Private backing field for mutable state
	        this._isInitialized = false;
	        this.engine = null;
	        this.render = null;
	        this.runner = null;
	        this.worlds = new Set();
	        this.bodyPool = [];
	        this.constraintPool = [];
	        this.objectPoolingEnabled = true;
	        this.maxBodies = 1000;
	        this.defaultMaterial = {
	            id: 'default',
	            name: 'Default Material',
	            friction: 0.1,
	            restitution: 0.0,
	            density: 0.001,
	            frictionAir: 0.01,
	            frictionStatic: 0.5,
	            damping: 0.1,
	            angularDamping: 0.1
	        };
	        this.materials = new Map();
	        this.performanceMetrics = {
	            averageStepTime: 0,
	            bodyCount: 0,
	            constraintCount: 0,
	            contactCount: 0,
	            broadphaseTime: 0,
	            narrowphaseTime: 0,
	            solverTime: 0,
	            memoryUsage: 0,
	            sleepingBodies: 0,
	            activeBodies: 0,
	            culledBodies: 0
	        };
	        // Initialize materials map with default material
	        this.materials.set(this.defaultMaterial.id, this.defaultMaterial);
	    }
	    /**
	     * Initialize the Matter.js engine
	     */
	    async initialize(config) {
	        try {
	            // Create the Matter.js engine
	            this.engine = Matter.Engine.create({
	                gravity: { x: 0, y: 1, scale: 0.001 },
	                timing: {
	                    timeScale: 1,
	                    timestamp: 0
	                }
	            });
	            // Configure broadphase separately (grid broadphase for better mobile performance)
	            if (this.engine.broadphase && typeof this.engine.broadphase === 'object') {
	                this.engine.broadphase.detector = Matter.Detector.canCollide;
	            }
	            // Configure for mobile optimization
	            this.optimizeForMobile();
	            this._isInitialized = true;
	            this.emit('initialized');
	        }
	        catch (error) {
	            this.emit('error', error);
	            throw error;
	        }
	    }
	    /**
	     * Destroy the engine and clean up resources
	     */
	    destroy() {
	        if (this.runner) {
	            Matter.Runner.stop(this.runner);
	            this.runner = null;
	        }
	        if (this.render) {
	            Matter.Render.stop(this.render);
	            this.render = null;
	        }
	        // Destroy all worlds
	        for (const world of this.worlds) {
	            world.destroy();
	        }
	        this.worlds.clear();
	        // Clear pools
	        this.bodyPool.length = 0;
	        this.constraintPool.length = 0;
	        this.engine = null;
	        this._isInitialized = false;
	        this.emit('destroyed');
	    }
	    /**
	     * Create a new 2D physics world
	     */
	    createWorld(config) {
	        if (!this.engine) {
	            throw new Error('Engine not initialized. Call initialize() first.');
	        }
	        const world = new Matter2DWorld(this, config);
	        this.worlds.add(world);
	        this.emit('world-created', world);
	        return world;
	    }
	    /**
	     * Destroy a physics world
	     */
	    destroyWorld(world) {
	        if (world instanceof Matter2DWorld) {
	            this.worlds.delete(world);
	            world.destroy();
	            this.emit('world-destroyed', world);
	        }
	    }
	    /**
	     * Create a physics material
	     */
	    createMaterial(config) {
	        const material = {
	            id: config.id || `material_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
	            name: config.name || 'Unnamed Material',
	            friction: config.friction ?? 0.1,
	            restitution: config.restitution ?? 0.0,
	            density: config.density ?? 0.001,
	            frictionAir: config.frictionAir ?? 0.01,
	            frictionStatic: config.frictionStatic ?? 0.5,
	            damping: config.damping ?? 0.1,
	            angularDamping: config.angularDamping ?? 0.1
	        };
	        this.materials.set(material.id, material);
	        return material;
	    }
	    /**
	     * Get the default physics material
	     */
	    getDefaultMaterial() {
	        return this.defaultMaterial;
	    }
	    /**
	     * Get a material by ID
	     */
	    getMaterial(id) {
	        return this.materials.get(id) || null;
	    }
	    /**
	     * Optimize engine for different device tiers
	     */
	    optimizeForDevice(deviceTier) {
	        if (!this.engine)
	            return;
	        switch (deviceTier) {
	            case 'low':
	                // Reduce quality for low-end devices
	                this.engine.constraintIterations = 1;
	                this.engine.velocityIterations = 2;
	                this.engine.positionIterations = 2;
	                this.maxBodies = 500;
	                break;
	            case 'medium':
	                // Balanced settings
	                this.engine.constraintIterations = 2;
	                this.engine.velocityIterations = 4;
	                this.engine.positionIterations = 3;
	                this.maxBodies = 750;
	                break;
	            case 'high':
	                // High quality for powerful devices
	                this.engine.constraintIterations = 3;
	                this.engine.velocityIterations = 6;
	                this.engine.positionIterations = 4;
	                this.maxBodies = 1000;
	                break;
	        }
	        this.emit('device-optimized', deviceTier);
	    }
	    /**
	     * Enable or disable object pooling
	     */
	    enableObjectPooling(enabled) {
	        this.objectPoolingEnabled = enabled;
	        if (!enabled) {
	            this.bodyPool.length = 0;
	            this.constraintPool.length = 0;
	        }
	        this.emit('object-pooling-changed', enabled);
	    }
	    /**
	     * Set maximum number of bodies
	     */
	    setMaxBodies(maxBodies) {
	        this.maxBodies = maxBodies;
	        // Trim pool if necessary
	        if (this.bodyPool.length > maxBodies) {
	            this.bodyPool.length = maxBodies;
	        }
	    }
	    /**
	     * Get the native Matter.js engine
	     */
	    getNativeEngine() {
	        return this.engine;
	    }
	    /**
	     * Get a body from the pool or create a new one
	     */
	    getPooledBody() {
	        if (this.objectPoolingEnabled && this.bodyPool.length > 0) {
	            return this.bodyPool.pop();
	        }
	        return null;
	    }
	    /**
	     * Return a body to the pool
	     */
	    returnBodyToPool(body) {
	        if (this.objectPoolingEnabled && this.bodyPool.length < this.maxBodies) {
	            // Reset body properties
	            Matter.Body.setPosition(body, { x: 0, y: 0 });
	            Matter.Body.setVelocity(body, { x: 0, y: 0 });
	            Matter.Body.setAngularVelocity(body, 0);
	            Matter.Body.setAngle(body, 0);
	            this.bodyPool.push(body);
	        }
	    }
	    /**
	     * Get performance metrics
	     */
	    getPerformanceMetrics() {
	        if (!this.engine) {
	            return this.performanceMetrics;
	        }
	        // Update metrics
	        this.performanceMetrics.bodyCount = this.engine.world.bodies.length;
	        this.performanceMetrics.constraintCount = this.engine.world.constraints.length;
	        this.performanceMetrics.activeBodies = this.engine.world.bodies.filter(body => !body.isSleeping).length;
	        this.performanceMetrics.sleepingBodies = this.engine.world.bodies.filter(body => body.isSleeping).length;
	        return this.performanceMetrics;
	    }
	    /**
	     * Update performance metrics
	     */
	    updatePerformanceMetrics(deltaTime, stepTime) {
	        this.performanceMetrics.averageStepTime = (this.performanceMetrics.averageStepTime * 0.9) + (stepTime * 0.1);
	        // Estimate memory usage (rough calculation)
	        const bodyMemory = this.performanceMetrics.bodyCount * 256; // ~256 bytes per body
	        const constraintMemory = this.performanceMetrics.constraintCount * 128; // ~128 bytes per constraint
	        this.performanceMetrics.memoryUsage = bodyMemory + constraintMemory;
	    }
	    /**
	     * Optimize engine for mobile devices
	     */
	    optimizeForMobile() {
	        if (!this.engine)
	            return;
	        // Enable sleeping for better performance
	        this.engine.enableSleeping = true;
	        // Configure sleep thresholds globally for all bodies
	        // Note: Matter.js applies sleep settings per body, not globally
	        // These settings will be applied to bodies when they are created
	        // Configure broadphase for better mobile performance
	        // Note: Broadphase configuration is handled during engine creation
	        // Optimize timing
	        this.engine.timing.timeScale = 1;
	        this.engine.constraintIterations = 2;
	        this.engine.velocityIterations = 4;
	        this.engine.positionIterations = 3;
	        // Reduce gravity scale for better mobile performance
	        this.engine.world.gravity.scale = 0.001;
	    }
	}

	/**
	 * Cannon.js 3D physics body implementation
	 */
	class Cannon3DBody extends EventEmitter {
	    // Public getters for readonly access
	    get isStatic() {
	        return this._isStatic;
	    }
	    get isSensor() {
	        return this._isSensor;
	    }
	    constructor(engine, config) {
	        super();
	        this.dimension = '3d';
	        this._userData = null;
	        this.engine = engine;
	        this.id = config.id || `body_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
	        this.type = config.type;
	        this._isStatic = config.isStatic || config.type === 'static';
	        this._isSensor = config.isSensor || false;
	        this._material = config.material || engine.getDefaultMaterial();
	        this._userData = config.userData;
	        this.cannonMaterial = engine.createCannonMaterial(this._material);
	        this.body = this.createCannonBody(config);
	        this.applyConfiguration(config);
	    }
	    /**
	     * Get if body is active (not sleeping)
	     */
	    get isActive() {
	        return this.body.sleepState === CANNON__namespace.Body.AWAKE;
	    }
	    /**
	     * Get if body is sleeping
	     */
	    get isSleeping() {
	        return this.body.sleepState === CANNON__namespace.Body.SLEEPING;
	    }
	    /**
	     * Get/set position
	     */
	    get position() {
	        return {
	            x: this.body.position.x,
	            y: this.body.position.y,
	            z: this.body.position.z
	        };
	    }
	    set position(position) {
	        if ('z' in position) {
	            const pos = position;
	            this.body.position.set(pos.x, pos.y, pos.z);
	        }
	        else {
	            // Convert 2D position to 3D
	            const pos = position;
	            this.body.position.set(pos.x, pos.y, 0);
	        }
	        this.emit('position-changed', position);
	    }
	    /**
	     * Get/set rotation (quaternion)
	     */
	    get rotation() {
	        return {
	            x: this.body.quaternion.x,
	            y: this.body.quaternion.y,
	            z: this.body.quaternion.z,
	            w: this.body.quaternion.w
	        };
	    }
	    set rotation(rotation) {
	        if (typeof rotation === 'number') {
	            // Convert 2D angle to 3D quaternion (rotation around Z axis)
	            this.body.quaternion.setFromAxisAngle(new CANNON__namespace.Vec3(0, 0, 1), rotation);
	        }
	        else {
	            const quat = rotation;
	            this.body.quaternion.set(quat.x, quat.y, quat.z, quat.w);
	        }
	        this.emit('rotation-changed', rotation);
	    }
	    /**
	     * Get/set velocity
	     */
	    get velocity() {
	        return {
	            x: this.body.velocity.x,
	            y: this.body.velocity.y,
	            z: this.body.velocity.z
	        };
	    }
	    set velocity(velocity) {
	        if ('z' in velocity) {
	            const vel = velocity;
	            this.body.velocity.set(vel.x, vel.y, vel.z);
	        }
	        else {
	            // Convert 2D velocity to 3D
	            const vel = velocity;
	            this.body.velocity.set(vel.x, vel.y, 0);
	        }
	        this.emit('velocity-changed', velocity);
	    }
	    /**
	     * Get/set angular velocity
	     */
	    get angularVelocity() {
	        return {
	            x: this.body.angularVelocity.x,
	            y: this.body.angularVelocity.y,
	            z: this.body.angularVelocity.z
	        };
	    }
	    set angularVelocity(angularVelocity) {
	        if (typeof angularVelocity === 'number') {
	            // Convert 2D angular velocity to 3D (around Z axis)
	            this.body.angularVelocity.set(0, 0, angularVelocity);
	        }
	        else {
	            const angVel = angularVelocity;
	            this.body.angularVelocity.set(angVel.x, angVel.y, angVel.z);
	        }
	        this.emit('angular-velocity-changed', angularVelocity);
	    }
	    /**
	     * Get/set mass
	     */
	    get mass() {
	        return this.body.mass;
	    }
	    set mass(mass) {
	        this.body.mass = mass;
	        this.body.updateMassProperties();
	        this.emit('mass-changed', mass);
	    }
	    /**
	     * Get/set material
	     */
	    get material() {
	        return this._material;
	    }
	    set material(material) {
	        this._material = material;
	        this.cannonMaterial = this.engine.createCannonMaterial(material);
	        this.applyMaterial(material);
	        this.emit('material-changed', material);
	    }
	    /**
	     * Get/set gravity scale (custom property)
	     */
	    get gravityScale() {
	        return this.body.gravityScale || 1;
	    }
	    set gravityScale(scale) {
	        this.body.gravityScale = scale;
	        this.emit('gravity-scale-changed', scale);
	    }
	    /**
	     * Get/set linear damping
	     */
	    get linearDamping() {
	        return this.body.linearDamping;
	    }
	    set linearDamping(damping) {
	        this.body.linearDamping = damping;
	        this.emit('linear-damping-changed', damping);
	    }
	    /**
	     * Get/set angular damping
	     */
	    get angularDamping() {
	        return this.body.angularDamping;
	    }
	    set angularDamping(damping) {
	        this.body.angularDamping = damping;
	        this.emit('angular-damping-changed', damping);
	    }
	    /**
	     * Get/set collision group
	     */
	    get collisionGroup() {
	        return this.body.collisionFilterGroup;
	    }
	    set collisionGroup(group) {
	        this.body.collisionFilterGroup = group;
	        this.emit('collision-group-changed', group);
	    }
	    /**
	     * Get/set collision mask
	     */
	    get collisionMask() {
	        return this.body.collisionFilterMask;
	    }
	    set collisionMask(mask) {
	        this.body.collisionFilterMask = mask;
	        this.emit('collision-mask-changed', mask);
	    }
	    /**
	     * Get body bounds
	     */
	    get bounds() {
	        // Force AABB update
	        this.body.updateBoundingRadius();
	        this.body.updateAABB();
	        return {
	            min: {
	                x: this.body.aabb.lowerBound.x,
	                y: this.body.aabb.lowerBound.y,
	                z: this.body.aabb.lowerBound.z
	            },
	            max: {
	                x: this.body.aabb.upperBound.x,
	                y: this.body.aabb.upperBound.y,
	                z: this.body.aabb.upperBound.z
	            }
	        };
	    }
	    /**
	     * Get/set user data
	     */
	    get userData() {
	        return this._userData;
	    }
	    set userData(data) {
	        this._userData = data;
	        this.emit('user-data-changed', data);
	    }
	    /**
	     * Apply force at a point
	     */
	    applyForce(force, point) {
	        const f = this.toVector3(force);
	        const p = point ? this.toVector3(point) : this.body.position;
	        const forceVec = new CANNON__namespace.Vec3(f.x, f.y, f.z);
	        const pointVec = new CANNON__namespace.Vec3(p.x, p.y, p.z);
	        this.body.applyForce(forceVec, pointVec);
	        this.emit('force-applied', { force: f, point: p });
	    }
	    /**
	     * Apply impulse at a point
	     */
	    applyImpulse(impulse, point) {
	        const imp = this.toVector3(impulse);
	        const p = point ? this.toVector3(point) : this.body.position;
	        const impulseVec = new CANNON__namespace.Vec3(imp.x, imp.y, imp.z);
	        const pointVec = new CANNON__namespace.Vec3(p.x, p.y, p.z);
	        this.body.applyImpulse(impulseVec, pointVec);
	        this.emit('impulse-applied', { impulse: imp, point: p });
	    }
	    /**
	     * Apply torque
	     */
	    applyTorque(torque) {
	        const t = typeof torque === 'number'
	            ? { x: 0, y: 0, z: torque } // 2D torque around Z axis
	            : torque;
	        const torqueVec = new CANNON__namespace.Vec3(t.x, t.y, t.z);
	        this.body.torque.vadd(torqueVec, this.body.torque);
	        this.emit('torque-applied', t);
	    }
	    /**
	     * Set body as static/dynamic
	     */
	    setStatic(isStatic) {
	        this.body.type = isStatic ? CANNON__namespace.Body.KINEMATIC : CANNON__namespace.Body.DYNAMIC;
	        if (isStatic) {
	            this.body.mass = 0;
	            this.body.updateMassProperties();
	        }
	        this._isStatic = isStatic;
	        this.emit('static-changed', isStatic);
	    }
	    /**
	     * Set body as sensor
	     */
	    setSensor(isSensor) {
	        this.body.isTrigger = isSensor;
	        this._isSensor = isSensor;
	        this.emit('sensor-changed', isSensor);
	    }
	    /**
	     * Set body active state
	     */
	    setActive(active) {
	        if (active) {
	            this.wakeUp();
	        }
	        else {
	            this.sleep();
	        }
	    }
	    /**
	     * Wake up the body
	     */
	    wakeUp() {
	        this.body.wakeUp();
	        this.emit('wake-up');
	    }
	    /**
	     * Put body to sleep
	     */
	    sleep() {
	        this.body.sleep();
	        this.emit('sleep');
	    }
	    /**
	     * Add a shape to the body
	     */
	    addShape(config) {
	        const shape = this.createCannonShape(config);
	        const offset = config.offset ? this.toVector3(config.offset) : new CANNON__namespace.Vec3(0, 0, 0);
	        const rotation = config.rotation ? this.toQuaternion(config.rotation) : new CANNON__namespace.Quaternion();
	        this.body.addShape(shape, new CANNON__namespace.Vec3(offset.x, offset.y, offset.z), rotation);
	        this.emit('shape-added', config);
	    }
	    /**
	     * Remove a shape from the body
	     */
	    removeShape(index) {
	        if (index >= 0 && index < this.body.shapes.length) {
	            this.body.removeShape(this.body.shapes[index]);
	            this.emit('shape-removed', index);
	        }
	    }
	    /**
	     * Update transform (force AABB recalculation)
	     */
	    updateTransform() {
	        this.body.updateBoundingRadius();
	        this.body.updateAABB();
	        this.emit('transform-updated');
	    }
	    /**
	     * Destroy the body
	     */
	    destroy() {
	        this.emit('destroy');
	        this.removeAllListeners();
	    }
	    /**
	     * Get the native Cannon.js body
	     */
	    getNativeBody() {
	        return this.body;
	    }
	    /**
	     * Create the Cannon.js body from configuration
	     */
	    createCannonBody(config) {
	        const position = this.toVector3(config.position);
	        const body = new CANNON__namespace.Body({
	            mass: this.isStatic ? 0 : (config.mass || 1),
	            position: new CANNON__namespace.Vec3(position.x, position.y, position.z),
	            material: this.cannonMaterial,
	            type: this.isStatic ? CANNON__namespace.Body.KINEMATIC : CANNON__namespace.Body.DYNAMIC,
	            isTrigger: this.isSensor
	        });
	        // Set rotation if provided
	        if (config.rotation !== undefined) {
	            const quat = this.toQuaternion(config.rotation);
	            body.quaternion.set(quat.x, quat.y, quat.z, quat.w);
	        }
	        // Add shapes
	        for (const shapeConfig of config.shapes) {
	            const shape = this.createCannonShape(shapeConfig);
	            const offset = shapeConfig.offset ? this.toVector3(shapeConfig.offset) : new CANNON__namespace.Vec3(0, 0, 0);
	            const rotation = shapeConfig.rotation ? this.toQuaternion(shapeConfig.rotation) : new CANNON__namespace.Quaternion();
	            body.addShape(shape, new CANNON__namespace.Vec3(offset.x, offset.y, offset.z), rotation);
	        }
	        // Set initial velocity if provided
	        if (config.velocity) {
	            const vel = this.toVector3(config.velocity);
	            body.velocity.set(vel.x, vel.y, vel.z);
	        }
	        // Set initial angular velocity if provided
	        if (config.angularVelocity) {
	            if (typeof config.angularVelocity === 'number') {
	                // For scalar angular velocity, assume rotation around Z-axis
	                body.angularVelocity.set(0, 0, config.angularVelocity);
	            }
	            else {
	                const angVel = this.toVector3(config.angularVelocity);
	                body.angularVelocity.set(angVel.x, angVel.y, angVel.z);
	            }
	        }
	        // Set collision filtering
	        if (config.collisionGroup !== undefined) {
	            body.collisionFilterGroup = config.collisionGroup;
	        }
	        if (config.collisionMask !== undefined) {
	            body.collisionFilterMask = config.collisionMask;
	        }
	        return body;
	    }
	    /**
	     * Create a Cannon.js shape from configuration
	     */
	    createCannonShape(config) {
	        const dimensions = this.toVector3(config.dimensions);
	        switch (config.type) {
	            case 'box':
	                return new CANNON__namespace.Box(new CANNON__namespace.Vec3(dimensions.x / 2, dimensions.y / 2, dimensions.z / 2));
	            case 'sphere':
	                return new CANNON__namespace.Sphere(config.radius || dimensions.x / 2);
	            case 'circle':
	                // Create a very thin cylinder for 2D circle
	                return new CANNON__namespace.Cylinder(config.radius || dimensions.x / 2, config.radius || dimensions.x / 2, 0.1, 8);
	            case 'capsule':
	                return new CANNON__namespace.Cylinder(config.radius || dimensions.x / 2, config.radius || dimensions.x / 2, config.height || dimensions.y, 8);
	            case 'heightfield':
	                // Would need height data
	                console.warn('Heightfield shape not implemented');
	                return new CANNON__namespace.Box(new CANNON__namespace.Vec3(1, 1, 1));
	            case 'mesh':
	                // Would need mesh data
	                console.warn('Mesh shape not implemented');
	                return new CANNON__namespace.Box(new CANNON__namespace.Vec3(1, 1, 1));
	            default:
	                // Default to box
	                return new CANNON__namespace.Box(new CANNON__namespace.Vec3(dimensions.x / 2, dimensions.y / 2, dimensions.z / 2));
	        }
	    }
	    /**
	     * Apply configuration to the body
	     */
	    applyConfiguration(config) {
	        // Set gravity scale
	        if (config.gravityScale !== undefined) {
	            this.gravityScale = config.gravityScale;
	        }
	        // Set damping values
	        if (config.linearDamping !== undefined) {
	            this.linearDamping = config.linearDamping;
	        }
	        if (config.angularDamping !== undefined) {
	            this.angularDamping = config.angularDamping;
	        }
	        // Set fixed rotation
	        if (config.fixedRotation) {
	            this.body.fixedRotation = true;
	            this.body.updateMassProperties();
	        }
	        // Configure sleeping
	        if (config.allowSleep !== undefined) {
	            this.body.allowSleep = config.allowSleep;
	            if (config.sleepTimeLimit !== undefined) {
	                this.body.sleepTimeLimit = config.sleepTimeLimit / 1000; // Convert to seconds
	            }
	            if (config.sleepSpeedLimit !== undefined) {
	                this.body.sleepSpeedLimit = config.sleepSpeedLimit;
	            }
	        }
	    }
	    /**
	     * Apply material properties to the body
	     */
	    applyMaterial(material) {
	        this.cannonMaterial.friction = material.friction;
	        this.cannonMaterial.restitution = material.restitution;
	        // Update body mass based on density
	        if (!this.isStatic) {
	            this.body.mass = this.calculateBodyVolume() * material.density;
	            this.body.updateMassProperties();
	        }
	    }
	    /**
	     * Calculate approximate body volume for mass calculation
	     */
	    calculateBodyVolume() {
	        let totalVolume = 0;
	        for (const shape of this.body.shapes) {
	            if (shape instanceof CANNON__namespace.Box) {
	                const box = shape;
	                totalVolume += 8 * box.halfExtents.x * box.halfExtents.y * box.halfExtents.z;
	            }
	            else if (shape instanceof CANNON__namespace.Sphere) {
	                const sphere = shape;
	                totalVolume += (4 / 3) * Math.PI * sphere.radius ** 3;
	            }
	            else if (shape instanceof CANNON__namespace.Cylinder) {
	                const cylinder = shape;
	                totalVolume += Math.PI * cylinder.radiusTop ** 2 * cylinder.height;
	            }
	            else {
	                // Default volume for unknown shapes
	                totalVolume += 1;
	            }
	        }
	        return Math.max(totalVolume, 0.1); // Minimum volume to avoid zero mass
	    }
	    /**
	     * Convert Point or Vector3 to Vector3
	     */
	    toVector3(input) {
	        if ('z' in input) {
	            return input;
	        }
	        else {
	            const point = input;
	            return { x: point.x, y: point.y, z: 0 };
	        }
	    }
	    /**
	     * Convert number or Quaternion to CANNON.Quaternion
	     */
	    toQuaternion(input) {
	        if (typeof input === 'number') {
	            // Convert 2D angle to 3D quaternion (rotation around Z axis)
	            return new CANNON__namespace.Quaternion().setFromAxisAngle(new CANNON__namespace.Vec3(0, 0, 1), input);
	        }
	        else {
	            const quat = input;
	            return new CANNON__namespace.Quaternion(quat.x, quat.y, quat.z, quat.w);
	        }
	    }
	}

	/**
	 * Cannon.js 3D physics constraint implementation
	 */
	class Cannon3DConstraint extends EventEmitter {
	    constructor(config, bodyA, bodyB) {
	        super();
	        this._userData = null;
	        this.id = config.id || `constraint_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
	        this.type = config.type;
	        this.bodyA = bodyA;
	        this.bodyB = bodyB;
	        this._userData = config.userData;
	        this.constraint = this.createCannonConstraint(config, bodyA, bodyB);
	    }
	    /**
	     * Get/set stiffness (not directly supported by Cannon.js)
	     */
	    get stiffness() {
	        return this.constraint.stiffness || 1;
	    }
	    set stiffness(stiffness) {
	        this.constraint.stiffness = Math.max(0, Math.min(1, stiffness));
	        this.emit('stiffness-changed', stiffness);
	    }
	    /**
	     * Get/set damping (not directly supported by Cannon.js)
	     */
	    get damping() {
	        return this.constraint.damping || 0;
	    }
	    set damping(damping) {
	        this.constraint.damping = Math.max(0, Math.min(1, damping));
	        this.emit('damping-changed', damping);
	    }
	    /**
	     * Get/set motor speed (for motorized constraints)
	     */
	    get motorSpeed() {
	        if (this.constraint instanceof CANNON__namespace.HingeConstraint) {
	            return this.constraint.motorTargetVelocity || 0;
	        }
	        return this.constraint.motorSpeed || 0;
	    }
	    set motorSpeed(speed) {
	        if (this.constraint instanceof CANNON__namespace.HingeConstraint) {
	            this.constraint.motorTargetVelocity = speed;
	        }
	        else {
	            this.constraint.motorSpeed = speed;
	        }
	        this.emit('motor-speed-changed', speed);
	    }
	    /**
	     * Get/set motor force (for motorized constraints)
	     */
	    get motorForce() {
	        if (this.constraint instanceof CANNON__namespace.HingeConstraint) {
	            return this.constraint.motorMaxForce || 0;
	        }
	        return this.constraint.motorForce || 0;
	    }
	    set motorForce(force) {
	        if (this.constraint instanceof CANNON__namespace.HingeConstraint) {
	            this.constraint.motorMaxForce = force;
	        }
	        else {
	            this.constraint.motorForce = force;
	        }
	        this.emit('motor-force-changed', force);
	    }
	    /**
	     * Get motor enabled state
	     */
	    get isMotorEnabled() {
	        if (this.constraint instanceof CANNON__namespace.HingeConstraint) {
	            return this.constraint.motorEnabled || false;
	        }
	        return this.constraint.motorEnabled || false;
	    }
	    /**
	     * Get/set user data
	     */
	    get userData() {
	        return this._userData;
	    }
	    set userData(data) {
	        this._userData = data;
	        this.emit('user-data-changed', data);
	    }
	    /**
	     * Set stiffness
	     */
	    setStiffness(stiffness) {
	        this.stiffness = stiffness;
	    }
	    /**
	     * Set damping
	     */
	    setDamping(damping) {
	        this.damping = damping;
	    }
	    /**
	     * Set motor speed
	     */
	    setMotorSpeed(speed) {
	        this.motorSpeed = speed;
	    }
	    /**
	     * Set motor force
	     */
	    setMotorForce(force) {
	        this.motorForce = force;
	    }
	    /**
	     * Enable or disable motor
	     */
	    enableMotor(enabled) {
	        if (this.constraint instanceof CANNON__namespace.HingeConstraint) {
	            this.constraint.motorEnabled = enabled;
	        }
	        else {
	            this.constraint.motorEnabled = enabled;
	        }
	        this.emit('motor-enabled-changed', enabled);
	    }
	    /**
	     * Destroy the constraint
	     */
	    destroy() {
	        this.emit('destroy');
	        this.removeAllListeners();
	    }
	    /**
	     * Get the native Cannon.js constraint
	     */
	    getNativeConstraint() {
	        return this.constraint;
	    }
	    /**
	     * Create the Cannon.js constraint from configuration
	     */
	    createCannonConstraint(config, bodyA, bodyB) {
	        const nativeBodyA = bodyA.getNativeBody();
	        const nativeBodyB = bodyB.getNativeBody();
	        let constraint;
	        switch (config.type) {
	            case 'distance':
	                // Distance constraint
	                const distance = config.length || this.calculateDistance(bodyA, bodyB);
	                constraint = new CANNON__namespace.DistanceConstraint(nativeBodyA, nativeBodyB, distance);
	                break;
	            case 'spring':
	                // Spring constraint (distance constraint with custom properties)
	                const springDistance = config.length || this.calculateDistance(bodyA, bodyB);
	                constraint = new CANNON__namespace.DistanceConstraint(nativeBodyA, nativeBodyB, springDistance);
	                constraint.stiffness = config.stiffness || 0.02;
	                constraint.damping = config.damping || 0.05;
	                break;
	            case 'revolute':
	                // Hinge constraint (revolute joint)
	                const pivotA = config.anchorA ? this.toVector3(config.anchorA) : { x: 0, y: 0, z: 0 };
	                const pivotB = config.anchorB ? this.toVector3(config.anchorB) : { x: 0, y: 0, z: 0 };
	                const axisA = config.axis ? this.toVector3(config.axis) : { x: 0, y: 0, z: 1 };
	                const axisB = config.axis ? this.toVector3(config.axis) : { x: 0, y: 0, z: 1 };
	                constraint = new CANNON__namespace.HingeConstraint(nativeBodyA, nativeBodyB, {
	                    pivotA: new CANNON__namespace.Vec3(pivotA.x, pivotA.y, pivotA.z),
	                    axisA: new CANNON__namespace.Vec3(axisA.x, axisA.y, axisA.z),
	                    pivotB: new CANNON__namespace.Vec3(pivotB.x, pivotB.y, pivotB.z),
	                    axisB: new CANNON__namespace.Vec3(axisB.x, axisB.y, axisB.z)
	                });
	                // Configure motor if specified
	                if (config.motorSpeed !== undefined || config.enableMotor) {
	                    constraint.motorEnabled = config.enableMotor || false;
	                    constraint.motorTargetVelocity = config.motorSpeed || 0;
	                    constraint.motorMaxForce = config.motorForce || 1;
	                }
	                break;
	            case 'prismatic':
	                // Prismatic constraint (linear movement along axis)
	                console.warn('Prismatic constraint not fully supported in Cannon.js, using distance constraint');
	                constraint = new CANNON__namespace.DistanceConstraint(nativeBodyA, nativeBodyB, config.length || 1);
	                break;
	            case 'fixed':
	                // Lock constraint (fixed joint)
	                constraint = new CANNON__namespace.LockConstraint(nativeBodyA, nativeBodyB);
	                break;
	            case 'rope':
	                // Rope constraint (distance with no compression)
	                const ropeDistance = config.length || this.calculateDistance(bodyA, bodyB);
	                constraint = new CANNON__namespace.DistanceConstraint(nativeBodyA, nativeBodyB, ropeDistance);
	                // Note: Cannon.js distance constraint doesn't prevent compression
	                break;
	            case 'gear':
	            case 'pulley':
	            case 'mouse':
	                // These constraint types are not directly supported by Cannon.js
	                console.warn(`Constraint type '${config.type}' not supported in Cannon.js, using distance constraint`);
	                constraint = new CANNON__namespace.DistanceConstraint(nativeBodyA, nativeBodyB, config.length || 1);
	                break;
	            default:
	                // Default to distance constraint
	                constraint = new CANNON__namespace.DistanceConstraint(nativeBodyA, nativeBodyB, config.length || 1);
	                break;
	        }
	        // Store configuration for later use
	        constraint.stiffness = config.stiffness || 1;
	        constraint.damping = config.damping || 0;
	        constraint.motorSpeed = config.motorSpeed || 0;
	        constraint.motorForce = config.motorForce || 0;
	        constraint.motorEnabled = config.enableMotor || false;
	        // Apply limits if specified (only supported by HingeConstraint)
	        if (constraint instanceof CANNON__namespace.HingeConstraint) {
	            if (config.lowerLimit !== undefined) {
	                constraint.lowerLimit = config.lowerLimit;
	            }
	            if (config.upperLimit !== undefined) {
	                constraint.upperLimit = config.upperLimit;
	            }
	        }
	        return constraint;
	    }
	    /**
	     * Calculate distance between two bodies
	     */
	    calculateDistance(bodyA, bodyB) {
	        const posA = bodyA.position;
	        const posB = bodyB.position;
	        const dx = posB.x - posA.x;
	        const dy = posB.y - posA.y;
	        const dz = posB.z - posA.z;
	        return Math.sqrt(dx * dx + dy * dy + dz * dz);
	    }
	    /**
	     * Convert Point or Vector3 to Vector3
	     */
	    toVector3(input) {
	        if ('z' in input) {
	            return input;
	        }
	        else {
	            const point = input;
	            return { x: point.x, y: point.y, z: 0 };
	        }
	    }
	}

	/**
	 * Cannon.js 3D physics world implementation
	 */
	class Cannon3DWorld extends EventEmitter {
	    // Public getter for readonly access
	    get isRunning() {
	        return this._isRunning;
	    }
	    constructor(engine, config) {
	        super();
	        this.dimension = '3d';
	        this.engineType = 'cannon';
	        // Private backing field for mutable state
	        this._isRunning = false;
	        this.bodies = new Map();
	        this.constraints = new Map();
	        this.lastStepTime = 0;
	        this.paused = false;
	        this.engine = engine;
	        this.config = { ...config };
	        this.world = new CANNON__namespace.World();
	        this.initializeWorld();
	        this.setupCollisionEvents();
	    }
	    /**
	     * Get current body count
	     */
	    get bodyCount() {
	        return this.bodies.size;
	    }
	    /**
	     * Get current constraint count
	     */
	    get constraintCount() {
	        return this.constraints.size;
	    }
	    /**
	     * Get current gravity
	     */
	    get gravity() {
	        return {
	            x: this.world.gravity.x,
	            y: this.world.gravity.y,
	            z: this.world.gravity.z
	        };
	    }
	    /**
	     * Set gravity
	     */
	    set gravity(gravity) {
	        if ('z' in gravity) {
	            const g = gravity;
	            this.world.gravity.set(g.x, g.y, g.z);
	        }
	        else {
	            // Convert 2D gravity to 3D (assume Z is up)
	            const g = gravity;
	            this.world.gravity.set(g.x, -g.y, 0); // Flip Y for 3D convention
	        }
	        this.emit('gravity-changed', gravity);
	    }
	    /**
	     * Get time step
	     */
	    get timeStep() {
	        return this.config.timeStep || 1 / 60;
	    }
	    /**
	     * Set time step
	     */
	    set timeStep(timeStep) {
	        this.config.timeStep = timeStep;
	    }
	    /**
	     * Get solver iterations
	     */
	    get iterations() {
	        // Cannon.js doesn't expose individual solver iterations
	        // Use a reasonable default or stored value
	        const defaultIterations = 10;
	        return {
	            velocity: defaultIterations,
	            position: defaultIterations
	        };
	    }
	    /**
	     * Set solver iterations
	     */
	    set iterations(iterations) {
	        // Cannon.js doesn't have separate velocity/position iterations
	        // Apply the maximum of both to the solver if possible
	        Math.max(iterations.velocity, iterations.position);
	        // Note: Cannon.js solver iterations are configured during world creation
	        // We can store this for reference but cannot dynamically change it
	    }
	    /**
	     * Step the physics simulation
	     */
	    step(deltaTime) {
	        if (this.paused)
	            return;
	        const startTime = performance.now();
	        // Step the world
	        this.world.step(this.timeStep, deltaTime, this.config.maxSubSteps || 3);
	        // Update performance metrics
	        const stepTime = performance.now() - startTime;
	        this.engine.updatePerformanceMetrics(deltaTime, stepTime);
	        this.lastStepTime = stepTime;
	        this.emit('step', deltaTime);
	    }
	    /**
	     * Start the physics simulation
	     */
	    start() {
	        if (this.isRunning)
	            return;
	        const animate = () => {
	            if (!this.isRunning)
	                return;
	            this.step(1 / 60); // 60 FPS
	            this.animationFrameId = requestAnimationFrame(animate);
	        };
	        this._isRunning = true;
	        animate();
	        this.emit('started');
	    }
	    /**
	     * Stop the physics simulation
	     */
	    stop() {
	        if (!this.isRunning)
	            return;
	        if (this.animationFrameId) {
	            cancelAnimationFrame(this.animationFrameId);
	            this.animationFrameId = undefined;
	        }
	        this._isRunning = false;
	        this.emit('stopped');
	    }
	    /**
	     * Pause the physics simulation
	     */
	    pause() {
	        this.paused = true;
	        this.emit('paused');
	    }
	    /**
	     * Resume the physics simulation
	     */
	    resume() {
	        this.paused = false;
	        this.emit('resumed');
	    }
	    /**
	     * Clear all bodies and constraints
	     */
	    clear() {
	        // Remove all bodies
	        for (const [id, body] of this.bodies) {
	            this.removeBody(body);
	        }
	        // Remove all constraints
	        for (const [id, constraint] of this.constraints) {
	            this.removeConstraint(constraint);
	        }
	        this.emit('cleared');
	    }
	    /**
	     * Create a physics body
	     */
	    createBody(config) {
	        const body = new Cannon3DBody(this.engine, config);
	        this.addBody(body);
	        return body;
	    }
	    /**
	     * Add a body to the world
	     */
	    addBody(body) {
	        if (!(body instanceof Cannon3DBody)) {
	            throw new Error('Body must be a Cannon3DBody');
	        }
	        this.bodies.set(body.id, body);
	        this.world.addBody(body.getNativeBody());
	        // Setup collision events for this body
	        this.setupBodyCollisionEvents(body);
	        this.emit('body-added', body);
	    }
	    /**
	     * Remove a body from the world
	     */
	    removeBody(body) {
	        const bodyId = typeof body === 'string' ? body : body.id;
	        const bodyInstance = this.bodies.get(bodyId);
	        if (bodyInstance) {
	            this.world.removeBody(bodyInstance.getNativeBody());
	            this.bodies.delete(bodyId);
	            // Return to pool if possible
	            this.engine.returnBodyToPool(bodyInstance.getNativeBody());
	            this.emit('body-removed', bodyInstance);
	        }
	    }
	    /**
	     * Get a body by ID
	     */
	    getBody(id) {
	        return this.bodies.get(id) || null;
	    }
	    /**
	     * Get all bodies
	     */
	    getAllBodies() {
	        return Array.from(this.bodies.values());
	    }
	    /**
	     * Get active bodies (not sleeping)
	     */
	    getActiveBodies() {
	        return Array.from(this.bodies.values()).filter(body => !body.isSleeping);
	    }
	    /**
	     * Get sleeping bodies
	     */
	    getSleepingBodies() {
	        return Array.from(this.bodies.values()).filter(body => body.isSleeping);
	    }
	    /**
	     * Create a constraint
	     */
	    createConstraint(config) {
	        const bodyA = this.getBody(config.bodyA);
	        const bodyB = this.getBody(config.bodyB);
	        if (!bodyA || !bodyB) {
	            throw new Error('Both bodies must exist in the world');
	        }
	        const constraint = new Cannon3DConstraint(config, bodyA, bodyB);
	        this.addConstraint(constraint);
	        return constraint;
	    }
	    /**
	     * Add a constraint to the world
	     */
	    addConstraint(constraint) {
	        if (!(constraint instanceof Cannon3DConstraint)) {
	            throw new Error('Constraint must be a Cannon3DConstraint');
	        }
	        this.constraints.set(constraint.id, constraint);
	        this.world.addConstraint(constraint.getNativeConstraint());
	        this.emit('constraint-added', constraint);
	    }
	    /**
	     * Remove a constraint from the world
	     */
	    removeConstraint(constraint) {
	        const constraintId = typeof constraint === 'string' ? constraint : constraint.id;
	        const constraintInstance = this.constraints.get(constraintId);
	        if (constraintInstance) {
	            this.world.removeConstraint(constraintInstance.getNativeConstraint());
	            this.constraints.delete(constraintId);
	            this.emit('constraint-removed', constraintInstance);
	        }
	    }
	    /**
	     * Get a constraint by ID
	     */
	    getConstraint(id) {
	        return this.constraints.get(id) || null;
	    }
	    /**
	     * Get all constraints
	     */
	    getAllConstraints() {
	        return Array.from(this.constraints.values());
	    }
	    /**
	     * Perform a raycast
	     */
	    raycast(options) {
	        const from = options.from;
	        const to = options.to;
	        const fromVec = new CANNON__namespace.Vec3(from.x, from.y, from.z);
	        const toVec = new CANNON__namespace.Vec3(to.x, to.y, to.z);
	        const result = new CANNON__namespace.RaycastResult();
	        this.world.raycastClosest(fromVec, toVec, {}, result);
	        const results = [];
	        if (result.hasHit) {
	            const physicsBody = this.findPhysicsBody(result.body);
	            if (physicsBody) {
	                results.push({
	                    hit: true,
	                    body: physicsBody,
	                    point: {
	                        x: result.hitPointWorld.x,
	                        y: result.hitPointWorld.y,
	                        z: result.hitPointWorld.z
	                    },
	                    normal: {
	                        x: result.hitNormalWorld.x,
	                        y: result.hitNormalWorld.y,
	                        z: result.hitNormalWorld.z
	                    },
	                    distance: result.distance,
	                    fraction: result.distance / fromVec.distanceTo(toVec)
	                });
	            }
	        }
	        return results;
	    }
	    /**
	     * Query bodies in AABB
	     */
	    queryAABB(min, max) {
	        const minVec = min;
	        const maxVec = max;
	        const results = [];
	        for (const [id, body] of this.bodies) {
	            const bounds = body.bounds;
	            const bodyMin = bounds.min;
	            const bodyMax = bounds.max;
	            // Check AABB overlap
	            if (bodyMin.x <= maxVec.x && bodyMax.x >= minVec.x &&
	                bodyMin.y <= maxVec.y && bodyMax.y >= minVec.y &&
	                bodyMin.z <= maxVec.z && bodyMax.z >= minVec.z) {
	                results.push(body);
	            }
	        }
	        return results;
	    }
	    /**
	     * Query bodies at point
	     */
	    queryPoint(point) {
	        const p = point;
	        const results = [];
	        for (const [id, body] of this.bodies) {
	            const bounds = body.bounds;
	            const bodyMin = bounds.min;
	            const bodyMax = bounds.max;
	            // Simple bounds check
	            if (p.x >= bodyMin.x && p.x <= bodyMax.x &&
	                p.y >= bodyMin.y && p.y <= bodyMax.y &&
	                p.z >= bodyMin.z && p.z <= bodyMax.z) {
	                results.push(body);
	            }
	        }
	        return results;
	    }
	    /**
	     * Check collision between two bodies
	     */
	    checkCollision(bodyA, bodyB) {
	        if (!(bodyA instanceof Cannon3DBody) || !(bodyB instanceof Cannon3DBody)) {
	            return false;
	        }
	        const nativeA = bodyA.getNativeBody();
	        const nativeB = bodyB.getNativeBody();
	        // Check if bodies are in contact
	        for (const contact of this.world.contacts) {
	            if ((contact.bi === nativeA && contact.bj === nativeB) ||
	                (contact.bi === nativeB && contact.bj === nativeA)) {
	                return true;
	            }
	        }
	        return false;
	    }
	    /**
	     * Get performance metrics
	     */
	    getPerformanceMetrics() {
	        return {
	            averageStepTime: this.lastStepTime,
	            bodyCount: this.bodies.size,
	            constraintCount: this.constraints.size,
	            contactCount: this.world.contacts.length,
	            broadphaseTime: 0, // Not available in Cannon.js
	            narrowphaseTime: 0, // Not available in Cannon.js
	            solverTime: 0, // Not available in Cannon.js
	            memoryUsage: this.bodies.size * 512 + this.constraints.size * 256, // Rough estimate
	            sleepingBodies: this.getSleepingBodies().length,
	            activeBodies: this.getActiveBodies().length,
	            culledBodies: 0
	        };
	    }
	    /**
	     * Enable debug drawing
	     */
	    enableDebugDraw(enabled) {
	        // Debug drawing would be implemented here
	        this.emit('debug-draw-changed', enabled);
	    }
	    /**
	     * Set gravity
	     */
	    setGravity(gravity) {
	        this.gravity = gravity;
	    }
	    /**
	     * Set time step
	     */
	    setTimeStep(timeStep) {
	        this.timeStep = timeStep;
	    }
	    /**
	     * Optimize for mobile devices
	     */
	    optimizeForMobile() {
	        // Configure solver for mobile (if supported)
	        // Note: Cannon.js solver configuration is limited
	        // Use simpler broadphase for better performance
	        this.world.broadphase = new CANNON__namespace.SAPBroadphase(this.world);
	        // Enable sleeping for better performance
	        this.world.allowSleep = true;
	        // Note: sleepSpeedLimit and sleepTimeLimit are configured per-body in Cannon.js
	        // Set default sleep thresholds for bodies created in this world
	        this.emit('mobile-optimized');
	    }
	    /**
	     * Destroy the world
	     */
	    destroy() {
	        this.stop();
	        this.clear();
	        this.bodies.clear();
	        this.constraints.clear();
	        this.emit('destroyed');
	    }
	    /**
	     * Get the native Cannon.js world
	     */
	    getNativeWorld() {
	        return this.world;
	    }
	    /**
	     * Initialize world properties
	     */
	    initializeWorld() {
	        // Set gravity
	        if (this.config.gravity) {
	            this.setGravity(this.config.gravity);
	        }
	        else {
	            // Default 3D gravity (Y is up)
	            this.world.gravity.set(0, -9.82, 0);
	        }
	        // Configure solver
	        // Note: Cannon.js has limited solver configuration options
	        // Solver iterations are set during solver creation, not dynamically
	        // Configure broadphase
	        switch (this.config.broadphaseType) {
	            case 'sap':
	                this.world.broadphase = new CANNON__namespace.SAPBroadphase(this.world);
	                break;
	            case 'grid':
	                this.world.broadphase = new CANNON__namespace.GridBroadphase();
	                break;
	            default:
	                this.world.broadphase = new CANNON__namespace.NaiveBroadphase();
	                break;
	        }
	        // Configure sleeping
	        if (this.config.allowSleep !== undefined) {
	            this.world.allowSleep = this.config.allowSleep;
	        }
	        // Configure bounds if specified
	        if (this.config.bounds) {
	            // Cannon.js doesn't have built-in world bounds, but we could add collision planes
	            console.warn('World bounds not implemented for Cannon3DWorld');
	        }
	        // Enable CCD if requested
	        if (this.config.enableCCD) {
	            // Cannon.js doesn't have built-in CCD, but we could implement it
	            console.warn('CCD not implemented for Cannon3DWorld');
	        }
	        // Optimize for mobile by default
	        this.optimizeForMobile();
	    }
	    /**
	     * Setup collision event handlers
	     */
	    setupCollisionEvents() {
	        // Collision begin
	        this.world.addEventListener('beginContact', (event) => {
	            const contact = event.contact;
	            const bodyA = this.findPhysicsBody(contact.bi);
	            const bodyB = this.findPhysicsBody(contact.bj);
	            if (bodyA && bodyB) {
	                const collisionEvent = {
	                    type: 'collision-start',
	                    bodyA,
	                    bodyB,
	                    contactPoint: {
	                        x: contact.ri.x + contact.bi.position.x,
	                        y: contact.ri.y + contact.bi.position.y,
	                        z: contact.ri.z + contact.bi.position.z
	                    },
	                    contactNormal: {
	                        x: contact.ni.x,
	                        y: contact.ni.y,
	                        z: contact.ni.z
	                    },
	                    timestamp: Date.now()
	                };
	                this.emit('collision-start', collisionEvent);
	                bodyA.emit('collision-start', collisionEvent);
	                bodyB.emit('collision-start', collisionEvent);
	            }
	        });
	        // Collision end
	        this.world.addEventListener('endContact', (event) => {
	            const contact = event.contact;
	            const bodyA = this.findPhysicsBody(contact.bi);
	            const bodyB = this.findPhysicsBody(contact.bj);
	            if (bodyA && bodyB) {
	                const collisionEvent = {
	                    type: 'collision-end',
	                    bodyA,
	                    bodyB,
	                    timestamp: Date.now()
	                };
	                this.emit('collision-end', collisionEvent);
	                bodyA.emit('collision-end', collisionEvent);
	                bodyB.emit('collision-end', collisionEvent);
	            }
	        });
	    }
	    /**
	     * Setup collision events for a specific body
	     */
	    setupBodyCollisionEvents(body) {
	        // Additional body-specific collision setup could be added here
	    }
	    /**
	     * Find the PhysicsBody wrapper for a native Cannon body
	     */
	    findPhysicsBody(nativeBody) {
	        for (const [id, body] of this.bodies) {
	            if (body.getNativeBody() === nativeBody) {
	                return body;
	            }
	        }
	        return null;
	    }
	}

	/**
	 * Cannon.js 3D physics engine wrapper optimized for mobile games
	 */
	class Cannon3DEngine extends EventEmitter {
	    // Public getter for readonly access
	    get isInitialized() {
	        return this._isInitialized;
	    }
	    constructor() {
	        super();
	        this.engineType = 'cannon';
	        this.dimension = '3d';
	        // Private backing field for mutable state
	        this._isInitialized = false;
	        this.worlds = new Set();
	        this.bodyPool = [];
	        this.constraintPool = [];
	        this.objectPoolingEnabled = true;
	        this.maxBodies = 1000;
	        this.defaultMaterial = {
	            id: 'default',
	            name: 'Default Material',
	            friction: 0.3,
	            restitution: 0.0,
	            density: 1.0,
	            frictionAir: 0.01,
	            frictionStatic: 0.3,
	            damping: 0.1,
	            angularDamping: 0.1
	        };
	        this.materials = new Map();
	        this.performanceMetrics = {
	            averageStepTime: 0,
	            bodyCount: 0,
	            constraintCount: 0,
	            contactCount: 0,
	            broadphaseTime: 0,
	            narrowphaseTime: 0,
	            solverTime: 0,
	            memoryUsage: 0,
	            sleepingBodies: 0,
	            activeBodies: 0,
	            culledBodies: 0
	        };
	        // Initialize materials map with default material
	        this.materials.set(this.defaultMaterial.id, this.defaultMaterial);
	    }
	    /**
	     * Initialize the Cannon.js engine
	     */
	    async initialize(config) {
	        try {
	            // Cannon.js doesn't require explicit initialization like Matter.js
	            // But we can set up global configurations here
	            // Configure for mobile optimization
	            this.optimizeForMobile();
	            this._isInitialized = true;
	            this.emit('initialized');
	        }
	        catch (error) {
	            this.emit('error', error);
	            throw error;
	        }
	    }
	    /**
	     * Destroy the engine and clean up resources
	     */
	    destroy() {
	        // Destroy all worlds
	        for (const world of this.worlds) {
	            world.destroy();
	        }
	        this.worlds.clear();
	        // Clear pools
	        this.bodyPool.length = 0;
	        this.constraintPool.length = 0;
	        this._isInitialized = false;
	        this.emit('destroyed');
	    }
	    /**
	     * Create a new 3D physics world
	     */
	    createWorld(config) {
	        const world = new Cannon3DWorld(this, config);
	        this.worlds.add(world);
	        this.emit('world-created', world);
	        return world;
	    }
	    /**
	     * Destroy a physics world
	     */
	    destroyWorld(world) {
	        if (world instanceof Cannon3DWorld) {
	            this.worlds.delete(world);
	            world.destroy();
	            this.emit('world-destroyed', world);
	        }
	    }
	    /**
	     * Create a physics material
	     */
	    createMaterial(config) {
	        const material = {
	            id: config.id || `material_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
	            name: config.name || 'Unnamed Material',
	            friction: config.friction ?? 0.3,
	            restitution: config.restitution ?? 0.0,
	            density: config.density ?? 1.0,
	            frictionAir: config.frictionAir ?? 0.01,
	            frictionStatic: config.frictionStatic ?? 0.3,
	            damping: config.damping ?? 0.1,
	            angularDamping: config.angularDamping ?? 0.1
	        };
	        this.materials.set(material.id, material);
	        return material;
	    }
	    /**
	     * Get the default physics material
	     */
	    getDefaultMaterial() {
	        return this.defaultMaterial;
	    }
	    /**
	     * Get a material by ID
	     */
	    getMaterial(id) {
	        return this.materials.get(id) || null;
	    }
	    /**
	     * Optimize engine for different device tiers
	     */
	    optimizeForDevice(deviceTier) {
	        switch (deviceTier) {
	            case 'low':
	                // Reduce quality for low-end devices
	                this.maxBodies = 300;
	                break;
	            case 'medium':
	                // Balanced settings
	                this.maxBodies = 500;
	                break;
	            case 'high':
	                // High quality for powerful devices
	                this.maxBodies = 1000;
	                break;
	        }
	        this.emit('device-optimized', deviceTier);
	    }
	    /**
	     * Enable or disable object pooling
	     */
	    enableObjectPooling(enabled) {
	        this.objectPoolingEnabled = enabled;
	        if (!enabled) {
	            this.bodyPool.length = 0;
	            this.constraintPool.length = 0;
	        }
	        this.emit('object-pooling-changed', enabled);
	    }
	    /**
	     * Set maximum number of bodies
	     */
	    setMaxBodies(maxBodies) {
	        this.maxBodies = maxBodies;
	        // Trim pool if necessary
	        if (this.bodyPool.length > maxBodies) {
	            this.bodyPool.length = maxBodies;
	        }
	    }
	    /**
	     * Get a body from the pool or create a new one
	     */
	    getPooledBody() {
	        if (this.objectPoolingEnabled && this.bodyPool.length > 0) {
	            return this.bodyPool.pop();
	        }
	        return null;
	    }
	    /**
	     * Return a body to the pool
	     */
	    returnBodyToPool(body) {
	        if (this.objectPoolingEnabled && this.bodyPool.length < this.maxBodies) {
	            // Reset body properties
	            body.position.set(0, 0, 0);
	            body.velocity.set(0, 0, 0);
	            body.angularVelocity.set(0, 0, 0);
	            body.quaternion.set(0, 0, 0, 1);
	            body.force.set(0, 0, 0);
	            body.torque.set(0, 0, 0);
	            this.bodyPool.push(body);
	        }
	    }
	    /**
	     * Get performance metrics
	     */
	    getPerformanceMetrics() {
	        // Update metrics from all worlds
	        let totalBodies = 0;
	        let totalConstraints = 0;
	        let totalActiveBodies = 0;
	        let totalSleepingBodies = 0;
	        for (const world of this.worlds) {
	            const metrics = world.getPerformanceMetrics();
	            totalBodies += metrics.bodyCount;
	            totalConstraints += metrics.constraintCount;
	            totalActiveBodies += metrics.activeBodies;
	            totalSleepingBodies += metrics.sleepingBodies;
	        }
	        this.performanceMetrics.bodyCount = totalBodies;
	        this.performanceMetrics.constraintCount = totalConstraints;
	        this.performanceMetrics.activeBodies = totalActiveBodies;
	        this.performanceMetrics.sleepingBodies = totalSleepingBodies;
	        return this.performanceMetrics;
	    }
	    /**
	     * Update performance metrics
	     */
	    updatePerformanceMetrics(deltaTime, stepTime) {
	        this.performanceMetrics.averageStepTime = (this.performanceMetrics.averageStepTime * 0.9) + (stepTime * 0.1);
	        // Estimate memory usage (rough calculation)
	        const bodyMemory = this.performanceMetrics.bodyCount * 512; // ~512 bytes per 3D body
	        const constraintMemory = this.performanceMetrics.constraintCount * 256; // ~256 bytes per constraint
	        this.performanceMetrics.memoryUsage = bodyMemory + constraintMemory;
	    }
	    /**
	     * Create a Cannon.js material from physics material
	     */
	    createCannonMaterial(physicsMaterial) {
	        const material = new CANNON__namespace.Material(physicsMaterial.id);
	        material.friction = physicsMaterial.friction;
	        material.restitution = physicsMaterial.restitution;
	        return material;
	    }
	    /**
	     * Optimize engine for mobile devices
	     */
	    optimizeForMobile() {
	        // Mobile optimization settings
	        // These would be applied to individual worlds when created
	        this.emit('mobile-optimized');
	    }
	}

	/**
	 * Platformer-specific physics helper with ground detection, jumping, and wall sliding
	 */
	class GameBytePlatformerHelper extends EventEmitter {
	    // Public getters for readonly access
	    get isGrounded() {
	        return this._isGrounded;
	    }
	    get isOnWall() {
	        return this._isOnWall;
	    }
	    get canWallJump() {
	        return this._canWallJump;
	    }
	    constructor(character, world) {
	        super();
	        this.canJump = true;
	        // Private backing fields for mutable state properties
	        this._isGrounded = false;
	        this._isOnWall = false;
	        this._canWallJump = false;
	        this.horizontalInput = 0;
	        this.groundRayLength = 0.1;
	        this.groundRayOffset = 0;
	        this.groundMask = 0xFFFFFFFF;
	        this.wallRayLength = 0.1;
	        this.wallRayOffset = 0;
	        this.wallMask = 0xFFFFFFFF;
	        // Movement settings
	        this.maxSpeed = 5;
	        this.acceleration = 20;
	        this.deceleration = 15;
	        this.airAcceleration = 10;
	        this.jumpForce = 8;
	        this.wallJumpForce = 6;
	        this.coyoteTime = 0.1;
	        this.jumpBufferTime = 0.1;
	        // State tracking
	        this.groundNormal = { x: 0, y: 1 };
	        this.wallNormal = { x: 1, y: 0 };
	        this.lastGroundedTime = 0;
	        this.jumpBufferTimer = 0;
	        this.wallSlideSpeed = 2;
	        // Features
	        this.doubleJumpEnabled = false;
	        this.wallSlidingEnabled = true;
	        this.coyoteTimeEnabled = true;
	        this.jumpBufferingEnabled = true;
	        this.hasDoubleJumped = false;
	        this.character = character;
	        this.world = world;
	        // Set up default ground detection
	        this.setGroundDetection({
	            rayLength: 0.1,
	            rayOffset: 0,
	            groundMask: 0xFFFFFFFF
	        });
	        // Set up default wall detection
	        this.setWallDetection({
	            rayLength: 0.1,
	            rayOffset: 0,
	            wallMask: 0xFFFFFFFF
	        });
	    }
	    /**
	     * Set horizontal input (-1 to 1)
	     */
	    setHorizontalInput(input) {
	        this.horizontalInput = Math.max(-1, Math.min(1, input));
	        this.emit('horizontal-input-changed', this.horizontalInput);
	    }
	    /**
	     * Attempt to jump
	     */
	    jump(force) {
	        const jumpForce = force || this.jumpForce;
	        // Check if can jump
	        if (this.canJump && (this.isGrounded || this.isWithinCoyoteTime())) {
	            this.performJump(jumpForce);
	            this.hasDoubleJumped = false;
	            return true;
	        }
	        // Double jump
	        if (this.doubleJumpEnabled && !this.hasDoubleJumped && !this.isGrounded) {
	            this.performJump(jumpForce * 0.8); // Slightly weaker double jump
	            this.hasDoubleJumped = true;
	            return true;
	        }
	        // Jump buffering
	        if (this.jumpBufferingEnabled && !this.isGrounded) {
	            this.jumpBufferTimer = this.jumpBufferTime;
	        }
	        return false;
	    }
	    /**
	     * Attempt to wall jump
	     */
	    wallJump(direction, force) {
	        if (!this.canWallJump || !this.isOnWall) {
	            return false;
	        }
	        const jumpForce = force || this.wallJumpForce;
	        const wallJumpDirection = Math.sign(direction);
	        // Apply wall jump force
	        const horizontalForce = wallJumpDirection * jumpForce * 0.8;
	        const verticalForce = jumpForce;
	        if (this.world.dimension === '2d') {
	            this.character.velocity = {
	                x: horizontalForce,
	                y: verticalForce
	            };
	        }
	        else {
	            this.character.velocity = {
	                x: horizontalForce,
	                y: verticalForce,
	                z: 0
	            };
	        }
	        this.emit('wall-jump', { direction: wallJumpDirection, force: jumpForce });
	        return true;
	    }
	    /**
	     * Perform a dash move
	     */
	    dash(direction, force) {
	        const normalizedDir = this.normalizeVector(direction);
	        if (this.world.dimension === '2d') {
	            this.character.applyImpulse({
	                x: normalizedDir.x * force,
	                y: normalizedDir.y * force
	            });
	        }
	        else {
	            this.character.applyImpulse({
	                x: normalizedDir.x * force,
	                y: normalizedDir.y * force,
	                z: 0
	            });
	        }
	        this.emit('dash', { direction: normalizedDir, force });
	    }
	    /**
	     * Configure ground detection
	     */
	    setGroundDetection(config) {
	        this.groundRayLength = config.rayLength;
	        this.groundRayOffset = config.rayOffset;
	        this.groundMask = config.groundMask;
	        this.emit('ground-detection-changed', config);
	    }
	    /**
	     * Configure wall detection
	     */
	    setWallDetection(config) {
	        this.wallRayLength = config.rayLength;
	        this.wallRayOffset = config.rayOffset;
	        this.wallMask = config.wallMask;
	        this.emit('wall-detection-changed', config);
	    }
	    /**
	     * Configure movement settings
	     */
	    setMovementSettings(config) {
	        this.maxSpeed = config.maxSpeed;
	        this.acceleration = config.acceleration;
	        this.deceleration = config.deceleration;
	        this.airAcceleration = config.airAcceleration;
	        this.jumpForce = config.jumpForce;
	        this.wallJumpForce = config.wallJumpForce;
	        this.coyoteTime = config.coyoteTime;
	        this.jumpBufferTime = config.jumpBufferTime;
	        this.emit('movement-settings-changed', config);
	    }
	    /**
	     * Get ground normal vector
	     */
	    getGroundNormal() {
	        return { ...this.groundNormal };
	    }
	    /**
	     * Get wall normal vector
	     */
	    getWallNormal() {
	        return { ...this.wallNormal };
	    }
	    /**
	     * Get current movement state
	     */
	    getMovementState() {
	        const velocity = this.character.velocity;
	        const horizontalSpeed = Math.abs(velocity.x);
	        const verticalSpeed = velocity.y;
	        if (this.isOnWall && this.wallSlidingEnabled && verticalSpeed < 0) {
	            return 'wall-sliding';
	        }
	        if (!this.isGrounded) {
	            return verticalSpeed > 0 ? 'jumping' : 'falling';
	        }
	        if (horizontalSpeed < 0.1) {
	            return 'idle';
	        }
	        return horizontalSpeed > this.maxSpeed * 0.8 ? 'running' : 'walking';
	    }
	    /**
	     * Update platformer physics (call every frame)
	     */
	    update(deltaTime) {
	        // Update state
	        this.updateGroundedState();
	        this.updateWallState();
	        // Handle movement
	        this.handleMovement(deltaTime);
	        // Handle wall sliding
	        if (this.wallSlidingEnabled && this.isOnWall && !this.isGrounded) {
	            this.handleWallSliding();
	        }
	        // Update timers
	        if (!this.isGrounded) {
	            this.lastGroundedTime += deltaTime;
	        }
	        else {
	            this.lastGroundedTime = 0;
	            this.hasDoubleJumped = false;
	            // Check jump buffer
	            if (this.jumpBufferTimer > 0 && this.jumpBufferingEnabled) {
	                this.jump();
	                this.jumpBufferTimer = 0;
	            }
	        }
	        if (this.jumpBufferTimer > 0) {
	            this.jumpBufferTimer -= deltaTime;
	        }
	        this.emit('update', deltaTime);
	    }
	    /**
	     * Check if character is grounded
	     */
	    checkGrounded() {
	        return this.performGroundRaycast();
	    }
	    /**
	     * Check if character is touching a wall
	     */
	    checkWallContact() {
	        return this.performWallRaycast();
	    }
	    /**
	     * Enable/disable double jump
	     */
	    enableDoubleJump(enabled) {
	        this.doubleJumpEnabled = enabled;
	        this.emit('double-jump-changed', enabled);
	    }
	    /**
	     * Enable/disable wall sliding
	     */
	    enableWallSliding(enabled) {
	        this.wallSlidingEnabled = enabled;
	        this.emit('wall-sliding-changed', enabled);
	    }
	    /**
	     * Enable/disable coyote time
	     */
	    enableCoyoteTime(enabled) {
	        this.coyoteTimeEnabled = enabled;
	        this.emit('coyote-time-changed', enabled);
	    }
	    /**
	     * Enable/disable jump buffering
	     */
	    enableJumpBuffering(enabled) {
	        this.jumpBufferingEnabled = enabled;
	        this.emit('jump-buffering-changed', enabled);
	    }
	    /**
	     * Update grounded state using raycast
	     */
	    updateGroundedState() {
	        const wasGrounded = this.isGrounded;
	        this._isGrounded = this.performGroundRaycast();
	        if (wasGrounded !== this.isGrounded) {
	            this.emit('grounded-changed', this.isGrounded);
	            if (this.isGrounded) {
	                this.emit('landed');
	            }
	            else {
	                this.emit('left-ground');
	            }
	        }
	    }
	    /**
	     * Update wall contact state using raycast
	     */
	    updateWallState() {
	        const wasOnWall = this.isOnWall;
	        this._isOnWall = this.performWallRaycast();
	        this._canWallJump = this.isOnWall && !this.isGrounded;
	        if (wasOnWall !== this.isOnWall) {
	            this.emit('wall-contact-changed', this.isOnWall);
	        }
	    }
	    /**
	     * Handle horizontal movement
	     */
	    handleMovement(deltaTime) {
	        if (Math.abs(this.horizontalInput) < 0.01) {
	            // Decelerate when no input
	            this.applyDeceleration(deltaTime);
	        }
	        else {
	            // Accelerate towards target speed
	            this.applyAcceleration(deltaTime);
	        }
	    }
	    /**
	     * Apply acceleration based on input
	     */
	    applyAcceleration(deltaTime) {
	        const targetSpeed = this.horizontalInput * this.maxSpeed;
	        const currentSpeed = this.character.velocity.x;
	        const acceleration = this.isGrounded ? this.acceleration : this.airAcceleration;
	        const speedDiff = targetSpeed - currentSpeed;
	        const accelerationAmount = Math.sign(speedDiff) * acceleration * deltaTime;
	        let newSpeed = currentSpeed + accelerationAmount;
	        // Clamp to target speed
	        if (Math.sign(speedDiff) !== Math.sign(targetSpeed - newSpeed)) {
	            newSpeed = targetSpeed;
	        }
	        // Update velocity
	        if (this.world.dimension === '2d') {
	            this.character.velocity = {
	                x: newSpeed,
	                y: this.character.velocity.y
	            };
	        }
	        else {
	            this.character.velocity = {
	                x: newSpeed,
	                y: this.character.velocity.y,
	                z: this.character.velocity.z
	            };
	        }
	    }
	    /**
	     * Apply deceleration when no input
	     */
	    applyDeceleration(deltaTime) {
	        const currentSpeed = this.character.velocity.x;
	        const deceleration = this.isGrounded ? this.deceleration : this.deceleration * 0.5;
	        const decelerationAmount = Math.sign(currentSpeed) * deceleration * deltaTime;
	        let newSpeed = currentSpeed - decelerationAmount;
	        // Stop if we would overshoot
	        if (Math.sign(currentSpeed) !== Math.sign(newSpeed)) {
	            newSpeed = 0;
	        }
	        // Update velocity
	        if (this.world.dimension === '2d') {
	            this.character.velocity = {
	                x: newSpeed,
	                y: this.character.velocity.y
	            };
	        }
	        else {
	            this.character.velocity = {
	                x: newSpeed,
	                y: this.character.velocity.y,
	                z: this.character.velocity.z
	            };
	        }
	    }
	    /**
	     * Handle wall sliding physics
	     */
	    handleWallSliding() {
	        const velocity = this.character.velocity;
	        if (velocity.y < -this.wallSlideSpeed) {
	            // Limit falling speed when wall sliding
	            if (this.world.dimension === '2d') {
	                this.character.velocity = {
	                    x: velocity.x,
	                    y: -this.wallSlideSpeed
	                };
	            }
	            else {
	                this.character.velocity = {
	                    x: velocity.x,
	                    y: -this.wallSlideSpeed,
	                    z: velocity.z
	                };
	            }
	        }
	    }
	    /**
	     * Perform the actual jump
	     */
	    performJump(force) {
	        if (this.world.dimension === '2d') {
	            this.character.velocity = {
	                x: this.character.velocity.x,
	                y: force
	            };
	        }
	        else {
	            this.character.velocity = {
	                x: this.character.velocity.x,
	                y: force,
	                z: this.character.velocity.z
	            };
	        }
	        this.emit('jump', { force });
	    }
	    /**
	     * Check if within coyote time
	     */
	    isWithinCoyoteTime() {
	        return this.coyoteTimeEnabled && this.lastGroundedTime <= this.coyoteTime;
	    }
	    /**
	     * Perform ground detection raycast
	     */
	    performGroundRaycast() {
	        const position = this.character.position;
	        const bounds = this.character.bounds;
	        const rayStart = this.world.dimension === '2d'
	            ? { x: position.x + this.groundRayOffset, y: bounds.min.y }
	            : { x: position.x + this.groundRayOffset, y: bounds.min.y, z: position.z };
	        const rayEnd = this.world.dimension === '2d'
	            ? { x: rayStart.x, y: rayStart.y - this.groundRayLength }
	            : { x: rayStart.x, y: rayStart.y - this.groundRayLength, z: rayStart.z };
	        const raycastOptions = {
	            from: rayStart,
	            to: rayEnd,
	            collisionMask: this.groundMask
	        };
	        const results = this.world.raycast(raycastOptions);
	        if (results.length > 0 && results[0].normal) {
	            this.groundNormal = results[0].normal;
	            return true;
	        }
	        return false;
	    }
	    /**
	     * Perform wall detection raycast
	     */
	    performWallRaycast() {
	        const position = this.character.position;
	        const bounds = this.character.bounds;
	        // Check both sides
	        const leftRayStart = this.world.dimension === '2d'
	            ? { x: bounds.min.x, y: position.y + this.wallRayOffset }
	            : { x: bounds.min.x, y: position.y + this.wallRayOffset, z: position.z };
	        const leftRayEnd = this.world.dimension === '2d'
	            ? { x: leftRayStart.x - this.wallRayLength, y: leftRayStart.y }
	            : { x: leftRayStart.x - this.wallRayLength, y: leftRayStart.y, z: leftRayStart.z };
	        const rightRayStart = this.world.dimension === '2d'
	            ? { x: bounds.max.x, y: position.y + this.wallRayOffset }
	            : { x: bounds.max.x, y: position.y + this.wallRayOffset, z: position.z };
	        const rightRayEnd = this.world.dimension === '2d'
	            ? { x: rightRayStart.x + this.wallRayLength, y: rightRayStart.y }
	            : { x: rightRayStart.x + this.wallRayLength, y: rightRayStart.y, z: rightRayStart.z };
	        // Check left wall
	        const leftResults = this.world.raycast({
	            from: leftRayStart,
	            to: leftRayEnd,
	            collisionMask: this.wallMask
	        });
	        // Check right wall
	        const rightResults = this.world.raycast({
	            from: rightRayStart,
	            to: rightRayEnd,
	            collisionMask: this.wallMask
	        });
	        if (leftResults.length > 0 && leftResults[0].normal) {
	            this.wallNormal = leftResults[0].normal;
	            return true;
	        }
	        if (rightResults.length > 0 && rightResults[0].normal) {
	            this.wallNormal = rightResults[0].normal;
	            return true;
	        }
	        return false;
	    }
	    /**
	     * Normalize a 2D vector
	     */
	    normalizeVector(vector) {
	        const length = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
	        if (length === 0) {
	            return { x: 0, y: 0 };
	        }
	        return {
	            x: vector.x / length,
	            y: vector.y / length
	        };
	    }
	}

	/**
	 * Top-down game physics helper for movement, collision, and triggers
	 */
	class GameByteTopDownHelper extends EventEmitter {
	    // Public getters for readonly access
	    get isMoving() {
	        return this._isMoving;
	    }
	    get currentSpeed() {
	        return this._currentSpeed;
	    }
	    constructor(character, world) {
	        super();
	        // Private backing fields for mutable state properties
	        this._isMoving = false;
	        this._currentSpeed = 0;
	        this.movementInput = { x: 0, y: 0 };
	        // Movement settings
	        this.maxSpeed = 5;
	        this.acceleration = 15;
	        this.deceleration = 10;
	        this.rotationSpeed = 5;
	        this.dragCoefficient = 0.98;
	        // Features
	        this.rotationEnabled = false;
	        this.momentumEnabled = true;
	        this.targetRotation = 0;
	        // State tracking
	        this.velocity = { x: 0, y: 0 };
	        this.lastMovementDirection = { x: 0, y: 1 };
	        this.character = character;
	        this.world = world;
	    }
	    /**
	     * Set movement input (normalized -1 to 1 for each axis)
	     */
	    setMovementInput(input) {
	        this.movementInput = {
	            x: Math.max(-1, Math.min(1, input.x)),
	            y: Math.max(-1, Math.min(1, input.y))
	        };
	        // Update target rotation if rotation is enabled
	        if (this.rotationEnabled && (Math.abs(input.x) > 0.1 || Math.abs(input.y) > 0.1)) {
	            this.targetRotation = Math.atan2(input.x, input.y);
	            this.lastMovementDirection = this.normalizeVector(input);
	        }
	        this.emit('movement-input-changed', this.movementInput);
	    }
	    /**
	     * Perform a dash move
	     */
	    dash(direction, force) {
	        const normalizedDir = this.normalizeVector(direction);
	        if (this.world.dimension === '2d') {
	            this.character.applyImpulse({
	                x: normalizedDir.x * force,
	                y: normalizedDir.y * force
	            });
	        }
	        else {
	            this.character.applyImpulse({
	                x: normalizedDir.x * force,
	                y: 0,
	                z: normalizedDir.y * force // Y becomes Z in 3D top-down
	            });
	        }
	        this.emit('dash', { direction: normalizedDir, force });
	    }
	    /**
	     * Apply braking force
	     */
	    brake(force) {
	        const brakeForce = force || this.deceleration * 2;
	        const velocity = this.character.velocity;
	        if (this.world.dimension === '2d') {
	            const vel = velocity;
	            const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
	            if (speed > 0.1) {
	                const brakeDirection = {
	                    x: -vel.x / speed,
	                    y: -vel.y / speed
	                };
	                this.character.applyForce({
	                    x: brakeDirection.x * brakeForce,
	                    y: brakeDirection.y * brakeForce
	                });
	            }
	        }
	        else {
	            const vel = velocity;
	            const speed = Math.sqrt(vel.x * vel.x + vel.z * vel.z);
	            if (speed > 0.1) {
	                const brakeDirection = {
	                    x: -vel.x / speed,
	                    y: 0,
	                    z: -vel.z / speed
	                };
	                this.character.applyForce(brakeDirection);
	            }
	        }
	        this.emit('brake', { force: brakeForce });
	    }
	    /**
	     * Configure movement settings
	     */
	    setMovementSettings(config) {
	        this.maxSpeed = config.maxSpeed;
	        this.acceleration = config.acceleration;
	        this.deceleration = config.deceleration;
	        this.rotationSpeed = config.rotationSpeed;
	        this.dragCoefficient = Math.max(0, Math.min(1, config.dragCoefficient));
	        this.emit('movement-settings-changed', config);
	    }
	    /**
	     * Get current movement direction
	     */
	    getMovementDirection() {
	        return { ...this.lastMovementDirection };
	    }
	    /**
	     * Get current movement speed
	     */
	    getMovementSpeed() {
	        const velocity = this.character.velocity;
	        if (this.world.dimension === '2d') {
	            const vel = velocity;
	            return Math.sqrt(vel.x * vel.x + vel.y * vel.y);
	        }
	        else {
	            const vel = velocity;
	            return Math.sqrt(vel.x * vel.x + vel.z * vel.z);
	        }
	    }
	    /**
	     * Update top-down physics (call every frame)
	     */
	    update(deltaTime) {
	        // Handle movement
	        this.handleMovement(deltaTime);
	        // Handle rotation
	        if (this.rotationEnabled) {
	            this.handleRotation(deltaTime);
	        }
	        // Apply drag if momentum is disabled
	        if (!this.momentumEnabled) {
	            this.applyDrag();
	        }
	        // Update state
	        this.updateMovementState();
	        this.emit('update', deltaTime);
	    }
	    /**
	     * Enable/disable rotation towards movement direction
	     */
	    enableRotation(enabled) {
	        this.rotationEnabled = enabled;
	        this.emit('rotation-changed', enabled);
	    }
	    /**
	     * Enable/disable momentum (physics-based movement)
	     */
	    enableMomentum(enabled) {
	        this.momentumEnabled = enabled;
	        this.emit('momentum-changed', enabled);
	    }
	    /**
	     * Handle movement input and physics
	     */
	    handleMovement(deltaTime) {
	        const hasInput = Math.abs(this.movementInput.x) > 0.01 || Math.abs(this.movementInput.y) > 0.01;
	        if (hasInput) {
	            // Apply acceleration towards input direction
	            this.applyAcceleration(deltaTime);
	        }
	        else {
	            // Apply deceleration when no input
	            this.applyDeceleration(deltaTime);
	        }
	    }
	    /**
	     * Apply acceleration based on input
	     */
	    applyAcceleration(deltaTime) {
	        const targetVelocity = {
	            x: this.movementInput.x * this.maxSpeed,
	            y: this.movementInput.y * this.maxSpeed
	        };
	        const currentVelocity = this.world.dimension === '2d'
	            ? this.character.velocity
	            : { x: this.character.velocity.x, y: this.character.velocity.z };
	        const velocityDiff = {
	            x: targetVelocity.x - currentVelocity.x,
	            y: targetVelocity.y - currentVelocity.y
	        };
	        const accelerationForce = {
	            x: velocityDiff.x * this.acceleration,
	            y: velocityDiff.y * this.acceleration
	        };
	        if (this.world.dimension === '2d') {
	            this.character.applyForce(accelerationForce);
	        }
	        else {
	            this.character.applyForce({
	                x: accelerationForce.x,
	                y: 0,
	                z: accelerationForce.y
	            });
	        }
	    }
	    /**
	     * Apply deceleration when no input
	     */
	    applyDeceleration(deltaTime) {
	        const velocity = this.world.dimension === '2d'
	            ? this.character.velocity
	            : { x: this.character.velocity.x, y: this.character.velocity.z };
	        const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
	        if (speed > 0.1) {
	            const decelerationForce = {
	                x: -(velocity.x / speed) * this.deceleration,
	                y: -(velocity.y / speed) * this.deceleration
	            };
	            if (this.world.dimension === '2d') {
	                this.character.applyForce(decelerationForce);
	            }
	            else {
	                this.character.applyForce({
	                    x: decelerationForce.x,
	                    y: 0,
	                    z: decelerationForce.y
	                });
	            }
	        }
	    }
	    /**
	     * Handle character rotation towards movement direction
	     */
	    handleRotation(deltaTime) {
	        let currentRotation;
	        if (this.world.dimension === '2d') {
	            currentRotation = this.character.rotation;
	        }
	        else {
	            // Extract Y rotation from quaternion for 3D
	            const quat = this.character.rotation;
	            currentRotation = Math.atan2(2 * (quat.w * quat.y + quat.x * quat.z), 1 - 2 * (quat.y * quat.y + quat.z * quat.z));
	        }
	        // Calculate rotation difference
	        let rotationDiff = this.targetRotation - currentRotation;
	        // Normalize rotation difference to [-Ï€, Ï€]
	        while (rotationDiff > Math.PI)
	            rotationDiff -= 2 * Math.PI;
	        while (rotationDiff < -Math.PI)
	            rotationDiff += 2 * Math.PI;
	        // Apply rotation
	        if (Math.abs(rotationDiff) > 0.01) {
	            const rotationAmount = Math.sign(rotationDiff) * this.rotationSpeed * deltaTime;
	            // Clamp to target
	            if (Math.abs(rotationAmount) > Math.abs(rotationDiff)) {
	                this.character.rotation = this.targetRotation;
	            }
	            else {
	                this.character.rotation = currentRotation + rotationAmount;
	            }
	        }
	    }
	    /**
	     * Apply drag to reduce velocity
	     */
	    applyDrag() {
	        const velocity = this.character.velocity;
	        if (this.world.dimension === '2d') {
	            const vel = velocity;
	            this.character.velocity = {
	                x: vel.x * this.dragCoefficient,
	                y: vel.y * this.dragCoefficient
	            };
	        }
	        else {
	            const vel = velocity;
	            this.character.velocity = {
	                x: vel.x * this.dragCoefficient,
	                y: vel.y,
	                z: vel.z * this.dragCoefficient
	            };
	        }
	    }
	    /**
	     * Update movement state flags
	     */
	    updateMovementState() {
	        const speed = this.getMovementSpeed();
	        const wasMoving = this.isMoving;
	        this._isMoving = speed > 0.1;
	        this._currentSpeed = speed;
	        if (wasMoving !== this.isMoving) {
	            this.emit('movement-state-changed', this.isMoving);
	            if (this.isMoving) {
	                this.emit('started-moving');
	            }
	            else {
	                this.emit('stopped-moving');
	            }
	        }
	    }
	    /**
	     * Normalize a 2D vector
	     */
	    normalizeVector(vector) {
	        const length = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
	        if (length === 0) {
	            return { x: 0, y: 0 };
	        }
	        return {
	            x: vector.x / length,
	            y: vector.y / length
	        };
	    }
	}

	/**
	 * Trigger zone implementation for game events
	 */
	class GameByteTriggerZone extends EventEmitter {
	    constructor(world, config) {
	        super();
	        this.enteredBodies = new Set();
	        // Private backing field for mutable state
	        this._isActive = true;
	        this.triggerMask = 0xFFFFFFFF;
	        this.enterCallbacks = [];
	        this.exitCallbacks = [];
	        this.stayCallbacks = [];
	        this.world = world;
	        this.id = config.id || `trigger_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
	        // Create trigger body (sensor)
	        const triggerConfig = {
	            ...config,
	            id: this.id,
	            type: 'static',
	            isSensor: true
	        };
	        this.body = world.createBody(triggerConfig);
	        this.setupCollisionEvents();
	    }
	    // Public getter for readonly access
	    get isActive() {
	        return this._isActive;
	    }
	    /**
	     * Set trigger zone active state
	     */
	    setActive(active) {
	        this._isActive = active;
	        this.emit('active-changed', active);
	    }
	    /**
	     * Set collision mask for trigger detection
	     */
	    setTriggerMask(mask) {
	        this.triggerMask = mask;
	        this.body.collisionMask = mask;
	        this.emit('trigger-mask-changed', mask);
	    }
	    /**
	     * Add callback for body entering trigger
	     */
	    onEnter(callback) {
	        this.enterCallbacks.push(callback);
	    }
	    /**
	     * Add callback for body exiting trigger
	     */
	    onExit(callback) {
	        this.exitCallbacks.push(callback);
	    }
	    /**
	     * Add callback for body staying in trigger
	     */
	    onStay(callback) {
	        this.stayCallbacks.push(callback);
	    }
	    /**
	     * Check if a body is inside the trigger
	     */
	    isBodyInside(body) {
	        return this.enteredBodies.has(body);
	    }
	    /**
	     * Get all bodies currently inside the trigger
	     */
	    getBodiesInside() {
	        return Array.from(this.enteredBodies);
	    }
	    /**
	     * Destroy the trigger zone
	     */
	    destroy() {
	        // Remove collision event listeners
	        this.body.removeAllListeners();
	        // Remove body from world
	        this.world.removeBody(this.body);
	        // Clear callbacks and references
	        this.enterCallbacks.length = 0;
	        this.exitCallbacks.length = 0;
	        this.stayCallbacks.length = 0;
	        this.enteredBodies.clear();
	        this.emit('destroyed');
	        this.removeAllListeners();
	    }
	    /**
	     * Setup collision event handling
	     */
	    setupCollisionEvents() {
	        // Handle collision start (body enters trigger)
	        this.body.on('collision-start', (event) => {
	            if (!this.isActive)
	                return;
	            const otherBody = event.bodyA === this.body ? event.bodyB : event.bodyA;
	            // Check if body matches trigger mask
	            if ((otherBody.collisionGroup & this.triggerMask) === 0) {
	                return;
	            }
	            // Add to entered bodies set
	            if (!this.enteredBodies.has(otherBody)) {
	                this.enteredBodies.add(otherBody);
	                // Emit enter event
	                this.emit('enter', otherBody);
	                // Call enter callbacks
	                for (const callback of this.enterCallbacks) {
	                    try {
	                        callback(otherBody);
	                    }
	                    catch (error) {
	                        this.emit('error', error);
	                    }
	                }
	            }
	        });
	        // Handle collision end (body exits trigger)
	        this.body.on('collision-end', (event) => {
	            if (!this.isActive)
	                return;
	            const otherBody = event.bodyA === this.body ? event.bodyB : event.bodyA;
	            // Remove from entered bodies set
	            if (this.enteredBodies.has(otherBody)) {
	                this.enteredBodies.delete(otherBody);
	                // Emit exit event
	                this.emit('exit', otherBody);
	                // Call exit callbacks
	                for (const callback of this.exitCallbacks) {
	                    try {
	                        callback(otherBody);
	                    }
	                    catch (error) {
	                        this.emit('error', error);
	                    }
	                }
	            }
	        });
	        // Handle collision active (body stays in trigger)
	        this.body.on('collision-active', (event) => {
	            if (!this.isActive)
	                return;
	            const otherBody = event.bodyA === this.body ? event.bodyB : event.bodyA;
	            // Check if body is in entered bodies set
	            if (this.enteredBodies.has(otherBody)) {
	                // Emit stay event
	                this.emit('stay', otherBody);
	                // Call stay callbacks
	                for (const callback of this.stayCallbacks) {
	                    try {
	                        callback(otherBody);
	                    }
	                    catch (error) {
	                        this.emit('error', error);
	                    }
	                }
	            }
	        });
	    }
	}

	/**
	 * Physics-based particle system implementation
	 */
	class GameByteParticleSystem extends EventEmitter {
	    // Public getters for readonly access
	    get particleCount() {
	        return this._particleCount;
	    }
	    get isActive() {
	        return this._isActive;
	    }
	    constructor(world, config) {
	        super();
	        // Private backing fields for mutable state properties
	        this._particleCount = 0;
	        this._isActive = false;
	        this.particles = [];
	        this.emissionRate = 10; // particles per second
	        this.emissionTimer = 0;
	        this.minLifetime = 1;
	        this.maxLifetime = 3;
	        this.velocityMin = { x: -1, y: 1 };
	        this.velocityMax = { x: 1, y: 3 };
	        this.forceOverTime = { x: 0, y: -9.82 };
	        this.baseConfig = {
	            type: 'dynamic',
	            position: { x: 0, y: 0 },
	            shapes: [{
	                    type: 'circle',
	                    dimensions: { x: 0.1, y: 0.1 },
	                    radius: 0.05
	                }],
	            mass: 0.1
	        };
	        this.maxParticles = 100;
	        this.burstMode = false;
	        this.world = world;
	        this.parseConfig(config);
	    }
	    /**
	     * Emit particles continuously
	     */
	    emitParticles(count, config) {
	        if (!this.isActive)
	            return;
	        const actualCount = Math.min(count, this.maxParticles - this.particles.length);
	        for (let i = 0; i < actualCount; i++) {
	            this.createParticle(config);
	        }
	        this.updateParticleCount();
	        super.emit('particles-emitted', actualCount);
	    }
	    /**
	     * Emit a burst of particles
	     */
	    burst(count, config) {
	        const actualCount = Math.min(count, this.maxParticles - this.particles.length);
	        for (let i = 0; i < actualCount; i++) {
	            this.createParticle(config);
	        }
	        this.updateParticleCount();
	        super.emit('particles-burst', actualCount);
	    }
	    /**
	     * Clear all particles
	     */
	    clear() {
	        for (const particle of this.particles) {
	            this.world.removeBody(particle.body);
	        }
	        this.particles.length = 0;
	        this.updateParticleCount();
	        super.emit('particles-cleared');
	    }
	    /**
	     * Set emission rate (particles per second)
	     */
	    setEmissionRate(rate) {
	        this.emissionRate = Math.max(0, rate);
	        super.emit('emission-rate-changed', this.emissionRate);
	    }
	    /**
	     * Set particle lifetime range
	     */
	    setLifetime(min, max) {
	        this.minLifetime = Math.max(0, min);
	        this.maxLifetime = Math.max(this.minLifetime, max);
	        super.emit('lifetime-changed', { min: this.minLifetime, max: this.maxLifetime });
	    }
	    /**
	     * Set particle velocity range
	     */
	    setVelocityRange(min, max) {
	        this.velocityMin = { ...min };
	        this.velocityMax = { ...max };
	        super.emit('velocity-range-changed', { min: this.velocityMin, max: this.velocityMax });
	    }
	    /**
	     * Set force applied to particles over time (e.g., gravity)
	     */
	    setForceOverTime(force) {
	        this.forceOverTime = { ...force };
	        super.emit('force-over-time-changed', this.forceOverTime);
	    }
	    /**
	     * Start the particle system
	     */
	    start() {
	        this._isActive = true;
	        super.emit('started');
	    }
	    /**
	     * Stop the particle system
	     */
	    stop() {
	        this._isActive = false;
	        super.emit('stopped');
	    }
	    /**
	     * Pause the particle system
	     */
	    pause() {
	        this._isActive = false;
	        super.emit('paused');
	    }
	    /**
	     * Update the particle system (call every frame)
	     */
	    update(deltaTime) {
	        // Update emission timer
	        if (this.isActive && !this.burstMode) {
	            this.emissionTimer += deltaTime;
	            if (this.emissionTimer >= 1 / this.emissionRate) {
	                this.emitParticles(1, this.baseConfig);
	                this.emissionTimer = 0;
	            }
	        }
	        // Update existing particles
	        this.updateParticles(deltaTime);
	        // Remove dead particles
	        this.removeDeadParticles();
	        super.emit('updated', deltaTime);
	    }
	    /**
	     * Destroy the particle system
	     */
	    destroy() {
	        this.stop();
	        this.clear();
	        super.emit('destroyed');
	        this.removeAllListeners();
	    }
	    /**
	     * Create a new particle
	     */
	    createParticle(config) {
	        // Clone config to avoid modifying original
	        const particleConfig = {
	            ...config,
	            id: `particle_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
	            velocity: this.randomizeVelocity()
	        };
	        // Create physics body
	        const body = this.world.createBody(particleConfig);
	        // Create particle data
	        const particle = {
	            body,
	            lifetime: this.randomLifetime(),
	            maxLifetime: this.randomLifetime(),
	            age: 0
	        };
	        this.particles.push(particle);
	    }
	    /**
	     * Update all particles
	     */
	    updateParticles(deltaTime) {
	        for (const particle of this.particles) {
	            // Update age
	            particle.age += deltaTime;
	            // Apply force over time
	            particle.body.applyForce(this.forceOverTime);
	            // Apply any particle-specific updates here
	            // (could add size scaling, color changes, etc.)
	        }
	    }
	    /**
	     * Remove particles that have exceeded their lifetime
	     */
	    removeDeadParticles() {
	        for (let i = this.particles.length - 1; i >= 0; i--) {
	            const particle = this.particles[i];
	            if (particle.age >= particle.lifetime) {
	                // Remove from physics world
	                this.world.removeBody(particle.body);
	                // Remove from particles array
	                this.particles.splice(i, 1);
	                super.emit('particle-died', particle);
	            }
	        }
	        this.updateParticleCount();
	    }
	    /**
	     * Generate random velocity within range
	     */
	    randomizeVelocity() {
	        if (this.world.dimension === '2d') {
	            const min = this.velocityMin;
	            const max = this.velocityMax;
	            return {
	                x: min.x + Math.random() * (max.x - min.x),
	                y: min.y + Math.random() * (max.y - min.y)
	            };
	        }
	        else {
	            const min = this.velocityMin;
	            const max = this.velocityMax;
	            return {
	                x: min.x + Math.random() * (max.x - min.x),
	                y: min.y + Math.random() * (max.y - min.y),
	                z: min.z + Math.random() * (max.z - min.z)
	            };
	        }
	    }
	    /**
	     * Generate random lifetime within range
	     */
	    randomLifetime() {
	        return this.minLifetime + Math.random() * (this.maxLifetime - this.minLifetime);
	    }
	    /**
	     * Update particle count property
	     */
	    updateParticleCount() {
	        this._particleCount = this.particles.length;
	    }
	    /**
	     * Parse configuration object
	     */
	    parseConfig(config) {
	        // Override base config if provided
	        if (config.baseConfig) {
	            this.baseConfig = { ...this.baseConfig, ...config.baseConfig };
	        }
	        // Parse emission settings
	        if (config.emissionRate !== undefined) {
	            this.setEmissionRate(config.emissionRate);
	        }
	        // Parse lifetime settings
	        if (config.lifetime) {
	            this.setLifetime(config.lifetime.min || this.minLifetime, config.lifetime.max || this.maxLifetime);
	        }
	        // Parse velocity settings
	        if (config.velocity) {
	            this.setVelocityRange(config.velocity.min || this.velocityMin, config.velocity.max || this.velocityMax);
	        }
	        // Parse force settings
	        if (config.forceOverTime !== undefined) {
	            this.setForceOverTime(config.forceOverTime);
	        }
	        // Parse limits
	        if (config.maxParticles !== undefined) {
	            this.maxParticles = Math.max(1, config.maxParticles);
	        }
	        // Parse mode
	        if (config.burstMode !== undefined) {
	            this.burstMode = config.burstMode;
	        }
	    }
	}

	/**
	 * Mobile-specific physics optimization system
	 */
	class GameByteMobileOptimizer extends EventEmitter {
	    constructor() {
	        super();
	        this.cullingEnabled = false;
	        this.cullingDistance = 50;
	        this.lodEnabled = false;
	        this.lodLevels = [
	            { distance: 10, quality: 1.0 },
	            { distance: 25, quality: 0.7 },
	            { distance: 50, quality: 0.4 }
	        ];
	        this.adaptiveQualityEnabled = false;
	        this.performanceTarget = 60; // Target FPS
	        this.currentQualityLevel = 'medium';
	        this.qualityLevels = {
	            low: { timeStep: 1 / 30, iterations: 2 },
	            medium: { timeStep: 1 / 60, iterations: 4 },
	            high: { timeStep: 1 / 90, iterations: 6 }
	        };
	        this.batteryOptimizationEnabled = false;
	        this.sleepThresholds = { linear: 0.1, angular: 0.1 };
	        this.adaptiveSleepEnabled = false;
	        this.objectPoolingEnabled = true;
	        this.poolSizes = { bodies: 100, constraints: 50 };
	        this.deviceTier = 'medium';
	        this.performanceMetrics = {
	            averageStepTime: 0,
	            bodyCount: 0,
	            constraintCount: 0,
	            contactCount: 0,
	            broadphaseTime: 0,
	            narrowphaseTime: 0,
	            solverTime: 0,
	            memoryUsage: 0,
	            sleepingBodies: 0,
	            activeBodies: 0,
	            culledBodies: 0
	        };
	        this.performanceHistory = [];
	        this.performanceMonitoringEnabled = false;
	        // Performance monitoring
	        this.lastFrameTime = 0;
	        this.frameTimeHistory = [];
	        this.maxHistoryLength = 60; // 1 second at 60fps
	        this.detectDeviceTier();
	    }
	    /**
	     * Enable or disable physics culling for off-screen objects
	     */
	    enableCulling(enabled) {
	        this.cullingEnabled = enabled;
	        this.emit('culling-changed', enabled);
	    }
	    /**
	     * Set distance threshold for culling
	     */
	    setCullingDistance(distance) {
	        this.cullingDistance = Math.max(0, distance);
	        this.emit('culling-distance-changed', this.cullingDistance);
	    }
	    /**
	     * Enable or disable Level of Detail (LOD) system
	     */
	    enableLOD(enabled) {
	        this.lodEnabled = enabled;
	        this.emit('lod-changed', enabled);
	    }
	    /**
	     * Set LOD levels based on distance
	     */
	    setLODLevels(levels) {
	        this.lodLevels = levels.sort((a, b) => a.distance - b.distance);
	        this.emit('lod-levels-changed', this.lodLevels);
	    }
	    /**
	     * Enable or disable adaptive quality scaling
	     */
	    enableAdaptiveQuality(enabled) {
	        this.adaptiveQualityEnabled = enabled;
	        this.emit('adaptive-quality-changed', enabled);
	    }
	    /**
	     * Set target FPS for adaptive quality
	     */
	    setPerformanceTarget(fps) {
	        this.performanceTarget = Math.max(15, Math.min(120, fps));
	        this.emit('performance-target-changed', this.performanceTarget);
	    }
	    /**
	     * Set quality levels for adaptive scaling
	     */
	    setQualityLevels(levels) {
	        this.qualityLevels = { ...levels };
	        this.emit('quality-levels-changed', this.qualityLevels);
	    }
	    /**
	     * Enable or disable battery optimization
	     */
	    enableBatteryOptimization(enabled) {
	        this.batteryOptimizationEnabled = enabled;
	        this.emit('battery-optimization-changed', enabled);
	    }
	    /**
	     * Set sleep thresholds for bodies
	     */
	    setSleepThresholds(linear, angular) {
	        this.sleepThresholds = {
	            linear: Math.max(0, linear),
	            angular: Math.max(0, angular)
	        };
	        this.emit('sleep-thresholds-changed', this.sleepThresholds);
	    }
	    /**
	     * Enable or disable adaptive sleep system
	     */
	    enableAdaptiveSleep(enabled) {
	        this.adaptiveSleepEnabled = enabled;
	        this.emit('adaptive-sleep-changed', enabled);
	    }
	    /**
	     * Enable or disable object pooling
	     */
	    enableObjectPooling(enabled) {
	        this.objectPoolingEnabled = enabled;
	        this.emit('object-pooling-changed', enabled);
	    }
	    /**
	     * Set object pool sizes
	     */
	    setPoolSizes(bodies, constraints) {
	        this.poolSizes = {
	            bodies: Math.max(0, bodies),
	            constraints: Math.max(0, constraints)
	        };
	        this.emit('pool-sizes-changed', this.poolSizes);
	    }
	    /**
	     * Force garbage collection (if available)
	     */
	    forceGarbageCollection() {
	        // Modern browsers don't expose GC directly, but we can hint at it
	        if (window.gc) {
	            window.gc();
	        }
	        this.emit('garbage-collection-forced');
	    }
	    /**
	     * Detect device tier using centralized DeviceDetector
	     */
	    detectDeviceTier() {
	        // Use centralized DeviceDetector for consistent detection across the framework
	        const tier = DeviceDetector.detectTierSync();
	        this.deviceTier = tier;
	        this.emit('device-tier-detected', tier);
	        return tier;
	    }
	    /**
	     * Apply optimizations based on detected device tier
	     */
	    optimizeForDevice() {
	        switch (this.deviceTier) {
	            case 'low':
	                this.enableCulling(true);
	                this.setCullingDistance(20);
	                this.enableLOD(true);
	                this.enableAdaptiveQuality(true);
	                this.setPerformanceTarget(30);
	                this.currentQualityLevel = 'low';
	                this.enableBatteryOptimization(true);
	                this.enableAdaptiveSleep(true);
	                this.setSleepThresholds(0.2, 0.2);
	                break;
	            case 'medium':
	                this.enableCulling(true);
	                this.setCullingDistance(40);
	                this.enableLOD(true);
	                this.enableAdaptiveQuality(true);
	                this.setPerformanceTarget(60);
	                this.currentQualityLevel = 'medium';
	                this.enableBatteryOptimization(true);
	                this.enableAdaptiveSleep(true);
	                this.setSleepThresholds(0.1, 0.1);
	                break;
	            case 'high':
	                this.enableCulling(false);
	                this.enableLOD(false);
	                this.enableAdaptiveQuality(false);
	                this.setPerformanceTarget(60);
	                this.currentQualityLevel = 'high';
	                this.enableBatteryOptimization(false);
	                this.enableAdaptiveSleep(false);
	                this.setSleepThresholds(0.05, 0.05);
	                break;
	        }
	        this.emit('device-optimized', this.deviceTier);
	    }
	    /**
	     * Get current performance metrics
	     */
	    getPerformanceMetrics() {
	        return { ...this.performanceMetrics };
	    }
	    /**
	     * Enable or disable performance monitoring
	     */
	    enablePerformanceMonitoring(enabled) {
	        this.performanceMonitoringEnabled = enabled;
	        if (enabled) {
	            this.startPerformanceMonitoring();
	        }
	        else {
	            this.stopPerformanceMonitoring();
	        }
	        this.emit('performance-monitoring-changed', enabled);
	    }
	    /**
	     * Get current quality level
	     */
	    getCurrentQualityLevel() {
	        return this.currentQualityLevel;
	    }
	    /**
	     * Get current quality settings
	     */
	    getCurrentQualitySettings() {
	        return { ...this.qualityLevels[this.currentQualityLevel] };
	    }
	    /**
	     * Update performance metrics and adaptive systems
	     */
	    update(deltaTime) {
	        if (this.performanceMonitoringEnabled) {
	            this.updatePerformanceMetrics(deltaTime);
	        }
	        if (this.adaptiveQualityEnabled) {
	            this.updateAdaptiveQuality();
	        }
	        if (this.adaptiveSleepEnabled) {
	            this.updateAdaptiveSleep();
	        }
	    }
	    /**
	     * Set device tier manually
	     */
	    setDeviceTier(tier) {
	        this.deviceTier = tier;
	        this.optimizeForDevice();
	        this.emit('device-tier-changed', tier);
	    }
	    /**
	     * Start performance monitoring
	     */
	    startPerformanceMonitoring() {
	        this.lastFrameTime = performance.now();
	        this.frameTimeHistory.length = 0;
	    }
	    /**
	     * Stop performance monitoring
	     */
	    stopPerformanceMonitoring() {
	        this.frameTimeHistory.length = 0;
	    }
	    /**
	     * Update performance metrics
	     */
	    updatePerformanceMetrics(deltaTime) {
	        const currentTime = performance.now();
	        const frameTime = currentTime - this.lastFrameTime;
	        this.frameTimeHistory.push(frameTime);
	        if (this.frameTimeHistory.length > this.maxHistoryLength) {
	            this.frameTimeHistory.shift();
	        }
	        // Calculate average frame time
	        const avgFrameTime = this.frameTimeHistory.reduce((sum, time) => sum + time, 0) / this.frameTimeHistory.length;
	        this.performanceMetrics.averageStepTime = avgFrameTime;
	        this.lastFrameTime = currentTime;
	    }
	    /**
	     * Update adaptive quality based on performance
	     */
	    updateAdaptiveQuality() {
	        if (this.frameTimeHistory.length < 10)
	            return; // Need some data first
	        const avgFrameTime = this.performanceMetrics.averageStepTime;
	        const currentFPS = 1000 / avgFrameTime;
	        1000 / this.performanceTarget;
	        // Determine if we need to adjust quality
	        if (currentFPS < this.performanceTarget * 0.9) {
	            // Performance is poor, reduce quality
	            if (this.currentQualityLevel === 'high') {
	                this.currentQualityLevel = 'medium';
	                this.emit('quality-reduced', 'medium');
	            }
	            else if (this.currentQualityLevel === 'medium') {
	                this.currentQualityLevel = 'low';
	                this.emit('quality-reduced', 'low');
	            }
	        }
	        else if (currentFPS > this.performanceTarget * 1.1) {
	            // Performance is good, increase quality
	            if (this.currentQualityLevel === 'low') {
	                this.currentQualityLevel = 'medium';
	                this.emit('quality-increased', 'medium');
	            }
	            else if (this.currentQualityLevel === 'medium' && this.deviceTier !== 'low') {
	                this.currentQualityLevel = 'high';
	                this.emit('quality-increased', 'high');
	            }
	        }
	    }
	    /**
	     * Update adaptive sleep thresholds
	     */
	    updateAdaptiveSleep() {
	        const avgFrameTime = this.performanceMetrics.averageStepTime;
	        const currentFPS = 1000 / avgFrameTime;
	        // Adjust sleep thresholds based on performance
	        if (currentFPS < this.performanceTarget * 0.8) {
	            // Poor performance, make bodies sleep easier
	            this.sleepThresholds.linear = Math.min(0.3, this.sleepThresholds.linear * 1.1);
	            this.sleepThresholds.angular = Math.min(0.3, this.sleepThresholds.angular * 1.1);
	        }
	        else if (currentFPS > this.performanceTarget * 1.2) {
	            // Good performance, make bodies less likely to sleep
	            this.sleepThresholds.linear = Math.max(0.05, this.sleepThresholds.linear * 0.9);
	            this.sleepThresholds.angular = Math.max(0.05, this.sleepThresholds.angular * 0.9);
	        }
	    }
	}

	/**
	 * Unified physics manager that handles both 2D and 3D physics
	 */
	class PhysicsManager extends EventEmitter {
	    constructor() {
	        super();
	        // Private backing fields for public readonly properties
	        this._isInitialized = false;
	        this._currentWorld = null;
	        this._dimension = null;
	        this.engine2D = null;
	        this.engine3D = null;
	        this.currentEngine = null;
	        this.activeWorld = null;
	        this.worlds = new Set();
	        this.materials = new Map();
	        this.deviceTier = 'medium';
	        this.mobileOptimizer = new GameByteMobileOptimizer();
	        this.detectDeviceTier();
	    }
	    // Public getters for readonly access
	    get isInitialized() {
	        return this._isInitialized;
	    }
	    get currentWorld() {
	        return this._currentWorld;
	    }
	    get dimension() {
	        return this._dimension;
	    }
	    /**
	     * Get current performance metrics
	     */
	    get performanceMetrics() {
	        if (this.currentEngine) {
	            return this.currentEngine.getPerformanceMetrics();
	        }
	        return this.getEmptyMetrics();
	    }
	    /**
	     * Initialize the physics manager
	     */
	    async initialize(dimension, engineType) {
	        try {
	            this._dimension = dimension;
	            // Initialize the appropriate engine
	            if (dimension === '2d') {
	                this.engine2D = new Matter2DEngine();
	                await this.engine2D.initialize();
	                this.currentEngine = this.engine2D;
	            }
	            else {
	                const engine = engineType || 'cannon';
	                if (engine === 'cannon') {
	                    this.engine3D = new Cannon3DEngine();
	                    await this.engine3D.initialize();
	                    this.currentEngine = this.engine3D;
	                }
	                else {
	                    throw new Error(`Unsupported 3D engine: ${engine}`);
	                }
	            }
	            // Optimize for detected device tier
	            this.currentEngine.optimizeForDevice(this.deviceTier);
	            // Initialize default materials
	            this.initializeDefaultMaterials();
	            // Create a default physics world automatically
	            this.createDefaultWorld(dimension);
	            this._isInitialized = true;
	            this.emit('initialized', { dimension, engineType });
	        }
	        catch (error) {
	            this.emit('error', error);
	            throw error;
	        }
	    }
	    /**
	     * Create the default physics world
	     */
	    createDefaultWorld(dimension) {
	        const defaultConfig = {
	            dimension,
	            gravity: dimension === '2d'
	                ? { x: 0, y: 1 } // 2D: positive Y is down (screen coordinates)
	                : { x: 0, y: -9.81, z: 0 }, // 3D: negative Y is down (world coordinates)
	            allowSleep: true,
	            iterations: { velocity: 4, position: 3 }
	        };
	        const world = this.createWorld(defaultConfig);
	        // Start the world immediately so physics simulation runs
	        world.start();
	    }
	    /**
	     * Destroy the physics manager
	     */
	    destroy() {
	        // Destroy all worlds
	        for (const world of this.worlds) {
	            world.destroy();
	        }
	        this.worlds.clear();
	        // Destroy engines
	        if (this.engine2D) {
	            this.engine2D.destroy();
	            this.engine2D = null;
	        }
	        if (this.engine3D) {
	            this.engine3D.destroy();
	            this.engine3D = null;
	        }
	        this.currentEngine = null;
	        this.activeWorld = null;
	        this._currentWorld = null;
	        this._dimension = null;
	        this._isInitialized = false;
	        this.materials.clear();
	        this.emit('destroyed');
	    }
	    /**
	     * Create a physics world
	     */
	    createWorld(config) {
	        if (!this.currentEngine) {
	            throw new Error('Physics manager not initialized');
	        }
	        // Ensure config dimension matches manager dimension
	        if (config.dimension !== this.dimension) {
	            throw new Error(`World dimension ${config.dimension} doesn't match manager dimension ${this.dimension}`);
	        }
	        const world = this.currentEngine.createWorld(config);
	        this.worlds.add(world);
	        // Set as active world if it's the first one
	        if (!this.activeWorld) {
	            this.setActiveWorld(world);
	        }
	        this.emit('world-created', world);
	        return world;
	    }
	    /**
	     * Set the active physics world
	     */
	    setActiveWorld(world) {
	        if (!this.worlds.has(world)) {
	            throw new Error('World is not managed by this physics manager');
	        }
	        const previousWorld = this.activeWorld;
	        this.activeWorld = world;
	        this._currentWorld = world;
	        this.emit('active-world-changed', { previous: previousWorld, current: world });
	    }
	    /**
	     * Get the active physics world
	     */
	    getActiveWorld() {
	        return this.activeWorld;
	    }
	    /**
	     * Destroy a physics world
	     */
	    destroyWorld(world) {
	        if (!this.worlds.has(world)) {
	            return;
	        }
	        // Stop the world if it's running
	        if (world.isRunning) {
	            world.stop();
	        }
	        // Remove from active if it's the current one
	        if (this.activeWorld === world) {
	            this.activeWorld = null;
	            this._currentWorld = null;
	        }
	        // Destroy and remove
	        world.destroy();
	        this.worlds.delete(world);
	        if (this.currentEngine) {
	            this.currentEngine.destroyWorld(world);
	        }
	        this.emit('world-destroyed', world);
	    }
	    /**
	     * Switch physics engine
	     */
	    async switchEngine(engineType) {
	        if (!this.dimension) {
	            throw new Error('Physics manager not initialized');
	        }
	        // Validate engine compatibility
	        if (this.dimension === '2d' && engineType !== 'matter') {
	            throw new Error(`Engine ${engineType} is not compatible with 2D physics`);
	        }
	        if (this.dimension === '3d' && engineType === 'matter') {
	            throw new Error('Matter.js engine is not compatible with 3D physics');
	        }
	        // Save current state
	        const wasInitialized = this.isInitialized;
	        const currentDimension = this.dimension;
	        // Destroy current state
	        this.destroy();
	        // Reinitialize with new engine
	        if (wasInitialized) {
	            await this.initialize(currentDimension, engineType);
	        }
	        this.emit('engine-switched', engineType);
	    }
	    /**
	     * Get the current physics engine
	     */
	    getCurrentEngine() {
	        return this.currentEngine;
	    }
	    /**
	     * Create a physics body in the active world
	     * Supports both simplified and full config formats
	     *
	     * @example Simplified format
	     * ```typescript
	     * const body = physicsManager.createBody({
	     *   shape: 'rectangle',
	     *   x: 100,
	     *   y: 100,
	     *   width: 40,
	     *   height: 60,
	     *   options: { friction: 0.1 }
	     * });
	     * ```
	     *
	     * @example Full format
	     * ```typescript
	     * const body = physicsManager.createBody({
	     *   type: 'dynamic',
	     *   position: { x: 100, y: 100 },
	     *   shapes: [{ type: 'box', dimensions: { x: 40, y: 60 } }]
	     * });
	     * ```
	     */
	    createBody(config) {
	        if (!this.activeWorld) {
	            throw new Error('No active physics world. Create a world first.');
	        }
	        // Check if it's a simplified config
	        if ('shape' in config) {
	            const fullConfig = this.convertSimpleToFullConfig(config);
	            return this.activeWorld.createBody(fullConfig);
	        }
	        // It's a full config
	        return this.activeWorld.createBody(config);
	    }
	    /**
	     * Convert simplified body config to full config format
	     */
	    convertSimpleToFullConfig(simple) {
	        const options = simple.options || {};
	        // Determine shape type for physics
	        let shapeType = 'box';
	        if (simple.shape === 'circle') {
	            shapeType = 'circle';
	        }
	        else if (simple.shape === 'polygon') {
	            shapeType = 'mesh';
	        }
	        // Build dimensions based on shape type
	        let dimensions;
	        if (simple.shape === 'circle') {
	            const radius = simple.radius || 16;
	            dimensions = { x: radius * 2, y: radius * 2 };
	        }
	        else if (simple.shape === 'polygon' && simple.vertices && simple.vertices.length > 0) {
	            // Calculate bounding box from vertices for polygon
	            const xs = simple.vertices.map(v => v.x);
	            const ys = simple.vertices.map(v => v.y);
	            dimensions = {
	                x: Math.max(...xs) - Math.min(...xs),
	                y: Math.max(...ys) - Math.min(...ys)
	            };
	        }
	        else {
	            dimensions = { x: simple.width || 32, y: simple.height || 32 };
	        }
	        // Build shape config with vertices for polygon shapes
	        const shapeConfig = {
	            type: shapeType,
	            dimensions,
	            radius: simple.shape === 'circle' ? simple.radius : undefined,
	            vertices: simple.shape === 'polygon' ? simple.vertices : undefined
	        };
	        const fullConfig = {
	            type: options.isStatic ? 'static' : 'dynamic',
	            position: { x: simple.x, y: simple.y },
	            shapes: [shapeConfig],
	            isStatic: options.isStatic,
	            isSensor: options.isSensor,
	            rotation: options.angle,
	            angularVelocity: options.angularVelocity,
	            fixedRotation: options.fixedRotation,
	            gravityScale: options.gravityScale,
	            collisionGroup: options.collisionGroup,
	            collisionMask: options.collisionMask,
	            mass: options.mass,
	            linearDamping: options.frictionAir,
	            userData: options.label ? { label: options.label } : undefined
	        };
	        // Add material properties if specified
	        if (options.friction !== undefined || options.restitution !== undefined || options.density !== undefined) {
	            fullConfig.material = {
	                id: 'custom',
	                name: 'Custom Material',
	                friction: options.friction ?? 0.1,
	                restitution: options.restitution ?? 0,
	                density: options.density ?? 0.001,
	                frictionAir: options.frictionAir,
	                frictionStatic: options.frictionStatic
	            };
	        }
	        return fullConfig;
	    }
	    /**
	     * Create a platformer physics helper
	     */
	    createPlatformerHelper(character) {
	        if (!this.activeWorld) {
	            throw new Error('No active physics world');
	        }
	        return new GameBytePlatformerHelper(character, this.activeWorld);
	    }
	    /**
	     * Create a top-down physics helper
	     */
	    createTopDownHelper(character) {
	        if (!this.activeWorld) {
	            throw new Error('No active physics world');
	        }
	        return new GameByteTopDownHelper(character, this.activeWorld);
	    }
	    /**
	     * Create a trigger zone
	     */
	    createTriggerZone(config) {
	        if (!this.activeWorld) {
	            throw new Error('No active physics world');
	        }
	        return new GameByteTriggerZone(this.activeWorld, config);
	    }
	    /**
	     * Create a particle system
	     */
	    createParticleSystem(config) {
	        if (!this.activeWorld) {
	            throw new Error('No active physics world');
	        }
	        return new GameByteParticleSystem(this.activeWorld, config);
	    }
	    /**
	     * Get the mobile optimizer
	     */
	    getMobileOptimizer() {
	        return this.mobileOptimizer;
	    }
	    /**
	     * Enable mobile optimizations
	     */
	    enableMobileOptimizations() {
	        this.mobileOptimizer.enableCulling(true);
	        this.mobileOptimizer.enableAdaptiveQuality(true);
	        this.mobileOptimizer.enableBatteryOptimization(true);
	        this.mobileOptimizer.enableObjectPooling(true);
	        this.mobileOptimizer.optimizeForDevice();
	        // Apply optimizations to current engine
	        if (this.currentEngine) {
	            this.currentEngine.optimizeForDevice(this.deviceTier);
	            this.currentEngine.enableObjectPooling(true);
	        }
	        this.emit('mobile-optimizations-enabled');
	    }
	    /**
	     * Set device tier for optimization
	     */
	    setDeviceTier(tier) {
	        this.deviceTier = tier;
	        if (this.currentEngine) {
	            this.currentEngine.optimizeForDevice(tier);
	        }
	        this.mobileOptimizer.setDeviceTier?.(tier);
	        this.emit('device-tier-changed', tier);
	    }
	    /**
	     * Create a physics material
	     */
	    createMaterial(config) {
	        if (!this.currentEngine) {
	            throw new Error('Physics manager not initialized');
	        }
	        const material = this.currentEngine.createMaterial(config);
	        this.materials.set(material.id, material);
	        this.emit('material-created', material);
	        return material;
	    }
	    /**
	     * Get a material by ID
	     */
	    getMaterial(id) {
	        return this.materials.get(id) || null;
	    }
	    /**
	     * Register a material
	     */
	    registerMaterial(material) {
	        this.materials.set(material.id, material);
	        this.emit('material-registered', material);
	    }
	    /**
	     * Update all physics worlds
	     */
	    update(deltaTime) {
	        // Update active world
	        if (this.activeWorld && this.activeWorld.isRunning) {
	            this.activeWorld.step(deltaTime);
	        }
	        // Update mobile optimizer
	        this.mobileOptimizer.update?.(deltaTime);
	        this.emit('update', deltaTime);
	    }
	    /**
	     * Get performance metrics
	     */
	    getPerformanceMetrics() {
	        return this.performanceMetrics;
	    }
	    /**
	     * Enable debug mode
	     */
	    enableDebugMode(enabled) {
	        if (this.activeWorld) {
	            this.activeWorld.enableDebugDraw(enabled);
	        }
	        this.emit('debug-mode-changed', enabled);
	    }
	    /**
	     * Optimize for mobile devices
	     */
	    optimizeForMobile() {
	        this.enableMobileOptimizations();
	        // Apply mobile-specific world settings
	        if (this.activeWorld) {
	            this.activeWorld.optimizeForMobile();
	        }
	        this.emit('mobile-optimized');
	    }
	    /**
	     * Initialize default materials
	     */
	    initializeDefaultMaterials() {
	        if (!this.currentEngine)
	            return;
	        // Default material
	        const defaultMaterial = this.currentEngine.getDefaultMaterial();
	        this.materials.set(defaultMaterial.id, defaultMaterial);
	        // Common game materials
	        const materials = [
	            {
	                id: 'bouncy',
	                name: 'Bouncy',
	                friction: 0.3,
	                restitution: 0.8,
	                density: 1.0
	            },
	            {
	                id: 'ice',
	                name: 'Ice',
	                friction: 0.1,
	                restitution: 0.1,
	                density: 0.9
	            },
	            {
	                id: 'rubber',
	                name: 'Rubber',
	                friction: 0.8,
	                restitution: 0.6,
	                density: 1.2
	            },
	            {
	                id: 'metal',
	                name: 'Metal',
	                friction: 0.4,
	                restitution: 0.2,
	                density: 7.8
	            },
	            {
	                id: 'wood',
	                name: 'Wood',
	                friction: 0.6,
	                restitution: 0.3,
	                density: 0.8
	            }
	        ];
	        for (const config of materials) {
	            const material = this.currentEngine.createMaterial(config);
	            this.materials.set(material.id, material);
	        }
	    }
	    /**
	     * Detect device tier for optimization
	     * Uses centralized DeviceDetector for consistent detection across the framework
	     */
	    detectDeviceTier() {
	        this.deviceTier = DeviceDetector.detectTierSync();
	        this.emit('device-tier-detected', this.deviceTier);
	    }
	    /**
	     * Get empty performance metrics
	     */
	    getEmptyMetrics() {
	        return {
	            averageStepTime: 0,
	            bodyCount: 0,
	            constraintCount: 0,
	            contactCount: 0,
	            broadphaseTime: 0,
	            narrowphaseTime: 0,
	            solverTime: 0,
	            memoryUsage: 0,
	            sleepingBodies: 0,
	            activeBodies: 0,
	            culledBodies: 0
	        };
	    }
	}

	/**
	 * Physics service provider for the GameByte framework
	 */
	class PhysicsServiceProvider extends AbstractServiceProvider {
	    /**
	     * Register physics services in the container
	     */
	    register(app) {
	        // Register the physics manager as a singleton
	        app.singleton('physics', () => new PhysicsManager());
	        // Register alias for easier access
	        app.getContainer().alias('PhysicsManager', 'physics');
	    }
	    /**
	     * Boot physics services after all providers have been registered
	     */
	    async boot(app) {
	        const physicsManager = app.make('physics');
	        // Set up event listeners for scene transitions
	        const sceneManager = app.make('scene.manager');
	        if (sceneManager) {
	            sceneManager.on('scene-changing', this.handleSceneChange.bind(this, physicsManager));
	            sceneManager.on('scene-changed', this.handleSceneChanged.bind(this, physicsManager));
	        }
	        // Set up render loop integration
	        const renderer = app.make('renderer');
	        if (renderer) {
	            renderer.on('render', this.handleRenderLoop.bind(this, physicsManager));
	        }
	        // Initialize physics when app is initialized (after renderer mode is known)
	        // Physics is optional - if Matter.js/Cannon.js is not available, skip gracefully
	        app.on('initialized', async (data) => {
	            if (!physicsManager.isInitialized) {
	                try {
	                    // Determine physics dimension based on renderer mode
	                    const is3D = data?.mode === '3d' || data?.mode === 'hybrid';
	                    const dimension = is3D ? '3d' : '2d';
	                    await physicsManager.initialize(dimension);
	                }
	                catch (error) {
	                    // Physics engine not available - this is fine for games that don't use physics
	                    console.warn('âš ï¸ Physics engine not available. If you need physics, include Matter.js (2D) or Cannon.js (3D).');
	                }
	            }
	        });
	        // Emit physics service booted event
	        app.emit('physics:booted', physicsManager);
	    }
	    /**
	     * Services provided by this provider
	     */
	    provides() {
	        return ['physics', 'PhysicsManager'];
	    }
	    /**
	     * Handle scene change events
	     */
	    handleSceneChange(physicsManager, event) {
	        // Pause physics when changing scenes
	        const activeWorld = physicsManager.getActiveWorld();
	        if (activeWorld && activeWorld.isRunning) {
	            activeWorld.pause();
	        }
	    }
	    /**
	     * Handle scene changed events
	     */
	    handleSceneChanged(physicsManager, event) {
	        // Resume physics after scene change
	        const activeWorld = physicsManager.getActiveWorld();
	        if (activeWorld) {
	            activeWorld.resume();
	        }
	    }
	    /**
	     * Handle render loop for physics updates
	     */
	    handleRenderLoop(physicsManager, deltaTime) {
	        // Update physics on each render frame
	        if (physicsManager.isInitialized) {
	            physicsManager.update(deltaTime);
	        }
	    }
	}

	/**
	 * Optimized game loop with adaptive performance scaling
	 * Maintains stable 60fps with dynamic quality adjustment
	 */
	class GameLoopOptimizer extends EventEmitter {
	    constructor(config = {}) {
	        super();
	        this.isRunning = false;
	        this.animationFrameId = null;
	        // Timing variables
	        this.lastTime = 0;
	        this.accumulator = 0;
	        this.fixedDeltaTime = 1000 / 60; // 16.67ms for 60fps
	        this.frameCount = 0;
	        this.fpsHistory = [];
	        this.frameTimeHistory = [];
	        // Performance tracking
	        this.currentFps = 60;
	        this.averageFps = 60;
	        this.frameTime = 16.67;
	        this.averageFrameTime = 16.67;
	        this.frameSkipCount = 0;
	        this.isFrameRateStable = true;
	        this.autoAdjustmentEnabled = true;
	        this.performanceTarget = 58; // Target 58fps to allow buffer
	        this.adjustmentCooldown = 0;
	        this.lastQualityAdjustment = 0;
	        // Update callbacks
	        this.updateCallbacks = [];
	        this.renderCallbacks = [];
	        this.fixedUpdateCallbacks = [];
	        this.config = {
	            targetFps: 60,
	            maxDeltaTime: 100, // 100ms max to prevent spiral of death
	            fixedTimeStep: false,
	            adaptiveFrameRate: true,
	            vsyncEnabled: true,
	            frameSkipping: true,
	            maxFrameSkip: 5,
	            ...config
	        };
	        this.fixedDeltaTime = 1000 / this.config.targetFps;
	        // Initialize default quality settings
	        this.qualitySettings = {
	            renderScale: 1.0,
	            textureQuality: exports.QualityLevel.HIGH,
	            shadowQuality: exports.QualityLevel.HIGH,
	            effectsQuality: exports.QualityLevel.HIGH,
	            antialiasing: true,
	            physicsTimestep: 1000 / 60,
	            physicsIterations: 10,
	            maxPhysicsObjects: 1000,
	            audioQuality: exports.QualityLevel.HIGH,
	            maxAudioSources: 32,
	            uiAnimationQuality: exports.QualityLevel.HIGH,
	            particleCount: 1000
	        };
	    }
	    /**
	     * Start the optimized game loop
	     */
	    start() {
	        if (this.isRunning)
	            return;
	        this.isRunning = true;
	        this.lastTime = performance.now();
	        this.frameCount = 0;
	        this.accumulator = 0;
	        this.loop();
	        this.emit('started');
	    }
	    /**
	     * Stop the game loop
	     */
	    stop() {
	        if (!this.isRunning)
	            return;
	        this.isRunning = false;
	        if (this.animationFrameId) {
	            cancelAnimationFrame(this.animationFrameId);
	            this.animationFrameId = null;
	        }
	        this.emit('stopped');
	    }
	    /**
	     * Main game loop implementation
	     */
	    loop() {
	        if (!this.isRunning)
	            return;
	        const currentTime = performance.now();
	        let deltaTime = currentTime - this.lastTime;
	        this.lastTime = currentTime;
	        // Clamp delta time to prevent spiral of death
	        deltaTime = Math.min(deltaTime, this.config.maxDeltaTime);
	        // Update performance metrics
	        this.updatePerformanceMetrics(deltaTime);
	        // Handle frame skipping if performance is poor
	        if (this.config.frameSkipping && this.shouldSkipFrame()) {
	            this.frameSkipCount++;
	            this.scheduleNextFrame();
	            return;
	        }
	        this.frameSkipCount = 0;
	        if (this.config.fixedTimeStep) {
	            this.runFixedTimeStep(deltaTime);
	        }
	        else {
	            this.runVariableTimeStep(deltaTime);
	        }
	        // Adaptive quality adjustment
	        if (this.autoAdjustmentEnabled && this.shouldAdjustQuality()) {
	            this.adjustQualityBasedOnPerformance();
	        }
	        this.scheduleNextFrame();
	    }
	    /**
	     * Run fixed timestep loop
	     */
	    runFixedTimeStep(deltaTime) {
	        this.accumulator += deltaTime;
	        // Run fixed updates
	        while (this.accumulator >= this.fixedDeltaTime) {
	            // Execute fixed update callbacks (physics, etc.)
	            this.fixedUpdateCallbacks.forEach(callback => {
	                try {
	                    callback(this.fixedDeltaTime);
	                }
	                catch (error) {
	                    this.emit('update-error', error);
	                }
	            });
	            this.accumulator -= this.fixedDeltaTime;
	        }
	        // Calculate interpolation alpha for smooth rendering
	        const alpha = this.accumulator / this.fixedDeltaTime;
	        // Run variable update (input, UI, etc.)
	        this.updateCallbacks.forEach(callback => {
	            try {
	                callback(deltaTime);
	            }
	            catch (error) {
	                this.emit('update-error', error);
	            }
	        });
	        // Run render callbacks with interpolation
	        this.renderCallbacks.forEach(callback => {
	            try {
	                callback(alpha);
	            }
	            catch (error) {
	                this.emit('render-error', error);
	            }
	        });
	        this.emit('frame', { deltaTime, alpha, type: 'fixed' });
	    }
	    /**
	     * Run variable timestep loop
	     */
	    runVariableTimeStep(deltaTime) {
	        // Run update callbacks
	        this.updateCallbacks.forEach(callback => {
	            try {
	                callback(deltaTime);
	            }
	            catch (error) {
	                this.emit('update-error', error);
	            }
	        });
	        // Run render callbacks
	        this.renderCallbacks.forEach(callback => {
	            try {
	                callback(deltaTime);
	            }
	            catch (error) {
	                this.emit('render-error', error);
	            }
	        });
	        this.emit('frame', { deltaTime, type: 'variable' });
	    }
	    /**
	     * Schedule next frame
	     */
	    scheduleNextFrame() {
	        if (this.config.vsyncEnabled) {
	            this.animationFrameId = requestAnimationFrame(() => this.loop());
	        }
	        else {
	            // Use setTimeout for custom frame rate
	            const targetFrameTime = 1000 / this.config.targetFps;
	            this.animationFrameId = window.setTimeout(() => this.loop(), targetFrameTime);
	        }
	    }
	    /**
	     * Update performance metrics
	     */
	    updatePerformanceMetrics(deltaTime) {
	        this.frameTime = deltaTime;
	        this.frameCount++;
	        // Calculate FPS
	        this.currentFps = 1000 / deltaTime;
	        // Update history buffers
	        this.fpsHistory.push(this.currentFps);
	        this.frameTimeHistory.push(deltaTime);
	        // Limit history size
	        const maxHistorySize = 120; // 2 seconds at 60fps
	        if (this.fpsHistory.length > maxHistorySize) {
	            this.fpsHistory.shift();
	            this.frameTimeHistory.shift();
	        }
	        // Calculate averages
	        this.averageFps = this.fpsHistory.reduce((sum, fps) => sum + fps, 0) / this.fpsHistory.length;
	        this.averageFrameTime = this.frameTimeHistory.reduce((sum, time) => sum + time, 0) / this.frameTimeHistory.length;
	        // Check frame rate stability
	        if (this.fpsHistory.length >= 60) { // 1 second of data
	            const recentFps = this.fpsHistory.slice(-60);
	            const variance = this.calculateVariance(recentFps);
	            this.isFrameRateStable = variance < 100; // Low variance = stable
	        }
	        // Emit metrics every second
	        if (this.frameCount % 60 === 0) {
	            this.emit('metrics-updated', {
	                fps: Math.round(this.currentFps),
	                averageFps: Math.round(this.averageFps),
	                frameTime: Math.round(this.frameTime * 100) / 100,
	                averageFrameTime: Math.round(this.averageFrameTime * 100) / 100,
	                isStable: this.isFrameRateStable,
	                frameSkips: this.frameSkipCount
	            });
	        }
	    }
	    /**
	     * Calculate variance for stability check
	     */
	    calculateVariance(values) {
	        const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
	        const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
	        return squaredDiffs.reduce((sum, diff) => sum + diff, 0) / values.length;
	    }
	    /**
	     * Check if frame should be skipped for performance
	     */
	    shouldSkipFrame() {
	        if (!this.config.frameSkipping)
	            return false;
	        if (this.frameSkipCount >= this.config.maxFrameSkip)
	            return false;
	        // Skip if we're significantly behind target FPS
	        return this.averageFps < (this.config.targetFps * 0.8) && this.frameTime > 25; // >25ms frame time
	    }
	    /**
	     * Check if quality should be adjusted
	     */
	    shouldAdjustQuality() {
	        if (this.adjustmentCooldown > 0) {
	            this.adjustmentCooldown--;
	            return false;
	        }
	        // Need at least 2 seconds of data
	        if (this.fpsHistory.length < 120)
	            return false;
	        // Check if performance is consistently poor or good
	        const recentFps = this.fpsHistory.slice(-60); // Last 1 second
	        const avgRecentFps = recentFps.reduce((sum, fps) => sum + fps, 0) / recentFps.length;
	        // Adjust if significantly above or below target
	        return Math.abs(avgRecentFps - this.performanceTarget) > 10;
	    }
	    /**
	     * Adjust quality settings based on performance
	     */
	    adjustQualityBasedOnPerformance() {
	        const recentFps = this.fpsHistory.slice(-60);
	        const avgRecentFps = recentFps.reduce((sum, fps) => sum + fps, 0) / recentFps.length;
	        let needsAdjustment = false;
	        if (avgRecentFps < this.performanceTarget - 5) {
	            // Performance is poor, reduce quality
	            needsAdjustment = this.reduceQuality();
	        }
	        else if (avgRecentFps > this.performanceTarget + 10) {
	            // Performance is good, increase quality if not at max
	            needsAdjustment = this.increaseQuality();
	        }
	        if (needsAdjustment) {
	            this.adjustmentCooldown = 180; // 3 seconds cooldown
	            this.lastQualityAdjustment = performance.now();
	            this.emit('quality-adjusted', this.qualitySettings);
	        }
	    }
	    /**
	     * Reduce quality settings to improve performance
	     */
	    reduceQuality() {
	        let adjusted = false;
	        // Progressive quality reduction
	        if (this.qualitySettings.renderScale > 0.5) {
	            this.qualitySettings.renderScale = Math.max(0.5, this.qualitySettings.renderScale - 0.1);
	            adjusted = true;
	        }
	        else if (this.qualitySettings.effectsQuality > exports.QualityLevel.LOW) {
	            this.qualitySettings.effectsQuality--;
	            adjusted = true;
	        }
	        else if (this.qualitySettings.shadowQuality > exports.QualityLevel.LOW) {
	            this.qualitySettings.shadowQuality--;
	            adjusted = true;
	        }
	        else if (this.qualitySettings.textureQuality > exports.QualityLevel.LOW) {
	            this.qualitySettings.textureQuality--;
	            adjusted = true;
	        }
	        else if (this.qualitySettings.antialiasing) {
	            this.qualitySettings.antialiasing = false;
	            adjusted = true;
	        }
	        else if (this.qualitySettings.particleCount > 100) {
	            this.qualitySettings.particleCount = Math.max(100, this.qualitySettings.particleCount * 0.7);
	            adjusted = true;
	        }
	        return adjusted;
	    }
	    /**
	     * Increase quality settings when performance allows
	     */
	    increaseQuality() {
	        let adjusted = false;
	        // Progressive quality increase (reverse order of reduction)
	        if (this.qualitySettings.particleCount < 1000) {
	            this.qualitySettings.particleCount = Math.min(1000, this.qualitySettings.particleCount * 1.3);
	            adjusted = true;
	        }
	        else if (!this.qualitySettings.antialiasing) {
	            this.qualitySettings.antialiasing = true;
	            adjusted = true;
	        }
	        else if (this.qualitySettings.textureQuality < exports.QualityLevel.HIGH) {
	            this.qualitySettings.textureQuality++;
	            adjusted = true;
	        }
	        else if (this.qualitySettings.shadowQuality < exports.QualityLevel.HIGH) {
	            this.qualitySettings.shadowQuality++;
	            adjusted = true;
	        }
	        else if (this.qualitySettings.effectsQuality < exports.QualityLevel.HIGH) {
	            this.qualitySettings.effectsQuality++;
	            adjusted = true;
	        }
	        else if (this.qualitySettings.renderScale < 1.0) {
	            this.qualitySettings.renderScale = Math.min(1.0, this.qualitySettings.renderScale + 0.1);
	            adjusted = true;
	        }
	        return adjusted;
	    }
	    /**
	     * Add update callback
	     */
	    addUpdateCallback(callback) {
	        this.updateCallbacks.push(callback);
	    }
	    /**
	     * Remove update callback
	     */
	    removeUpdateCallback(callback) {
	        const index = this.updateCallbacks.indexOf(callback);
	        if (index > -1) {
	            this.updateCallbacks.splice(index, 1);
	        }
	    }
	    /**
	     * Add render callback
	     */
	    addRenderCallback(callback) {
	        this.renderCallbacks.push(callback);
	    }
	    /**
	     * Remove render callback
	     */
	    removeRenderCallback(callback) {
	        const index = this.renderCallbacks.indexOf(callback);
	        if (index > -1) {
	            this.renderCallbacks.splice(index, 1);
	        }
	    }
	    /**
	     * Add fixed update callback
	     */
	    addFixedUpdateCallback(callback) {
	        this.fixedUpdateCallbacks.push(callback);
	    }
	    /**
	     * Remove fixed update callback
	     */
	    removeFixedUpdateCallback(callback) {
	        const index = this.fixedUpdateCallbacks.indexOf(callback);
	        if (index > -1) {
	            this.fixedUpdateCallbacks.splice(index, 1);
	        }
	    }
	    /**
	     * Get current performance metrics
	     */
	    getMetrics() {
	        return {
	            fps: Math.round(this.currentFps),
	            averageFps: Math.round(this.averageFps),
	            frameTime: Math.round(this.frameTime * 100) / 100,
	            averageFrameTime: Math.round(this.averageFrameTime * 100) / 100,
	            isStable: this.isFrameRateStable,
	            frameSkips: this.frameSkipCount,
	            targetFps: this.config.targetFps
	        };
	    }
	    /**
	     * Get current quality settings
	     */
	    getQualitySettings() {
	        return { ...this.qualitySettings };
	    }
	    /**
	     * Set quality settings
	     */
	    setQualitySettings(settings) {
	        this.qualitySettings = { ...this.qualitySettings, ...settings };
	        this.emit('quality-changed', this.qualitySettings);
	    }
	    /**
	     * Enable/disable auto quality adjustment
	     */
	    setAutoAdjustmentEnabled(enabled) {
	        this.autoAdjustmentEnabled = enabled;
	        this.emit('auto-adjustment-changed', enabled);
	    }
	    /**
	     * Set performance target FPS
	     */
	    setPerformanceTarget(fps) {
	        this.performanceTarget = Math.max(30, Math.min(120, fps));
	        this.emit('target-changed', this.performanceTarget);
	    }
	    /**
	     * Force quality adjustment
	     */
	    forceQualityAdjustment() {
	        this.adjustmentCooldown = 0;
	        if (this.shouldAdjustQuality()) {
	            this.adjustQualityBasedOnPerformance();
	        }
	    }
	    /**
	     * Reset quality to defaults
	     */
	    resetQuality() {
	        this.qualitySettings = {
	            renderScale: 1.0,
	            textureQuality: exports.QualityLevel.HIGH,
	            shadowQuality: exports.QualityLevel.HIGH,
	            effectsQuality: exports.QualityLevel.HIGH,
	            antialiasing: true,
	            physicsTimestep: 1000 / 60,
	            physicsIterations: 10,
	            maxPhysicsObjects: 1000,
	            audioQuality: exports.QualityLevel.HIGH,
	            maxAudioSources: 32,
	            uiAnimationQuality: exports.QualityLevel.HIGH,
	            particleCount: 1000
	        };
	        this.emit('quality-reset', this.qualitySettings);
	    }
	    /**
	     * Clean up resources
	     */
	    destroy() {
	        this.stop();
	        this.updateCallbacks.length = 0;
	        this.renderCallbacks.length = 0;
	        this.fixedUpdateCallbacks.length = 0;
	        this.fpsHistory.length = 0;
	        this.frameTimeHistory.length = 0;
	        this.removeAllListeners();
	    }
	}

	/**
	 * Advanced frame rate management and monitoring system
	 * Provides precise FPS control and stability analysis
	 */
	class FrameRateManager extends EventEmitter {
	    constructor() {
	        super();
	        this.isInitialized = false;
	        this.isRunning = false;
	        // Frame timing
	        this.currentFps = 0;
	        this.targetFps = 60;
	        this.frameTime = 0;
	        this.lastFrameTime = 0;
	        this.frameTimes = [];
	        this.fpsHistory = [];
	        // Stability analysis
	        this.frameTimeVariance = 0;
	        this.fpsStability = 1.0; // 0-1 scale
	        this.droppedFrames = 0;
	        this.stableFrameCount = 0;
	        this.unstableFrameCount = 0;
	        // Performance thresholds
	        this.STABLE_FPS_THRESHOLD = 0.95; // 95% of target FPS
	        this.FRAME_TIME_HISTORY_SIZE = 120; // 2 seconds at 60fps
	        this.VARIANCE_THRESHOLD = 4.0; // ms variance for stability
	        // Adaptive features
	        this.dynamicTargetEnabled = false;
	        this.performanceProfile = 'balanced';
	        this.thermalThrottling = false;
	        this.config = {
	            targetFps: 60,
	            maxDeltaTime: 100,
	            fixedTimeStep: false,
	            adaptiveFrameRate: true,
	            vsyncEnabled: true,
	            frameSkipping: false,
	            maxFrameSkip: 0
	        };
	    }
	    /**
	     * Initialize the frame rate manager
	     */
	    initialize(config = {}) {
	        this.config = { ...this.config, ...config };
	        this.targetFps = this.config.targetFps;
	        this.isInitialized = true;
	        // Reset all metrics
	        this.resetMetrics();
	        this.emit('initialized', this.config);
	    }
	    /**
	     * Start frame rate monitoring
	     */
	    start() {
	        if (!this.isInitialized) {
	            throw new Error('FrameRateManager must be initialized before starting');
	        }
	        if (this.isRunning)
	            return;
	        this.isRunning = true;
	        this.lastFrameTime = performance.now();
	        this.resetMetrics();
	        this.emit('started');
	    }
	    /**
	     * Stop frame rate monitoring
	     */
	    stop() {
	        if (!this.isRunning)
	            return;
	        this.isRunning = false;
	        this.emit('stopped');
	    }
	    /**
	     * Update frame rate metrics (called each frame)
	     */
	    update(deltaTime) {
	        if (!this.isRunning)
	            return;
	        const currentTime = performance.now();
	        this.frameTime = currentTime - this.lastFrameTime;
	        this.lastFrameTime = currentTime;
	        // Calculate FPS from frame time
	        this.currentFps = 1000 / this.frameTime;
	        // Update histories
	        this.updateFrameHistory(this.frameTime, this.currentFps);
	        // Calculate stability metrics
	        this.calculateStabilityMetrics();
	        // Check for frame drops
	        this.detectFrameDrops();
	        // Adaptive adjustments
	        if (this.config.adaptiveFrameRate) {
	            this.adaptiveFrameRateAdjustment();
	        }
	        // Emit metrics periodically
	        if (this.frameTimes.length % 60 === 0) {
	            this.emitMetrics();
	        }
	    }
	    /**
	     * Update frame time and FPS history
	     */
	    updateFrameHistory(frameTime, fps) {
	        // Add to histories
	        this.frameTimes.push(frameTime);
	        this.fpsHistory.push(fps);
	        // Limit history size
	        if (this.frameTimes.length > this.FRAME_TIME_HISTORY_SIZE) {
	            this.frameTimes.shift();
	            this.fpsHistory.shift();
	        }
	    }
	    /**
	     * Calculate frame rate stability metrics
	     */
	    calculateStabilityMetrics() {
	        if (this.frameTimes.length < 30)
	            return; // Need some data
	        // Calculate frame time variance
	        const recentFrameTimes = this.frameTimes.slice(-60); // Last 1 second
	        const avgFrameTime = recentFrameTimes.reduce((sum, time) => sum + time, 0) / recentFrameTimes.length;
	        const squaredDiffs = recentFrameTimes.map(time => Math.pow(time - avgFrameTime, 2));
	        this.frameTimeVariance = squaredDiffs.reduce((sum, diff) => sum + diff, 0) / recentFrameTimes.length;
	        // Calculate FPS stability (0-1 scale)
	        const recentFps = this.fpsHistory.slice(-60);
	        const avgFps = recentFps.reduce((sum, fps) => sum + fps, 0) / recentFps.length;
	        const targetRatio = avgFps / this.targetFps;
	        // Stability is high when FPS is close to target and variance is low
	        const fpsStability = Math.max(0, Math.min(1, targetRatio));
	        const varianceStability = Math.max(0, 1 - (this.frameTimeVariance / (this.VARIANCE_THRESHOLD * this.VARIANCE_THRESHOLD)));
	        this.fpsStability = (fpsStability + varianceStability) / 2;
	        // Update stable/unstable frame counts
	        if (this.isFrameRateStable()) {
	            this.stableFrameCount++;
	            this.unstableFrameCount = 0;
	        }
	        else {
	            this.unstableFrameCount++;
	            this.stableFrameCount = Math.max(0, this.stableFrameCount - 1);
	        }
	    }
	    /**
	     * Detect frame drops and performance issues
	     */
	    detectFrameDrops() {
	        const expectedFrameTime = 1000 / this.targetFps;
	        const dropThreshold = expectedFrameTime * 1.5; // 50% longer than expected
	        if (this.frameTime > dropThreshold) {
	            this.droppedFrames++;
	            this.emit('frame-drop', {
	                frameTime: this.frameTime,
	                expectedTime: expectedFrameTime,
	                severity: this.frameTime > expectedFrameTime * 2 ? 'high' : 'medium'
	            });
	        }
	        // Reset dropped frames counter periodically
	        if (this.frameTimes.length % 300 === 0) { // Every 5 seconds
	            this.droppedFrames = 0;
	        }
	    }
	    /**
	     * Adaptive frame rate adjustment based on performance
	     */
	    adaptiveFrameRateAdjustment() {
	        if (!this.dynamicTargetEnabled)
	            return;
	        const avgFps = this.getAverageFps();
	        const stability = this.fpsStability;
	        // Adjust target based on device capabilities and thermal state
	        if (this.thermalThrottling) {
	            // Reduce target FPS during thermal throttling
	            this.adjustTargetFps(Math.min(this.targetFps, 45));
	        }
	        else if (stability < 0.8 && avgFps < this.targetFps * 0.9) {
	            // Performance is poor, reduce target
	            const newTarget = Math.max(30, this.targetFps - 5);
	            this.adjustTargetFps(newTarget);
	        }
	        else if (stability > 0.95 && avgFps > this.targetFps * 1.05) {
	            // Performance is excellent, potentially increase target
	            if (this.performanceProfile === 'performance') {
	                const newTarget = Math.min(120, this.targetFps + 5);
	                this.adjustTargetFps(newTarget);
	            }
	        }
	    }
	    /**
	     * Adjust target FPS with validation
	     */
	    adjustTargetFps(newTarget) {
	        const oldTarget = this.targetFps;
	        this.targetFps = Math.max(30, Math.min(120, newTarget));
	        if (oldTarget !== this.targetFps) {
	            this.emit('target-fps-changed', {
	                oldTarget,
	                newTarget: this.targetFps,
	                reason: this.thermalThrottling ? 'thermal' : 'performance'
	            });
	        }
	    }
	    /**
	     * Emit current metrics
	     */
	    emitMetrics() {
	        const metrics = {
	            currentFps: Math.round(this.currentFps),
	            averageFps: Math.round(this.getAverageFps()),
	            targetFps: this.targetFps,
	            frameTime: Math.round(this.frameTime * 100) / 100,
	            averageFrameTime: Math.round(this.getAverageFrameTime() * 100) / 100,
	            frameTimeVariance: Math.round(this.frameTimeVariance * 100) / 100,
	            stability: Math.round(this.fpsStability * 100) / 100,
	            isStable: this.isFrameRateStable(),
	            droppedFrames: this.droppedFrames,
	            stableFrameCount: this.stableFrameCount,
	            unstableFrameCount: this.unstableFrameCount
	        };
	        this.emit('metrics-updated', metrics);
	    }
	    /**
	     * Reset all metrics
	     */
	    resetMetrics() {
	        this.currentFps = 0;
	        this.frameTime = 0;
	        this.frameTimes.length = 0;
	        this.fpsHistory.length = 0;
	        this.frameTimeVariance = 0;
	        this.fpsStability = 1.0;
	        this.droppedFrames = 0;
	        this.stableFrameCount = 0;
	        this.unstableFrameCount = 0;
	    }
	    /**
	     * Get current FPS
	     */
	    getCurrentFps() {
	        return Math.round(this.currentFps);
	    }
	    /**
	     * Get target FPS
	     */
	    getTargetFps() {
	        return this.targetFps;
	    }
	    /**
	     * Set target FPS
	     */
	    setTargetFps(fps) {
	        const oldTarget = this.targetFps;
	        this.targetFps = Math.max(30, Math.min(120, fps));
	        this.config.targetFps = this.targetFps;
	        if (oldTarget !== this.targetFps) {
	            this.emit('target-fps-changed', {
	                oldTarget,
	                newTarget: this.targetFps,
	                reason: 'manual'
	            });
	        }
	    }
	    /**
	     * Get current frame time in milliseconds
	     */
	    getFrameTime() {
	        return this.frameTime;
	    }
	    /**
	     * Get average FPS over recent history
	     */
	    getAverageFps() {
	        if (this.fpsHistory.length === 0)
	            return 0;
	        const recentFps = this.fpsHistory.slice(-60); // Last 1 second
	        return recentFps.reduce((sum, fps) => sum + fps, 0) / recentFps.length;
	    }
	    /**
	     * Get average frame time over recent history
	     */
	    getAverageFrameTime() {
	        if (this.frameTimes.length === 0)
	            return 0;
	        const recentTimes = this.frameTimes.slice(-60); // Last 1 second
	        return recentTimes.reduce((sum, time) => sum + time, 0) / recentTimes.length;
	    }
	    /**
	     * Check if frame rate is stable
	     */
	    isFrameRateStable() {
	        if (this.frameTimes.length < 30)
	            return true; // Not enough data
	        const avgFps = this.getAverageFps();
	        const isWithinTarget = avgFps >= (this.targetFps * this.STABLE_FPS_THRESHOLD);
	        const hasLowVariance = this.frameTimeVariance < this.VARIANCE_THRESHOLD;
	        return isWithinTarget && hasLowVariance;
	    }
	    /**
	     * Get frame rate stability score (0-1)
	     */
	    getStabilityScore() {
	        return this.fpsStability;
	    }
	    /**
	     * Get performance quality assessment
	     */
	    getPerformanceQuality() {
	        const avgFps = this.getAverageFps();
	        const targetRatio = avgFps / this.targetFps;
	        const stability = this.fpsStability;
	        if (targetRatio >= 0.98 && stability >= 0.9)
	            return 'excellent';
	        if (targetRatio >= 0.9 && stability >= 0.8)
	            return 'good';
	        if (targetRatio >= 0.8 && stability >= 0.6)
	            return 'fair';
	        return 'poor';
	    }
	    /**
	     * Set performance profile
	     */
	    setPerformanceProfile(profile) {
	        this.performanceProfile = profile;
	        // Adjust target FPS based on profile
	        switch (profile) {
	            case 'battery':
	                this.setTargetFps(30);
	                break;
	            case 'balanced':
	                this.setTargetFps(60);
	                break;
	            case 'performance':
	                this.setTargetFps(120);
	                this.dynamicTargetEnabled = true;
	                break;
	        }
	        this.emit('performance-profile-changed', profile);
	    }
	    /**
	     * Enable/disable dynamic target FPS
	     */
	    setDynamicTargetEnabled(enabled) {
	        this.dynamicTargetEnabled = enabled;
	        this.emit('dynamic-target-changed', enabled);
	    }
	    /**
	     * Set thermal throttling state
	     */
	    setThermalThrottling(enabled) {
	        this.thermalThrottling = enabled;
	        if (enabled) {
	            // Reduce target FPS during thermal throttling
	            this.adjustTargetFps(Math.min(this.targetFps, 45));
	        }
	        else {
	            // Restore normal target based on profile
	            this.setPerformanceProfile(this.performanceProfile);
	        }
	        this.emit('thermal-throttling-changed', enabled);
	    }
	    /**
	     * Get detailed performance report
	     */
	    getPerformanceReport() {
	        return {
	            // Current metrics
	            currentFps: this.getCurrentFps(),
	            targetFps: this.getTargetFps(),
	            averageFps: Math.round(this.getAverageFps()),
	            frameTime: Math.round(this.frameTime * 100) / 100,
	            averageFrameTime: Math.round(this.getAverageFrameTime() * 100) / 100,
	            // Stability metrics
	            frameTimeVariance: Math.round(this.frameTimeVariance * 100) / 100,
	            stabilityScore: Math.round(this.fpsStability * 100) / 100,
	            isStable: this.isFrameRateStable(),
	            performanceQuality: this.getPerformanceQuality(),
	            // Frame tracking
	            droppedFrames: this.droppedFrames,
	            stableFrameCount: this.stableFrameCount,
	            unstableFrameCount: this.unstableFrameCount,
	            // Configuration
	            performanceProfile: this.performanceProfile,
	            dynamicTargetEnabled: this.dynamicTargetEnabled,
	            thermalThrottling: this.thermalThrottling,
	            // History sizes
	            frameHistorySize: this.frameTimes.length,
	            fpsHistorySize: this.fpsHistory.length
	        };
	    }
	    /**
	     * Export frame rate data for analysis
	     */
	    exportData() {
	        return {
	            frameTimes: [...this.frameTimes],
	            fpsHistory: [...this.fpsHistory],
	            config: { ...this.config },
	            metrics: this.getPerformanceReport(),
	            timestamp: Date.now()
	        };
	    }
	    /**
	     * Clean up resources
	     */
	    destroy() {
	        this.stop();
	        this.frameTimes.length = 0;
	        this.fpsHistory.length = 0;
	        this.removeAllListeners();
	        this.isInitialized = false;
	    }
	}

	/**
	 * Object pool implementation for memory optimization
	 */
	class GameByteObjectPool {
	    constructor(config) {
	        this.pool = [];
	        this.inUseObjects = new Set();
	        this.totalCreated = 0;
	        this.totalReused = 0;
	        this.config = config;
	        this.grow(config.initialSize);
	    }
	    /**
	     * Get an object from the pool
	     */
	    get() {
	        let obj;
	        if (this.pool.length > 0) {
	            obj = this.pool.pop();
	            this.totalReused++;
	        }
	        else if (this.inUseObjects.size < this.config.maxSize) {
	            obj = this.config.createFunction();
	            this.totalCreated++;
	        }
	        else {
	            throw new Error('Object pool exhausted');
	        }
	        this.inUseObjects.add(obj);
	        return obj;
	    }
	    /**
	     * Release an object back to the pool
	     */
	    release(obj) {
	        if (!this.inUseObjects.has(obj)) {
	            console.warn('Attempting to release object not from this pool');
	            return;
	        }
	        this.inUseObjects.delete(obj);
	        // Reset object if reset function provided
	        if (this.config.resetFunction) {
	            this.config.resetFunction(obj);
	        }
	        this.pool.push(obj);
	        // Shrink pool if it's getting too large
	        if (this.pool.length > this.config.shrinkThreshold) {
	            this.shrink();
	        }
	    }
	    /**
	     * Clear all objects from the pool
	     */
	    clear() {
	        // Destroy objects if destroy function provided
	        if (this.config.destroyFunction) {
	            this.pool.forEach(obj => this.config.destroyFunction(obj));
	            this.inUseObjects.forEach(obj => this.config.destroyFunction(obj));
	        }
	        this.pool.length = 0;
	        this.inUseObjects.clear();
	    }
	    /**
	     * Get total pool size
	     */
	    size() {
	        return this.pool.length + this.inUseObjects.size;
	    }
	    /**
	     * Get available objects count
	     */
	    available() {
	        return this.pool.length;
	    }
	    /**
	     * Get in-use objects count
	     */
	    inUse() {
	        return this.inUseObjects.size;
	    }
	    /**
	     * Grow the pool by specified count
	     */
	    grow(count) {
	        for (let i = 0; i < count; i++) {
	            if (this.size() >= this.config.maxSize)
	                break;
	            this.pool.push(this.config.createFunction());
	            this.totalCreated++;
	        }
	    }
	    /**
	     * Shrink the pool by removing excess objects
	     */
	    shrink() {
	        const excess = this.pool.length - this.config.shrinkThreshold;
	        if (excess > 0) {
	            const removed = this.pool.splice(0, excess);
	            if (this.config.destroyFunction) {
	                removed.forEach(obj => this.config.destroyFunction(obj));
	            }
	        }
	    }
	    /**
	     * Get pool statistics
	     */
	    getStats() {
	        return {
	            totalSize: this.size(),
	            available: this.available(),
	            inUse: this.inUse(),
	            totalCreated: this.totalCreated,
	            totalReused: this.totalReused,
	            reuseRatio: this.totalReused / (this.totalCreated + this.totalReused)
	        };
	    }
	}
	/**
	 * Memory optimization and management system
	 */
	class MemoryOptimizer extends EventEmitter {
	    constructor() {
	        super(...arguments);
	        this.isInitialized = false;
	        this.objectPools = new Map();
	        this.memoryMonitorInterval = null;
	        this.gcScheduleInterval = null;
	        // Memory tracking
	        this.memoryHistory = [];
	        this.maxHistorySize = 300; // 5 minutes at 1 sample per second
	        this.lastMemoryInfo = null;
	        this.memoryLeaks = [];
	        // GC tracking
	        this.gcCount = 0;
	        this.totalGcTime = 0;
	        this.lastGcTime = 0;
	        this.forcedGcCount = 0;
	        // Memory pressure detection
	        this.memoryPressureThreshold = 0.8; // 80% of available memory
	        this.memoryWarningThreshold = 0.9; // 90% of available memory
	        this.memoryLeakThreshold = 50 * 1024 * 1024; // 50MB growth without GC
	        // Performance optimization
	        this.autoGcEnabled = true;
	        this.gcScheduleMs = 30000; // 30 seconds
	        this.memoryMonitorMs = 1000; // 1 second
	    }
	    /**
	     * Initialize memory optimizer
	     */
	    initialize() {
	        if (this.isInitialized)
	            return;
	        this.isInitialized = true;
	        this.setupMemoryMonitoring();
	        this.setupGarbageCollectionScheduling();
	        // Create default object pools
	        this.createDefaultPools();
	        this.emit('initialized');
	    }
	    /**
	     * Get current memory usage information
	     */
	    getMemoryUsage() {
	        const memory = performance.memory;
	        const info = {
	            used: 0,
	            total: 0,
	            percentage: 0,
	            jsHeapSizeUsed: 0,
	            jsHeapSizeTotal: 0,
	            jsHeapSizeLimit: 0,
	            gcCount: this.gcCount,
	            gcTime: this.totalGcTime
	        };
	        if (memory) {
	            info.jsHeapSizeUsed = memory.usedJSHeapSize;
	            info.jsHeapSizeTotal = memory.totalJSHeapSize;
	            info.jsHeapSizeLimit = memory.jsHeapSizeLimit;
	            info.used = memory.usedJSHeapSize;
	            info.total = memory.jsHeapSizeLimit;
	            info.percentage = (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100;
	        }
	        else {
	            // Fallback for browsers without memory API
	            info.used = 50 * 1024 * 1024; // Estimate 50MB
	            info.total = 100 * 1024 * 1024; // Estimate 100MB
	            info.percentage = 50;
	        }
	        this.lastMemoryInfo = info;
	        return info;
	    }
	    /**
	     * Setup memory monitoring
	     */
	    setupMemoryMonitoring() {
	        this.memoryMonitorInterval = window.setInterval(() => {
	            const memInfo = this.getMemoryUsage();
	            this.memoryHistory.push(memInfo);
	            // Limit history size
	            if (this.memoryHistory.length > this.maxHistorySize) {
	                this.memoryHistory.shift();
	            }
	            // Check for memory pressure
	            this.checkMemoryPressure(memInfo);
	            // Detect potential memory leaks
	            this.detectMemoryLeaksInternal();
	            this.emit('memory-updated', memInfo);
	        }, this.memoryMonitorMs);
	    }
	    /**
	     * Setup garbage collection scheduling
	     */
	    setupGarbageCollectionScheduling() {
	        if (!this.autoGcEnabled)
	            return;
	        this.gcScheduleInterval = window.setInterval(() => {
	            this.scheduleGC();
	        }, this.gcScheduleMs);
	    }
	    /**
	     * Check for memory pressure and emit warnings
	     */
	    checkMemoryPressure(memInfo) {
	        const pressureLevel = memInfo.percentage / 100;
	        if (pressureLevel >= this.memoryWarningThreshold) {
	            this.emit('memory-warning', {
	                level: 'critical',
	                percentage: memInfo.percentage,
	                message: 'Memory usage is critically high'
	            });
	            // Force garbage collection
	            this.optimizeMemory();
	        }
	        else if (pressureLevel >= this.memoryPressureThreshold) {
	            this.emit('memory-warning', {
	                level: 'high',
	                percentage: memInfo.percentage,
	                message: 'Memory usage is high'
	            });
	        }
	    }
	    /**
	     * Detect potential memory leaks
	     */
	    detectMemoryLeaksInternal() {
	        if (this.memoryHistory.length < 60)
	            return; // Need at least 1 minute of data
	        const recentHistory = this.memoryHistory.slice(-60); // Last 1 minute
	        const oldHistory = this.memoryHistory.slice(-120, -60); // Previous 1 minute
	        if (oldHistory.length === 0)
	            return;
	        const recentAvg = recentHistory.reduce((sum, info) => sum + info.used, 0) / recentHistory.length;
	        const oldAvg = oldHistory.reduce((sum, info) => sum + info.used, 0) / oldHistory.length;
	        const growth = recentAvg - oldAvg;
	        if (growth > this.memoryLeakThreshold) {
	            const leak = {
	                type: 'sustained_growth',
	                count: 1,
	                size: growth,
	                severity: growth > this.memoryLeakThreshold * 2 ? 'high' : 'medium',
	                location: 'unknown'
	            };
	            this.memoryLeaks.push(leak);
	            this.emit('memory-leak-detected', leak);
	            // Limit leak history
	            if (this.memoryLeaks.length > 10) {
	                this.memoryLeaks.shift();
	            }
	        }
	    }
	    /**
	     * Get detected memory leaks
	     */
	    detectMemoryLeaks() {
	        return [...this.memoryLeaks];
	    }
	    /**
	     * Optimize memory usage
	     */
	    optimizeMemory() {
	        const startTime = performance.now();
	        // Force garbage collection if available
	        this.forceGC();
	        // Optimize object pools
	        this.optimizeObjectPools();
	        // Clear memory history to prevent it from growing too large
	        if (this.memoryHistory.length > this.maxHistorySize * 1.5) {
	            this.memoryHistory = this.memoryHistory.slice(-this.maxHistorySize);
	        }
	        const endTime = performance.now();
	        const optimizationTime = endTime - startTime;
	        this.emit('memory-optimized', {
	            duration: optimizationTime,
	            beforeMemory: this.lastMemoryInfo,
	            afterMemory: this.getMemoryUsage()
	        });
	    }
	    /**
	     * Schedule garbage collection
	     */
	    scheduleGC() {
	        if (!this.autoGcEnabled)
	            return;
	        const memInfo = this.getMemoryUsage();
	        // Only trigger GC if memory usage is above threshold
	        if (memInfo.percentage > 70) {
	            this.forceGC();
	        }
	    }
	    /**
	     * Force garbage collection if available
	     */
	    forceGC() {
	        const startTime = performance.now();
	        try {
	            // Try different GC methods
	            if (window.gc) {
	                window.gc();
	            }
	            else if (window.CollectGarbage) {
	                window.CollectGarbage();
	            }
	            else {
	                // Fallback: create and release large objects to trigger GC
	                this.triggerGCFallback();
	            }
	            const endTime = performance.now();
	            const gcTime = endTime - startTime;
	            this.gcCount++;
	            this.totalGcTime += gcTime;
	            this.lastGcTime = gcTime;
	            this.forcedGcCount++;
	            this.emit('gc-completed', {
	                duration: gcTime,
	                method: 'forced'
	            });
	        }
	        catch (error) {
	            this.emit('gc-error', error);
	        }
	    }
	    /**
	     * Fallback method to trigger GC by memory pressure
	     */
	    triggerGCFallback() {
	        // Create large temporary objects to trigger GC
	        const temp = [];
	        for (let i = 0; i < 1000; i++) {
	            temp.push(new Array(1000).fill(Math.random()));
	        }
	        // Objects will be collected when temp goes out of scope
	    }
	    /**
	     * Optimize all object pools
	     */
	    optimizeObjectPools() {
	        this.objectPools.forEach((pool, name) => {
	            try {
	                pool.shrink();
	            }
	            catch (error) {
	                this.emit('pool-optimization-error', { poolName: name, error });
	            }
	        });
	    }
	    /**
	     * Create default object pools for common objects
	     */
	    createDefaultPools() {
	        // Vector2 pool
	        this.registerPool('Vector2', {
	            initialSize: 100,
	            maxSize: 1000,
	            growthFactor: 1.5,
	            shrinkThreshold: 200,
	            createFunction: () => ({ x: 0, y: 0 }),
	            resetFunction: (obj) => {
	                obj.x = 0;
	                obj.y = 0;
	            }
	        });
	        // Array pool for temporary calculations
	        this.registerPool('TempArray', {
	            initialSize: 50,
	            maxSize: 500,
	            growthFactor: 1.5,
	            shrinkThreshold: 100,
	            createFunction: () => [],
	            resetFunction: (arr) => {
	                arr.length = 0;
	            }
	        });
	        // Object pool for temporary objects
	        this.registerPool('TempObject', {
	            initialSize: 50,
	            maxSize: 500,
	            growthFactor: 1.5,
	            shrinkThreshold: 100,
	            createFunction: () => ({}),
	            resetFunction: (obj) => {
	                for (const key in obj) {
	                    delete obj[key];
	                }
	            }
	        });
	    }
	    /**
	     * Create a new object pool
	     */
	    createObjectPool(config) {
	        const pool = new GameByteObjectPool(config);
	        return pool;
	    }
	    /**
	     * Get object pools map
	     */
	    getObjectPools() {
	        return new Map(this.objectPools);
	    }
	    /**
	     * Register a named object pool
	     */
	    registerPool(name, config) {
	        if (this.objectPools.has(name)) {
	            throw new Error(`Object pool '${name}' already exists`);
	        }
	        const pool = new GameByteObjectPool(config);
	        this.objectPools.set(name, pool);
	        this.emit('pool-created', { name, config });
	        return pool;
	    }
	    /**
	     * Get object pool by name
	     */
	    getPool(name) {
	        return this.objectPools.get(name) || null;
	    }
	    /**
	     * Remove object pool
	     */
	    removePool(name) {
	        const pool = this.objectPools.get(name);
	        if (pool) {
	            pool.clear();
	            this.objectPools.delete(name);
	            this.emit('pool-removed', name);
	            return true;
	        }
	        return false;
	    }
	    /**
	     * Get memory optimization report
	     */
	    getReport() {
	        const currentMemory = this.getMemoryUsage();
	        const poolStats = Array.from(this.objectPools.entries()).map(([name, pool]) => ({
	            name,
	            stats: pool.getStats()
	        }));
	        return {
	            currentMemory,
	            memoryHistory: this.memoryHistory.slice(-10), // Last 10 entries
	            gcStats: {
	                count: this.gcCount,
	                totalTime: this.totalGcTime,
	                lastTime: this.lastGcTime,
	                forcedCount: this.forcedGcCount
	            },
	            objectPools: poolStats,
	            memoryLeaks: this.memoryLeaks,
	            settings: {
	                autoGcEnabled: this.autoGcEnabled,
	                memoryPressureThreshold: this.memoryPressureThreshold,
	                memoryWarningThreshold: this.memoryWarningThreshold,
	                gcScheduleMs: this.gcScheduleMs
	            }
	        };
	    }
	    /**
	     * Set auto GC enabled state
	     */
	    setAutoGCEnabled(enabled) {
	        this.autoGcEnabled = enabled;
	        if (enabled && !this.gcScheduleInterval) {
	            this.setupGarbageCollectionScheduling();
	        }
	        else if (!enabled && this.gcScheduleInterval) {
	            clearInterval(this.gcScheduleInterval);
	            this.gcScheduleInterval = null;
	        }
	        this.emit('auto-gc-changed', enabled);
	    }
	    /**
	     * Set memory pressure thresholds
	     */
	    setMemoryThresholds(pressure, warning) {
	        this.memoryPressureThreshold = Math.max(0.5, Math.min(1.0, pressure));
	        this.memoryWarningThreshold = Math.max(0.5, Math.min(1.0, warning));
	        this.emit('thresholds-changed', {
	            pressure: this.memoryPressureThreshold,
	            warning: this.memoryWarningThreshold
	        });
	    }
	    /**
	     * Clean up resources
	     */
	    destroy() {
	        if (this.memoryMonitorInterval) {
	            clearInterval(this.memoryMonitorInterval);
	            this.memoryMonitorInterval = null;
	        }
	        if (this.gcScheduleInterval) {
	            clearInterval(this.gcScheduleInterval);
	            this.gcScheduleInterval = null;
	        }
	        // Clear all object pools
	        this.objectPools.forEach((pool) => {
	            pool.clear();
	        });
	        this.objectPools.clear();
	        // Clear history
	        this.memoryHistory.length = 0;
	        this.memoryLeaks.length = 0;
	        this.removeAllListeners();
	        this.isInitialized = false;
	    }
	}

	/**
	 * Advanced rendering optimizer with batching and culling
	 */
	class RenderingOptimizer extends EventEmitter {
	    constructor() {
	        super();
	        this.isInitialized = false;
	        // Batch rendering
	        this.batchGroups = new Map();
	        this.renderQueue = [];
	        this.maxBatchSize = 1000;
	        this.batchingEnabled = true;
	        // Culling systems
	        this.frustumCullingEnabled = true;
	        this.occlusionCullingEnabled = false;
	        this.distanceCullingEnabled = true;
	        this.maxRenderDistance = 1000;
	        // LOD system
	        this.lodLevels = [];
	        this.lodEnabled = true;
	        // Render statistics
	        this.renderStats = {
	            drawCalls: 0,
	            triangles: 0,
	            visibleObjects: 0,
	            culledObjects: 0,
	            batchedObjects: 0,
	            textureSwaps: 0,
	            shaderSwaps: 0
	        };
	        // Performance tracking
	        this.frameRenderTime = 0;
	        this.lastFrameStats = { ...this.renderStats };
	        this.renderTimeHistory = [];
	        // Texture atlas for batching
	        this.textureAtlas = new Map();
	        this.atlasTexture = null;
	        // Occlusion culling
	        this.occlusionQueries = new Map();
	        this.occlusionResults = new Map();
	        this.config = {
	            maxBatchSize: 1000,
	            sortingEnabled: true,
	            textureAtlasing: true,
	            instancedRendering: false,
	            frustumCulling: true,
	            occlusionCulling: false,
	            distanceCulling: true,
	            maxDistance: 1000
	        };
	        // Initialize default LOD levels
	        this.lodLevels = [
	            { distance: 0, quality: exports.QualityLevel.ULTRA_HIGH, enabled: true },
	            { distance: 100, quality: exports.QualityLevel.HIGH, enabled: true },
	            { distance: 300, quality: exports.QualityLevel.MEDIUM, enabled: true },
	            { distance: 600, quality: exports.QualityLevel.LOW, enabled: true },
	            { distance: 1000, quality: exports.QualityLevel.ULTRA_LOW, enabled: true }
	        ];
	    }
	    /**
	     * Initialize the rendering optimizer
	     */
	    initialize(config = {}) {
	        this.config = { ...this.config, ...config };
	        this.maxBatchSize = this.config.maxBatchSize;
	        this.frustumCullingEnabled = this.config.frustumCulling;
	        this.occlusionCullingEnabled = this.config.occlusionCulling;
	        this.distanceCullingEnabled = this.config.distanceCulling;
	        this.maxRenderDistance = this.config.maxDistance;
	        this.resetStats();
	        this.isInitialized = true;
	        this.emit('initialized', this.config);
	    }
	    /**
	     * Enable batch rendering
	     */
	    enableBatching() {
	        this.batchingEnabled = true;
	        this.emit('batching-enabled');
	    }
	    /**
	     * Disable batch rendering
	     */
	    disableBatching() {
	        this.batchingEnabled = false;
	        this.clearBatches();
	        this.emit('batching-disabled');
	    }
	    /**
	     * Enable culling systems
	     */
	    enableCulling() {
	        this.frustumCullingEnabled = true;
	        this.distanceCullingEnabled = true;
	        this.emit('culling-enabled');
	    }
	    /**
	     * Disable culling systems
	     */
	    disableCulling() {
	        this.frustumCullingEnabled = false;
	        this.distanceCullingEnabled = false;
	        this.occlusionCullingEnabled = false;
	        this.emit('culling-disabled');
	    }
	    /**
	     * Set LOD levels configuration
	     */
	    setLODLevels(levels) {
	        this.lodLevels = [...levels].sort((a, b) => a.distance - b.distance);
	        this.emit('lod-levels-updated', this.lodLevels);
	    }
	    /**
	     * Update culling calculations
	     */
	    updateCulling(camera) {
	        if (!this.isInitialized)
	            return;
	        const startTime = performance.now();
	        // Update camera frustum if needed
	        if (this.frustumCullingEnabled && !camera.frustum) {
	            camera.frustum = this.calculateFrustum(camera);
	        }
	        // Reset culling stats
	        this.renderStats.visibleObjects = 0;
	        this.renderStats.culledObjects = 0;
	        // Process render queue
	        for (const obj of this.renderQueue) {
	            obj.distanceFromCamera = this.calculateDistance(camera.position, obj.position);
	            let visible = obj.visible;
	            // Distance culling
	            if (visible && this.distanceCullingEnabled) {
	                visible = obj.distanceFromCamera <= this.maxRenderDistance;
	            }
	            // Frustum culling
	            if (visible && this.frustumCullingEnabled && camera.frustum) {
	                visible = this.isInFrustum(obj, camera.frustum);
	            }
	            // Occlusion culling
	            if (visible && this.occlusionCullingEnabled) {
	                visible = !this.isOccluded(obj, camera);
	            }
	            // LOD calculation
	            if (visible && this.lodEnabled) {
	                obj.lodLevel = this.calculateLOD(obj.distanceFromCamera);
	                // Skip if LOD level is disabled
	                const lodConfig = this.lodLevels.find(l => l.quality === obj.lodLevel);
	                if (lodConfig && !lodConfig.enabled) {
	                    visible = false;
	                }
	            }
	            if (visible) {
	                this.renderStats.visibleObjects++;
	            }
	            else {
	                this.renderStats.culledObjects++;
	            }
	            obj.visible = visible;
	        }
	        const cullingTime = performance.now() - startTime;
	        this.emit('culling-updated', {
	            time: cullingTime,
	            visible: this.renderStats.visibleObjects,
	            culled: this.renderStats.culledObjects
	        });
	    }
	    /**
	     * Calculate camera frustum planes
	     */
	    calculateFrustum(camera) {
	        const frustum = { planes: [] };
	        // Simplified frustum calculation
	        // In a real implementation, this would use proper matrix math
	        const fov = camera.fov || 75;
	        const aspect = 16 / 9; // Default aspect ratio
	        // Calculate frustum planes (simplified)
	        const halfFov = (fov * Math.PI / 180) / 2;
	        const nearHeight = 2 * Math.tan(halfFov) * camera.near;
	        const nearWidth = nearHeight * aspect;
	        2 * Math.tan(halfFov) * camera.far;
	        // Create six frustum planes
	        frustum.planes = [
	            { normal: { x: 0, y: 0, z: 1 }, distance: -camera.near }, // Near
	            { normal: { x: 0, y: 0, z: -1 }, distance: camera.far }, // Far
	            { normal: { x: 1, y: 0, z: 0 }, distance: nearWidth / 2 }, // Left
	            { normal: { x: -1, y: 0, z: 0 }, distance: nearWidth / 2 }, // Right
	            { normal: { x: 0, y: 1, z: 0 }, distance: nearHeight / 2 }, // Bottom
	            { normal: { x: 0, y: -1, z: 0 }, distance: nearHeight / 2 } // Top
	        ];
	        return frustum;
	    }
	    /**
	     * Check if object is within camera frustum
	     */
	    isInFrustum(obj, frustum) {
	        // Simplified frustum culling - check object bounds against frustum planes
	        for (const plane of frustum.planes) {
	            const distance = plane.normal.x * obj.position.x +
	                plane.normal.y * obj.position.y +
	                plane.normal.z * (obj.position.z || 0) -
	                plane.distance;
	            // If object is completely outside any plane, it's culled
	            if (distance < -10) { // Add small buffer
	                return false;
	            }
	        }
	        return true;
	    }
	    /**
	     * Check if object is occluded
	     */
	    isOccluded(obj, camera) {
	        // Simplified occlusion culling
	        // In a real implementation, this would use occlusion queries or spatial data structures
	        const result = this.occlusionResults.get(obj.id);
	        return result !== undefined ? result : false;
	    }
	    /**
	     * Calculate distance between two points
	     */
	    calculateDistance(pos1, pos2) {
	        const dx = pos2.x - pos1.x;
	        const dy = pos2.y - pos1.y;
	        const dz = (pos2.z || 0) - (pos1.z || 0);
	        return Math.sqrt(dx * dx + dy * dy + dz * dz);
	    }
	    /**
	     * Calculate LOD level based on distance
	     */
	    calculateLOD(distance) {
	        for (let i = this.lodLevels.length - 1; i >= 0; i--) {
	            if (distance >= this.lodLevels[i].distance) {
	                return this.lodLevels[i].quality;
	            }
	        }
	        return exports.QualityLevel.ULTRA_HIGH;
	    }
	    /**
	     * Add object to render queue
	     */
	    addToRenderQueue(obj) {
	        this.renderQueue.push(obj);
	        if (this.batchingEnabled) {
	            this.addToBatch(obj);
	        }
	    }
	    /**
	     * Remove object from render queue
	     */
	    removeFromRenderQueue(objId) {
	        const index = this.renderQueue.findIndex(obj => obj.id === objId);
	        if (index !== -1) {
	            const obj = this.renderQueue[index];
	            this.renderQueue.splice(index, 1);
	            if (this.batchingEnabled) {
	                this.removeFromBatch(obj);
	            }
	        }
	    }
	    /**
	     * Add object to appropriate batch group
	     */
	    addToBatch(obj) {
	        const batchKey = this.getBatchKey(obj);
	        let batch = this.batchGroups.get(batchKey);
	        if (!batch) {
	            batch = this.createBatchGroup(obj);
	            this.batchGroups.set(batchKey, batch);
	        }
	        batch.objects.push(obj);
	        batch.dirty = true;
	        // Split batch if it gets too large
	        if (batch.objects.length > this.maxBatchSize) {
	            this.splitBatch(batchKey, batch);
	        }
	    }
	    /**
	     * Remove object from batch group
	     */
	    removeFromBatch(obj) {
	        const batchKey = this.getBatchKey(obj);
	        const batch = this.batchGroups.get(batchKey);
	        if (batch) {
	            const index = batch.objects.findIndex(o => o.id === obj.id);
	            if (index !== -1) {
	                batch.objects.splice(index, 1);
	                batch.dirty = true;
	                // Remove empty batch
	                if (batch.objects.length === 0) {
	                    this.batchGroups.delete(batchKey);
	                }
	            }
	        }
	    }
	    /**
	     * Generate batch key for grouping objects
	     */
	    getBatchKey(obj) {
	        // Group by texture and shader
	        const textureId = obj.texture ? obj.texture.id || 'default' : 'default';
	        return `${textureId}_${obj.shader}`;
	    }
	    /**
	     * Create new batch group
	     */
	    createBatchGroup(obj) {
	        return {
	            texture: obj.texture,
	            shader: obj.shader,
	            objects: [],
	            vertices: new Float32Array(this.maxBatchSize * 16), // 4 vertices * 4 components
	            indices: new Uint16Array(this.maxBatchSize * 6), // 2 triangles * 3 indices
	            dirty: true
	        };
	    }
	    /**
	     * Split large batch into smaller ones
	     */
	    splitBatch(batchKey, batch) {
	        const midPoint = Math.floor(batch.objects.length / 2);
	        const secondHalf = batch.objects.splice(midPoint);
	        // Create new batch for second half
	        const newBatch = this.createBatchGroup(batch.objects[0]);
	        newBatch.objects = secondHalf;
	        const newKey = `${batchKey}_${Date.now()}`;
	        this.batchGroups.set(newKey, newBatch);
	        batch.dirty = true;
	        newBatch.dirty = true;
	    }
	    /**
	     * Update batch geometry
	     */
	    updateBatchGeometry(batch) {
	        if (!batch.dirty)
	            return;
	        let vertexIndex = 0;
	        let indexIndex = 0;
	        let quadIndex = 0;
	        for (const obj of batch.objects) {
	            if (!obj.visible)
	                continue;
	            // Generate quad vertices for object
	            const quad = this.generateQuadVertices(obj);
	            // Copy vertices
	            batch.vertices.set(quad.vertices, vertexIndex);
	            // Generate indices for quad
	            const baseIndex = quadIndex * 4;
	            batch.indices[indexIndex++] = baseIndex;
	            batch.indices[indexIndex++] = baseIndex + 1;
	            batch.indices[indexIndex++] = baseIndex + 2;
	            batch.indices[indexIndex++] = baseIndex;
	            batch.indices[indexIndex++] = baseIndex + 2;
	            batch.indices[indexIndex++] = baseIndex + 3;
	            vertexIndex += quad.vertices.length;
	            quadIndex++;
	        }
	        batch.dirty = false;
	    }
	    /**
	     * Generate quad vertices for object
	     */
	    generateQuadVertices(obj) {
	        const { position, scale, rotation } = obj;
	        const halfWidth = scale.x / 2;
	        const halfHeight = scale.y / 2;
	        // Simple quad vertices (position, UV)
	        const vertices = new Float32Array([
	            // Top-left
	            position.x - halfWidth, position.y + halfHeight, 0, 1,
	            // Top-right
	            position.x + halfWidth, position.y + halfHeight, 1, 1,
	            // Bottom-right
	            position.x + halfWidth, position.y - halfHeight, 1, 0,
	            // Bottom-left
	            position.x - halfWidth, position.y - halfHeight, 0, 0
	        ]);
	        // Apply rotation if needed
	        if (rotation !== 0) {
	            this.applyRotation(vertices, position, rotation);
	        }
	        return { vertices };
	    }
	    /**
	     * Apply rotation to vertices
	     */
	    applyRotation(vertices, center, rotation) {
	        const cos = Math.cos(rotation);
	        const sin = Math.sin(rotation);
	        for (let i = 0; i < vertices.length; i += 4) {
	            const x = vertices[i] - center.x;
	            const y = vertices[i + 1] - center.y;
	            vertices[i] = x * cos - y * sin + center.x;
	            vertices[i + 1] = x * sin + y * cos + center.y;
	        }
	    }
	    /**
	     * Render all batches
	     */
	    renderBatches() {
	        const startTime = performance.now();
	        this.resetStats();
	        if (this.config.sortingEnabled) {
	            this.sortBatches();
	        }
	        let lastTexture = null;
	        let lastShader = '';
	        for (const [batchKey, batch] of this.batchGroups) {
	            if (batch.objects.length === 0)
	                continue;
	            // Update batch geometry if dirty
	            this.updateBatchGeometry(batch);
	            // Count texture/shader swaps
	            if (batch.texture !== lastTexture) {
	                this.renderStats.textureSwaps++;
	                lastTexture = batch.texture;
	            }
	            if (batch.shader !== lastShader) {
	                this.renderStats.shaderSwaps++;
	                lastShader = batch.shader;
	            }
	            // Render batch (this would call actual rendering API)
	            this.renderBatch(batch);
	            this.renderStats.drawCalls++;
	            this.renderStats.batchedObjects += batch.objects.filter(obj => obj.visible).length;
	            this.renderStats.triangles += batch.objects.filter(obj => obj.visible).length * 2;
	        }
	        this.frameRenderTime = performance.now() - startTime;
	        this.updateRenderTimeHistory();
	        this.emit('render-completed', {
	            time: this.frameRenderTime,
	            stats: { ...this.renderStats }
	        });
	    }
	    /**
	     * Sort batches for optimal rendering
	     */
	    sortBatches() {
	        // Sort by shader first, then by texture to minimize state changes
	        const sortedEntries = Array.from(this.batchGroups.entries()).sort((a, b) => {
	            const [keyA, batchA] = a;
	            const [keyB, batchB] = b;
	            if (batchA.shader !== batchB.shader) {
	                return batchA.shader.localeCompare(batchB.shader);
	            }
	            const textureIdA = batchA.texture?.id || '';
	            const textureIdB = batchB.texture?.id || '';
	            return textureIdA.localeCompare(textureIdB);
	        });
	        // Rebuild map with sorted order
	        this.batchGroups.clear();
	        for (const [key, batch] of sortedEntries) {
	            this.batchGroups.set(key, batch);
	        }
	    }
	    /**
	     * Render individual batch (stub - would interface with actual renderer)
	     */
	    renderBatch(batch) {
	        // This would interface with the actual rendering system
	        // For now, just emit an event
	        this.emit('batch-rendered', {
	            objectCount: batch.objects.filter(obj => obj.visible).length,
	            textureId: batch.texture?.id,
	            shader: batch.shader
	        });
	    }
	    /**
	     * Clear all batches
	     */
	    clearBatches() {
	        this.batchGroups.clear();
	        this.emit('batches-cleared');
	    }
	    /**
	     * Reset render statistics
	     */
	    resetStats() {
	        this.lastFrameStats = { ...this.renderStats };
	        this.renderStats = {
	            drawCalls: 0,
	            triangles: 0,
	            visibleObjects: 0,
	            culledObjects: 0,
	            batchedObjects: 0,
	            textureSwaps: 0,
	            shaderSwaps: 0
	        };
	    }
	    /**
	     * Update render time history
	     */
	    updateRenderTimeHistory() {
	        this.renderTimeHistory.push(this.frameRenderTime);
	        // Limit history size
	        if (this.renderTimeHistory.length > 120) {
	            this.renderTimeHistory.shift();
	        }
	    }
	    /**
	     * Get render statistics
	     */
	    getRenderStats() {
	        return { ...this.renderStats };
	    }
	    /**
	     * Get detailed performance report
	     */
	    getPerformanceReport() {
	        const avgRenderTime = this.renderTimeHistory.length > 0
	            ? this.renderTimeHistory.reduce((sum, time) => sum + time, 0) / this.renderTimeHistory.length
	            : 0;
	        return {
	            currentFrame: {
	                renderTime: this.frameRenderTime,
	                stats: { ...this.renderStats }
	            },
	            averageRenderTime: Math.round(avgRenderTime * 100) / 100,
	            batching: {
	                enabled: this.batchingEnabled,
	                batchCount: this.batchGroups.size,
	                maxBatchSize: this.maxBatchSize,
	                totalObjects: this.renderQueue.length
	            },
	            culling: {
	                frustumEnabled: this.frustumCullingEnabled,
	                distanceEnabled: this.distanceCullingEnabled,
	                occlusionEnabled: this.occlusionCullingEnabled,
	                maxDistance: this.maxRenderDistance
	            },
	            lod: {
	                enabled: this.lodEnabled,
	                levels: this.lodLevels.length
	            },
	            efficiency: {
	                cullingRatio: this.renderStats.culledObjects / (this.renderStats.visibleObjects + this.renderStats.culledObjects),
	                batchingRatio: this.renderStats.batchedObjects / Math.max(1, this.renderStats.visibleObjects),
	                averageObjectsPerBatch: this.batchGroups.size > 0
	                    ? this.renderStats.batchedObjects / this.batchGroups.size
	                    : 0
	            }
	        };
	    }
	    /**
	     * Set optimization settings
	     */
	    setOptimizationSettings(settings) {
	        if (settings.batchingEnabled !== undefined) {
	            if (settings.batchingEnabled) {
	                this.enableBatching();
	            }
	            else {
	                this.disableBatching();
	            }
	        }
	        if (settings.frustumCulling !== undefined) {
	            this.frustumCullingEnabled = settings.frustumCulling;
	        }
	        if (settings.distanceCulling !== undefined) {
	            this.distanceCullingEnabled = settings.distanceCulling;
	        }
	        if (settings.occlusionCulling !== undefined) {
	            this.occlusionCullingEnabled = settings.occlusionCulling;
	        }
	        if (settings.lodEnabled !== undefined) {
	            this.lodEnabled = settings.lodEnabled;
	        }
	        if (settings.maxRenderDistance !== undefined) {
	            this.maxRenderDistance = settings.maxRenderDistance;
	        }
	        if (settings.maxBatchSize !== undefined) {
	            this.maxBatchSize = settings.maxBatchSize;
	        }
	        this.emit('settings-updated', settings);
	    }
	    /**
	     * Clean up resources
	     */
	    destroy() {
	        this.clearBatches();
	        this.renderQueue.length = 0;
	        this.renderTimeHistory.length = 0;
	        this.occlusionQueries.clear();
	        this.occlusionResults.clear();
	        this.textureAtlas.clear();
	        this.removeAllListeners();
	        this.isInitialized = false;
	    }
	}

	/**
	 * Mobile-specific performance optimizer
	 * Handles device tier detection, thermal management, and battery optimization
	 */
	class MobileOptimizer extends EventEmitter {
	    constructor() {
	        super();
	        this.isInitialized = false;
	        this.deviceTier = exports.DevicePerformanceTier.UNKNOWN;
	        this.thermalState = exports.DeviceThermalState.NORMAL;
	        this.batteryOptimizationMode = exports.BatteryOptimizationMode.BALANCED;
	        // Battery monitoring
	        this.battery = null;
	        this.batteryLevel = 1.0;
	        this.isCharging = false;
	        this.batteryMonitorInterval = null;
	        // Thermal monitoring
	        this.thermalMonitorInterval = null;
	        this.thermalThrottlingEnabled = true;
	        this.currentTemperature = 0;
	        // Network monitoring
	        this.networkInfo = null;
	        this.networkMonitorInterval = null;
	        // Performance scaling
	        this.baseQualitySettings = null;
	        this.currentQualitySettings = null;
	        this.performanceScale = 1.0;
	        // Mobile-specific optimizations
	        this.touchOptimizationsEnabled = true;
	        this.backgroundThrottlingEnabled = true;
	        this.memoryPressureOptimizations = true;
	        this.lowPowerModeEnabled = false;
	        // Performance monitoring
	        this.frameTimeTarget = 16.67; // 60fps
	        this.thermalThrottleHistory = [];
	        this.performanceHistory = [];
	        // Initialize thermal configuration
	        this.thermalConfig = {
	            normalTemp: 40,
	            warmTemp: 50,
	            hotTemp: 60,
	            criticalTemp: 70,
	            throttleSteps: [
	                { temperature: 45, qualityReduction: 0.1, fpsReduction: 0 },
	                { temperature: 55, qualityReduction: 0.25, fpsReduction: 0.1 },
	                { temperature: 65, qualityReduction: 0.5, fpsReduction: 0.25 },
	                { temperature: 75, qualityReduction: 0.75, fpsReduction: 0.5 }
	            ]
	        };
	    }
	    /**
	     * Initialize mobile optimizer
	     */
	    async initialize() {
	        if (this.isInitialized)
	            return;
	        try {
	            // Detect device tier
	            this.deviceTier = this.detectDeviceTier();
	            // Initialize battery monitoring
	            await this.initializeBatteryMonitoring();
	            // Initialize network monitoring
	            this.initializeNetworkMonitoring();
	            // Start thermal monitoring
	            this.startThermalMonitoring();
	            // Set initial optimization mode based on device
	            this.setOptimalBatteryMode();
	            // Listen for visibility changes
	            this.setupVisibilityChangeHandling();
	            this.isInitialized = true;
	            this.emit('initialized', {
	                deviceTier: this.deviceTier,
	                batterySupported: !!this.battery,
	                thermalSupported: this.supportsThermalAPI()
	            });
	        }
	        catch (error) {
	            this.emit('initialization-error', error);
	            throw error;
	        }
	    }
	    /**
	     * Detect device performance tier using centralized DeviceDetector
	     */
	    detectDeviceTier() {
	        let score = 0;
	        // Use centralized DeviceDetector for hardware info
	        const cores = DeviceDetector.getCoreCount();
	        const deviceMemory = DeviceDetector.getDeviceMemory();
	        // CPU cores (0-20 points)
	        score += Math.min(cores * 3, 20);
	        // Memory (0-25 points)
	        if (deviceMemory >= 8)
	            score += 25;
	        else if (deviceMemory >= 4)
	            score += 20;
	        else if (deviceMemory >= 2)
	            score += 15;
	        else
	            score += 10;
	        // WebGL capabilities (0-20 points)
	        const webglScore = this.assessWebGLCapabilities();
	        score += webglScore;
	        // Performance benchmark (0-25 points)
	        const benchmarkScore = this.runPerformanceBenchmark();
	        score += benchmarkScore;
	        // Device type adjustment (0-10 points)
	        const userAgent = navigator.userAgent.toLowerCase();
	        if (/iphone|ipad/.test(userAgent)) {
	            // iOS devices tend to have better optimization
	            score += 8;
	        }
	        else if (/android/.test(userAgent)) {
	            // Android varies widely
	            score += 5;
	        }
	        // Classify tier based on score
	        if (score >= 70)
	            return exports.DevicePerformanceTier.HIGH;
	        else if (score >= 45)
	            return exports.DevicePerformanceTier.MID;
	        else
	            return exports.DevicePerformanceTier.LOW;
	    }
	    /**
	     * Assess WebGL capabilities for performance scoring
	     */
	    assessWebGLCapabilities() {
	        const canvas = document.createElement('canvas');
	        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
	        if (!gl)
	            return 0;
	        let score = 0;
	        // WebGL version
	        if (gl instanceof WebGL2RenderingContext) {
	            score += 8;
	        }
	        else {
	            score += 5;
	        }
	        // Texture size
	        const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
	        if (maxTextureSize >= 4096)
	            score += 6;
	        else if (maxTextureSize >= 2048)
	            score += 4;
	        else
	            score += 2;
	        // Extensions
	        const extensions = gl.getSupportedExtensions() || [];
	        if (extensions.length > 20)
	            score += 4;
	        else if (extensions.length > 10)
	            score += 2;
	        // Vertex shader precision
	        const vertexPrecision = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);
	        if (vertexPrecision && vertexPrecision.precision > 0)
	            score += 2;
	        canvas.remove();
	        return Math.min(score, 20);
	    }
	    /**
	     * Run performance benchmark
	     */
	    runPerformanceBenchmark() {
	        const startTime = performance.now();
	        let operationCount = 0;
	        const maxOperations = 100000; // Fixed number of operations
	        // CPU benchmark - synchronous
	        for (let i = 0; i < maxOperations; i++) {
	            operationCount++;
	        }
	        const elapsed = performance.now() - startTime;
	        const opsPerSecond = (operationCount / elapsed) * 1000;
	        // Calculate score based on operations per second
	        if (opsPerSecond > 500000)
	            return 25;
	        else if (opsPerSecond > 300000)
	            return 20;
	        else if (opsPerSecond > 150000)
	            return 15;
	        else if (opsPerSecond > 75000)
	            return 10;
	        else
	            return 5;
	    }
	    /**
	     * Initialize battery monitoring
	     */
	    async initializeBatteryMonitoring() {
	        try {
	            if ('getBattery' in navigator) {
	                this.battery = await navigator.getBattery();
	                this.batteryLevel = this.battery.level;
	                this.isCharging = this.battery.charging;
	                // Listen for battery events
	                this.battery.addEventListener('chargingchange', () => {
	                    this.isCharging = this.battery.charging;
	                    this.handleBatteryChange();
	                });
	                this.battery.addEventListener('levelchange', () => {
	                    this.batteryLevel = this.battery.level;
	                    this.handleBatteryChange();
	                });
	                // Start battery monitoring
	                this.batteryMonitorInterval = window.setInterval(() => {
	                    this.updateBatteryInfo();
	                }, 10000); // Check every 10 seconds
	                this.emit('battery-initialized', {
	                    level: this.batteryLevel,
	                    charging: this.isCharging
	                });
	            }
	        }
	        catch (error) {
	            console.warn('Battery API not available:', error);
	        }
	    }
	    /**
	     * Initialize network monitoring
	     */
	    initializeNetworkMonitoring() {
	        const connection = navigator.connection;
	        if (connection) {
	            this.updateNetworkInfo();
	            connection.addEventListener('change', () => {
	                this.updateNetworkInfo();
	            });
	            this.networkMonitorInterval = window.setInterval(() => {
	                this.updateNetworkInfo();
	            }, 30000); // Check every 30 seconds
	        }
	    }
	    /**
	     * Update network information
	     */
	    updateNetworkInfo() {
	        const connection = navigator.connection;
	        if (connection) {
	            this.networkInfo = {
	                effectiveType: connection.effectiveType || '4g',
	                downlink: connection.downlink || 10,
	                rtt: connection.rtt || 100,
	                saveData: connection.saveData || false
	            };
	            // Adjust optimizations based on network
	            if (this.networkInfo.saveData || this.networkInfo.effectiveType === '2g' || this.networkInfo.effectiveType === 'slow-2g') {
	                this.enableDataSavingOptimizations();
	            }
	            this.emit('network-updated', this.networkInfo);
	        }
	    }
	    /**
	     * Start thermal monitoring
	     */
	    startThermalMonitoring() {
	        // Check for thermal API support
	        if (this.supportsThermalAPI()) {
	            this.thermalMonitorInterval = window.setInterval(() => {
	                this.updateThermalState();
	            }, 5000); // Check every 5 seconds
	        }
	        else {
	            // Fallback: monitor performance metrics for thermal estimation
	            this.thermalMonitorInterval = window.setInterval(() => {
	                this.estimateThermalState();
	            }, 10000); // Check every 10 seconds
	        }
	    }
	    /**
	     * Check if thermal API is supported
	     */
	    supportsThermalAPI() {
	        const connection = navigator.connection;
	        return connection && 'thermalState' in connection;
	    }
	    /**
	     * Update thermal state from system APIs
	     */
	    updateThermalState() {
	        try {
	            const connection = navigator.connection;
	            if (connection && 'thermalState' in connection) {
	                const thermalState = connection.thermalState;
	                switch (thermalState) {
	                    case 'nominal':
	                        this.thermalState = exports.DeviceThermalState.NORMAL;
	                        this.currentTemperature = 35;
	                        break;
	                    case 'fair':
	                        this.thermalState = exports.DeviceThermalState.FAIR;
	                        this.currentTemperature = 45;
	                        break;
	                    case 'serious':
	                        this.thermalState = exports.DeviceThermalState.SERIOUS;
	                        this.currentTemperature = 60;
	                        break;
	                    case 'critical':
	                        this.thermalState = exports.DeviceThermalState.CRITICAL;
	                        this.currentTemperature = 75;
	                        break;
	                }
	                this.handleThermalStateChange();
	            }
	        }
	        catch (error) {
	            console.warn('Thermal API error:', error);
	        }
	    }
	    /**
	     * Estimate thermal state based on performance metrics
	     */
	    estimateThermalState() {
	        // Estimate thermal state based on performance degradation
	        if (this.performanceHistory.length >= 10) {
	            const recent = this.performanceHistory.slice(-5);
	            const older = this.performanceHistory.slice(-10, -5);
	            const recentAvgFps = recent.reduce((sum, p) => sum + p.fps, 0) / recent.length;
	            const olderAvgFps = older.reduce((sum, p) => sum + p.fps, 0) / older.length;
	            const fpsDropRatio = (olderAvgFps - recentAvgFps) / olderAvgFps;
	            // Estimate thermal state based on performance drop
	            if (fpsDropRatio > 0.3) {
	                this.thermalState = exports.DeviceThermalState.CRITICAL;
	                this.currentTemperature = 70;
	            }
	            else if (fpsDropRatio > 0.2) {
	                this.thermalState = exports.DeviceThermalState.SERIOUS;
	                this.currentTemperature = 60;
	            }
	            else if (fpsDropRatio > 0.1) {
	                this.thermalState = exports.DeviceThermalState.FAIR;
	                this.currentTemperature = 45;
	            }
	            else {
	                this.thermalState = exports.DeviceThermalState.NORMAL;
	                this.currentTemperature = 35;
	            }
	            this.handleThermalStateChange();
	        }
	    }
	    /**
	     * Handle thermal state changes
	     */
	    handleThermalStateChange() {
	        if (this.thermalThrottlingEnabled) {
	            this.applyThermalThrottling();
	        }
	        this.thermalThrottleHistory.push(this.currentTemperature);
	        if (this.thermalThrottleHistory.length > 60) {
	            this.thermalThrottleHistory.shift();
	        }
	        this.emit('thermal-state-changed', {
	            state: this.thermalState,
	            temperature: this.currentTemperature
	        });
	    }
	    /**
	     * Apply thermal throttling optimizations
	     */
	    applyThermalThrottling() {
	        if (!this.currentQualitySettings)
	            return;
	        const throttleStep = this.thermalConfig.throttleSteps.find(step => this.currentTemperature >= step.temperature);
	        if (throttleStep) {
	            const newSettings = { ...this.currentQualitySettings };
	            // Reduce quality settings
	            newSettings.renderScale = Math.max(0.5, 1.0 - throttleStep.qualityReduction);
	            newSettings.textureQuality = Math.max(exports.QualityLevel.LOW, newSettings.textureQuality - Math.floor(throttleStep.qualityReduction * 2));
	            newSettings.effectsQuality = Math.max(exports.QualityLevel.LOW, newSettings.effectsQuality - Math.floor(throttleStep.qualityReduction * 2));
	            newSettings.particleCount = Math.max(100, newSettings.particleCount * (1 - throttleStep.qualityReduction));
	            this.currentQualitySettings = newSettings;
	            this.emit('thermal-throttling-applied', {
	                temperature: this.currentTemperature,
	                qualityReduction: throttleStep.qualityReduction,
	                settings: newSettings
	            });
	        }
	    }
	    /**
	     * Handle battery level changes
	     */
	    handleBatteryChange() {
	        // Adjust optimization mode based on battery level
	        if (!this.isCharging && this.batteryLevel < 0.2) {
	            // Critical battery - enable power saving
	            this.setBatteryOptimizationMode(exports.BatteryOptimizationMode.POWER_SAVER);
	        }
	        else if (!this.isCharging && this.batteryLevel < 0.5) {
	            // Low battery - use balanced mode
	            this.setBatteryOptimizationMode(exports.BatteryOptimizationMode.BALANCED);
	        }
	        else if (this.isCharging || this.batteryLevel > 0.8) {
	            // Good battery - allow performance mode
	            this.setBatteryOptimizationMode(exports.BatteryOptimizationMode.PERFORMANCE);
	        }
	        this.emit('battery-changed', {
	            level: this.batteryLevel,
	            charging: this.isCharging,
	            mode: this.batteryOptimizationMode
	        });
	    }
	    /**
	     * Update battery information
	     */
	    updateBatteryInfo() {
	        if (this.battery) {
	            this.batteryLevel = this.battery.level;
	            this.isCharging = this.battery.charging;
	        }
	    }
	    /**
	     * Setup visibility change handling for background optimization
	     */
	    setupVisibilityChangeHandling() {
	        document.addEventListener('visibilitychange', () => {
	            if (document.hidden) {
	                if (this.backgroundThrottlingEnabled) {
	                    this.enableBackgroundOptimizations();
	                }
	            }
	            else {
	                this.disableBackgroundOptimizations();
	            }
	        });
	    }
	    /**
	     * Enable optimizations when app goes to background
	     */
	    enableBackgroundOptimizations() {
	        this.emit('background-optimizations-enabled');
	    }
	    /**
	     * Disable background optimizations when app becomes visible
	     */
	    disableBackgroundOptimizations() {
	        this.emit('background-optimizations-disabled');
	    }
	    /**
	     * Enable data saving optimizations
	     */
	    enableDataSavingOptimizations() {
	        this.emit('data-saving-enabled', {
	            networkType: this.networkInfo?.effectiveType,
	            saveData: this.networkInfo?.saveData
	        });
	    }
	    /**
	     * Set optimal battery optimization mode
	     */
	    setOptimalBatteryMode() {
	        switch (this.deviceTier) {
	            case exports.DevicePerformanceTier.HIGH:
	                this.setBatteryOptimizationMode(exports.BatteryOptimizationMode.PERFORMANCE);
	                break;
	            case exports.DevicePerformanceTier.MID:
	                this.setBatteryOptimizationMode(exports.BatteryOptimizationMode.BALANCED);
	                break;
	            case exports.DevicePerformanceTier.LOW:
	                this.setBatteryOptimizationMode(exports.BatteryOptimizationMode.POWER_SAVER);
	                break;
	            default:
	                this.setBatteryOptimizationMode(exports.BatteryOptimizationMode.BALANCED);
	        }
	    }
	    /**
	     * Get current thermal state
	     */
	    getThermalState() {
	        return this.thermalState;
	    }
	    /**
	     * Get battery level (0-1)
	     */
	    getBatteryLevel() {
	        return this.batteryLevel;
	    }
	    /**
	     * Get current battery optimization mode
	     */
	    getBatteryOptimizationMode() {
	        return this.batteryOptimizationMode;
	    }
	    /**
	     * Set battery optimization mode
	     */
	    setBatteryOptimizationMode(mode) {
	        const oldMode = this.batteryOptimizationMode;
	        this.batteryOptimizationMode = mode;
	        if (oldMode !== mode) {
	            this.applyBatteryOptimizations(mode);
	            this.emit('battery-mode-changed', { oldMode, newMode: mode });
	        }
	    }
	    /**
	     * Apply battery optimizations based on mode
	     */
	    applyBatteryOptimizations(mode) {
	        if (!this.currentQualitySettings)
	            return;
	        const settings = { ...this.currentQualitySettings };
	        switch (mode) {
	            case exports.BatteryOptimizationMode.POWER_SAVER:
	                settings.renderScale = 0.7;
	                settings.textureQuality = exports.QualityLevel.LOW;
	                settings.effectsQuality = exports.QualityLevel.LOW;
	                settings.shadowQuality = exports.QualityLevel.LOW;
	                settings.antialiasing = false;
	                settings.particleCount = Math.min(settings.particleCount, 200);
	                settings.maxAudioSources = Math.min(settings.maxAudioSources, 8);
	                this.frameTimeTarget = 33.33; // 30fps
	                break;
	            case exports.BatteryOptimizationMode.BALANCED:
	                settings.renderScale = 0.85;
	                settings.textureQuality = exports.QualityLevel.MEDIUM;
	                settings.effectsQuality = exports.QualityLevel.MEDIUM;
	                settings.shadowQuality = exports.QualityLevel.MEDIUM;
	                settings.antialiasing = true;
	                settings.particleCount = Math.min(settings.particleCount, 500);
	                settings.maxAudioSources = Math.min(settings.maxAudioSources, 16);
	                this.frameTimeTarget = 16.67; // 60fps
	                break;
	            case exports.BatteryOptimizationMode.PERFORMANCE:
	                // Use base settings or even enhance them
	                settings.renderScale = 1.0;
	                settings.textureQuality = exports.QualityLevel.HIGH;
	                settings.effectsQuality = exports.QualityLevel.HIGH;
	                settings.shadowQuality = exports.QualityLevel.HIGH;
	                settings.antialiasing = true;
	                // Don't limit particle count or audio sources
	                this.frameTimeTarget = 16.67; // 60fps
	                break;
	        }
	        this.currentQualitySettings = settings;
	        this.emit('battery-optimizations-applied', { mode, settings });
	    }
	    /**
	     * Enable thermal throttling
	     */
	    enableThermalThrottling() {
	        this.thermalThrottlingEnabled = true;
	        this.emit('thermal-throttling-enabled');
	    }
	    /**
	     * Disable thermal throttling
	     */
	    disableThermalThrottling() {
	        this.thermalThrottlingEnabled = false;
	        this.emit('thermal-throttling-disabled');
	    }
	    /**
	     * Optimize for battery life
	     */
	    optimizeForBattery() {
	        this.setBatteryOptimizationMode(exports.BatteryOptimizationMode.POWER_SAVER);
	        this.enableBackgroundOptimizations();
	        this.lowPowerModeEnabled = true;
	        this.emit('battery-optimization-enabled');
	    }
	    /**
	     * Optimize for performance
	     */
	    optimizeForPerformance() {
	        this.setBatteryOptimizationMode(exports.BatteryOptimizationMode.PERFORMANCE);
	        this.lowPowerModeEnabled = false;
	        this.emit('performance-optimization-enabled');
	    }
	    /**
	     * Update performance metrics for thermal estimation
	     */
	    updatePerformanceMetrics(fps) {
	        this.performanceHistory.push({
	            timestamp: Date.now(),
	            fps,
	            temperature: this.currentTemperature,
	            batteryLevel: this.batteryLevel,
	            thermalState: this.thermalState
	        });
	        // Limit history size
	        if (this.performanceHistory.length > 100) {
	            this.performanceHistory.shift();
	        }
	    }
	    /**
	     * Get mobile optimization report
	     */
	    getOptimizationReport() {
	        return {
	            device: {
	                tier: this.deviceTier,
	                userAgent: navigator.userAgent
	            },
	            thermal: {
	                state: this.thermalState,
	                temperature: this.currentTemperature,
	                throttlingEnabled: this.thermalThrottlingEnabled,
	                history: this.thermalThrottleHistory.slice(-10)
	            },
	            battery: {
	                level: this.batteryLevel,
	                charging: this.isCharging,
	                optimizationMode: this.batteryOptimizationMode,
	                lowPowerMode: this.lowPowerModeEnabled
	            },
	            network: this.networkInfo,
	            optimizations: {
	                touchOptimizations: this.touchOptimizationsEnabled,
	                backgroundThrottling: this.backgroundThrottlingEnabled,
	                memoryPressure: this.memoryPressureOptimizations
	            },
	            performance: {
	                frameTimeTarget: this.frameTimeTarget,
	                recentHistory: this.performanceHistory.slice(-5)
	            }
	        };
	    }
	    /**
	     * Set quality settings reference for optimization
	     */
	    setQualitySettings(settings) {
	        if (!this.baseQualitySettings) {
	            this.baseQualitySettings = { ...settings };
	        }
	        this.currentQualitySettings = { ...settings };
	    }
	    /**
	     * Get optimized quality settings
	     */
	    getOptimizedQualitySettings() {
	        return this.currentQualitySettings ? { ...this.currentQualitySettings } : null;
	    }
	    /**
	     * Clean up resources
	     */
	    destroy() {
	        if (this.batteryMonitorInterval) {
	            clearInterval(this.batteryMonitorInterval);
	            this.batteryMonitorInterval = null;
	        }
	        if (this.thermalMonitorInterval) {
	            clearInterval(this.thermalMonitorInterval);
	            this.thermalMonitorInterval = null;
	        }
	        if (this.networkMonitorInterval) {
	            clearInterval(this.networkMonitorInterval);
	            this.networkMonitorInterval = null;
	        }
	        // Clean up battery event listeners
	        if (this.battery) {
	            this.battery.removeEventListener('chargingchange', this.handleBatteryChange);
	            this.battery.removeEventListener('levelchange', this.handleBatteryChange);
	        }
	        this.performanceHistory.length = 0;
	        this.thermalThrottleHistory.length = 0;
	        this.removeAllListeners();
	        this.isInitialized = false;
	    }
	}

	/**
	 * Comprehensive performance monitoring and management system
	 * Integrates all performance optimization components
	 */
	class PerformanceMonitor extends EventEmitter {
	    constructor() {
	        super();
	        this.isInitialized = false;
	        this.isRunning = false;
	        // Monitoring intervals
	        this.metricsUpdateInterval = null;
	        this.warningCheckInterval = null;
	        this.autoOptimizationInterval = null;
	        this.metricsHistory = [];
	        this.warnings = [];
	        // Profiling
	        this.profilingSessions = new Map();
	        this.performanceMarks = new Map();
	        // Auto-optimization
	        this.autoQualityAdjustment = true;
	        this.autoGarbageCollection = true;
	        this.autoThermalThrottling = true;
	        // Alert system
	        this.alertConfigs = [];
	        this.activeAlerts = new Map(); // type -> lastAlertTime
	        // Feature flags
	        this.optimizationFeatures = new Map([
	            ['batching', true],
	            ['culling', true],
	            ['pooling', true],
	            ['thermal', true],
	            ['battery', true]
	        ]);
	        // Initialize default configuration
	        this.config = {
	            metricsUpdateInterval: 1000,
	            performanceHistorySize: 300,
	            targetFps: 60,
	            minFps: 30,
	            maxMemoryUsage: 0.8,
	            autoQualityAdjustment: true,
	            autoGarbageCollection: true,
	            autoThermalThrottling: true,
	            enableWarnings: true,
	            warningThresholds: {
	                lowFps: 45,
	                highMemory: 0.85,
	                highDrawCalls: 100
	            }
	        };
	        // Initialize current metrics
	        this.currentMetrics = this.createEmptyMetrics();
	        // Initialize components
	        this.deviceDetector = new DeviceDetector();
	        this.gameLoopOptimizer = new GameLoopOptimizer();
	        this.frameRateManager = new FrameRateManager();
	        this.memoryOptimizer = new MemoryOptimizer();
	        this.renderingOptimizer = new RenderingOptimizer();
	        this.mobileOptimizer = new MobileOptimizer();
	        // Setup component event listeners
	        this.setupComponentListeners();
	        // Initialize default alert configurations
	        this.setupDefaultAlerts();
	    }
	    /**
	     * Initialize the performance manager
	     */
	    async initialize(config = {}) {
	        if (this.isInitialized)
	            return;
	        this.config = { ...this.config, ...config };
	        try {
	            // Initialize all components
	            await this.deviceDetector.initialize();
	            this.gameLoopOptimizer.setAutoAdjustmentEnabled(this.config.autoQualityAdjustment);
	            this.gameLoopOptimizer.setPerformanceTarget(this.config.targetFps);
	            this.frameRateManager.initialize({
	                targetFps: this.config.targetFps,
	                adaptiveFrameRate: true,
	                maxDeltaTime: 100,
	                fixedTimeStep: false,
	                vsyncEnabled: true,
	                frameSkipping: false,
	                maxFrameSkip: 0
	            });
	            this.memoryOptimizer.initialize();
	            this.memoryOptimizer.setAutoGCEnabled(this.config.autoGarbageCollection);
	            this.renderingOptimizer.initialize();
	            await this.mobileOptimizer.initialize();
	            // Set optimization features
	            this.autoQualityAdjustment = this.config.autoQualityAdjustment;
	            this.autoGarbageCollection = this.config.autoGarbageCollection;
	            this.autoThermalThrottling = this.config.autoThermalThrottling;
	            this.isInitialized = true;
	            this.emit('initialized', this.config);
	        }
	        catch (error) {
	            this.emit('initialization-error', error);
	            throw error;
	        }
	    }
	    /**
	     * Start performance monitoring and optimization
	     */
	    start() {
	        if (!this.isInitialized) {
	            throw new Error('PerformanceMonitor must be initialized before starting');
	        }
	        if (this.isRunning)
	            return;
	        // Start all components
	        this.frameRateManager.start();
	        this.gameLoopOptimizer.start();
	        // Start monitoring intervals
	        this.startMetricsUpdate();
	        this.startWarningChecks();
	        this.startAutoOptimization();
	        this.isRunning = true;
	        this.emit('started');
	    }
	    /**
	     * Stop performance monitoring
	     */
	    stop() {
	        if (!this.isRunning)
	            return;
	        // Stop components
	        this.frameRateManager.stop();
	        this.gameLoopOptimizer.stop();
	        // Stop monitoring intervals
	        this.stopAllIntervals();
	        this.isRunning = false;
	        this.emit('stopped');
	    }
	    /**
	     * Setup component event listeners
	     */
	    setupComponentListeners() {
	        // Frame rate manager events
	        this.frameRateManager.on('metrics-updated', (metrics) => {
	            this.updateFrameRateMetrics(metrics);
	        });
	        this.frameRateManager.on('frame-drop', (data) => {
	            this.handleFrameDrop(data);
	        });
	        // Memory optimizer events
	        this.memoryOptimizer.on('memory-warning', (warning) => {
	            this.addWarning('memory', warning.level, warning.message, warning.percentage);
	        });
	        this.memoryOptimizer.on('memory-leak-detected', (leak) => {
	            this.addWarning('memory', 'high', `Memory leak detected: ${leak.type}`, leak.size);
	        });
	        // Mobile optimizer events
	        this.mobileOptimizer.on('thermal-state-changed', (data) => {
	            this.handleThermalStateChange(data);
	        });
	        this.mobileOptimizer.on('battery-changed', (data) => {
	            this.handleBatteryChange(data);
	        });
	        // Rendering optimizer events
	        this.renderingOptimizer.on('render-completed', (data) => {
	            this.updateRenderingMetrics(data);
	        });
	        // Game loop optimizer events
	        this.gameLoopOptimizer.on('quality-adjusted', (settings) => {
	            this.handleQualityAdjustment(settings);
	        });
	    }
	    /**
	     * Setup default alert configurations
	     */
	    setupDefaultAlerts() {
	        this.alertConfigs = [
	            {
	                type: 'fps',
	                threshold: this.config.warningThresholds.lowFps,
	                duration: 3000, // 3 seconds
	                cooldown: 10000, // 10 seconds
	                enabled: true
	            },
	            {
	                type: 'memory',
	                threshold: this.config.warningThresholds.highMemory,
	                duration: 5000, // 5 seconds
	                cooldown: 15000, // 15 seconds
	                enabled: true
	            },
	            {
	                type: 'drawcalls',
	                threshold: this.config.warningThresholds.highDrawCalls,
	                duration: 2000, // 2 seconds
	                cooldown: 8000, // 8 seconds
	                enabled: true
	            }
	        ];
	    }
	    /**
	     * Start metrics update interval
	     */
	    startMetricsUpdate() {
	        this.metricsUpdateInterval = window.setInterval(() => {
	            this.updateMetrics();
	        }, this.config.metricsUpdateInterval);
	    }
	    /**
	     * Start warning checks interval
	     */
	    startWarningChecks() {
	        if (!this.config.enableWarnings)
	            return;
	        this.warningCheckInterval = window.setInterval(() => {
	            this.checkForWarnings();
	        }, 2000); // Check every 2 seconds
	    }
	    /**
	     * Start auto-optimization interval
	     */
	    startAutoOptimization() {
	        this.autoOptimizationInterval = window.setInterval(() => {
	            this.performAutoOptimization();
	        }, 5000); // Check every 5 seconds
	    }
	    /**
	     * Stop all monitoring intervals
	     */
	    stopAllIntervals() {
	        if (this.metricsUpdateInterval) {
	            clearInterval(this.metricsUpdateInterval);
	            this.metricsUpdateInterval = null;
	        }
	        if (this.warningCheckInterval) {
	            clearInterval(this.warningCheckInterval);
	            this.warningCheckInterval = null;
	        }
	        if (this.autoOptimizationInterval) {
	            clearInterval(this.autoOptimizationInterval);
	            this.autoOptimizationInterval = null;
	        }
	    }
	    /**
	     * Update performance metrics
	     */
	    updateMetrics() {
	        const frameMetrics = this.frameRateManager.getPerformanceReport();
	        const memoryInfo = this.memoryOptimizer.getMemoryUsage();
	        const renderStats = this.renderingOptimizer.getRenderStats();
	        this.deviceDetector.getCapabilities();
	        this.currentMetrics = {
	            // Frame rate metrics
	            fps: frameMetrics.fps,
	            averageFps: frameMetrics.averageFps,
	            minFps: Math.min(this.currentMetrics.minFps || frameMetrics.fps, frameMetrics.fps),
	            maxFps: Math.max(this.currentMetrics.maxFps || frameMetrics.fps, frameMetrics.fps),
	            frameTime: frameMetrics.frameTime,
	            averageFrameTime: frameMetrics.averageFrameTime,
	            frameTimeVariance: this.calculateFrameTimeVariance(),
	            // Memory metrics
	            memoryUsage: {
	                used: memoryInfo.used,
	                total: memoryInfo.total,
	                percentage: memoryInfo.percentage,
	                jsHeapSizeUsed: memoryInfo.jsHeapSizeUsed,
	                jsHeapSizeTotal: memoryInfo.jsHeapSizeTotal,
	                jsHeapSizeLimit: memoryInfo.jsHeapSizeLimit
	            },
	            // Rendering metrics
	            drawCalls: renderStats.drawCalls,
	            triangles: renderStats.triangles,
	            textureMemory: this.estimateTextureMemory(),
	            geometryMemory: this.estimateGeometryMemory(),
	            batchCount: renderStats.batchedObjects,
	            // CPU/GPU metrics (estimated)
	            cpuUsage: this.estimateCPUUsage(),
	            gpuUsage: this.estimateGPUUsage(),
	            thermalState: this.mobileOptimizer.getThermalState(),
	            // Warnings
	            warnings: [...this.warnings]
	        };
	        // Add to history
	        this.metricsHistory.push({ ...this.currentMetrics });
	        // Limit history size
	        if (this.metricsHistory.length > this.config.performanceHistorySize) {
	            this.metricsHistory.shift();
	        }
	        // Update mobile optimizer with current FPS
	        this.mobileOptimizer.updatePerformanceMetrics(this.currentMetrics.fps);
	        this.emit('metrics-updated', this.currentMetrics);
	    }
	    /**
	     * Check for performance warnings
	     */
	    checkForWarnings() {
	        if (!this.config.enableWarnings)
	            return;
	        const now = Date.now();
	        for (const alertConfig of this.alertConfigs) {
	            if (!alertConfig.enabled)
	                continue;
	            const lastAlert = this.activeAlerts.get(alertConfig.type) || 0;
	            if (now - lastAlert < alertConfig.cooldown)
	                continue;
	            let shouldAlert = false;
	            let value = 0;
	            switch (alertConfig.type) {
	                case 'fps':
	                    value = this.currentMetrics.fps;
	                    shouldAlert = value < alertConfig.threshold;
	                    break;
	                case 'memory':
	                    value = this.currentMetrics.memoryUsage.percentage;
	                    shouldAlert = value > alertConfig.threshold * 100;
	                    break;
	                case 'drawcalls':
	                    value = this.currentMetrics.drawCalls;
	                    shouldAlert = value > alertConfig.threshold;
	                    break;
	            }
	            if (shouldAlert) {
	                this.activeAlerts.set(alertConfig.type, now);
	                this.addWarning(alertConfig.type, 'medium', `${alertConfig.type} threshold exceeded`, value, alertConfig.threshold);
	            }
	        }
	    }
	    /**
	     * Perform automatic optimizations
	     */
	    performAutoOptimization() {
	        // Auto quality adjustment
	        if (this.autoQualityAdjustment) {
	            this.gameLoopOptimizer.forceQualityAdjustment();
	        }
	        // Auto garbage collection
	        if (this.autoGarbageCollection && this.currentMetrics.memoryUsage.percentage > 70) {
	            this.memoryOptimizer.optimizeMemory();
	        }
	        // Auto thermal throttling
	        if (this.autoThermalThrottling) {
	            const thermalState = this.mobileOptimizer.getThermalState();
	            if (thermalState !== 'normal') {
	                this.mobileOptimizer.optimizeForBattery();
	            }
	        }
	    }
	    /**
	     * Create empty metrics object
	     */
	    createEmptyMetrics() {
	        return {
	            fps: 0,
	            averageFps: 0,
	            minFps: 0,
	            maxFps: 0,
	            frameTime: 0,
	            averageFrameTime: 0,
	            frameTimeVariance: 0,
	            memoryUsage: {
	                used: 0,
	                total: 0,
	                percentage: 0,
	                jsHeapSizeUsed: 0,
	                jsHeapSizeTotal: 0,
	                jsHeapSizeLimit: 0
	            },
	            drawCalls: 0,
	            triangles: 0,
	            textureMemory: 0,
	            geometryMemory: 0,
	            batchCount: 0,
	            cpuUsage: 0,
	            gpuUsage: 0,
	            thermalState: exports.DeviceThermalState.NORMAL,
	            warnings: []
	        };
	    }
	    /**
	     * Calculate frame time variance
	     */
	    calculateFrameTimeVariance() {
	        // This would use frame time history from frame rate manager
	        return this.frameRateManager.getStabilityScore() * 100;
	    }
	    /**
	     * Estimate texture memory usage
	     */
	    estimateTextureMemory() {
	        // Simplified estimation - in real implementation would track actual textures
	        return this.currentMetrics.drawCalls * 1024; // Estimate 1KB per draw call
	    }
	    /**
	     * Estimate geometry memory usage
	     */
	    estimateGeometryMemory() {
	        // Simplified estimation - in real implementation would track actual geometry
	        return this.currentMetrics.triangles * 48; // Estimate 48 bytes per triangle
	    }
	    /**
	     * Estimate CPU usage
	     */
	    estimateCPUUsage() {
	        // Estimate based on frame time and target
	        const targetFrameTime = 1000 / this.config.targetFps;
	        const usage = Math.min(100, (this.currentMetrics.frameTime / targetFrameTime) * 100);
	        return Math.round(usage);
	    }
	    /**
	     * Estimate GPU usage
	     */
	    estimateGPUUsage() {
	        // Estimate based on draw calls and triangles
	        const drawCallFactor = Math.min(100, this.currentMetrics.drawCalls * 2);
	        const triangleFactor = Math.min(100, this.currentMetrics.triangles / 1000);
	        return Math.round((drawCallFactor + triangleFactor) / 2);
	    }
	    /**
	     * Add performance warning
	     */
	    addWarning(type, severity, message, value, threshold) {
	        const warning = {
	            type,
	            severity,
	            message,
	            timestamp: Date.now(),
	            value,
	            threshold
	        };
	        this.warnings.push(warning);
	        // Limit warnings array size
	        if (this.warnings.length > 50) {
	            this.warnings.shift();
	        }
	        this.emit('warning', warning);
	    }
	    /**
	     * Event handlers
	     */
	    updateFrameRateMetrics(metrics) {
	        // Frame rate metrics are handled in updateMetrics()
	    }
	    handleFrameDrop(data) {
	        this.addWarning('fps', data.severity, `Frame drop detected: ${data.frameTime}ms`, data.frameTime, data.expectedTime);
	    }
	    updateRenderingMetrics(data) {
	        // Rendering metrics are handled in updateMetrics()
	    }
	    handleThermalStateChange(data) {
	        if (data.state !== 'normal') {
	            this.addWarning('thermal', 'high', `Thermal state changed to ${data.state}`, data.temperature);
	        }
	    }
	    handleBatteryChange(data) {
	        if (!data.charging && data.level < 0.2) {
	            this.addWarning('battery', 'medium', `Low battery: ${Math.round(data.level * 100)}%`, data.level);
	        }
	    }
	    handleQualityAdjustment(settings) {
	        this.emit('quality-adjusted', settings);
	    }
	    /**
	     * Public API methods
	     */
	    /**
	     * Get current performance metrics
	     */
	    getMetrics() {
	        return { ...this.currentMetrics };
	    }
	    /**
	     * Get device capabilities
	     */
	    getDeviceCapabilities() {
	        const capabilities = this.deviceDetector.getCapabilities();
	        if (!capabilities) {
	            throw new Error('Device capabilities not available - ensure PerformanceMonitor is initialized');
	        }
	        return capabilities;
	    }
	    /**
	     * Get current quality settings
	     */
	    getQualitySettings() {
	        return this.gameLoopOptimizer.getQualitySettings();
	    }
	    /**
	     * Set quality settings
	     */
	    setQualitySettings(settings) {
	        this.gameLoopOptimizer.setQualitySettings(settings);
	        const fullSettings = this.gameLoopOptimizer.getQualitySettings();
	        this.mobileOptimizer.setQualitySettings(fullSettings);
	    }
	    /**
	     * Auto-adjust quality based on performance
	     */
	    autoAdjustQuality() {
	        this.gameLoopOptimizer.forceQualityAdjustment();
	    }
	    /**
	     * Force garbage collection
	     */
	    forceGC() {
	        this.memoryOptimizer.optimizeMemory();
	    }
	    /**
	     * Create an object pool
	     */
	    createObjectPool(name, config) {
	        return this.memoryOptimizer.registerPool(name, config);
	    }
	    /**
	     * Get an object pool by name
	     */
	    getObjectPool(name) {
	        return this.memoryOptimizer.getPool(name);
	    }
	    /**
	     * Enable/disable performance optimization features
	     */
	    setOptimizationEnabled(feature, enabled) {
	        this.optimizationFeatures.set(feature, enabled);
	        switch (feature) {
	            case 'batching':
	                if (enabled) {
	                    this.renderingOptimizer.enableBatching();
	                }
	                else {
	                    this.renderingOptimizer.disableBatching();
	                }
	                break;
	            case 'culling':
	                if (enabled) {
	                    this.renderingOptimizer.enableCulling();
	                }
	                else {
	                    this.renderingOptimizer.disableCulling();
	                }
	                break;
	            case 'thermal':
	                if (enabled) {
	                    this.mobileOptimizer.enableThermalThrottling();
	                }
	                else {
	                    this.mobileOptimizer.disableThermalThrottling();
	                }
	                break;
	        }
	        this.emit('optimization-feature-changed', { feature, enabled });
	    }
	    /**
	     * Get performance history
	     */
	    getPerformanceHistory(count) {
	        if (count) {
	            return this.metricsHistory.slice(-count);
	        }
	        return [...this.metricsHistory];
	    }
	    /**
	     * Get comprehensive performance report
	     */
	    getPerformanceReport() {
	        return {
	            current: this.getMetrics(),
	            device: this.getDeviceCapabilities(),
	            quality: this.getQualitySettings(),
	            components: {
	                frameRate: this.frameRateManager.getPerformanceReport(),
	                memory: this.memoryOptimizer.getReport(),
	                rendering: this.renderingOptimizer.getPerformanceReport(),
	                mobile: this.mobileOptimizer.getOptimizationReport()
	            },
	            configuration: this.config,
	            warnings: this.warnings.slice(-10), // Last 10 warnings
	            optimizationFeatures: Object.fromEntries(this.optimizationFeatures)
	        };
	    }
	    /**
	     * Export performance data
	     */
	    exportPerformanceData() {
	        const data = {
	            timestamp: Date.now(),
	            report: this.getPerformanceReport(),
	            history: this.metricsHistory,
	            profilingSessions: Array.from(this.profilingSessions.values())
	        };
	        return JSON.stringify(data, null, 2);
	    }
	    /**
	     * Clean up resources
	     */
	    destroy() {
	        this.stop();
	        // Destroy all components
	        this.deviceDetector.destroy();
	        this.gameLoopOptimizer.destroy();
	        this.frameRateManager.destroy();
	        this.memoryOptimizer.destroy();
	        this.renderingOptimizer.destroy();
	        this.mobileOptimizer.destroy();
	        // Clear data
	        this.metricsHistory.length = 0;
	        this.warnings.length = 0;
	        this.profilingSessions.clear();
	        this.performanceMarks.clear();
	        this.activeAlerts.clear();
	        this.optimizationFeatures.clear();
	        this.removeAllListeners();
	        this.isInitialized = false;
	    }
	}

	/**
	 * Performance profiler implementation
	 */
	class PerformanceProfiler extends EventEmitter {
	    constructor() {
	        super(...arguments);
	        this.sessions = new Map();
	        this.marks = new Map();
	        this.results = [];
	    }
	    /**
	     * Start profiling a named section
	     */
	    startProfiling(name) {
	        const startTime = performance.now();
	        if (!this.sessions.has(name)) {
	            this.sessions.set(name, {
	                startTime,
	                calls: 0,
	                totalTime: 0,
	                minTime: Infinity,
	                maxTime: 0
	            });
	        }
	        else {
	            this.sessions.get(name).startTime = startTime;
	        }
	    }
	    /**
	     * End profiling a named section
	     */
	    endProfiling(name) {
	        const endTime = performance.now();
	        const session = this.sessions.get(name);
	        if (!session) {
	            console.warn(`No profiling session found for: ${name}`);
	            return 0;
	        }
	        const duration = endTime - session.startTime;
	        session.calls++;
	        session.totalTime += duration;
	        session.minTime = Math.min(session.minTime, duration);
	        session.maxTime = Math.max(session.maxTime, duration);
	        // Add to results
	        const result = {
	            name,
	            duration,
	            startTime: session.startTime,
	            endTime,
	            calls: session.calls,
	            averageDuration: session.totalTime / session.calls,
	            minDuration: session.minTime,
	            maxDuration: session.maxTime
	        };
	        this.results.push(result);
	        // Limit results array size
	        if (this.results.length > 1000) {
	            this.results.shift();
	        }
	        this.emit('profiling-completed', result);
	        return duration;
	    }
	    /**
	     * Create a performance mark
	     */
	    mark(name) {
	        const time = performance.now();
	        this.marks.set(name, time);
	        // Use browser performance API if available
	        if (performance.mark) {
	            performance.mark(name);
	        }
	    }
	    /**
	     * Measure time between two marks
	     */
	    measure(name, startMark, endMark) {
	        const startTime = this.marks.get(startMark);
	        const endTime = this.marks.get(endMark);
	        if (startTime === undefined || endTime === undefined) {
	            console.warn(`Marks not found: ${startMark}, ${endMark}`);
	            return 0;
	        }
	        const duration = endTime - startTime;
	        // Use browser performance API if available
	        if (performance.measure) {
	            try {
	                performance.measure(name, startMark, endMark);
	            }
	            catch (e) {
	                // Fallback to manual calculation
	            }
	        }
	        this.emit('measurement-completed', { name, duration, startMark, endMark });
	        return duration;
	    }
	    /**
	     * Get all profiling results
	     */
	    getProfilingResults() {
	        return [...this.results];
	    }
	    /**
	     * Clear all results
	     */
	    clearResults() {
	        this.results.length = 0;
	        this.sessions.clear();
	        this.marks.clear();
	        // Clear browser performance entries if available
	        if (performance.clearMarks) {
	            performance.clearMarks();
	        }
	        if (performance.clearMeasures) {
	            performance.clearMeasures();
	        }
	        this.emit('results-cleared');
	    }
	    /**
	     * Export results as JSON
	     */
	    exportResults() {
	        const data = {
	            timestamp: Date.now(),
	            results: this.results,
	            sessions: Object.fromEntries(this.sessions),
	            marks: Object.fromEntries(this.marks)
	        };
	        return JSON.stringify(data, null, 2);
	    }
	}
	/**
	 * Performance debugging overlay with real-time metrics and graphs
	 */
	class PerformanceDebugOverlay extends EventEmitter {
	    constructor() {
	        super();
	        this._isVisible = false;
	        this.container = null;
	        this.graphs = new Map();
	        this.panels = new Map();
	        // Position and size
	        this.position = { x: 10, y: 10 };
	        this.size = { width: 320, height: 400 };
	        // Update interval
	        this.updateInterval = null;
	        this.updateRate = 500; // 2 updates per second
	        // Metrics display
	        this.currentMetrics = null;
	        this.metricsElement = null;
	        this.graphsElement = null;
	        this.profileElement = null;
	        // Styling
	        this.isDarkTheme = true;
	        this.profiler = new PerformanceProfiler();
	        this.setupProfilerListeners();
	    }
	    /**
	     * Setup profiler event listeners
	     */
	    setupProfilerListeners() {
	        this.profiler.on('profiling-completed', (result) => {
	            this.updateProfileDisplay();
	        });
	    }
	    /**
	     * Show the overlay
	     */
	    show() {
	        if (this._isVisible)
	            return;
	        this.createOverlay();
	        this.startUpdates();
	        this._isVisible = true;
	        this.emit('shown');
	    }
	    /**
	     * Hide the overlay
	     */
	    hide() {
	        if (!this._isVisible)
	            return;
	        this.destroyOverlay();
	        this.stopUpdates();
	        this._isVisible = false;
	        this.emit('hidden');
	    }
	    /**
	     * Toggle overlay visibility
	     */
	    toggle() {
	        if (this._isVisible) {
	            this.hide();
	        }
	        else {
	            this.show();
	        }
	    }
	    /**
	     * Check if overlay is visible
	     */
	    isVisible() {
	        return this._isVisible;
	    }
	    /**
	     * Update metrics display
	     */
	    updateMetrics(metrics) {
	        this.currentMetrics = metrics;
	        if (this._isVisible && this.metricsElement) {
	            this.updateMetricsDisplay();
	            this.updateGraphs(metrics);
	        }
	    }
	    /**
	     * Add a graph to the overlay
	     */
	    addGraph(name, maxValue, color, unit = '') {
	        const graph = {
	            name,
	            maxValue,
	            color,
	            unit,
	            values: [],
	            maxPoints: 100
	        };
	        this.graphs.set(name, graph);
	        if (this._isVisible) {
	            this.createGraphElement(graph);
	        }
	        this.emit('graph-added', name);
	    }
	    /**
	     * Remove a graph from the overlay
	     */
	    removeGraph(name) {
	        this.graphs.delete(name);
	        if (this._isVisible && this.graphsElement) {
	            const graphElement = this.graphsElement.querySelector(`[data-graph="${name}"]`);
	            if (graphElement) {
	                graphElement.remove();
	            }
	        }
	        this.emit('graph-removed', name);
	    }
	    /**
	     * Set overlay position
	     */
	    setPosition(x, y) {
	        this.position = { x, y };
	        if (this.container) {
	            this.container.style.left = `${x}px`;
	            this.container.style.top = `${y}px`;
	        }
	    }
	    /**
	     * Set overlay size
	     */
	    setSize(width, height) {
	        this.size = { width, height };
	        if (this.container) {
	            this.container.style.width = `${width}px`;
	            this.container.style.height = `${height}px`;
	        }
	    }
	    /**
	     * Create the overlay DOM structure
	     */
	    createOverlay() {
	        // Create main container
	        this.container = document.createElement('div');
	        this.container.className = 'performance-debug-overlay';
	        this.applyContainerStyles();
	        // Create header
	        const header = this.createHeader();
	        this.container.appendChild(header);
	        // Create tabs
	        const tabs = this.createTabs();
	        this.container.appendChild(tabs);
	        // Create metrics panel
	        this.metricsElement = this.createMetricsPanel();
	        this.container.appendChild(this.metricsElement);
	        // Create graphs panel
	        this.graphsElement = this.createGraphsPanel();
	        this.container.appendChild(this.graphsElement);
	        // Create profiler panel
	        this.profileElement = this.createProfilerPanel();
	        this.container.appendChild(this.profileElement);
	        // Add default graphs
	        this.addDefaultGraphs();
	        // Add to DOM
	        document.body.appendChild(this.container);
	        // Make draggable
	        this.makeDraggable();
	    }
	    /**
	     * Apply container styles
	     */
	    applyContainerStyles() {
	        if (!this.container)
	            return;
	        const styles = `
      position: fixed;
      left: ${this.position.x}px;
      top: ${this.position.y}px;
      width: ${this.size.width}px;
      height: ${this.size.height}px;
      background: ${this.isDarkTheme ? '#1a1a1a' : '#ffffff'};
      border: 1px solid ${this.isDarkTheme ? '#333' : '#ccc'};
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      color: ${this.isDarkTheme ? '#ffffff' : '#000000'};
      z-index: 9999;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
    `;
	        this.container.style.cssText = styles;
	    }
	    /**
	     * Create header with title and controls
	     */
	    createHeader() {
	        const header = document.createElement('div');
	        header.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: ${this.isDarkTheme ? '#2a2a2a' : '#f0f0f0'};
      border-bottom: 1px solid ${this.isDarkTheme ? '#333' : '#ccc'};
      cursor: move;
      user-select: none;
    `;
	        const title = document.createElement('span');
	        title.textContent = 'Performance Monitor';
	        title.style.fontWeight = 'bold';
	        const controls = document.createElement('div');
	        controls.style.display = 'flex';
	        controls.style.gap = '8px';
	        // Theme toggle
	        const themeButton = document.createElement('button');
	        themeButton.textContent = this.isDarkTheme ? 'â˜€ï¸' : 'ðŸŒ™';
	        themeButton.style.cssText = 'background: none; border: none; cursor: pointer; font-size: 14px;';
	        themeButton.onclick = () => this.toggleTheme();
	        // Close button
	        const closeButton = document.createElement('button');
	        closeButton.textContent = 'âœ•';
	        closeButton.style.cssText = 'background: none; border: none; cursor: pointer; color: #ff4444; font-weight: bold;';
	        closeButton.onclick = () => this.hide();
	        controls.appendChild(themeButton);
	        controls.appendChild(closeButton);
	        header.appendChild(title);
	        header.appendChild(controls);
	        return header;
	    }
	    /**
	     * Create tab navigation
	     */
	    createTabs() {
	        const tabs = document.createElement('div');
	        tabs.style.cssText = `
      display: flex;
      background: ${this.isDarkTheme ? '#333' : '#e0e0e0'};
      border-bottom: 1px solid ${this.isDarkTheme ? '#444' : '#ccc'};
    `;
	        const tabNames = ['Metrics', 'Graphs', 'Profiler'];
	        tabNames.forEach((name, index) => {
	            const tab = document.createElement('button');
	            tab.textContent = name;
	            tab.style.cssText = `
        flex: 1;
        padding: 8px;
        background: ${index === 0 ? (this.isDarkTheme ? '#444' : '#fff') : 'transparent'};
        border: none;
        color: ${this.isDarkTheme ? '#fff' : '#000'};
        cursor: pointer;
        border-bottom: 2px solid ${index === 0 ? '#4CAF50' : 'transparent'};
      `;
	            tab.onclick = () => this.switchTab(name.toLowerCase());
	            tabs.appendChild(tab);
	        });
	        return tabs;
	    }
	    /**
	     * Create metrics display panel
	     */
	    createMetricsPanel() {
	        const panel = document.createElement('div');
	        panel.className = 'metrics-panel';
	        panel.style.cssText = `
      padding: 12px;
      overflow-y: auto;
      height: calc(100% - 120px);
      display: block;
    `;
	        return panel;
	    }
	    /**
	     * Create graphs display panel
	     */
	    createGraphsPanel() {
	        const panel = document.createElement('div');
	        panel.className = 'graphs-panel';
	        panel.style.cssText = `
      padding: 12px;
      overflow-y: auto;
      height: calc(100% - 120px);
      display: none;
    `;
	        return panel;
	    }
	    /**
	     * Create profiler panel
	     */
	    createProfilerPanel() {
	        const panel = document.createElement('div');
	        panel.className = 'profiler-panel';
	        panel.style.cssText = `
      padding: 12px;
      overflow-y: auto;
      height: calc(100% - 120px);
      display: none;
    `;
	        return panel;
	    }
	    /**
	     * Add default graphs
	     */
	    addDefaultGraphs() {
	        this.addGraph('FPS', 120, '#4CAF50', 'fps');
	        this.addGraph('Frame Time', 50, '#FF9800', 'ms');
	        this.addGraph('Memory', 100, '#F44336', '%');
	        this.addGraph('Draw Calls', 200, '#2196F3', 'calls');
	    }
	    /**
	     * Update metrics display
	     */
	    updateMetricsDisplay() {
	        if (!this.metricsElement || !this.currentMetrics)
	            return;
	        const metrics = this.currentMetrics;
	        const html = `
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px;">
        <div><strong>Frame Rate</strong></div>
        <div></div>
        
        <div>Current FPS:</div>
        <div style="color: ${metrics.fps < 45 ? '#ff4444' : metrics.fps < 55 ? '#ffaa00' : '#44ff44'};">
          ${metrics.fps.toFixed(1)}
        </div>
        
        <div>Average FPS:</div>
        <div>${metrics.averageFps.toFixed(1)}</div>
        
        <div>Frame Time:</div>
        <div>${metrics.frameTime.toFixed(2)}ms</div>
        
        <div>Variance:</div>
        <div>${metrics.frameTimeVariance.toFixed(2)}ms</div>
        
        <div><strong>Memory</strong></div>
        <div></div>
        
        <div>Used:</div>
        <div style="color: ${metrics.memoryUsage.percentage > 80 ? '#ff4444' : '#44ff44'};">
          ${(metrics.memoryUsage.used / 1024 / 1024).toFixed(1)}MB (${metrics.memoryUsage.percentage.toFixed(1)}%)
        </div>
        
        <div>JS Heap:</div>
        <div>${(metrics.memoryUsage.jsHeapSizeUsed / 1024 / 1024).toFixed(1)}MB</div>
        
        <div><strong>Rendering</strong></div>
        <div></div>
        
        <div>Draw Calls:</div>
        <div style="color: ${metrics.drawCalls > 100 ? '#ff4444' : '#44ff44'};">
          ${metrics.drawCalls}
        </div>
        
        <div>Triangles:</div>
        <div>${metrics.triangles.toLocaleString()}</div>
        
        <div>Batches:</div>
        <div>${metrics.batchCount}</div>
        
        <div><strong>System</strong></div>
        <div></div>
        
        <div>CPU Usage:</div>
        <div>${metrics.cpuUsage}%</div>
        
        <div>GPU Usage:</div>
        <div>${metrics.gpuUsage}%</div>
        
        <div>Thermal State:</div>
        <div style="color: ${metrics.thermalState === 'normal' ? '#44ff44' : metrics.thermalState === 'critical' ? '#ff4444' : '#ffaa00'};">
          ${metrics.thermalState}
        </div>
      </div>
      
      ${metrics.warnings.length > 0 ? `
        <div style="margin-top: 12px; padding: 8px; background: #ff444420; border-radius: 4px;">
          <strong>Warnings (${metrics.warnings.length})</strong>
          ${metrics.warnings.slice(-3).map(w => `
            <div style="font-size: 10px; margin-top: 4px; color: #ff6666;">
              ${w.type}: ${w.message}
            </div>
          `).join('')}
        </div>
      ` : ''}
    `;
	        this.metricsElement.innerHTML = html;
	    }
	    /**
	     * Update graphs with new data
	     */
	    updateGraphs(metrics) {
	        // Update FPS graph
	        this.updateGraph('FPS', metrics.fps);
	        // Update Frame Time graph
	        this.updateGraph('Frame Time', metrics.frameTime);
	        // Update Memory graph
	        this.updateGraph('Memory', metrics.memoryUsage.percentage);
	        // Update Draw Calls graph
	        this.updateGraph('Draw Calls', metrics.drawCalls);
	    }
	    /**
	     * Update individual graph
	     */
	    updateGraph(name, value) {
	        const graph = this.graphs.get(name);
	        if (!graph)
	            return;
	        graph.values.push(value);
	        // Limit values array size
	        if (graph.values.length > graph.maxPoints) {
	            graph.values.shift();
	        }
	        // Update graph display
	        this.renderGraph(graph);
	    }
	    /**
	     * Create graph element
	     */
	    createGraphElement(graph) {
	        if (!this.graphsElement)
	            return;
	        const graphContainer = document.createElement('div');
	        graphContainer.setAttribute('data-graph', graph.name);
	        graphContainer.style.cssText = `
      margin-bottom: 16px;
      padding: 8px;
      border: 1px solid ${this.isDarkTheme ? '#444' : '#ccc'};
      border-radius: 4px;
    `;
	        const title = document.createElement('div');
	        title.textContent = `${graph.name} (${graph.unit})`;
	        title.style.cssText = 'font-weight: bold; margin-bottom: 4px; font-size: 11px;';
	        const canvas = document.createElement('canvas');
	        canvas.width = 280;
	        canvas.height = 60;
	        canvas.style.cssText = 'width: 100%; height: 60px; display: block;';
	        graphContainer.appendChild(title);
	        graphContainer.appendChild(canvas);
	        this.graphsElement.appendChild(graphContainer);
	    }
	    /**
	     * Render graph data to canvas
	     */
	    renderGraph(graph) {
	        if (!this.graphsElement)
	            return;
	        const graphElement = this.graphsElement.querySelector(`[data-graph="${graph.name}"]`);
	        if (!graphElement)
	            return;
	        const canvas = graphElement.querySelector('canvas');
	        if (!canvas)
	            return;
	        const ctx = canvas.getContext('2d');
	        if (!ctx)
	            return;
	        const { width, height } = canvas;
	        // Clear canvas
	        ctx.clearRect(0, 0, width, height);
	        // Draw background
	        ctx.fillStyle = this.isDarkTheme ? '#1a1a1a' : '#f8f8f8';
	        ctx.fillRect(0, 0, width, height);
	        // Draw grid
	        ctx.strokeStyle = this.isDarkTheme ? '#333' : '#e0e0e0';
	        ctx.lineWidth = 1;
	        // Horizontal grid lines
	        for (let i = 0; i <= 4; i++) {
	            const y = (height / 4) * i;
	            ctx.beginPath();
	            ctx.moveTo(0, y);
	            ctx.lineTo(width, y);
	            ctx.stroke();
	        }
	        // Draw values
	        if (graph.values.length > 1) {
	            ctx.strokeStyle = graph.color;
	            ctx.lineWidth = 2;
	            ctx.beginPath();
	            const pointWidth = width / (graph.maxPoints - 1);
	            graph.values.forEach((value, index) => {
	                const x = index * pointWidth;
	                const y = height - (value / graph.maxValue) * height;
	                if (index === 0) {
	                    ctx.moveTo(x, y);
	                }
	                else {
	                    ctx.lineTo(x, y);
	                }
	            });
	            ctx.stroke();
	            // Draw current value
	            const currentValue = graph.values[graph.values.length - 1];
	            const title = graphElement.querySelector('div');
	            if (title) {
	                title.textContent = `${graph.name}: ${currentValue.toFixed(1)} ${graph.unit}`;
	            }
	        }
	    }
	    /**
	     * Update profiler display
	     */
	    updateProfileDisplay() {
	        if (!this.profileElement)
	            return;
	        const results = this.profiler.getProfilingResults();
	        const sessionMap = new Map();
	        // Group results by name
	        results.forEach(result => {
	            if (!sessionMap.has(result.name)) {
	                sessionMap.set(result.name, []);
	            }
	            sessionMap.get(result.name).push(result);
	        });
	        let html = `
      <div style="display: flex; justify-content: space-between; margin-bottom: 12px;">
        <strong>Profiling Sessions</strong>
        <button onclick="this.parentElement.parentElement.clearProfiler()" 
                style="background: #ff4444; color: white; border: none; padding: 2px 8px; border-radius: 4px; cursor: pointer;">
          Clear
        </button>
      </div>
    `;
	        if (sessionMap.size === 0) {
	            html += '<div style="color: #888; font-style: italic;">No profiling data available</div>';
	        }
	        else {
	            sessionMap.forEach((sessionResults, name) => {
	                const latest = sessionResults[sessionResults.length - 1];
	                html += `
          <div style="margin-bottom: 8px; padding: 6px; background: ${this.isDarkTheme ? '#2a2a2a' : '#f0f0f0'}; border-radius: 4px;">
            <div style="font-weight: bold; font-size: 11px;">${name}</div>
            <div style="font-size: 10px; display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
              <div>Calls: ${latest.calls}</div>
              <div>Avg: ${latest.averageDuration.toFixed(2)}ms</div>
              <div>Min: ${latest.minDuration.toFixed(2)}ms</div>
              <div>Max: ${latest.maxDuration.toFixed(2)}ms</div>
            </div>
          </div>
        `;
	            });
	        }
	        this.profileElement.innerHTML = html;
	        // Add clear function to element
	        this.profileElement.clearProfiler = () => {
	            this.profiler.clearResults();
	            this.updateProfileDisplay();
	        };
	    }
	    /**
	     * Switch between tabs
	     */
	    switchTab(tabName) {
	        // Hide all panels
	        if (this.metricsElement)
	            this.metricsElement.style.display = 'none';
	        if (this.graphsElement)
	            this.graphsElement.style.display = 'none';
	        if (this.profileElement)
	            this.profileElement.style.display = 'none';
	        // Show selected panel
	        switch (tabName) {
	            case 'metrics':
	                if (this.metricsElement)
	                    this.metricsElement.style.display = 'block';
	                break;
	            case 'graphs':
	                if (this.graphsElement)
	                    this.graphsElement.style.display = 'block';
	                break;
	            case 'profiler':
	                if (this.profileElement)
	                    this.profileElement.style.display = 'block';
	                break;
	        }
	        // Update tab styles
	        if (this.container) {
	            const tabs = this.container.querySelectorAll('button');
	            tabs.forEach((tab, index) => {
	                const isActive = (index === 1 && tabName === 'metrics') ||
	                    (index === 2 && tabName === 'graphs') ||
	                    (index === 3 && tabName === 'profiler');
	                tab.style.background = isActive ? (this.isDarkTheme ? '#444' : '#fff') : 'transparent';
	                tab.style.borderBottom = `2px solid ${isActive ? '#4CAF50' : 'transparent'}`;
	            });
	        }
	    }
	    /**
	     * Toggle theme
	     */
	    toggleTheme() {
	        this.isDarkTheme = !this.isDarkTheme;
	        if (this._isVisible) {
	            this.hide();
	            this.show();
	        }
	    }
	    /**
	     * Make overlay draggable
	     */
	    makeDraggable() {
	        if (!this.container)
	            return;
	        const header = this.container.querySelector('div');
	        let isDragging = false;
	        let dragOffset = { x: 0, y: 0 };
	        header.addEventListener('mousedown', (e) => {
	            isDragging = true;
	            dragOffset.x = e.clientX - this.position.x;
	            dragOffset.y = e.clientY - this.position.y;
	            e.preventDefault();
	        });
	        document.addEventListener('mousemove', (e) => {
	            if (!isDragging)
	                return;
	            const newX = e.clientX - dragOffset.x;
	            const newY = e.clientY - dragOffset.y;
	            this.setPosition(newX, newY);
	        });
	        document.addEventListener('mouseup', () => {
	            isDragging = false;
	        });
	    }
	    /**
	     * Start update interval
	     */
	    startUpdates() {
	        this.updateInterval = window.setInterval(() => {
	            if (this.currentMetrics) {
	                this.updateMetricsDisplay();
	                this.updateGraphs(this.currentMetrics);
	            }
	        }, this.updateRate);
	    }
	    /**
	     * Stop update interval
	     */
	    stopUpdates() {
	        if (this.updateInterval) {
	            clearInterval(this.updateInterval);
	            this.updateInterval = null;
	        }
	    }
	    /**
	     * Destroy overlay DOM
	     */
	    destroyOverlay() {
	        if (this.container && this.container.parentNode) {
	            this.container.parentNode.removeChild(this.container);
	        }
	        this.container = null;
	        this.metricsElement = null;
	        this.graphsElement = null;
	        this.profileElement = null;
	    }
	    /**
	     * Get profiler instance
	     */
	    getProfiler() {
	        return this.profiler;
	    }
	    /**
	     * Set update rate
	     */
	    setUpdateRate(rateMs) {
	        this.updateRate = Math.max(100, rateMs); // Minimum 100ms
	        if (this.updateInterval) {
	            this.stopUpdates();
	            this.startUpdates();
	        }
	    }
	    /**
	     * Clean up resources
	     */
	    destroy() {
	        this.hide();
	        this.profiler.removeAllListeners();
	        this.graphs.clear();
	        this.panels.clear();
	        this.removeAllListeners();
	    }
	}

	/**
	 * Service provider for performance optimization and monitoring
	 * Integrates all performance components with the GameByte framework
	 */
	class PerformanceServiceProvider extends AbstractServiceProvider {
	    /**
	     * Register performance services in the container
	     */
	    register(app) {
	        // Register core performance monitor (singleton)
	        app.singleton('performance', () => new PerformanceMonitor());
	        // Register individual performance components (singletons)
	        app.singleton('performance.device', () => new DeviceDetector());
	        app.singleton('performance.gameloop', () => new GameLoopOptimizer());
	        app.singleton('performance.framerate', () => new FrameRateManager());
	        app.singleton('performance.memory', () => new MemoryOptimizer());
	        app.singleton('performance.rendering', () => new RenderingOptimizer());
	        app.singleton('performance.mobile', () => new MobileOptimizer());
	        // Register developer tools
	        app.singleton('performance.overlay', () => new PerformanceDebugOverlay());
	        app.singleton('performance.profiler', () => new PerformanceProfiler());
	        // Register performance configuration factory
	        app.bind('performance.config', () => this.createDefaultConfig());
	        // Register quality settings factory
	        app.bind('performance.quality', () => this.createDefaultQualitySettings());
	        // Register device tier detection helper
	        app.bind('performance.detectTier', () => async () => {
	            const deviceDetector = app.make('performance.device');
	            await deviceDetector.initialize();
	            return deviceDetector.getPerformanceTier();
	        });
	        // Register performance optimization helpers
	        app.bind('performance.optimize', () => ({
	            // Quick optimization methods
	            enableBatteryMode: () => {
	                const mobile = app.make('performance.mobile');
	                mobile.optimizeForBattery();
	            },
	            enablePerformanceMode: () => {
	                const mobile = app.make('performance.mobile');
	                mobile.optimizeForPerformance();
	            },
	            enableLowEndMode: () => {
	                const performance = app.make('performance');
	                performance.setQualitySettings({
	                    renderScale: 0.7,
	                    textureQuality: exports.QualityLevel.LOW,
	                    shadowQuality: exports.QualityLevel.LOW,
	                    effectsQuality: exports.QualityLevel.LOW,
	                    antialiasing: false,
	                    particleCount: 200,
	                    maxAudioSources: 8
	                });
	            },
	            enableHighEndMode: () => {
	                const performance = app.make('performance');
	                performance.setQualitySettings({
	                    renderScale: 1.0,
	                    textureQuality: exports.QualityLevel.ULTRA_HIGH,
	                    shadowQuality: exports.QualityLevel.HIGH,
	                    effectsQuality: exports.QualityLevel.HIGH,
	                    antialiasing: true,
	                    particleCount: 2000,
	                    maxAudioSources: 32
	                });
	            },
	            forceGC: () => {
	                const performance = app.make('performance');
	                performance.forceGC();
	            },
	            autoAdjustQuality: () => {
	                const performance = app.make('performance');
	                performance.autoAdjustQuality();
	            }
	        }));
	        // Register debug utilities
	        app.bind('performance.debug', () => ({
	            showOverlay: () => {
	                const overlay = app.make('performance.overlay');
	                overlay.show();
	            },
	            hideOverlay: () => {
	                const overlay = app.make('performance.overlay');
	                overlay.hide();
	            },
	            toggleOverlay: () => {
	                const overlay = app.make('performance.overlay');
	                overlay.toggle();
	            },
	            startProfiling: (name) => {
	                const profiler = app.make('performance.profiler');
	                profiler.startProfiling(name);
	            },
	            endProfiling: (name) => {
	                const profiler = app.make('performance.profiler');
	                return profiler.endProfiling(name);
	            },
	            exportData: () => {
	                const performance = app.make('performance');
	                return performance.exportPerformanceData();
	            },
	            getReport: () => {
	                const performance = app.make('performance');
	                return performance.getPerformanceReport();
	            }
	        }));
	        // Register auto-initialization helper
	        app.bind('performance.autoInit', () => async (config) => {
	            const performance = app.make('performance');
	            const defaultConfig = app.make('performance.config');
	            const finalConfig = { ...defaultConfig, ...config };
	            await performance.initialize(finalConfig);
	            // Auto-detect device tier and apply optimizations
	            const deviceDetector = app.make('performance.device');
	            const tier = deviceDetector.getPerformanceTier();
	            const optimizers = app.make('performance.optimize');
	            switch (tier) {
	                case 'low':
	                    if (typeof optimizers.enableLowEndMode === 'function') {
	                        optimizers.enableLowEndMode();
	                    }
	                    if (typeof optimizers.enableBatteryMode === 'function') {
	                        optimizers.enableBatteryMode();
	                    }
	                    break;
	                case 'mid':
	                    // Use balanced settings (default)
	                    break;
	                case 'high':
	                    if (typeof optimizers.enableHighEndMode === 'function') {
	                        optimizers.enableHighEndMode();
	                    }
	                    if (typeof optimizers.enablePerformanceMode === 'function') {
	                        optimizers.enablePerformanceMode();
	                    }
	                    break;
	            }
	            // Start performance monitoring
	            performance.start();
	            return performance;
	        });
	    }
	    /**
	     * Bootstrap performance services
	     */
	    async boot(app) {
	        // Setup global performance monitoring if enabled
	        const container = app.getContainer();
	        // Register global error handlers for performance monitoring
	        window.addEventListener('error', (event) => {
	            if (container.bound('performance')) {
	                app.make('performance');
	                // Log performance-related errors
	                app.emit('performance:error', {
	                    message: event.message,
	                    filename: event.filename,
	                    lineno: event.lineno,
	                    colno: event.colno,
	                    error: event.error
	                });
	            }
	        });
	        // Register unhandled promise rejections
	        window.addEventListener('unhandledrejection', (event) => {
	            if (container.bound('performance')) {
	                app.emit('performance:promise-rejection', {
	                    reason: event.reason,
	                    promise: event.promise
	                });
	            }
	        });
	        // Setup renderer integration if available
	        if (container.bound('renderer')) {
	            const renderer = app.make('renderer');
	            // Listen for renderer events and forward to performance monitor
	            renderer.on('render', (deltaTime) => {
	                if (container.bound('performance')) {
	                    const performance = app.make('performance');
	                    const overlay = app.make('performance.overlay');
	                    // Update overlay if visible
	                    if (overlay.isVisible()) {
	                        const metrics = performance.getMetrics();
	                        overlay.updateMetrics(metrics);
	                    }
	                }
	            });
	            renderer.on('resize', (width, height) => {
	                if (container.bound('performance')) {
	                    app.emit('performance:renderer-resize', { width, height });
	                }
	            });
	        }
	        // Setup keyboard shortcuts for debug overlay
	        document.addEventListener('keydown', (event) => {
	            // F1 to toggle performance overlay
	            if (event.key === 'F1' && !event.altKey && !event.ctrlKey && !event.shiftKey) {
	                event.preventDefault();
	                if (container.bound('performance.debug')) {
	                    const debug = app.make('performance.debug');
	                    debug.toggleOverlay();
	                }
	            }
	            // Ctrl+Shift+P for performance profiling toggle
	            if (event.key === 'P' && event.ctrlKey && event.shiftKey) {
	                event.preventDefault();
	                if (container.bound('performance.debug')) {
	                    const debug = app.make('performance.debug');
	                    console.log('Performance Report:', debug.getReport());
	                }
	            }
	        });
	        // Setup automatic quality adjustment based on device capabilities
	        if (container.bound('performance') && container.bound('performance.device')) {
	            try {
	                const deviceDetector = app.make('performance.device');
	                await deviceDetector.initialize();
	                const recommendations = deviceDetector.getOptimizationRecommendations();
	                if (recommendations.length > 0) {
	                    app.emit('performance:optimization-recommendations', recommendations);
	                }
	            }
	            catch (error) {
	                console.warn('Failed to initialize device detection:', error);
	            }
	        }
	        // Emit bootstrap completion
	        app.emit('performance:service-booted', {
	            services: this.provides(),
	            timestamp: Date.now()
	        });
	    }
	    /**
	     * Create default performance configuration
	     */
	    createDefaultConfig() {
	        return {
	            metricsUpdateInterval: 1000,
	            performanceHistorySize: 300,
	            targetFps: 60,
	            minFps: 30,
	            maxMemoryUsage: 0.8,
	            autoQualityAdjustment: true,
	            autoGarbageCollection: true,
	            autoThermalThrottling: true,
	            enableWarnings: true,
	            warningThresholds: {
	                lowFps: 45,
	                highMemory: 0.85,
	                highDrawCalls: 100
	            }
	        };
	    }
	    /**
	     * Create default quality settings
	     */
	    createDefaultQualitySettings() {
	        return {
	            renderScale: 1.0,
	            textureQuality: exports.QualityLevel.HIGH,
	            shadowQuality: exports.QualityLevel.HIGH,
	            effectsQuality: exports.QualityLevel.HIGH,
	            antialiasing: true,
	            physicsTimestep: 1000 / 60,
	            physicsIterations: 10,
	            maxPhysicsObjects: 1000,
	            audioQuality: exports.QualityLevel.HIGH,
	            maxAudioSources: 32,
	            uiAnimationQuality: exports.QualityLevel.HIGH,
	            particleCount: 1000
	        };
	    }
	    /**
	     * Services provided by this provider
	     */
	    provides() {
	        return [
	            'performance',
	            'performance.device',
	            'performance.gameloop',
	            'performance.framerate',
	            'performance.memory',
	            'performance.rendering',
	            'performance.mobile',
	            'performance.overlay',
	            'performance.profiler',
	            'performance.config',
	            'performance.quality',
	            'performance.detectTier',
	            'performance.optimize',
	            'performance.debug',
	            'performance.autoInit'
	        ];
	    }
	    /**
	     * Indicates this provider should be loaded immediately
	     */
	    isDeferred() {
	        return false;
	    }
	}
	/**
	 * Performance facade for static access
	 */
	class PerformanceFacade {
	    /**
	     * Set the application instance
	     */
	    static setApplication(app) {
	        PerformanceFacade.app = app;
	    }
	    /**
	     * Get performance monitor instance
	     */
	    static getMonitor() {
	        if (!PerformanceFacade.app) {
	            throw new Error('GameByte application not set on PerformanceFacade');
	        }
	        return PerformanceFacade.app.make('performance');
	    }
	    /**
	     * Get current performance metrics
	     */
	    static getMetrics() {
	        return PerformanceFacade.getMonitor().getMetrics();
	    }
	    /**
	     * Get device capabilities
	     */
	    static getDeviceCapabilities() {
	        return PerformanceFacade.getMonitor().getDeviceCapabilities();
	    }
	    /**
	     * Get quality settings
	     */
	    static getQualitySettings() {
	        return PerformanceFacade.getMonitor().getQualitySettings();
	    }
	    /**
	     * Set quality settings
	     */
	    static setQualitySettings(settings) {
	        return PerformanceFacade.getMonitor().setQualitySettings(settings);
	    }
	    /**
	     * Auto-adjust quality
	     */
	    static autoAdjustQuality() {
	        return PerformanceFacade.getMonitor().autoAdjustQuality();
	    }
	    /**
	     * Force garbage collection
	     */
	    static forceGC() {
	        return PerformanceFacade.getMonitor().forceGC();
	    }
	    /**
	     * Show debug overlay
	     */
	    static showDebugOverlay() {
	        if (!PerformanceFacade.app)
	            return;
	        const debug = PerformanceFacade.app.make('performance.debug');
	        debug.showOverlay();
	    }
	    /**
	     * Hide debug overlay
	     */
	    static hideDebugOverlay() {
	        if (!PerformanceFacade.app)
	            return;
	        const debug = PerformanceFacade.app.make('performance.debug');
	        debug.hideOverlay();
	    }
	    /**
	     * Toggle debug overlay
	     */
	    static toggleDebugOverlay() {
	        if (!PerformanceFacade.app)
	            return;
	        const debug = PerformanceFacade.app.make('performance.debug');
	        debug.toggleOverlay();
	    }
	    /**
	     * Start profiling
	     */
	    static startProfiling(name) {
	        if (!PerformanceFacade.app)
	            return;
	        const debug = PerformanceFacade.app.make('performance.debug');
	        debug.startProfiling(name);
	    }
	    /**
	     * End profiling
	     */
	    static endProfiling(name) {
	        if (!PerformanceFacade.app)
	            return 0;
	        const debug = PerformanceFacade.app.make('performance.debug');
	        return debug.endProfiling(name);
	    }
	    /**
	     * Get performance report
	     */
	    static getReport() {
	        if (!PerformanceFacade.app)
	            return null;
	        const debug = PerformanceFacade.app.make('performance.debug');
	        return debug.getReport();
	    }
	    /**
	     * Export performance data
	     */
	    static exportData() {
	        if (!PerformanceFacade.app)
	            return '';
	        const debug = PerformanceFacade.app.make('performance.debug');
	        return debug.exportData();
	    }
	    /**
	     * Enable battery optimization mode
	     */
	    static enableBatteryMode() {
	        if (!PerformanceFacade.app)
	            return;
	        const optimize = PerformanceFacade.app.make('performance.optimize');
	        optimize.enableBatteryMode();
	    }
	    /**
	     * Enable performance mode
	     */
	    static enablePerformanceMode() {
	        if (!PerformanceFacade.app)
	            return;
	        const optimize = PerformanceFacade.app.make('performance.optimize');
	        optimize.enablePerformanceMode();
	    }
	    /**
	     * Enable low-end device mode
	     */
	    static enableLowEndMode() {
	        if (!PerformanceFacade.app)
	            return;
	        const optimize = PerformanceFacade.app.make('performance.optimize');
	        optimize.enableLowEndMode();
	    }
	    /**
	     * Enable high-end device mode
	     */
	    static enableHighEndMode() {
	        if (!PerformanceFacade.app)
	            return;
	        const optimize = PerformanceFacade.app.make('performance.optimize');
	        optimize.enableHighEndMode();
	    }
	    /**
	     * Auto-initialize performance system
	     */
	    static async autoInit(config) {
	        if (!PerformanceFacade.app)
	            return null;
	        const autoInit = PerformanceFacade.app.make('performance.autoInit');
	        return await autoInit(config);
	    }
	}
	PerformanceFacade.app = null;

	/**
	 * Renderer facade for easy static access to rendering services.
	 */
	class Renderer extends Facade {
	    /**
	     * Get the service key for the renderer.
	     */
	    static getFacadeAccessor() {
	        return 'renderer';
	    }
	    /**
	     * Initialize the renderer with a canvas element.
	     */
	    static async initialize(canvas, options) {
	        const renderer = this.resolveFacadeInstance();
	        return renderer.initialize(canvas, options);
	    }
	    /**
	     * Start the render loop.
	     */
	    static start() {
	        const renderer = this.resolveFacadeInstance();
	        renderer.start();
	    }
	    /**
	     * Stop the render loop.
	     */
	    static stop() {
	        const renderer = this.resolveFacadeInstance();
	        renderer.stop();
	    }
	    /**
	     * Resize the renderer.
	     */
	    static resize(width, height) {
	        const renderer = this.resolveFacadeInstance();
	        renderer.resize(width, height);
	    }
	    /**
	     * Render a single frame.
	     */
	    static render(deltaTime) {
	        const renderer = this.resolveFacadeInstance();
	        renderer.render(deltaTime);
	    }
	    /**
	     * Get the current canvas element.
	     */
	    static getCanvas() {
	        const renderer = this.resolveFacadeInstance();
	        return renderer.getCanvas();
	    }
	    /**
	     * Get renderer statistics.
	     */
	    static getStats() {
	        const renderer = this.resolveFacadeInstance();
	        return renderer.getStats();
	    }
	    /**
	     * Get the underlying renderer instance.
	     */
	    static getInstance() {
	        return this.resolveFacadeInstance();
	    }
	}

	/**
	 * Scenes facade for easy static access to scene management services.
	 */
	class Scenes extends Facade {
	    /**
	     * Get the service key for the scene manager.
	     */
	    static getFacadeAccessor() {
	        return 'scene.manager';
	    }
	    /**
	     * Register a scene with the manager.
	     */
	    static add(scene) {
	        const manager = this.resolveFacadeInstance();
	        manager.add(scene);
	    }
	    /**
	     * Remove a scene from the manager.
	     */
	    static remove(sceneId) {
	        const manager = this.resolveFacadeInstance();
	        manager.remove(sceneId);
	    }
	    /**
	     * Switch to a different scene.
	     */
	    static async switchTo(sceneId, transition) {
	        const manager = this.resolveFacadeInstance();
	        return manager.switchTo(sceneId, transition);
	    }
	    /**
	     * Get the currently active scene.
	     */
	    static getCurrentScene() {
	        const manager = this.resolveFacadeInstance();
	        return manager.getCurrentScene();
	    }
	    /**
	     * Get a scene by its ID.
	     */
	    static getScene(sceneId) {
	        const manager = this.resolveFacadeInstance();
	        return manager.getScene(sceneId);
	    }
	    /**
	     * Check if a scene exists.
	     */
	    static hasScene(sceneId) {
	        const manager = this.resolveFacadeInstance();
	        return manager.hasScene(sceneId);
	    }
	    /**
	     * Update the current scene.
	     */
	    static update(deltaTime) {
	        const manager = this.resolveFacadeInstance();
	        manager.update(deltaTime);
	    }
	    /**
	     * Render the current scene.
	     */
	    static render(renderer) {
	        const manager = this.resolveFacadeInstance();
	        manager.render(renderer);
	    }
	    /**
	     * Get the underlying scene manager instance.
	     */
	    static getInstance() {
	        return this.resolveFacadeInstance();
	    }
	}

	/**
	 * Plugins facade for easy static access to plugin management services.
	 */
	class Plugins extends Facade {
	    /**
	     * Get the service key for the plugin manager.
	     */
	    static getFacadeAccessor() {
	        return 'plugin.manager';
	    }
	    /**
	     * Register a plugin with the framework.
	     */
	    static register(config) {
	        const manager = this.resolveFacadeInstance();
	        manager.register(config);
	    }
	    /**
	     * Load a plugin by registering its service provider.
	     */
	    static async load(pluginName) {
	        const manager = this.resolveFacadeInstance();
	        return manager.load(pluginName);
	    }
	    /**
	     * Unload a plugin by removing its services.
	     */
	    static unload(pluginName) {
	        const manager = this.resolveFacadeInstance();
	        manager.unload(pluginName);
	    }
	    /**
	     * Enable a plugin.
	     */
	    static enable(pluginName) {
	        const manager = this.resolveFacadeInstance();
	        manager.enable(pluginName);
	    }
	    /**
	     * Disable a plugin.
	     */
	    static disable(pluginName) {
	        const manager = this.resolveFacadeInstance();
	        manager.disable(pluginName);
	    }
	    /**
	     * Load all registered and enabled plugins.
	     */
	    static async loadAll() {
	        const manager = this.resolveFacadeInstance();
	        return manager.loadAll();
	    }
	    /**
	     * Get plugin information.
	     */
	    static getPlugin(pluginName) {
	        const manager = this.resolveFacadeInstance();
	        return manager.getPlugin(pluginName);
	    }
	    /**
	     * Get all registered plugins.
	     */
	    static getAllPlugins() {
	        const manager = this.resolveFacadeInstance();
	        return manager.getAllPlugins();
	    }
	    /**
	     * Check if a plugin is registered.
	     */
	    static hasPlugin(pluginName) {
	        const manager = this.resolveFacadeInstance();
	        return manager.hasPlugin(pluginName);
	    }
	    /**
	     * Check if a plugin is loaded.
	     */
	    static isLoaded(pluginName) {
	        const manager = this.resolveFacadeInstance();
	        return manager.isLoaded(pluginName);
	    }
	    /**
	     * Check if a plugin is enabled.
	     */
	    static isEnabled(pluginName) {
	        const manager = this.resolveFacadeInstance();
	        return manager.isEnabled(pluginName);
	    }
	    /**
	     * Get the underlying plugin manager instance.
	     */
	    static getInstance() {
	        return this.resolveFacadeInstance();
	    }
	}

	/**
	 * UI facade for static access to the UI system
	 */
	class UI extends Facade {
	    /**
	     * Get the facade accessor
	     */
	    static getFacadeAccessor() {
	        return 'ui.manager';
	    }
	    /**
	     * Get the UI manager instance
	     */
	    static manager() {
	        return this.resolveFacadeInstance();
	    }
	    /**
	     * Show a screen
	     */
	    static async showScreen(screenName, data) {
	        return this.callStatic('showScreen', [screenName, data]);
	    }
	    /**
	     * Hide a screen
	     */
	    static async hideScreen(screenName) {
	        return this.callStatic('hideScreen', [screenName]);
	    }
	    /**
	     * Get current screen
	     */
	    static getCurrentScreen() {
	        return this.callStatic('getCurrentScreen', []);
	    }
	    /**
	     * Register a screen
	     */
	    static registerScreen(screen) {
	        return this.callStatic('registerScreen', [screen]);
	    }
	    /**
	     * Create a component
	     */
	    static createComponent(type, config) {
	        return this.callStatic('createComponent', [type, config]);
	    }
	    /**
	     * Register a component factory
	     */
	    static registerComponent(type, factory) {
	        return this.callStatic('registerComponent', [type, factory]);
	    }
	    /**
	     * Handle interaction event
	     */
	    static handleInteraction(event) {
	        return this.callStatic('handleInteraction', [event]);
	    }
	    /**
	     * Request layout update
	     */
	    static requestLayout() {
	        return this.callStatic('requestLayout', []);
	    }
	    /**
	     * Set theme
	     */
	    static setTheme(theme) {
	        return this.callStatic('setTheme', [theme]);
	    }
	    /**
	     * Get current theme
	     */
	    static getTheme() {
	        return this.callStatic('getTheme', []);
	    }
	    /**
	     * Get root UI component
	     */
	    static getRoot() {
	        return this.callStatic('root', []);
	    }
	    /**
	     * Handle orientation change
	     */
	    static handleOrientationChange(orientation) {
	        return this.callStatic('handleOrientationChange', [orientation]);
	    }
	}
	/**
	 * Animations facade for static access to the animation system
	 */
	class Animations extends Facade {
	    /**
	     * Get the facade accessor
	     */
	    static getFacadeAccessor() {
	        return 'ui.animations';
	    }
	    /**
	     * Animate properties to target values
	     */
	    static async to(target, properties, config) {
	        return this.callStatic('to', [target, properties, config]);
	    }
	    /**
	     * Animate properties from initial values
	     */
	    static async from(target, properties, config) {
	        return this.callStatic('from', [target, properties, config]);
	    }
	    /**
	     * Set properties immediately
	     */
	    static set(target, properties) {
	        return this.callStatic('set', [target, properties]);
	    }
	    /**
	     * Create a timeline
	     */
	    static createTimeline() {
	        return this.callStatic('createTimeline', []);
	    }
	    /**
	     * Spring animation
	     */
	    static async spring(target, properties, config) {
	        return this.callStatic('spring', [target, properties, config]);
	    }
	    /**
	     * Kill all animations for target
	     */
	    static killTweensOf(target) {
	        return this.callStatic('killTweensOf', [target]);
	    }
	    /**
	     * Pause all animations
	     */
	    static pauseAll() {
	        return this.callStatic('pauseAll', []);
	    }
	    /**
	     * Resume all animations
	     */
	    static resumeAll() {
	        return this.callStatic('resumeAll', []);
	    }
	    /**
	     * Set global time scale
	     */
	    static setTimeScale(scale) {
	        return this.callStatic('setTimeScale', [scale]);
	    }
	}
	/**
	 * Themes facade for static access to the theme system
	 */
	class Themes extends Facade {
	    /**
	     * Get the facade accessor
	     */
	    static getFacadeAccessor() {
	        return 'ui.themes';
	    }
	    /**
	     * Register a theme
	     */
	    static registerTheme(theme) {
	        return this.callStatic('registerTheme', [theme]);
	    }
	    /**
	     * Set active theme
	     */
	    static setTheme(themeName) {
	        return this.callStatic('setTheme', [themeName]);
	    }
	    /**
	     * Get current theme
	     */
	    static getCurrentTheme() {
	        return this.callStatic('getCurrentTheme', []);
	    }
	    /**
	     * Get available themes
	     */
	    static getAvailableThemes() {
	        return this.callStatic('getAvailableThemes', []);
	    }
	}

	/**
	 * Input facade for convenient static access to input system functionality
	 * Provides a clean API for game developers to interact with the input system
	 */
	class Input extends Facade {
	    /**
	     * Get the service key for the facade
	     */
	    static getFacadeAccessor() {
	        return 'input.manager';
	    }
	    /**
	     * Get the input manager instance
	     */
	    static getInputManager() {
	        return this.app.make('input.manager');
	    }
	    /**
	     * Get the virtual controls manager instance
	     */
	    static getVirtualControls() {
	        return this.app.make('input.virtualControls');
	    }
	    /**
	     * Get the input mapping manager instance
	     */
	    static getInputMapping() {
	        return this.app.make('input.mapping');
	    }
	    /**
	     * Get the performance manager instance
	     */
	    static getPerformanceManager() {
	        return this.app.make('input.performance');
	    }
	    // === Core Input Management ===
	    /**
	     * Initialize input system with DOM element
	     */
	    static initialize(element) {
	        try {
	            this.getInputManager().initialize(element);
	        }
	        catch (error) {
	            console.error('Failed to initialize input system:', error);
	            throw error;
	        }
	    }
	    /**
	     * Set current input context
	     */
	    static setContext(context) {
	        try {
	            this.getInputManager().setContext(context);
	        }
	        catch (error) {
	            console.warn('Failed to set input context:', error);
	        }
	    }
	    /**
	     * Get current input context
	     */
	    static getContext() {
	        try {
	            return this.getInputManager().currentContext;
	        }
	        catch (error) {
	            console.warn('Failed to get input context:', error);
	            return 'menu'; // Default fallback
	        }
	    }
	    /**
	     * Enable/disable input processing
	     */
	    static setEnabled(enabled) {
	        this.getInputManager().setEnabled(enabled);
	    }
	    /**
	     * Get device capabilities
	     */
	    static getDeviceCapabilities() {
	        return this.getInputManager().deviceCapabilities;
	    }
	    /**
	     * Add input handler
	     */
	    static addHandler(handler) {
	        this.getInputManager().addHandler(handler);
	    }
	    /**
	     * Remove input handler
	     */
	    static removeHandler(handlerName) {
	        this.getInputManager().removeHandler(handlerName);
	    }
	    /**
	     * Get input handler by name
	     */
	    static getHandler(handlerName) {
	        try {
	            return this.getInputManager().getHandler(handlerName);
	        }
	        catch (error) {
	            console.warn('Failed to get input handler:', error);
	            return null;
	        }
	    }
	    // === Event Listening ===
	    /**
	     * Listen for input actions
	     */
	    static onAction(action, callback) {
	        this.getInputManager().on('action', (receivedAction, data, source) => {
	            if (receivedAction === action) {
	                callback(data, source);
	            }
	        });
	    }
	    /**
	     * Listen for any input action
	     */
	    static onAnyAction(callback) {
	        this.getInputManager().on('action', callback);
	    }
	    /**
	     * Listen for context changes
	     */
	    static onContextChange(callback) {
	        this.getInputManager().on('context-changed', callback);
	    }
	    /**
	     * Listen for raw input events
	     */
	    static onRawInput(callback) {
	        this.getInputManager().on('raw-input', callback);
	    }
	    // === Virtual Controls ===
	    /**
	     * Add virtual control
	     */
	    static addVirtualControl(id, config) {
	        const fullConfig = { ...config, id };
	        this.getVirtualControls().addControl(fullConfig);
	    }
	    /**
	     * Remove virtual control
	     */
	    static removeVirtualControl(id) {
	        this.getVirtualControls().removeControl(id);
	    }
	    /**
	     * Update virtual control configuration
	     */
	    static updateVirtualControl(id, config) {
	        this.getVirtualControls().updateControl(id, config);
	    }
	    /**
	     * Show/hide virtual controls
	     */
	    static setVirtualControlsVisible(visible) {
	        this.getVirtualControls().setVisible(visible);
	    }
	    /**
	     * Enable/disable virtual controls
	     */
	    static setVirtualControlsEnabled(enabled) {
	        this.getVirtualControls().setEnabled(enabled);
	    }
	    /**
	     * Update virtual controls layout for screen size
	     */
	    static updateVirtualControlsLayout(screenSize) {
	        this.getVirtualControls().updateLayout(screenSize);
	    }
	    // === Input Mapping ===
	    /**
	     * Load input profile
	     */
	    static loadInputProfile(profile) {
	        this.getInputMapping().saveProfile(profile);
	        this.getInputMapping().loadSavedProfile(profile.id);
	    }
	    /**
	     * Get current input profile
	     */
	    static getCurrentInputProfile() {
	        return this.getInputMapping().getCurrentProfile();
	    }
	    /**
	     * Add input mapping
	     */
	    static addInputMapping(mapping) {
	        this.getInputMapping().setMapping(mapping);
	    }
	    /**
	     * Remove input mapping
	     */
	    static removeInputMapping(context, deviceType, trigger) {
	        const input = `${deviceType}:${trigger}`;
	        this.getInputMapping().removeMapping(context, input);
	    }
	    /**
	     * Get available input profiles
	     */
	    static getAvailableInputProfiles() {
	        return this.getInputMapping().getAvailableProfiles();
	    }
	    /**
	     * Load saved input profile
	     */
	    static loadSavedInputProfile(name) {
	        return this.getInputMapping().loadSavedProfile(name);
	    }
	    /**
	     * Save current input profile
	     */
	    static saveInputProfile(name) {
	        const currentProfile = this.getInputMapping().getCurrentProfile();
	        if (currentProfile) {
	            const profileToSave = { ...currentProfile, name, id: name };
	            this.getInputMapping().saveProfile(profileToSave);
	        }
	    }
	    // === Settings & Configuration ===
	    /**
	     * Configure input settings
	     */
	    static configure(settings) {
	        this.getInputManager().configure(settings);
	    }
	    /**
	     * Get current input settings
	     */
	    static getSettings() {
	        return this.getInputManager().getSettings();
	    }
	    // === Performance Management ===
	    /**
	     * Get performance metrics
	     */
	    static getPerformanceMetrics() {
	        return this.getPerformanceManager().getMetrics();
	    }
	    /**
	     * Set performance mode
	     */
	    static setPerformanceMode(mode) {
	        this.getPerformanceManager().setPerformanceMode(mode);
	    }
	    /**
	     * Enable/disable input prediction
	     */
	    static enableInputPrediction(enabled) {
	        this.getPerformanceManager().enablePrediction(enabled);
	    }
	    /**
	     * Optimize for battery life
	     */
	    static optimizeForBattery() {
	        this.getPerformanceManager().optimizeForBattery();
	    }
	    /**
	     * Optimize for performance
	     */
	    static optimizeForPerformance() {
	        this.getPerformanceManager().optimizeForPerformance();
	    }
	    // === Game-Specific Helpers ===
	    /**
	     * Quick setup for platformer game controls
	     */
	    static setupPlatformerControls() {
	        this.loadSavedInputProfile('Platformer');
	        this.setContext('gameplay');
	        // Add virtual controls for mobile
	        if (this.getDeviceCapabilities().hasTouchScreen && !this.getDeviceCapabilities().hasKeyboard) {
	            this.addVirtualControl('movement-joystick', {
	                type: 'joystick',
	                position: { x: 60, y: window.innerHeight - 140 },
	                size: { width: 120, height: 120 },
	                visible: true,
	                alpha: 0.7,
	                deadZone: 0.15,
	                returnToCenter: true,
	                maxDistance: 50
	            });
	            this.addVirtualControl('jump-button', {
	                type: 'button',
	                position: { x: window.innerWidth - 120, y: window.innerHeight - 140 },
	                size: { width: 80, height: 80 },
	                visible: true,
	                alpha: 0.7,
	                action: 'jump'
	            });
	        }
	    }
	    /**
	     * Quick setup for top-down game controls
	     */
	    static setupTopDownControls() {
	        this.loadSavedInputProfile('Top-Down');
	        this.setContext('gameplay');
	        // Add virtual controls for mobile
	        if (this.getDeviceCapabilities().hasTouchScreen && !this.getDeviceCapabilities().hasKeyboard) {
	            this.addVirtualControl('movement-joystick', {
	                type: 'joystick',
	                position: { x: 60, y: window.innerHeight - 140 },
	                size: { width: 120, height: 120 },
	                visible: true,
	                alpha: 0.7,
	                deadZone: 0.1,
	                returnToCenter: true
	            });
	            this.addVirtualControl('action-button', {
	                type: 'button',
	                position: { x: window.innerWidth - 120, y: window.innerHeight - 140 },
	                size: { width: 80, height: 80 },
	                visible: true,
	                alpha: 0.7,
	                action: 'attack'
	            });
	        }
	    }
	    /**
	     * Quick setup for menu navigation
	     */
	    static setupMenuNavigation() {
	        this.setContext('menu');
	        this.setVirtualControlsVisible(false);
	    }
	    /**
	     * Quick setup for pause menu
	     */
	    static setupPauseMenu() {
	        this.setContext('pause');
	        this.setVirtualControlsVisible(false);
	    }
	    // === Convenience Methods ===
	    /**
	     * Check if specific action is currently active
	     */
	    static isActionActive(action) {
	        // This would need to be implemented based on current handler states
	        // For now, return false as a placeholder
	        return false;
	    }
	    /**
	     * Get movement vector from player movement handler
	     */
	    static getMovementVector() {
	        try {
	            const handler = this.getHandler('player-movement');
	            if (handler && 'getMovementVector' in handler) {
	                return handler.getMovementVector();
	            }
	        }
	        catch (error) {
	            console.warn('Failed to get movement vector:', error);
	        }
	        return { x: 0, y: 0 };
	    }
	    /**
	     * Check if player is moving
	     */
	    static isPlayerMoving() {
	        try {
	            const handler = this.getHandler('player-movement');
	            if (handler && 'isMoving' in handler) {
	                return handler.isMoving();
	            }
	        }
	        catch (error) {
	            console.warn('Failed to check if player is moving:', error);
	        }
	        return false;
	    }
	    /**
	     * Check if jump is pressed (for platformer games)
	     */
	    static isJumpPressed() {
	        try {
	            const handler = this.getHandler('platformer-input');
	            if (handler && 'isJumpPressed' in handler) {
	                return handler.isJumpPressed();
	            }
	        }
	        catch (error) {
	            console.warn('Failed to check if jump is pressed:', error);
	        }
	        return false;
	    }
	    /**
	     * Check if jump was just pressed this frame (for platformer games)
	     */
	    static wasJumpJustPressed() {
	        try {
	            const handler = this.getHandler('platformer-input');
	            if (handler && 'wasJumpJustPressed' in handler) {
	                return handler.wasJumpJustPressed();
	            }
	        }
	        catch (error) {
	            console.warn('Failed to check if jump was just pressed:', error);
	        }
	        return false;
	    }
	    /**
	     * Get camera pan delta
	     */
	    static getCameraPanDelta() {
	        try {
	            const handler = this.getHandler('camera-input');
	            if (handler && 'getPanDelta' in handler) {
	                return handler.getPanDelta();
	            }
	        }
	        catch (error) {
	            console.warn('Failed to get camera pan delta:', error);
	        }
	        return { x: 0, y: 0 };
	    }
	    /**
	     * Get camera zoom delta
	     */
	    static getCameraZoomDelta() {
	        try {
	            const handler = this.getHandler('camera-input');
	            if (handler && 'getZoomDelta' in handler) {
	                return handler.getZoomDelta();
	            }
	        }
	        catch (error) {
	            console.warn('Failed to get camera zoom delta:', error);
	        }
	        return 0;
	    }
	    // === Mobile-Specific Helpers ===
	    /**
	     * Check if device is mobile
	     */
	    static isMobile() {
	        const capabilities = this.getDeviceCapabilities();
	        return capabilities.hasTouchScreen && !capabilities.hasKeyboard;
	    }
	    /**
	     * Check if device has touch support
	     */
	    static hasTouchScreen() {
	        return this.getDeviceCapabilities().hasTouchScreen;
	    }
	    /**
	     * Check if device has gamepad support
	     */
	    static hasGamepad() {
	        return this.getDeviceCapabilities().hasGamepad;
	    }
	    /**
	     * Trigger haptic feedback (mobile)
	     */
	    static vibrate(pattern) {
	        if ('vibrate' in navigator) {
	            navigator.vibrate(pattern);
	        }
	    }
	    // === Debug & Development Helpers ===
	    /**
	     * Enable debug mode with input visualization
	     */
	    static enableDebugMode() {
	        this.onRawInput((event) => {
	            console.log('Input Event:', event);
	        });
	        this.onAnyAction((action, data, source) => {
	            console.log(`Action: ${action} [${source}]`, data);
	        });
	    }
	    /**
	     * Get debug information
	     */
	    static getDebugInfo() {
	        return {
	            context: this.getContext(),
	            capabilities: this.getDeviceCapabilities(),
	            settings: this.getSettings(),
	            metrics: this.getPerformanceMetrics(),
	            profile: this.getCurrentInputProfile()?.name || 'None'
	        };
	    }
	}

	/**
	 * Physics facade for easy access to physics functionality
	 */
	class Physics extends Facade {
	    /**
	     * Get the facade accessor key
	     */
	    static getFacadeAccessor() {
	        return 'physics';
	    }
	    /**
	     * Get the physics manager instance
	     */
	    static getManager() {
	        return this.resolve();
	    }
	    /**
	     * Initialize the physics system
	     */
	    static async initialize(dimension, engineType) {
	        const manager = this.getManager();
	        return manager.initialize(dimension, engineType);
	    }
	    /**
	     * Create a physics world
	     */
	    static createWorld(config) {
	        const manager = this.getManager();
	        return manager.createWorld(config);
	    }
	    /**
	     * Get the active physics world
	     */
	    static getActiveWorld() {
	        const manager = this.getManager();
	        return manager.getActiveWorld();
	    }
	    /**
	     * Set the active physics world
	     */
	    static setActiveWorld(world) {
	        const manager = this.getManager();
	        manager.setActiveWorld(world);
	    }
	    /**
	     * Create a physics body in the active world
	     */
	    static createBody(config) {
	        const world = this.getActiveWorld();
	        if (!world) {
	            throw new Error('No active physics world. Create a world first.');
	        }
	        return world.createBody(config);
	    }
	    /**
	     * Create a physics material
	     */
	    static createMaterial(config) {
	        const manager = this.getManager();
	        return manager.createMaterial(config);
	    }
	    /**
	     * Get a material by ID
	     */
	    static getMaterial(id) {
	        const manager = this.getManager();
	        return manager.getMaterial(id);
	    }
	    /**
	     * Create a platformer physics helper
	     */
	    static createPlatformerHelper(character) {
	        const manager = this.getManager();
	        return manager.createPlatformerHelper(character);
	    }
	    /**
	     * Create a top-down physics helper
	     */
	    static createTopDownHelper(character) {
	        const manager = this.getManager();
	        return manager.createTopDownHelper(character);
	    }
	    /**
	     * Create a trigger zone
	     */
	    static createTriggerZone(config) {
	        const manager = this.getManager();
	        return manager.createTriggerZone(config);
	    }
	    /**
	     * Create a particle system
	     */
	    static createParticleSystem(config) {
	        const manager = this.getManager();
	        return manager.createParticleSystem(config);
	    }
	    /**
	     * Get the mobile optimizer
	     */
	    static getMobileOptimizer() {
	        const manager = this.getManager();
	        return manager.getMobileOptimizer();
	    }
	    /**
	     * Enable mobile optimizations
	     */
	    static enableMobileOptimizations() {
	        const manager = this.getManager();
	        manager.enableMobileOptimizations();
	    }
	    /**
	     * Set device tier for optimization
	     */
	    static setDeviceTier(tier) {
	        const manager = this.getManager();
	        manager.setDeviceTier(tier);
	    }
	    /**
	     * Get performance metrics
	     */
	    static getPerformanceMetrics() {
	        const manager = this.getManager();
	        return manager.getPerformanceMetrics();
	    }
	    /**
	     * Enable debug mode
	     */
	    static enableDebugMode(enabled) {
	        const manager = this.getManager();
	        manager.enableDebugMode(enabled);
	    }
	    /**
	     * Optimize for mobile devices
	     */
	    static optimizeForMobile() {
	        const manager = this.getManager();
	        manager.optimizeForMobile();
	    }
	    /**
	     * Switch physics engine
	     */
	    static async switchEngine(engineType) {
	        const manager = this.getManager();
	        return manager.switchEngine(engineType);
	    }
	    /**
	     * Check if physics is initialized
	     */
	    static isInitialized() {
	        const manager = this.getManager();
	        return manager.isInitialized;
	    }
	    /**
	     * Get current dimension
	     */
	    static getDimension() {
	        const manager = this.getManager();
	        return manager.dimension;
	    }
	    /**
	     * Perform a raycast in the active world
	     */
	    static raycast(options) {
	        const world = this.getActiveWorld();
	        if (!world) {
	            throw new Error('No active physics world. Create a world first.');
	        }
	        return world.raycast(options);
	    }
	    /**
	     * Query bodies in AABB in the active world
	     */
	    static queryAABB(min, max) {
	        const world = this.getActiveWorld();
	        if (!world) {
	            throw new Error('No active physics world. Create a world first.');
	        }
	        return world.queryAABB(min, max);
	    }
	    /**
	     * Query bodies at point in the active world
	     */
	    static queryPoint(point) {
	        const world = this.getActiveWorld();
	        if (!world) {
	            throw new Error('No active physics world. Create a world first.');
	        }
	        return world.queryPoint(point);
	    }
	    /**
	     * Start the active physics world
	     */
	    static start() {
	        const world = this.getActiveWorld();
	        if (world) {
	            world.start();
	        }
	    }
	    /**
	     * Stop the active physics world
	     */
	    static stop() {
	        const world = this.getActiveWorld();
	        if (world) {
	            world.stop();
	        }
	    }
	    /**
	     * Pause the active physics world
	     */
	    static pause() {
	        const world = this.getActiveWorld();
	        if (world) {
	            world.pause();
	        }
	    }
	    /**
	     * Resume the active physics world
	     */
	    static resume() {
	        const world = this.getActiveWorld();
	        if (world) {
	            world.resume();
	        }
	    }
	    /**
	     * Clear all bodies and constraints from the active world
	     */
	    static clear() {
	        const world = this.getActiveWorld();
	        if (world) {
	            world.clear();
	        }
	    }
	}

	/**
	 * Performance facade for static access to performance optimization features
	 *
	 * @example
	 * ```typescript
	 * import { Performance } from 'gamebyte-framework';
	 *
	 * // Get current performance metrics
	 * const metrics = Performance.getMetrics();
	 * console.log(`FPS: ${metrics.fps}, Memory: ${metrics.memoryUsage.percentage}%`);
	 *
	 * // Show debug overlay
	 * Performance.showDebugOverlay();
	 *
	 * // Auto-adjust quality based on performance
	 * Performance.autoAdjustQuality();
	 *
	 * // Enable battery optimization mode
	 * Performance.enableBatteryMode();
	 *
	 * // Start/end profiling
	 * Performance.startProfiling('update-loop');
	 * // ... code to profile ...
	 * const duration = Performance.endProfiling('update-loop');
	 * ```
	 */
	class Performance extends Facade {
	    /**
	     * Get the service key for the facade
	     */
	    static getFacadeAccessor() {
	        return 'performance';
	    }
	    /**
	     * Get current performance metrics
	     */
	    static getMetrics() {
	        return PerformanceFacade.getMetrics();
	    }
	    /**
	     * Get device capabilities
	     */
	    static getDeviceCapabilities() {
	        return PerformanceFacade.getDeviceCapabilities();
	    }
	    /**
	     * Get current quality settings
	     */
	    static getQualitySettings() {
	        return PerformanceFacade.getQualitySettings();
	    }
	    /**
	     * Set quality settings
	     */
	    static setQualitySettings(settings) {
	        return PerformanceFacade.setQualitySettings(settings);
	    }
	    /**
	     * Auto-adjust quality based on current performance
	     */
	    static autoAdjustQuality() {
	        return PerformanceFacade.autoAdjustQuality();
	    }
	    /**
	     * Force garbage collection
	     */
	    static forceGC() {
	        return PerformanceFacade.forceGC();
	    }
	    /**
	     * Show performance debug overlay
	     */
	    static showDebugOverlay() {
	        return PerformanceFacade.showDebugOverlay();
	    }
	    /**
	     * Hide performance debug overlay
	     */
	    static hideDebugOverlay() {
	        return PerformanceFacade.hideDebugOverlay();
	    }
	    /**
	     * Toggle performance debug overlay visibility
	     */
	    static toggleDebugOverlay() {
	        return PerformanceFacade.toggleDebugOverlay();
	    }
	    /**
	     * Start profiling a named section
	     */
	    static startProfiling(name) {
	        return PerformanceFacade.startProfiling(name);
	    }
	    /**
	     * End profiling a named section and return duration
	     */
	    static endProfiling(name) {
	        return PerformanceFacade.endProfiling(name);
	    }
	    /**
	     * Get comprehensive performance report
	     */
	    static getReport() {
	        return PerformanceFacade.getReport();
	    }
	    /**
	     * Export performance data as JSON string
	     */
	    static exportData() {
	        return PerformanceFacade.exportData();
	    }
	    /**
	     * Enable battery optimization mode
	     */
	    static enableBatteryMode() {
	        return PerformanceFacade.enableBatteryMode();
	    }
	    /**
	     * Enable performance mode
	     */
	    static enablePerformanceMode() {
	        return PerformanceFacade.enablePerformanceMode();
	    }
	    /**
	     * Enable low-end device optimizations
	     */
	    static enableLowEndMode() {
	        return PerformanceFacade.enableLowEndMode();
	    }
	    /**
	     * Enable high-end device optimizations
	     */
	    static enableHighEndMode() {
	        return PerformanceFacade.enableHighEndMode();
	    }
	    /**
	     * Auto-initialize performance system with device detection
	     */
	    static async autoInit(config) {
	        return PerformanceFacade.autoInit(config);
	    }
	    /**
	     * Utility method to profile a function
	     */
	    static async profile(name, fn) {
	        Performance.startProfiling(name);
	        try {
	            const result = await fn();
	            const duration = Performance.endProfiling(name);
	            return { result, duration };
	        }
	        catch (error) {
	            Performance.endProfiling(name);
	            throw error;
	        }
	    }
	    /**
	     * Monitor performance for a duration and return statistics
	     */
	    static async monitor(durationMs) {
	        const startTime = Date.now();
	        const samples = [];
	        return new Promise((resolve) => {
	            const interval = setInterval(() => {
	                const metrics = Performance.getMetrics();
	                samples.push(metrics);
	                if (Date.now() - startTime >= durationMs) {
	                    clearInterval(interval);
	                    if (samples.length === 0) {
	                        resolve({
	                            averageFps: 0,
	                            minFps: 0,
	                            maxFps: 0,
	                            averageMemory: 0,
	                            peakMemory: 0,
	                            warnings: 0
	                        });
	                        return;
	                    }
	                    const avgFps = samples.reduce((sum, s) => sum + s.fps, 0) / samples.length;
	                    const minFps = Math.min(...samples.map(s => s.fps));
	                    const maxFps = Math.max(...samples.map(s => s.fps));
	                    const avgMemory = samples.reduce((sum, s) => sum + s.memoryUsage.percentage, 0) / samples.length;
	                    const peakMemory = Math.max(...samples.map(s => s.memoryUsage.percentage));
	                    const warnings = samples.reduce((sum, s) => sum + s.warnings.length, 0);
	                    resolve({
	                        averageFps: Math.round(avgFps),
	                        minFps: Math.round(minFps),
	                        maxFps: Math.round(maxFps),
	                        averageMemory: Math.round(avgMemory),
	                        peakMemory: Math.round(peakMemory),
	                        warnings
	                    });
	                }
	            }, 100); // Sample every 100ms
	        });
	    }
	    /**
	     * Run a performance benchmark
	     */
	    static async benchmark() {
	        // CPU benchmark
	        const cpuResult = await Performance.profile('cpu-benchmark', () => {
	            let result = 0;
	            for (let i = 0; i < 100000; i++) {
	                result += Math.sin(i) * Math.cos(i) + Math.sqrt(i);
	            }
	            return result;
	        });
	        const cpuScore = Math.max(0, Math.min(100, 100 - (cpuResult.duration / 10)));
	        // Memory benchmark
	        const memoryBefore = Performance.getMetrics().memoryUsage.percentage;
	        const arrays = [];
	        for (let i = 0; i < 1000; i++) {
	            arrays.push(new Array(1000).fill(Math.random()));
	        }
	        await new Promise(resolve => setTimeout(resolve, 100));
	        const memoryAfter = Performance.getMetrics().memoryUsage.percentage;
	        const memoryDiff = memoryAfter - memoryBefore;
	        const memoryScore = Math.max(0, Math.min(100, 100 - memoryDiff));
	        // Cleanup
	        arrays.length = 0;
	        Performance.forceGC();
	        // Render benchmark (simplified)
	        const renderMetrics = Performance.getMetrics();
	        const renderScore = Math.min(100, renderMetrics.fps * 1.5);
	        const overallScore = (cpuScore + memoryScore + renderScore) / 3;
	        let tier;
	        if (overallScore >= 75)
	            tier = 'high';
	        else if (overallScore >= 45)
	            tier = 'mid';
	        else
	            tier = 'low';
	        return {
	            cpuScore: Math.round(cpuScore),
	            memoryScore: Math.round(memoryScore),
	            renderScore: Math.round(renderScore),
	            overallScore: Math.round(overallScore),
	            tier
	        };
	    }
	}

	/**
	 * Merge facade for easy access to merge game functionality
	 *
	 * Provides a simple, static API for creating and managing merge puzzle games.
	 *
	 * @example
	 * ```typescript
	 * import { Merge } from 'gamebyte-framework';
	 *
	 * // Quick setup - create a 5x5 merge game
	 * const grid = Merge.createGame({
	 *   rows: 5,
	 *   cols: 5,
	 *   initialItems: 3
	 * });
	 *
	 * // Listen for events
	 * Merge.on('merge', (item, tier, score) => {
	 *   console.log(`Merged! Tier: ${tier}, Score: ${score}`);
	 * });
	 *
	 * // Start the game
	 * Merge.start();
	 *
	 * // Add to your scene
	 * scene.addChild(Merge.getContainer());
	 * ```
	 */
	class Merge extends Facade {
	    /**
	     * Get the facade accessor key
	     */
	    static getFacadeAccessor() {
	        return 'merge';
	    }
	    /**
	     * Get the merge manager instance
	     */
	    static getManager() {
	        return this.resolve();
	    }
	    // ============================================
	    // GAME CREATION
	    // ============================================
	    /**
	     * Create a new merge game
	     *
	     * @example
	     * ```typescript
	     * // Simple 5x5 grid
	     * Merge.createGame({ rows: 5, cols: 5 });
	     *
	     * // Custom configuration
	     * Merge.createGame({
	     *   rows: 6,
	     *   cols: 6,
	     *   maxTier: 12,
	     *   initialItems: 5,
	     *   autoSpawn: true,
	     *   tierColors: [0xFF0000, 0x00FF00, 0x0000FF]
	     * });
	     * ```
	     */
	    static createGame(config) {
	        return this.getManager().createGame(config);
	    }
	    /**
	     * Quick create - creates a game with sensible defaults
	     *
	     * @example
	     * ```typescript
	     * // Creates 5x5 grid with 3 initial items
	     * const grid = Merge.quick();
	     * scene.addChild(Merge.getContainer());
	     * Merge.start();
	     * ```
	     */
	    static quick() {
	        return this.createGame({
	            rows: 5,
	            cols: 5,
	            initialItems: 3,
	            autoSpawn: false
	        });
	    }
	    /**
	     * Create a Candy Crush style merge game
	     */
	    static createCandyStyle(rows = 6, cols = 5) {
	        return this.createGame({
	            rows,
	            cols,
	            cellWidth: 70,
	            cellHeight: 70,
	            gap: 6,
	            padding: 12,
	            maxTier: 8,
	            initialItems: 4,
	            tierColors: [
	                0xE57373, // Red candy
	                0x81C784, // Green candy
	                0x64B5F6, // Blue candy
	                0xFFD54F, // Yellow candy
	                0xBA68C8, // Purple candy
	                0x4DD0E1, // Cyan candy
	                0xFFB74D, // Orange candy
	                0xF06292, // Pink candy
	            ]
	        });
	    }
	    /**
	     * Create a compact mobile-friendly merge game
	     */
	    static createMobileCompact() {
	        return this.createGame({
	            rows: 4,
	            cols: 4,
	            cellWidth: 85,
	            cellHeight: 85,
	            gap: 10,
	            padding: 20,
	            initialItems: 2,
	            autoSpawn: false
	        });
	    }
	    // ============================================
	    // GAME CONTROL
	    // ============================================
	    /**
	     * Start the game
	     */
	    static start() {
	        this.getManager().start();
	    }
	    /**
	     * Pause the game
	     */
	    static pause() {
	        this.getManager().pause();
	    }
	    /**
	     * Resume the game
	     */
	    static resume() {
	        this.getManager().resume();
	    }
	    /**
	     * Reset the game
	     */
	    static reset() {
	        this.getManager().reset();
	    }
	    /**
	     * Restart the game (reset + start)
	     */
	    static restart() {
	        this.reset();
	        this.start();
	    }
	    // ============================================
	    // ITEM MANAGEMENT
	    // ============================================
	    /**
	     * Spawn a new item
	     */
	    static spawnItem(tier = 1) {
	        return this.getManager().spawnItem(tier);
	    }
	    /**
	     * Spawn multiple items
	     */
	    static spawnItems(count, tier = 1) {
	        const items = [];
	        for (let i = 0; i < count; i++) {
	            const item = this.spawnItem(tier);
	            if (item) {
	                items.push(item);
	            }
	        }
	        return items;
	    }
	    // ============================================
	    // STATE & GETTERS
	    // ============================================
	    /**
	     * Get the grid instance
	     */
	    static getGrid() {
	        return this.getManager().getGrid();
	    }
	    /**
	     * Get the container for adding to scene
	     */
	    static getContainer() {
	        return this.getManager().getContainer();
	    }
	    /**
	     * Get current game state
	     */
	    static getState() {
	        return this.getManager().getState();
	    }
	    /**
	     * Get current score
	     */
	    static getScore() {
	        return this.getManager().getScore();
	    }
	    /**
	     * Get highest tier achieved
	     */
	    static getHighestTier() {
	        return this.getManager().getHighestTier();
	    }
	    /**
	     * Check if game is over
	     */
	    static isGameOver() {
	        return this.getManager().isGameOver();
	    }
	    /**
	     * Check if game is paused
	     */
	    static isPaused() {
	        return this.getManager().isPaused();
	    }
	    /**
	     * Get grid dimensions
	     */
	    static getDimensions() {
	        return this.getManager().getDimensions();
	    }
	    // ============================================
	    // POSITIONING
	    // ============================================
	    /**
	     * Set grid position
	     */
	    static setPosition(x, y) {
	        this.getManager().setPosition(x, y);
	        return this;
	    }
	    /**
	     * Center grid in area
	     */
	    static centerIn(width, height) {
	        this.getManager().centerIn(width, height);
	        return this;
	    }
	    // ============================================
	    // EVENTS
	    // ============================================
	    /**
	     * Listen for game events
	     *
	     * @example
	     * ```typescript
	     * Merge.on('merge', (item, tier, score) => {
	     *   showMergeEffect(item.getPosition());
	     *   updateScoreDisplay(score);
	     * });
	     *
	     * Merge.on('game-over', (state) => {
	     *   showGameOverScreen(state.score);
	     * });
	     *
	     * Merge.on('max-tier', (item) => {
	     *   celebrate();
	     * });
	     * ```
	     */
	    static on(event, callback) {
	        this.getManager().on(event, callback);
	        return this;
	    }
	    /**
	     * Listen for event once
	     */
	    static once(event, callback) {
	        this.getManager().once(event, callback);
	        return this;
	    }
	    /**
	     * Remove event listener
	     */
	    static off(event, callback) {
	        if (callback) {
	            this.getManager().off(event, callback);
	        }
	        else {
	            this.getManager().removeAllListeners(event);
	        }
	        return this;
	    }
	    // ============================================
	    // CLEANUP
	    // ============================================
	    /**
	     * Destroy the merge game
	     */
	    static destroy() {
	        this.getManager().destroy();
	    }
	}

	/**
	 * Modern UIButton component for mobile games
	 *
	 * Features:
	 * - Gradient backgrounds
	 * - Glow effects
	 * - Shadow effects
	 * - Ripple animations on tap
	 * - Smooth touch feedback
	 * - Mobile-optimized (44px minimum touch target)
	 *
	 * @example
	 * ```typescript
	 * const button = new UIButton({
	 *   text: 'PLAY',
	 *   width: 200,
	 *   height: 60,
	 *   backgroundColor: 0x4CAF50,
	 *   gradient: { enabled: true, colorTop: 0x66BB6A, colorBottom: 0x388E3C },
	 *   glowEffect: true,
	 *   shadowEffect: true
	 * });
	 *
	 * button.on('click', () => console.log('Button clicked!'));
	 * scene.addChild(button.getContainer());
	 * ```
	 */
	class UIButton extends EventEmitter {
	    constructor(config = {}) {
	        super();
	        this.isPressed = false;
	        this.isHovered = false;
	        this.activeRipples = [];
	        // Default configuration with mobile game polish
	        this.config = {
	            text: config.text || '',
	            width: config.width || 180,
	            height: config.height || 60,
	            fontSize: config.fontSize || 24,
	            fontFamily: config.fontFamily || getFrameworkFontFamily(),
	            fontWeight: config.fontWeight || 'bold',
	            textColor: config.textColor !== undefined ? config.textColor : 0xFFFFFF,
	            backgroundColor: config.backgroundColor !== undefined ? config.backgroundColor : 0x007AFF,
	            hoverColor: config.hoverColor !== undefined ? config.hoverColor : 0x0096FF,
	            pressedColor: config.pressedColor !== undefined ? config.pressedColor : 0x0056B3,
	            disabledColor: config.disabledColor !== undefined ? config.disabledColor : 0x999999,
	            borderColor: config.borderColor !== undefined ? config.borderColor : 0xFFFFFF,
	            borderWidth: config.borderWidth !== undefined ? config.borderWidth : 0,
	            borderRadius: config.borderRadius !== undefined ? config.borderRadius : 12,
	            disabled: config.disabled || false,
	            rippleEffect: config.rippleEffect !== false,
	            glowEffect: config.glowEffect !== false,
	            shadowEffect: config.shadowEffect !== false,
	            gradient: config.gradient || { enabled: true, colorTop: undefined, colorBottom: undefined }
	        };
	        // Ensure minimum touch target size (Apple HIG: 44x44pt)
	        this.config.width = Math.max(this.config.width, 44);
	        this.config.height = Math.max(this.config.height, 44);
	        // Create container
	        this.container = graphics().createContainer();
	        this.rippleContainer = graphics().createContainer();
	        // Create graphics elements
	        this.shadowGraphics = graphics().createGraphics();
	        this.glowGraphics = graphics().createGraphics();
	        this.background = graphics().createGraphics();
	        // Build button
	        this.container.addChild(this.shadowGraphics);
	        this.container.addChild(this.glowGraphics);
	        this.container.addChild(this.background);
	        this.container.addChild(this.rippleContainer);
	        // Create text
	        if (this.config.text) {
	            this.createText();
	        }
	        // Render initial state
	        this.render();
	        // Setup interactivity
	        this.setupInteractivity();
	    }
	    /**
	     * Create text field
	     */
	    createText() {
	        this.textField = graphics().createText(this.config.text, {
	            fontFamily: this.config.fontFamily,
	            fontSize: this.config.fontSize,
	            fontWeight: this.config.fontWeight,
	            fill: this.config.textColor,
	            align: 'center'
	        });
	        if (this.textField.anchor)
	            this.textField.anchor.set(0.5, 0.5);
	        this.textField.x = this.config.width / 2;
	        this.textField.y = this.config.height / 2;
	        this.container.addChild(this.textField);
	    }
	    /**
	     * Setup touch/mouse interactivity
	     */
	    setupInteractivity() {
	        this.container.eventMode = 'static';
	        this.container.cursor = this.config.disabled ? 'default' : 'pointer';
	        // Pointer events
	        this.container.on('pointerdown', this.onPointerDown.bind(this));
	        this.container.on('pointerup', this.onPointerUp.bind(this));
	        this.container.on('pointerupoutside', this.onPointerUpOutside.bind(this));
	        this.container.on('pointerover', this.onPointerOver.bind(this));
	        this.container.on('pointerout', this.onPointerOut.bind(this));
	    }
	    /**
	     * Render button graphics
	     */
	    render() {
	        const { width, height, borderRadius, shadowEffect, glowEffect } = this.config;
	        // Clear all graphics
	        this.background.clear();
	        if (this.shadowGraphics)
	            this.shadowGraphics.clear();
	        if (this.glowGraphics)
	            this.glowGraphics.clear();
	        // Get current state color
	        const currentColor = this.getCurrentColor();
	        // Shadow effect
	        if (shadowEffect && !this.config.disabled) {
	            this.renderShadow();
	        }
	        // Glow effect (for pressed/hover states)
	        if (glowEffect && (this.isPressed || this.isHovered) && !this.config.disabled) {
	            this.renderGlow();
	        }
	        // Background with gradient
	        if (this.config.gradient.enabled) {
	            this.renderGradientBackground(currentColor);
	        }
	        else {
	            this.renderSolidBackground(currentColor);
	        }
	        // Border
	        if (this.config.borderWidth > 0) {
	            this.renderBorder();
	        }
	    }
	    /**
	     * Render shadow effect
	     */
	    renderShadow() {
	        if (!this.shadowGraphics)
	            return;
	        const { width, height, borderRadius } = this.config;
	        const offsetY = this.isPressed ? 2 : 4;
	        const alpha = this.isPressed ? 0.2 : 0.3;
	        this.shadowGraphics.roundRect(0, offsetY, width, height, borderRadius);
	        this.shadowGraphics.fill({ color: 0x000000, alpha });
	        // Note: Blur filter is renderer-specific and applied internally by the graphics implementation
	        // The framework handles blur effects automatically based on the renderer type
	    }
	    /**
	     * Render glow effect
	     */
	    renderGlow() {
	        if (!this.glowGraphics)
	            return;
	        const { width, height, borderRadius, backgroundColor } = this.config;
	        this.glowGraphics.roundRect(-4, -4, width + 8, height + 8, borderRadius + 4);
	        this.glowGraphics.fill({ color: backgroundColor, alpha: 0.4 });
	        // Note: Blur filter is renderer-specific and applied internally by the graphics implementation
	        // The framework handles blur effects automatically based on the renderer type
	    }
	    /**
	     * Render gradient background
	     */
	    renderGradientBackground(baseColor) {
	        const { width, height, borderRadius, gradient } = this.config;
	        // Determine gradient colors
	        const colorTop = gradient.colorTop !== undefined ? gradient.colorTop : this.lightenColor(baseColor, 0.2);
	        const colorBottom = gradient.colorBottom !== undefined ? gradient.colorBottom : this.darkenColor(baseColor, 0.2);
	        // Create gradient texture using framework abstraction
	        const texture = graphics().createCanvasTexture(width, height, (ctx) => {
	            const gradientFill = ctx.createLinearGradient(0, 0, 0, height);
	            gradientFill.addColorStop(0, this.numberToHex(colorTop));
	            gradientFill.addColorStop(1, this.numberToHex(colorBottom));
	            ctx.fillStyle = gradientFill;
	            this.roundRect(ctx, 0, 0, width, height, borderRadius);
	            ctx.fill();
	        });
	        // Apply to sprite
	        this.background.texture(texture);
	        this.background.roundRect(0, 0, width, height, borderRadius);
	        this.background.fill();
	    }
	    /**
	     * Render solid background
	     */
	    renderSolidBackground(color) {
	        const { width, height, borderRadius } = this.config;
	        this.background.roundRect(0, 0, width, height, borderRadius);
	        this.background.fill({ color });
	    }
	    /**
	     * Render border
	     */
	    renderBorder() {
	        const { width, height, borderRadius, borderWidth, borderColor } = this.config;
	        this.background.roundRect(0, 0, width, height, borderRadius);
	        this.background.stroke({ width: borderWidth, color: borderColor, alpha: 1 });
	    }
	    /**
	     * Get current button color based on state
	     */
	    getCurrentColor() {
	        if (this.config.disabled)
	            return this.config.disabledColor;
	        if (this.isPressed)
	            return this.config.pressedColor;
	        if (this.isHovered)
	            return this.config.hoverColor;
	        return this.config.backgroundColor;
	    }
	    /**
	     * Create ripple effect at position
	     */
	    createRipple(x, y) {
	        if (!this.config.rippleEffect)
	            return;
	        const ripple = graphics().createGraphics();
	        ripple.x = x;
	        ripple.y = y;
	        this.rippleContainer.addChild(ripple);
	        this.activeRipples.push({
	            graphics: ripple,
	            startTime: Date.now(),
	            x,
	            y
	        });
	    }
	    /**
	     * Update ripple animations
	     */
	    update(deltaTime) {
	        const now = Date.now();
	        const duration = 400; // ms
	        this.activeRipples = this.activeRipples.filter(ripple => {
	            const elapsed = now - ripple.startTime;
	            if (elapsed >= duration) {
	                this.rippleContainer.removeChild(ripple.graphics);
	                ripple.graphics.destroy();
	                return false;
	            }
	            // Animate ripple
	            const progress = elapsed / duration;
	            const radius = progress * Math.max(this.config.width, this.config.height);
	            const alpha = 1 - progress;
	            ripple.graphics.clear();
	            ripple.graphics.circle(0, 0, radius);
	            ripple.graphics.fill({ color: 0xFFFFFF, alpha: alpha * 0.5 });
	            return true;
	        });
	    }
	    /**
	     * Pointer event handlers
	     */
	    onPointerDown(event) {
	        if (this.config.disabled)
	            return;
	        this.isPressed = true;
	        this.render();
	        // Create ripple at touch position
	        const localPos = event.getLocalPosition ? event.getLocalPosition(this.container) : { x: this.config.width / 2, y: this.config.height / 2 };
	        this.createRipple(localPos.x, localPos.y);
	        // Scale feedback
	        this.container.scale.x = 0.95;
	        this.container.scale.y = 0.95;
	        this.emit('press', event);
	    }
	    onPointerUp(event) {
	        if (this.config.disabled)
	            return;
	        this.isPressed = false;
	        this.render();
	        // Scale back
	        this.container.scale.x = 1;
	        this.container.scale.y = 1;
	        this.emit('click', event);
	        this.emit('release', event);
	    }
	    onPointerUpOutside() {
	        if (this.config.disabled)
	            return;
	        this.isPressed = false;
	        this.render();
	        // Scale back
	        this.container.scale.x = 1;
	        this.container.scale.y = 1;
	        this.emit('cancel');
	    }
	    onPointerOver() {
	        if (this.config.disabled)
	            return;
	        this.isHovered = true;
	        this.render();
	        this.emit('hover');
	    }
	    onPointerOut() {
	        if (this.config.disabled)
	            return;
	        this.isHovered = false;
	        this.render();
	        this.emit('hoverEnd');
	    }
	    /**
	     * Public API
	     */
	    setText(text) {
	        this.config.text = text;
	        if (this.textField) {
	            this.textField.text = text;
	        }
	        else {
	            this.createText();
	        }
	        return this;
	    }
	    setDisabled(disabled) {
	        this.config.disabled = disabled;
	        this.container.cursor = disabled ? 'default' : 'pointer';
	        this.render();
	        this.emit('disabled-changed', disabled);
	        return this;
	    }
	    setBackgroundColor(color) {
	        this.config.backgroundColor = color;
	        this.render();
	        return this;
	    }
	    setTextColor(color) {
	        this.config.textColor = color;
	        if (this.textField) {
	            this.textField.style.fill = color;
	        }
	        return this;
	    }
	    getContainer() {
	        return this.container;
	    }
	    destroy() {
	        this.activeRipples.forEach(ripple => {
	            ripple.graphics.destroy();
	        });
	        this.activeRipples = [];
	        this.container.destroy({ children: true });
	        this.removeAllListeners();
	    }
	    /**
	     * Utility methods
	     */
	    lightenColor(color, amount) {
	        const r = ((color >> 16) & 0xFF) + Math.floor(255 * amount);
	        const g = ((color >> 8) & 0xFF) + Math.floor(255 * amount);
	        const b = (color & 0xFF) + Math.floor(255 * amount);
	        return ((Math.min(255, r) << 16) | (Math.min(255, g) << 8) | Math.min(255, b));
	    }
	    darkenColor(color, amount) {
	        const r = ((color >> 16) & 0xFF) - Math.floor(255 * amount);
	        const g = ((color >> 8) & 0xFF) - Math.floor(255 * amount);
	        const b = (color & 0xFF) - Math.floor(255 * amount);
	        return ((Math.max(0, r) << 16) | (Math.max(0, g) << 8) | Math.max(0, b));
	    }
	    numberToHex(num) {
	        return `#${num.toString(16).padStart(6, '0')}`;
	    }
	    roundRect(ctx, x, y, width, height, radius) {
	        ctx.beginPath();
	        ctx.moveTo(x + radius, y);
	        ctx.lineTo(x + width - radius, y);
	        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
	        ctx.lineTo(x + width, y + height - radius);
	        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
	        ctx.lineTo(x + radius, y + height);
	        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
	        ctx.lineTo(x, y + radius);
	        ctx.quadraticCurveTo(x, y, x + radius, y);
	        ctx.closePath();
	    }
	}

	/**
	 * TopBar item types
	 */
	exports.TopBarItemType = void 0;
	(function (TopBarItemType) {
	    TopBarItemType["RESOURCE"] = "resource";
	    TopBarItemType["SCORE"] = "score";
	    TopBarItemType["TIMER"] = "timer";
	    TopBarItemType["LEVEL"] = "level";
	    TopBarItemType["BUTTON"] = "button";
	    TopBarItemType["COUNTER"] = "counter";
	    TopBarItemType["CUSTOM"] = "custom";
	})(exports.TopBarItemType || (exports.TopBarItemType = {}));
	/**
	 * TopBar - Flexible top bar UI component for mobile games
	 *
	 * Supports multiple item types:
	 * - Resource displays (coins, gems, lives, etc.)
	 * - Scores and counters
	 * - Timers (countdown/countup)
	 * - Level indicators
	 * - Buttons (settings, pause, etc.)
	 *
	 * @example
	 * ```typescript
	 * const topBar = new TopBar({
	 *     width: 800,
	 *     items: [
	 *         { type: 'resource', icon: 'coin', value: 1000, animated: true },
	 *         { type: 'resource', icon: 'life', value: 3, max: 5 },
	 *         { type: 'score', value: 0, prefix: 'Score: ' },
	 *         { type: 'button', icon: 'pause', onClick: pauseGame }
	 *     ]
	 * });
	 * ```
	 */
	class TopBar extends EventEmitter {
	    constructor(config) {
	        super();
	        this.config = config;
	        this.items = new Map();
	        // Default theme
	        this.theme = {
	            backgroundColor: 0x2C3E50,
	            backgroundAlpha: 0.95,
	            textColor: 0xFFFFFF,
	            iconSize: 32,
	            height: 80,
	            padding: 15,
	            itemSpacing: 20,
	            borderRadius: 0,
	            fontFamily: getFrameworkFontFamily(),
	            fontSize: 24,
	            ...config.theme
	        };
	        this.container = graphics().createContainer();
	        this.background = graphics().createGraphics();
	        this.container.addChild(this.background);
	        this.createBackground();
	        this.createItems();
	        // Position
	        if (config.position === 'bottom') {
	            // Position will be set by parent based on canvas height
	            this.container.y = 0; // Placeholder
	        }
	        this.container.visible = config.visible !== false;
	    }
	    /**
	     * Create background graphics
	     */
	    createBackground() {
	        this.background.clear();
	        if (this.theme.borderRadius > 0) {
	            this.background.roundRect(0, 0, this.config.width, this.theme.height, this.theme.borderRadius);
	        }
	        else {
	            this.background.rect(0, 0, this.config.width, this.theme.height);
	        }
	        this.background.fill({
	            color: this.theme.backgroundColor,
	            alpha: this.theme.backgroundAlpha
	        });
	    }
	    /**
	     * Create all items
	     */
	    createItems() {
	        // Clear existing items
	        this.items.forEach(item => {
	            this.container.removeChild(item.container);
	        });
	        this.items.clear();
	        // Calculate layout
	        const visibleItems = this.config.items.filter(item => item.visible !== false);
	        const totalItems = visibleItems.length;
	        if (totalItems === 0)
	            return;
	        // Distribute items across the width
	        const availableWidth = this.config.width - (this.theme.padding * 2);
	        const itemWidth = (availableWidth - (this.theme.itemSpacing * (totalItems - 1))) / totalItems;
	        let currentX = this.theme.padding;
	        visibleItems.forEach((itemConfig, index) => {
	            const item = this.createItem(itemConfig, itemWidth);
	            item.container.x = currentX;
	            item.container.y = this.theme.height / 2;
	            const itemId = itemConfig.id || `item_${index}`;
	            this.items.set(itemId, item);
	            this.container.addChild(item.container);
	            currentX += itemWidth + this.theme.itemSpacing;
	        });
	    }
	    /**
	     * Create a single item
	     */
	    createItem(config, width) {
	        const container = graphics().createContainer();
	        const item = {
	            config,
	            container,
	            value: config.value || 0
	        };
	        // Create based on type
	        switch (config.type) {
	            case exports.TopBarItemType.RESOURCE:
	            case exports.TopBarItemType.SCORE:
	            case exports.TopBarItemType.COUNTER:
	                this.createResourceItem(item, width);
	                break;
	            case exports.TopBarItemType.TIMER:
	                this.createTimerItem(item, width);
	                break;
	            case exports.TopBarItemType.LEVEL:
	                this.createLevelItem(item, width);
	                break;
	            case exports.TopBarItemType.BUTTON:
	                this.createButtonItem(item, width);
	                break;
	        }
	        return item;
	    }
	    /**
	     * Create resource/score item (icon + text)
	     */
	    createResourceItem(item, width) {
	        const config = item.config;
	        // Icon
	        if (config.icon) {
	            const iconTexture = typeof config.icon === 'string'
	                ? graphics().createTexture(config.icon)
	                : config.icon;
	            item.icon = graphics().createSprite(iconTexture);
	            if (item.icon.anchor)
	                item.icon.anchor.set(0.5, 0.5);
	            item.icon.width = this.theme.iconSize;
	            item.icon.height = this.theme.iconSize;
	            item.icon.x = -width / 4;
	            item.container.addChild(item.icon);
	        }
	        // Text
	        const textValue = this.formatValue(item.value, config);
	        item.text = graphics().createText(textValue, {
	            fontFamily: this.theme.fontFamily,
	            fontSize: this.theme.fontSize,
	            fill: this.theme.textColor,
	            align: 'left'
	        });
	        if (item.text.anchor)
	            item.text.anchor.set(0, 0.5);
	        item.text.x = config.icon ? this.theme.iconSize / 2 + 5 : -width / 2;
	        item.container.addChild(item.text);
	        // Progress bar for max values
	        if (config.max !== undefined) {
	            this.createProgressBar(item, width);
	        }
	    }
	    /**
	     * Create timer item
	     */
	    createTimerItem(item, width) {
	        const textValue = this.formatValue(item.value, { ...item.config, format: 'time' });
	        item.text = graphics().createText(textValue, {
	            fontFamily: this.theme.fontFamily,
	            fontSize: this.theme.fontSize,
	            fill: this.theme.textColor,
	            align: 'center'
	        });
	        if (item.text.anchor)
	            item.text.anchor.set(0.5, 0.5);
	        item.container.addChild(item.text);
	    }
	    /**
	     * Create level indicator
	     */
	    createLevelItem(item, width) {
	        const prefix = item.config.prefix || 'Level ';
	        const textValue = prefix + item.value;
	        item.text = graphics().createText(textValue, {
	            fontFamily: this.theme.fontFamily,
	            fontSize: this.theme.fontSize,
	            fill: this.theme.textColor,
	            align: 'center'
	        });
	        if (item.text.anchor)
	            item.text.anchor.set(0.5, 0.5);
	        item.container.addChild(item.text);
	    }
	    /**
	     * Create button item
	     */
	    createButtonItem(item, width) {
	        const config = item.config;
	        // Background
	        item.background = graphics().createGraphics();
	        item.background.roundRect(-this.theme.iconSize / 2 - 10, -this.theme.iconSize / 2 - 10, this.theme.iconSize + 20, this.theme.iconSize + 20, 10);
	        item.background.fill({ color: 0xFFFFFF, alpha: 0.1 });
	        item.container.addChild(item.background);
	        // Icon
	        if (config.icon) {
	            const iconTexture = typeof config.icon === 'string'
	                ? graphics().createTexture(config.icon)
	                : config.icon;
	            item.icon = graphics().createSprite(iconTexture);
	            if (item.icon.anchor)
	                item.icon.anchor.set(0.5, 0.5);
	            item.icon.width = this.theme.iconSize;
	            item.icon.height = this.theme.iconSize;
	            item.container.addChild(item.icon);
	        }
	        // Make interactive
	        item.container.eventMode = 'static';
	        item.container.cursor = 'pointer';
	        item.container.on('pointerdown', () => {
	            if (item.background) {
	                item.background.tint = 0xCCCCCC;
	            }
	        });
	        item.container.on('pointerup', () => {
	            if (item.background) {
	                item.background.tint = 0xFFFFFF;
	            }
	            if (config.onClick) {
	                config.onClick();
	                this.emit('button:click', config.id);
	            }
	        });
	        item.container.on('pointerupoutside', () => {
	            if (item.background) {
	                item.background.tint = 0xFFFFFF;
	            }
	        });
	    }
	    /**
	     * Create progress bar (for resources with max values)
	     */
	    createProgressBar(item, width) {
	        // TODO: Implement progress bar visualization
	        // For now, show value/max in text
	        if (item.config.max !== undefined && item.text) {
	            const textValue = `${item.value}/${item.config.max}`;
	            item.text.text = textValue;
	        }
	    }
	    /**
	     * Format value based on format type
	     */
	    formatValue(value, config) {
	        if (typeof value === 'string')
	            return value;
	        let formatted;
	        switch (config.format) {
	            case 'abbreviate':
	                formatted = this.abbreviateNumber(value);
	                break;
	            case 'time':
	                formatted = this.formatTime(value);
	                break;
	            case 'number':
	            default:
	                formatted = value.toLocaleString();
	                break;
	        }
	        const prefix = config.prefix || '';
	        const suffix = config.suffix || '';
	        return prefix + formatted + suffix;
	    }
	    /**
	     * Abbreviate large numbers (1000 -> 1K, 1000000 -> 1M)
	     */
	    abbreviateNumber(num) {
	        if (num < 1000)
	            return num.toString();
	        if (num < 1000000)
	            return (num / 1000).toFixed(1) + 'K';
	        if (num < 1000000000)
	            return (num / 1000000).toFixed(1) + 'M';
	        return (num / 1000000000).toFixed(1) + 'B';
	    }
	    /**
	     * Format time (seconds to mm:ss or hh:mm:ss)
	     */
	    formatTime(seconds) {
	        const hrs = Math.floor(seconds / 3600);
	        const mins = Math.floor((seconds % 3600) / 60);
	        const secs = Math.floor(seconds % 60);
	        if (hrs > 0) {
	            return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
	        }
	        return `${mins}:${secs.toString().padStart(2, '0')}`;
	    }
	    /**
	     * Update an item's value
	     */
	    updateItem(id, value, animated = false) {
	        const item = this.items.get(id);
	        if (!item || !item.text)
	            return;
	        const oldValue = item.value;
	        item.value = value;
	        const newText = this.formatValue(value, item.config);
	        item.text.text = newText;
	        // Animate if requested and value is numeric
	        if (animated && typeof value === 'number' && typeof oldValue === 'number') {
	            this.animateValueChange(item, oldValue, value);
	        }
	        this.emit('item:updated', id, value);
	    }
	    /**
	     * Animate value change
	     */
	    animateValueChange(item, from, to) {
	        // Simple scale animation on change
	        if (!item.text)
	            return;
	        const originalScale = item.text.scale.x;
	        item.text.scale.x = originalScale * 1.2;
	        item.text.scale.y = originalScale * 1.2;
	        // Smooth back to original scale
	        const animate = () => {
	            if (!item.text)
	                return;
	            const currentScale = item.text.scale.x;
	            const newScale = currentScale + (originalScale - currentScale) * 0.1;
	            item.text.scale.x = newScale;
	            item.text.scale.y = newScale;
	            if (Math.abs(newScale - originalScale) > 0.01) {
	                requestAnimationFrame(animate);
	            }
	            else {
	                item.text.scale.x = originalScale;
	                item.text.scale.y = originalScale;
	            }
	        };
	        requestAnimationFrame(animate);
	    }
	    /**
	     * Get item value
	     */
	    getItemValue(id) {
	        return this.items.get(id)?.value;
	    }
	    /**
	     * Set item visibility
	     */
	    setItemVisible(id, visible) {
	        const item = this.items.get(id);
	        if (item) {
	            item.container.visible = visible;
	        }
	    }
	    /**
	     * Update theme
	     */
	    setTheme(theme) {
	        this.theme = { ...this.theme, ...theme };
	        this.createBackground();
	        this.createItems();
	    }
	    /**
	     * Show/hide TopBar
	     */
	    setVisible(visible) {
	        this.container.visible = visible;
	        this.emit('visibility:changed', visible);
	    }
	    /**
	     * Get container
	     */
	    getContainer() {
	        return this.container;
	    }
	    /**
	     * Destroy TopBar
	     */
	    destroy() {
	        this.items.forEach(item => {
	            item.container.destroy({ children: true });
	        });
	        this.items.clear();
	        this.container.destroy({ children: true });
	        this.removeAllListeners();
	    }
	}

	/**
	 * MergeCell - A single cell in the merge grid
	 *
	 * A MergeCell can hold one MergeItem at a time and acts as a drop zone
	 * for drag operations. When an item is dropped on a cell that already
	 * contains an item of the same tier, a merge is triggered.
	 *
	 * Features:
	 * - Hold single item
	 * - Drop zone detection
	 * - Merge trigger logic
	 * - Visual feedback (hover, occupied, locked states)
	 * - Lock/unlock for progression systems
	 *
	 * @example
	 * ```typescript
	 * const cell = new MergeCell({
	 *   row: 0,
	 *   col: 0,
	 *   width: 100,
	 *   height: 100
	 * });
	 *
	 * cell.on('item-dropped', (cell, item) => {
	 *   if (cell.hasItem() && cell.getItem()?.canMergeWith(item)) {
	 *     // Trigger merge
	 *   }
	 * });
	 * ```
	 */
	class MergeCell extends EventEmitter {
	    constructor(config) {
	        super();
	        this._item = null;
	        this._isHovered = false;
	        this._isHighlighted = false;
	        this._isDestroyed = false;
	        this.config = {
	            width: config.width ?? 100,
	            height: config.height ?? 100,
	            row: config.row,
	            col: config.col,
	            backgroundColor: config.backgroundColor ?? 0x2a2a2a,
	            borderColor: config.borderColor ?? 0x444444,
	            borderWidth: config.borderWidth ?? 2,
	            borderRadius: config.borderRadius ?? 8,
	            acceptsItems: config.acceptsItems ?? true,
	            locked: config.locked ?? false,
	            emptyStyle: config.emptyStyle ?? 'solid'
	        };
	        // Create visual elements
	        this.container = graphics().createContainer();
	        this.background = graphics().createGraphics();
	        this.highlightGraphics = graphics().createGraphics();
	        this.container.addChild(this.background);
	        this.container.addChild(this.highlightGraphics);
	        // Setup interaction
	        this.setupInteraction();
	        // Initial render
	        this.updateVisuals();
	    }
	    // ============================================
	    // PUBLIC GETTERS
	    // ============================================
	    /** Get row index */
	    get row() {
	        return this.config.row;
	    }
	    /** Get column index */
	    get col() {
	        return this.config.col;
	    }
	    /** Get cell width */
	    get width() {
	        return this.config.width;
	    }
	    /** Get cell height */
	    get height() {
	        return this.config.height;
	    }
	    /** Check if cell is locked */
	    get isLocked() {
	        return this.config.locked;
	    }
	    /** Check if cell can accept items */
	    get acceptsItems() {
	        return this.config.acceptsItems && !this.config.locked;
	    }
	    /** Get the display container */
	    getContainer() {
	        return this.container;
	    }
	    /** Get cell center position */
	    getCenterPosition() {
	        return {
	            x: this.container.x + this.config.width / 2,
	            y: this.container.y + this.config.height / 2
	        };
	    }
	    /** Get world center position */
	    getWorldCenterPosition() {
	        const containerAny = this.container;
	        const globalPos = containerAny.getGlobalPosition?.() ?? { x: this.container.x, y: this.container.y };
	        return {
	            x: globalPos.x + this.config.width / 2,
	            y: globalPos.y + this.config.height / 2
	        };
	    }
	    // ============================================
	    // ITEM MANAGEMENT
	    // ============================================
	    /**
	     * Check if cell has an item
	     */
	    hasItem() {
	        return this._item !== null;
	    }
	    /**
	     * Get the current item (if any)
	     */
	    getItem() {
	        return this._item;
	    }
	    /**
	     * Place an item in this cell
	     */
	    placeItem(item) {
	        if (!this.acceptsItems) {
	            return false;
	        }
	        if (this._item !== null) {
	            // Cell already has an item
	            return false;
	        }
	        this._item = item;
	        // Position item at cell center
	        const center = this.getCenterPosition();
	        item.setPosition(center.x, center.y);
	        // Add item to container
	        const itemContainerAny = item.getContainer();
	        if (itemContainerAny.parent !== this.container) {
	            this.container.addChild(item.getContainer());
	        }
	        this.updateVisuals();
	        this.emit('item-placed', this, item);
	        return true;
	    }
	    /**
	     * Remove the current item
	     */
	    removeItem() {
	        if (!this._item) {
	            return null;
	        }
	        const item = this._item;
	        this._item = null;
	        // Remove from container
	        const itemContainerAny = item.getContainer();
	        if (itemContainerAny.parent === this.container) {
	            this.container.removeChild(item.getContainer());
	        }
	        this.updateVisuals();
	        this.emit('item-removed', this, item);
	        return item;
	    }
	    /**
	     * Check if this cell can accept a specific item
	     */
	    canAcceptItem(item) {
	        if (!this.acceptsItems) {
	            return false;
	        }
	        // Empty cell can accept any item
	        if (!this._item) {
	            return true;
	        }
	        // Cell with item can accept if merge is possible
	        return this._item.canMergeWith(item);
	    }
	    /**
	     * Handle a dropped item
	     * Returns: 'placed' | 'merged' | 'rejected'
	     */
	    handleDrop(item) {
	        if (!this.acceptsItems) {
	            return 'rejected';
	        }
	        // Emit drop event
	        this.emit('item-dropped', this, item);
	        // If cell is empty, place the item
	        if (!this._item) {
	            this.placeItem(item);
	            return 'placed';
	        }
	        // If cell has item, try to merge
	        if (this._item.canMergeWith(item)) {
	            this.emit('merge-attempt', this, item, this._item);
	            return 'merged';
	        }
	        return 'rejected';
	    }
	    // ============================================
	    // HIT DETECTION
	    // ============================================
	    /**
	     * Check if a point is inside this cell
	     */
	    containsPoint(worldX, worldY) {
	        const containerAny = this.container;
	        const pos = containerAny.getGlobalPosition?.() ?? { x: this.container.x, y: this.container.y };
	        const x = pos.x;
	        const y = pos.y;
	        return (worldX >= x &&
	            worldX <= x + this.config.width &&
	            worldY >= y &&
	            worldY <= y + this.config.height);
	    }
	    // ============================================
	    // VISUAL STATE
	    // ============================================
	    /**
	     * Set highlight state (for drag hover feedback)
	     */
	    setHighlighted(highlighted, canDrop = true) {
	        if (this._isHighlighted === highlighted)
	            return;
	        this._isHighlighted = highlighted;
	        this.updateHighlight(canDrop);
	    }
	    /**
	     * Lock/unlock the cell
	     */
	    setLocked(locked) {
	        if (this.config.locked === locked)
	            return;
	        this.config.locked = locked;
	        this.updateVisuals();
	        this.emit('locked-changed', this, locked);
	    }
	    /**
	     * Set position
	     */
	    setPosition(x, y) {
	        this.container.x = x;
	        this.container.y = y;
	        return this;
	    }
	    /**
	     * Destroy the cell
	     */
	    destroy() {
	        if (this._isDestroyed)
	            return;
	        this._isDestroyed = true;
	        if (this._item) {
	            this._item.destroy();
	        }
	        this.container.destroy();
	        this.removeAllListeners();
	    }
	    // ============================================
	    // PRIVATE METHODS
	    // ============================================
	    /**
	     * Setup cell interaction
	     */
	    setupInteraction() {
	        this.container.interactive = true;
	        this.container.on('pointerover', () => {
	            if (this._isDestroyed)
	                return;
	            this._isHovered = true;
	            this.emit('hover-enter', this);
	        });
	        this.container.on('pointerout', () => {
	            if (this._isDestroyed)
	                return;
	            this._isHovered = false;
	            this.emit('hover-exit', this);
	        });
	    }
	    /**
	     * Update visual appearance
	     */
	    updateVisuals() {
	        const { width, height, backgroundColor, borderColor, borderWidth, borderRadius, locked } = this.config;
	        this.background.clear();
	        // Determine colors based on state
	        let bgColor = backgroundColor;
	        let alpha = 1;
	        if (locked) {
	            bgColor = 0x1a1a1a;
	            alpha = 0.5;
	        }
	        else if (this._item) {
	            // Slightly lighter when occupied
	            bgColor = this.lightenColor(backgroundColor, 0.1);
	        }
	        // Draw background using Pixi v8 modern API
	        this.background
	            .roundRect(0, 0, width, height, borderRadius)
	            .fill({ color: bgColor, alpha })
	            .stroke({ color: borderColor, width: borderWidth, alpha });
	        // Draw lock icon if locked
	        if (locked) {
	            this.drawLockIcon();
	        }
	        // Draw empty indicator if not occupied and not locked
	        if (!this._item && !locked && this.config.emptyStyle !== 'none') {
	            this.drawEmptyIndicator();
	        }
	    }
	    /**
	     * Update highlight overlay
	     */
	    updateHighlight(canDrop) {
	        this.highlightGraphics.clear();
	        if (!this._isHighlighted)
	            return;
	        const { width, height, borderRadius } = this.config;
	        const color = canDrop ? 0x4CAF50 : 0xF44336;
	        // Draw highlight fill and glow border using Pixi v8 modern API
	        this.highlightGraphics
	            .roundRect(0, 0, width, height, borderRadius)
	            .fill({ color, alpha: 0.3 })
	            .stroke({ color, width: 3, alpha: 0.8 });
	    }
	    /**
	     * Draw lock icon
	     */
	    drawLockIcon() {
	        const { width, height } = this.config;
	        const iconSize = Math.min(width, height) * 0.3;
	        const centerX = width / 2;
	        const centerY = height / 2;
	        // Lock body using Pixi v8 modern API
	        this.background
	            .roundRect(centerX - iconSize / 2, centerY - iconSize / 4, iconSize, iconSize * 0.7, 4)
	            .fill({ color: 0x666666, alpha: 0.8 });
	        // Lock shackle (simplified as a small circle on top)
	        this.background
	            .circle(centerX, centerY - iconSize / 3, iconSize * 0.25)
	            .stroke({ color: 0x666666, width: iconSize * 0.12, alpha: 0.8 });
	    }
	    /**
	     * Draw empty cell indicator
	     */
	    drawEmptyIndicator() {
	        const { width, height } = this.config;
	        const size = Math.min(width, height) * 0.2;
	        const centerX = width / 2;
	        const centerY = height / 2;
	        // Draw plus sign using Pixi v8 modern API
	        // Horizontal line
	        this.background
	            .moveTo(centerX - size / 2, centerY)
	            .lineTo(centerX + size / 2, centerY)
	            .stroke({ color: 0x555555, width: 2, alpha: 0.5 });
	        // Vertical line
	        this.background
	            .moveTo(centerX, centerY - size / 2)
	            .lineTo(centerX, centerY + size / 2)
	            .stroke({ color: 0x555555, width: 2, alpha: 0.5 });
	    }
	    /**
	     * Lighten a color
	     */
	    lightenColor(color, amount) {
	        const r = Math.min(255, ((color >> 16) & 0xFF) + 255 * amount);
	        const g = Math.min(255, ((color >> 8) & 0xFF) + 255 * amount);
	        const b = Math.min(255, (color & 0xFF) + 255 * amount);
	        return (r << 16) | (g << 8) | b;
	    }
	}

	/**
	 * Default tier colors (vibrant mobile game palette)
	 */
	const DEFAULT_TIER_COLORS = [
	    0x9E9E9E, // Tier 0: Gray
	    0x4CAF50, // Tier 1: Green
	    0x2196F3, // Tier 2: Blue
	    0x9C27B0, // Tier 3: Purple
	    0xFF9800, // Tier 4: Orange
	    0xF44336, // Tier 5: Red
	    0xFFEB3B, // Tier 6: Yellow/Gold
	    0x00BCD4, // Tier 7: Cyan
	    0xE91E63, // Tier 8: Pink
	    0x673AB7, // Tier 9: Deep Purple
	    0xFFD700, // Tier 10+: Gold (max tier)
	];
	/**
	 * MergeItem - Draggable, mergeable item for merge puzzle games
	 *
	 * A MergeItem represents a single item on the merge grid that can be:
	 * - Dragged by the player
	 * - Dropped onto other items or cells
	 * - Merged with items of the same tier to create a higher tier item
	 *
	 * Features:
	 * - Tier-based visual system (colors or textures)
	 * - Touch/mouse drag support
	 * - Merge zone detection
	 * - Smooth animations for spawn, merge, destroy
	 * - Mobile-optimized touch targets
	 *
	 * @example
	 * ```typescript
	 * const item = new MergeItem({
	 *   tier: 1,
	 *   size: 80,
	 *   draggable: true
	 * });
	 *
	 * item.on('drag-end', (item, x, y) => {
	 *   // Check for merge or placement
	 * });
	 *
	 * // Merge two items
	 * if (item1.canMergeWith(item2)) {
	 *   const result = item1.mergeWith(item2);
	 * }
	 * ```
	 */
	class MergeItem extends EventEmitter {
	    constructor(config) {
	        super();
	        this._isDragging = false;
	        this._isDestroyed = false;
	        this._originalPosition = { x: 0, y: 0 };
	        this._dragOffset = { x: 0, y: 0 };
	        // For merge zone detection
	        this._mergeZoneRadius = 1.2; // 20% larger than visual size
	        this.config = {
	            tier: config.tier,
	            maxTier: config.maxTier ?? 10,
	            size: config.size ?? 80,
	            id: config.id ?? `item_${Math.random().toString(36).substr(2, 9)}`,
	            textures: config.textures ?? new Map(),
	            tierColors: config.tierColors ?? DEFAULT_TIER_COLORS,
	            draggable: config.draggable ?? true,
	            mergeable: config.mergeable ?? true,
	            data: config.data ?? {}
	        };
	        this._tier = config.tier;
	        // Create visual elements
	        this.container = graphics().createContainer();
	        this.background = graphics().createGraphics();
	        this.container.addChild(this.background);
	        // Setup interactive
	        if (this.config.draggable) {
	            this.setupDragInteraction();
	        }
	        // Initial render
	        this.updateVisuals();
	    }
	    // ============================================
	    // PUBLIC GETTERS
	    // ============================================
	    /** Get the item's unique ID */
	    get id() {
	        return this.config.id;
	    }
	    /** Get the current tier */
	    get tier() {
	        return this._tier;
	    }
	    /** Get the visual size */
	    get size() {
	        return this.config.size;
	    }
	    /** Check if item is being dragged */
	    get isDragging() {
	        return this._isDragging;
	    }
	    /** Check if item can be dragged */
	    get canBeDragged() {
	        return this.config.draggable && !this._isDestroyed;
	    }
	    /** Check if item can be merged */
	    get canBeMerged() {
	        return this.config.mergeable && !this._isDestroyed && this._tier < this.config.maxTier;
	    }
	    /** Get the display container */
	    getContainer() {
	        return this.container;
	    }
	    /** Get current position */
	    getPosition() {
	        return {
	            x: this.container.x,
	            y: this.container.y
	        };
	    }
	    /** Get world position */
	    getWorldPosition() {
	        const containerAny = this.container;
	        const pos = containerAny.getGlobalPosition?.() ?? { x: this.container.x, y: this.container.y };
	        return { x: pos.x, y: pos.y };
	    }
	    /** Get custom data */
	    getData(key) {
	        return this.config.data[key];
	    }
	    // ============================================
	    // PUBLIC METHODS
	    // ============================================
	    /**
	     * Set the item's position
	     */
	    setPosition(x, y) {
	        this.container.x = x;
	        this.container.y = y;
	        return this;
	    }
	    /**
	     * Set the item's scale
	     */
	    setScale(scale) {
	        this.container.scale.x = scale;
	        this.container.scale.y = scale;
	        return this;
	    }
	    /**
	     * Store the original position (for drag cancel)
	     */
	    storeOriginalPosition() {
	        this._originalPosition = this.getPosition();
	    }
	    /**
	     * Return to original position (with optional animation)
	     */
	    returnToOriginalPosition(animate = true) {
	        if (animate) {
	            // TODO: Use GSAP or built-in animation system
	            this.setPosition(this._originalPosition.x, this._originalPosition.y);
	        }
	        else {
	            this.setPosition(this._originalPosition.x, this._originalPosition.y);
	        }
	    }
	    /**
	     * Check if this item can merge with another
	     */
	    canMergeWith(other) {
	        if (!this.canBeMerged || !other.canBeMerged) {
	            return false;
	        }
	        if (other === this) {
	            return false;
	        }
	        if (other._tier !== this._tier) {
	            return false;
	        }
	        if (this._tier >= this.config.maxTier) {
	            return false;
	        }
	        return true;
	    }
	    /**
	     * Check if a point is within this item's merge zone
	     * (The merge zone is slightly larger than the visual for easier gameplay)
	     */
	    isPointInMergeZone(x, y) {
	        const pos = this.getWorldPosition();
	        const mergeRadius = (this.config.size / 2) * this._mergeZoneRadius;
	        const dx = x - pos.x;
	        const dy = y - pos.y;
	        const distance = Math.sqrt(dx * dx + dy * dy);
	        return distance <= mergeRadius;
	    }
	    /**
	     * Perform merge with another item
	     * Returns the resulting higher-tier item
	     */
	    mergeWith(other) {
	        if (!this.canMergeWith(other)) {
	            throw new Error('Cannot merge these items');
	        }
	        // Emit merge start event
	        this.emit('merge-start', this, other);
	        other.emit('merge-start', other, this);
	        // Calculate result position (midpoint)
	        const pos1 = this.getPosition();
	        const pos2 = other.getPosition();
	        const resultPos = {
	            x: (pos1.x + pos2.x) / 2,
	            y: (pos1.y + pos2.y) / 2
	        };
	        // Create result item with higher tier
	        const resultItem = new MergeItem({
	            ...this.config,
	            tier: this._tier + 1,
	            id: undefined // Generate new ID
	        });
	        resultItem.setPosition(resultPos.x, resultPos.y);
	        // Emit events
	        this.emit('merge-complete', resultItem, [this, other]);
	        other.emit('merge-complete', resultItem, [this, other]);
	        resultItem.emit('tier-changed', resultItem, 0, resultItem.tier);
	        // Destroy merged items
	        this.destroy();
	        other.destroy();
	        return resultItem;
	    }
	    /**
	     * Upgrade tier (used after merge animation)
	     */
	    upgradeTier() {
	        if (this._tier >= this.config.maxTier) {
	            return false;
	        }
	        const oldTier = this._tier;
	        this._tier++;
	        this.updateVisuals();
	        this.emit('tier-changed', this, oldTier, this._tier);
	        return true;
	    }
	    /**
	     * Set custom data
	     */
	    setData(key, value) {
	        this.config.data[key] = value;
	        return this;
	    }
	    /**
	     * Destroy the item
	     */
	    destroy() {
	        if (this._isDestroyed)
	            return;
	        this._isDestroyed = true;
	        this.emit('destroyed', this);
	        // Clean up graphics
	        this.container.destroy();
	        this.removeAllListeners();
	    }
	    // ============================================
	    // PRIVATE METHODS
	    // ============================================
	    /**
	     * Setup drag interaction
	     */
	    setupDragInteraction() {
	        this.container.interactive = true;
	        this.container.cursor = 'pointer';
	        // Pointer down
	        this.container.on('pointerdown', (event) => {
	            if (!this.canBeDragged)
	                return;
	            this._isDragging = true;
	            this.storeOriginalPosition();
	            const pos = event.data?.global ?? event.global ?? { x: 0, y: 0 };
	            const itemPos = this.getPosition();
	            this._dragOffset = {
	                x: itemPos.x - pos.x,
	                y: itemPos.y - pos.y
	            };
	            // Bring to front
	            const containerAny = this.container;
	            if (containerAny.parent) {
	                containerAny.parent.setChildIndex(this.container, containerAny.parent.children.length - 1);
	            }
	            this.emit('drag-start', this, pos.x, pos.y);
	        });
	        // Pointer move
	        this.container.on('pointermove', (event) => {
	            if (!this._isDragging)
	                return;
	            const pos = event.data?.global ?? event.global ?? { x: 0, y: 0 };
	            this.setPosition(pos.x + this._dragOffset.x, pos.y + this._dragOffset.y);
	            this.emit('drag-move', this, pos.x, pos.y);
	        });
	        // Pointer up
	        this.container.on('pointerup', (event) => {
	            if (!this._isDragging)
	                return;
	            this._isDragging = false;
	            const pos = event.data?.global ?? event.global ?? { x: 0, y: 0 };
	            this.emit('drag-end', this, pos.x, pos.y);
	        });
	        // Pointer up outside
	        this.container.on('pointerupoutside', (event) => {
	            if (!this._isDragging)
	                return;
	            this._isDragging = false;
	            const pos = event.data?.global ?? event.global ?? { x: 0, y: 0 };
	            this.emit('drag-end', this, pos.x, pos.y);
	        });
	    }
	    /**
	     * Update visual appearance based on tier
	     */
	    updateVisuals() {
	        const size = this.config.size;
	        const halfSize = size / 2;
	        // Clear previous graphics
	        this.background.clear();
	        // Get color for current tier
	        const colorIndex = Math.min(this._tier, this.config.tierColors.length - 1);
	        const color = this.config.tierColors[colorIndex];
	        // Check for texture
	        const texture = this.config.textures.get(this._tier);
	        if (texture && !this.sprite) {
	            // Create sprite for texture
	            this.sprite = graphics().createSprite(texture);
	            this.sprite.anchor?.set(0.5, 0.5);
	            this.sprite.width = size;
	            this.sprite.height = size;
	            this.container.addChild(this.sprite);
	        }
	        else if (texture && this.sprite) {
	            // Update sprite texture
	            this.sprite.texture = texture;
	        }
	        else {
	            // Draw colored circle/square using Pixi v8 modern API
	            // Shadow
	            this.background
	                .roundRect(-halfSize + 3, -halfSize + 3, size, size, size * 0.2)
	                .fill({ color: 0x000000, alpha: 0.2 });
	            // Main shape
	            this.background
	                .roundRect(-halfSize, -halfSize, size, size, size * 0.2)
	                .fill({ color, alpha: 1 });
	            // Highlight
	            this.background
	                .roundRect(-halfSize + 4, -halfSize + 4, size - 8, size * 0.3, size * 0.15)
	                .fill({ color: 0xFFFFFF, alpha: 0.3 });
	            // Tier indicator (small number or stars)
	            this.drawTierIndicator();
	        }
	    }
	    /**
	     * Draw tier indicator (number or stars)
	     */
	    drawTierIndicator() {
	        const size = this.config.size;
	        const indicatorSize = size * 0.25;
	        // Draw tier number in bottom-right corner
	        if (!this.tierLabel) {
	            this.tierLabel = graphics().createGraphics();
	            this.container.addChild(this.tierLabel);
	        }
	        this.tierLabel.clear();
	        // Background circle using Pixi v8 modern API
	        this.tierLabel
	            .circle(size / 2 - indicatorSize, size / 2 - indicatorSize, indicatorSize)
	            .fill({ color: 0x000000, alpha: 0.5 });
	        // TODO: Add text for tier number when text rendering is available
	    }
	}

	/**
	 * MergeGrid - Main container for merge puzzle games
	 *
	 * MergeGrid manages a grid of MergeCells and handles:
	 * - Cell layout and positioning
	 * - Item drag and drop between cells
	 * - Merge detection and execution
	 * - Item spawning
	 * - Progression (cell unlocking)
	 *
	 * Features:
	 * - Flexible grid sizing (rows x cols)
	 * - Configurable cell appearance
	 * - Automatic merge handling
	 * - Drop zone detection during drag
	 * - Cell locking/unlocking for progression
	 * - Event system for game logic integration
	 *
	 * @example
	 * ```typescript
	 * const grid = new MergeGrid({
	 *   rows: 5,
	 *   cols: 5,
	 *   cellWidth: 80,
	 *   cellHeight: 80,
	 *   gap: 8
	 * });
	 *
	 * // Spawn an item
	 * grid.spawnItem({ tier: 1 });
	 *
	 * // Listen for merges
	 * grid.on('merge-completed', (grid, item, cell) => {
	 *   console.log(`Merged! New tier: ${item.tier}`);
	 * });
	 *
	 * scene.addChild(grid.getContainer());
	 * ```
	 */
	class MergeGrid extends EventEmitter {
	    constructor(config) {
	        super();
	        this.cells = [];
	        this.allCells = [];
	        this._currentDragItem = null;
	        this._currentDragFromCell = null;
	        this._highlightedCell = null;
	        this._isDestroyed = false;
	        this.config = {
	            rows: config.rows,
	            cols: config.cols,
	            cellWidth: config.cellWidth ?? 80,
	            cellHeight: config.cellHeight ?? 80,
	            gap: config.gap ?? 8,
	            padding: config.padding ?? 16,
	            backgroundColor: config.backgroundColor ?? 0x1a1a1a,
	            cellConfig: config.cellConfig ?? {},
	            lockedCells: config.lockedCells ?? [],
	            autoSpawn: config.autoSpawn ?? false,
	            maxTier: config.maxTier ?? 10
	        };
	        // Create containers
	        this.container = graphics().createContainer();
	        this.background = graphics().createGraphics();
	        this.cellsContainer = graphics().createContainer();
	        this.itemsContainer = graphics().createContainer();
	        this.container.addChild(this.background);
	        this.container.addChild(this.cellsContainer);
	        this.container.addChild(this.itemsContainer);
	        // Initialize grid
	        this.initializeGrid();
	        // Setup global pointer move for drag tracking
	        this.setupGlobalDragTracking();
	        this.emit('initialized', this);
	    }
	    // ============================================
	    // PUBLIC GETTERS
	    // ============================================
	    /** Get grid dimensions */
	    get rows() { return this.config.rows; }
	    get cols() { return this.config.cols; }
	    /** Get total grid size */
	    get width() {
	        return this.config.padding * 2 + this.config.cols * this.config.cellWidth + (this.config.cols - 1) * this.config.gap;
	    }
	    get height() {
	        return this.config.padding * 2 + this.config.rows * this.config.cellHeight + (this.config.rows - 1) * this.config.gap;
	    }
	    /** Get the display container */
	    getContainer() {
	        return this.container;
	    }
	    /** Get all cells */
	    getCells() {
	        return [...this.allCells];
	    }
	    /** Get cell at position */
	    getCell(row, col) {
	        if (row < 0 || row >= this.config.rows || col < 0 || col >= this.config.cols) {
	            return null;
	        }
	        return this.cells[row][col];
	    }
	    /** Get all items currently in grid */
	    getAllItems() {
	        return this.allCells
	            .filter(cell => cell.hasItem())
	            .map(cell => cell.getItem());
	    }
	    /** Get empty cells */
	    getEmptyCells() {
	        return this.allCells.filter(cell => !cell.hasItem() && cell.acceptsItems);
	    }
	    /** Get unlocked cells */
	    getUnlockedCells() {
	        return this.allCells.filter(cell => !cell.isLocked);
	    }
	    /** Check if grid is full */
	    isFull() {
	        return this.getEmptyCells().length === 0;
	    }
	    // ============================================
	    // ITEM MANAGEMENT
	    // ============================================
	    /**
	     * Spawn a new item in a random empty cell
	     */
	    spawnItem(itemConfig = {}) {
	        const emptyCells = this.getEmptyCells();
	        if (emptyCells.length === 0) {
	            this.emit('grid-full', this);
	            return null;
	        }
	        // Pick random empty cell
	        const cell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
	        return this.spawnItemInCell(cell, itemConfig);
	    }
	    /**
	     * Spawn item in a specific cell
	     */
	    spawnItemInCell(cell, itemConfig = {}) {
	        if (cell.hasItem() || !cell.acceptsItems) {
	            return null;
	        }
	        const item = new MergeItem({
	            tier: itemConfig.tier ?? 1,
	            size: Math.min(this.config.cellWidth, this.config.cellHeight) * 0.8,
	            maxTier: this.config.maxTier,
	            ...itemConfig
	        });
	        // Setup item events
	        this.setupItemEvents(item, cell);
	        // Add to items container (for proper z-ordering during drag)
	        this.itemsContainer.addChild(item.getContainer());
	        // Place in cell
	        cell.placeItem(item);
	        this.emit('item-spawned', this, item, cell);
	        return item;
	    }
	    /**
	     * Remove an item from the grid
	     */
	    removeItem(item) {
	        for (const cell of this.allCells) {
	            if (cell.getItem() === item) {
	                cell.removeItem();
	                item.destroy();
	                return true;
	            }
	        }
	        return false;
	    }
	    /**
	     * Clear all items from grid
	     */
	    clearAllItems() {
	        for (const cell of this.allCells) {
	            const item = cell.removeItem();
	            if (item) {
	                item.destroy();
	            }
	        }
	    }
	    // ============================================
	    // CELL MANAGEMENT
	    // ============================================
	    /**
	     * Unlock a specific cell
	     */
	    unlockCell(row, col) {
	        const cell = this.getCell(row, col);
	        if (!cell || !cell.isLocked) {
	            return false;
	        }
	        cell.setLocked(false);
	        this.emit('cell-unlocked', this, cell);
	        return true;
	    }
	    /**
	     * Lock a specific cell
	     */
	    lockCell(row, col) {
	        const cell = this.getCell(row, col);
	        if (!cell || cell.isLocked) {
	            return false;
	        }
	        // Remove item if present
	        const item = cell.removeItem();
	        if (item) {
	            item.destroy();
	        }
	        cell.setLocked(true);
	        return true;
	    }
	    /**
	     * Find cell at world position
	     */
	    getCellAtPosition(worldX, worldY) {
	        for (const cell of this.allCells) {
	            if (cell.containsPoint(worldX, worldY)) {
	                return cell;
	            }
	        }
	        return null;
	    }
	    /**
	     * Find the cell containing a specific item
	     */
	    getCellForItem(item) {
	        for (const cell of this.allCells) {
	            if (cell.getItem() === item) {
	                return cell;
	            }
	        }
	        return null;
	    }
	    // ============================================
	    // MERGE OPERATIONS
	    // ============================================
	    /**
	     * Attempt to merge two items
	     */
	    performMerge(cell, droppedItem) {
	        const existingItem = cell.getItem();
	        if (!existingItem || !existingItem.canMergeWith(droppedItem)) {
	            return null;
	        }
	        this.emit('merge-started', this, droppedItem, existingItem, cell);
	        // Remove existing item from cell
	        cell.removeItem();
	        // Perform merge
	        const resultItem = existingItem.mergeWith(droppedItem);
	        // Place result in cell
	        this.itemsContainer.addChild(resultItem.getContainer());
	        this.setupItemEvents(resultItem, cell);
	        cell.placeItem(resultItem);
	        // Check for max tier
	        if (resultItem.tier >= this.config.maxTier) {
	            this.emit('max-tier-reached', this, resultItem);
	        }
	        this.emit('merge-completed', this, resultItem, cell);
	        // Auto spawn if enabled
	        if (this.config.autoSpawn) {
	            this.spawnItem({ tier: 1 });
	        }
	        return resultItem;
	    }
	    // ============================================
	    // POSITION & LAYOUT
	    // ============================================
	    /**
	     * Set grid position
	     */
	    setPosition(x, y) {
	        this.container.x = x;
	        this.container.y = y;
	        return this;
	    }
	    /**
	     * Center the grid in a given area
	     */
	    centerIn(width, height) {
	        this.setPosition((width - this.width) / 2, (height - this.height) / 2);
	        return this;
	    }
	    /**
	     * Destroy the grid
	     */
	    destroy() {
	        if (this._isDestroyed)
	            return;
	        this._isDestroyed = true;
	        // Destroy all items and cells
	        for (const cell of this.allCells) {
	            const item = cell.getItem();
	            if (item) {
	                item.destroy();
	            }
	            cell.destroy();
	        }
	        this.container.destroy();
	        this.removeAllListeners();
	    }
	    // ============================================
	    // PRIVATE METHODS
	    // ============================================
	    /**
	     * Initialize the grid cells
	     */
	    initializeGrid() {
	        const { rows, cols, cellWidth, cellHeight, gap, padding, lockedCells, cellConfig } = this.config;
	        // Create locked cells set for O(1) lookup
	        const lockedSet = new Set(lockedCells.map(([r, c]) => `${r},${c}`));
	        // Draw background
	        this.drawBackground();
	        // Create cells
	        for (let row = 0; row < rows; row++) {
	            this.cells[row] = [];
	            for (let col = 0; col < cols; col++) {
	                const isLocked = lockedSet.has(`${row},${col}`);
	                const cell = new MergeCell({
	                    row,
	                    col,
	                    width: cellWidth,
	                    height: cellHeight,
	                    locked: isLocked,
	                    ...cellConfig
	                });
	                // Position cell
	                const x = padding + col * (cellWidth + gap);
	                const y = padding + row * (cellHeight + gap);
	                cell.setPosition(x, y);
	                // Add to container
	                this.cellsContainer.addChild(cell.getContainer());
	                // Store reference
	                this.cells[row][col] = cell;
	                this.allCells.push(cell);
	                // Setup cell events
	                this.setupCellEvents(cell);
	            }
	        }
	    }
	    /**
	     * Draw grid background
	     */
	    drawBackground() {
	        this.background.clear();
	        // Use Pixi v8 modern API
	        this.background
	            .roundRect(0, 0, this.width, this.height, 12)
	            .fill({ color: this.config.backgroundColor, alpha: 1 });
	    }
	    /**
	     * Setup events for a cell
	     */
	    setupCellEvents(cell) {
	        cell.on('hover-enter', () => {
	            if (this._currentDragItem && !cell.hasItem()) {
	                cell.setHighlighted(true, cell.canAcceptItem(this._currentDragItem));
	            }
	        });
	        cell.on('hover-exit', () => {
	            cell.setHighlighted(false);
	        });
	        cell.on('merge-attempt', (c, droppedItem, existingItem) => {
	            this.performMerge(c, droppedItem);
	        });
	    }
	    /**
	     * Setup events for an item
	     */
	    setupItemEvents(item, initialCell) {
	        item.on('drag-start', (it, x, y) => {
	            this._currentDragItem = it;
	            this._currentDragFromCell = this.getCellForItem(it);
	            // Remove from cell and add back to items container for dragging
	            if (this._currentDragFromCell) {
	                this._currentDragFromCell.removeItem();
	                this.itemsContainer.addChild(it.getContainer());
	            }
	            // Move to top of items container
	            this.itemsContainer.setChildIndex(it.getContainer(), this.itemsContainer.children.length - 1);
	        });
	        item.on('drag-move', (it, x, y) => {
	            // Update highlighted cell
	            const cellUnder = this.getCellAtPosition(x, y);
	            if (this._highlightedCell && this._highlightedCell !== cellUnder) {
	                this._highlightedCell.setHighlighted(false);
	            }
	            if (cellUnder && cellUnder !== this._highlightedCell) {
	                const canDrop = cellUnder.canAcceptItem(it);
	                cellUnder.setHighlighted(true, canDrop);
	                this._highlightedCell = cellUnder;
	            }
	            else if (!cellUnder) {
	                this._highlightedCell = null;
	            }
	        });
	        item.on('drag-end', (it, x, y) => {
	            // Clear highlight
	            if (this._highlightedCell) {
	                this._highlightedCell.setHighlighted(false);
	            }
	            // Find drop target
	            const dropCell = this.getCellAtPosition(x, y);
	            if (dropCell) {
	                const result = dropCell.handleDrop(it);
	                if (result === 'placed') {
	                    this.emit('item-moved', this, it, this._currentDragFromCell, dropCell);
	                }
	                else if (result === 'rejected') {
	                    // Return to original cell
	                    if (this._currentDragFromCell) {
	                        this._currentDragFromCell.placeItem(it);
	                    }
	                }
	                // 'merged' is handled by merge-attempt event
	            }
	            else {
	                // Dropped outside grid - return to original cell
	                if (this._currentDragFromCell) {
	                    this._currentDragFromCell.placeItem(it);
	                }
	            }
	            this._currentDragItem = null;
	            this._currentDragFromCell = null;
	            this._highlightedCell = null;
	        });
	    }
	    /**
	     * Setup global drag tracking
	     */
	    setupGlobalDragTracking() {
	        // The item handles its own drag via pointermove
	        // This is for grid-level tracking if needed
	    }
	}

	/**
	 * MergeManager - Core manager for merge puzzle games
	 *
	 * Provides high-level API for creating and managing merge games.
	 * Handles game state, scoring, and lifecycle.
	 *
	 * @example
	 * ```typescript
	 * const manager = new MergeManager();
	 * const grid = manager.createGame({
	 *   rows: 5,
	 *   cols: 5,
	 *   maxTier: 10,
	 *   initialItems: 3
	 * });
	 *
	 * manager.on('merge', (item, tier, score) => {
	 *   console.log(`Merged to tier ${tier}! Score: ${score}`);
	 * });
	 *
	 * manager.start();
	 * ```
	 */
	class MergeManager extends EventEmitter {
	    constructor(config = {}) {
	        super();
	        this.grid = null;
	        this.config = { ...MergeManager.DEFAULT_CONFIG, ...config };
	        this.container = graphics().createContainer();
	        this.state = this.createInitialState();
	    }
	    // ============================================
	    // PUBLIC API
	    // ============================================
	    /**
	     * Create a new merge game grid
	     */
	    createGame(config) {
	        if (config) {
	            this.config = { ...this.config, ...config };
	        }
	        // Destroy existing grid if any
	        if (this.grid) {
	            this.grid.destroy();
	        }
	        // Create new grid
	        this.grid = new MergeGrid({
	            rows: this.config.rows,
	            cols: this.config.cols,
	            cellWidth: this.config.cellWidth,
	            cellHeight: this.config.cellHeight,
	            gap: this.config.gap,
	            padding: this.config.padding,
	            backgroundColor: this.config.backgroundColor,
	            maxTier: this.config.maxTier,
	            autoSpawn: this.config.autoSpawn,
	            lockedCells: this.config.lockedCells,
	            cellConfig: {
	                backgroundColor: this.config.cellBackgroundColor,
	                borderColor: this.config.cellBorderColor
	            }
	        });
	        // Setup event handlers
	        this.setupGridEvents();
	        // Add to container
	        this.container.addChild(this.grid.getContainer());
	        // Reset state
	        this.state = this.createInitialState();
	        return this.grid;
	    }
	    /**
	     * Start the game (spawn initial items)
	     */
	    start() {
	        if (!this.grid) {
	            throw new Error('No game created. Call createGame() first.');
	        }
	        this.state.isPaused = false;
	        this.state.isGameOver = false;
	        // Spawn initial items
	        for (let i = 0; i < this.config.initialItems; i++) {
	            this.spawnItem(this.config.initialTier);
	        }
	        this.emit('game-started', { ...this.state });
	    }
	    /**
	     * Pause the game
	     */
	    pause() {
	        this.state.isPaused = true;
	        this.emit('game-paused', { ...this.state });
	    }
	    /**
	     * Resume the game
	     */
	    resume() {
	        this.state.isPaused = false;
	        this.emit('game-resumed', { ...this.state });
	    }
	    /**
	     * Reset the game
	     */
	    reset() {
	        if (this.grid) {
	            this.grid.clearAllItems();
	        }
	        this.state = this.createInitialState();
	        this.emit('game-reset', { ...this.state });
	    }
	    /**
	     * Spawn a new item
	     */
	    spawnItem(tier = 1) {
	        if (!this.grid || this.state.isPaused || this.state.isGameOver) {
	            return null;
	        }
	        const item = this.grid.spawnItem({
	            tier,
	            tierColors: this.config.tierColors,
	            textures: this.config.tierTextures,
	            maxTier: this.config.maxTier
	        });
	        if (item) {
	            this.state.itemsSpawned++;
	            this.emit('item-spawned', item);
	            this.emit('state-changed', { ...this.state });
	        }
	        return item;
	    }
	    /**
	     * Get the grid instance
	     */
	    getGrid() {
	        return this.grid;
	    }
	    /**
	     * Get the container for adding to scene
	     */
	    getContainer() {
	        return this.container;
	    }
	    /**
	     * Get current game state
	     */
	    getState() {
	        return { ...this.state };
	    }
	    /**
	     * Get current score
	     */
	    getScore() {
	        return this.state.score;
	    }
	    /**
	     * Get highest tier achieved
	     */
	    getHighestTier() {
	        return this.state.highestTier;
	    }
	    /**
	     * Check if game is over
	     */
	    isGameOver() {
	        return this.state.isGameOver;
	    }
	    /**
	     * Check if game is paused
	     */
	    isPaused() {
	        return this.state.isPaused;
	    }
	    /**
	     * Set position
	     */
	    setPosition(x, y) {
	        this.container.x = x;
	        this.container.y = y;
	        return this;
	    }
	    /**
	     * Center in area
	     */
	    centerIn(width, height) {
	        if (this.grid) {
	            this.grid.centerIn(width, height);
	        }
	        return this;
	    }
	    /**
	     * Get grid dimensions
	     */
	    getDimensions() {
	        if (!this.grid) {
	            return { width: 0, height: 0 };
	        }
	        return {
	            width: this.grid.width,
	            height: this.grid.height
	        };
	    }
	    /**
	     * Destroy the manager
	     */
	    destroy() {
	        if (this.grid) {
	            this.grid.destroy();
	            this.grid = null;
	        }
	        this.container.destroy();
	        this.removeAllListeners();
	    }
	    // ============================================
	    // PRIVATE METHODS
	    // ============================================
	    /**
	     * Create initial game state
	     */
	    createInitialState() {
	        return {
	            score: 0,
	            highestTier: 0,
	            totalMerges: 0,
	            itemsSpawned: 0,
	            isGameOver: false,
	            isPaused: false
	        };
	    }
	    /**
	     * Setup grid event handlers
	     */
	    setupGridEvents() {
	        if (!this.grid)
	            return;
	        this.grid.on('merge-completed', (grid, resultItem, cell) => {
	            this.handleMerge(resultItem);
	        });
	        this.grid.on('max-tier-reached', (grid, item) => {
	            this.emit('max-tier', item);
	        });
	        this.grid.on('grid-full', () => {
	            this.handleGridFull();
	        });
	    }
	    /**
	     * Handle merge event
	     */
	    handleMerge(resultItem) {
	        const tier = resultItem.tier;
	        const scoreGain = tier * this.config.scoreMultiplier;
	        // Update state
	        this.state.totalMerges++;
	        this.state.score += scoreGain;
	        if (tier > this.state.highestTier) {
	            this.state.highestTier = tier;
	        }
	        // Emit events
	        this.emit('score-changed', this.state.score, scoreGain);
	        this.emit('merge', resultItem, tier, scoreGain);
	        this.emit('state-changed', { ...this.state });
	        // Haptic feedback
	        if (this.config.hapticFeedback && 'vibrate' in navigator) {
	            navigator.vibrate(50);
	        }
	    }
	    /**
	     * Handle grid full event
	     */
	    handleGridFull() {
	        this.state.isGameOver = true;
	        this.emit('grid-full');
	        this.emit('game-over', { ...this.state });
	    }
	}
	MergeManager.DEFAULT_CONFIG = {
	    rows: 5,
	    cols: 5,
	    cellWidth: 80,
	    cellHeight: 80,
	    gap: 8,
	    padding: 16,
	    backgroundColor: 0x1a1a1a,
	    cellBackgroundColor: 0x2a2a2a,
	    cellBorderColor: 0x444444,
	    maxTier: 10,
	    autoSpawn: false,
	    initialItems: 3,
	    initialTier: 1,
	    lockedCells: [],
	    tierColors: [
	        0x9E9E9E, // Tier 0: Gray
	        0x4CAF50, // Tier 1: Green
	        0x2196F3, // Tier 2: Blue
	        0x9C27B0, // Tier 3: Purple
	        0xFF9800, // Tier 4: Orange
	        0xF44336, // Tier 5: Red
	        0xFFEB3B, // Tier 6: Yellow/Gold
	        0x00BCD4, // Tier 7: Cyan
	        0xE91E63, // Tier 8: Pink
	        0x673AB7, // Tier 9: Deep Purple
	        0xFFD700, // Tier 10+: Gold
	    ],
	    tierTextures: new Map(),
	    scoreMultiplier: 100,
	    hapticFeedback: true,
	    soundEnabled: true,
	    mergeAnimationDuration: 200,
	    spawnAnimationDuration: 150
	};

	/**
	 * Service provider for the Merge game system
	 *
	 * Registers merge game services and components in the container.
	 *
	 * @example
	 * ```typescript
	 * import { GameByte, MergeServiceProvider } from 'gamebyte-framework';
	 *
	 * const game = GameByte.create();
	 * game.register(new MergeServiceProvider());
	 *
	 * await game.initialize(canvas, '2d');
	 *
	 * // Now you can use the Merge facade
	 * import { Merge } from 'gamebyte-framework';
	 * Merge.createGame({ rows: 5, cols: 5 });
	 * ```
	 */
	class MergeServiceProvider extends AbstractServiceProvider {
	    constructor(config = {}) {
	        super();
	        this.config = config;
	    }
	    /**
	     * Register merge services in the container
	     */
	    register(app) {
	        // Register MergeManager as singleton
	        app.singleton('merge', () => {
	            return new MergeManager(this.config);
	        });
	        // Register alias for convenience
	        app.getContainer().alias('merge.manager', 'merge');
	    }
	    /**
	     * Boot the merge services
	     */
	    async boot(app) {
	        // Get the merge manager to ensure it's initialized
	        const mergeManager = app.make('merge');
	        // Emit merge system ready event
	        app.emit('merge-system-ready', { mergeManager });
	    }
	    /**
	     * Services this provider offers
	     */
	    provides() {
	        return ['merge', 'merge.manager'];
	    }
	}

	/**
	 * MergeGameScene - Ready-to-use scene for merge puzzle games
	 *
	 * Provides a complete merge game experience with:
	 * - Pre-configured merge grid
	 * - Optional score display
	 * - Event handling
	 * - Game state management
	 *
	 * @example
	 * ```typescript
	 * // Simple usage
	 * const mergeScene = new MergeGameScene({
	 *   rows: 5,
	 *   cols: 5,
	 *   showScoreUI: true
	 * });
	 *
	 * await sceneManager.add(mergeScene);
	 * await sceneManager.switchTo('merge-game');
	 *
	 * // With callbacks
	 * const mergeScene = new MergeGameScene({
	 *   rows: 6,
	 *   cols: 6,
	 *   onMerge: (item, tier, score) => {
	 *     playMergeSound(tier);
	 *   },
	 *   onGameOver: (state) => {
	 *     showGameOverModal(state.score);
	 *   }
	 * });
	 * ```
	 */
	class MergeGameScene extends BaseScene {
	    constructor(config = {}) {
	        const sceneId = config.sceneId || 'merge-game';
	        const sceneName = config.sceneName || 'Merge Game';
	        super(sceneId, sceneName);
	        this.scoreText = null;
	        this.tierText = null;
	        this.uiContainer = null;
	        this.backgroundGraphics = null;
	        // Merge configs
	        this.sceneConfig = {
	            ...MergeGameScene.DEFAULT_SCENE_CONFIG,
	            ...config
	        };
	        // Create merge manager with game config
	        this.mergeManager = new MergeManager(config);
	    }
	    /**
	     * Initialize the scene
	     */
	    async initialize() {
	        await super.initialize();
	        // Create background
	        this.createBackground();
	        // Create merge game
	        this.mergeManager.createGame();
	        // Add merge grid to scene
	        const gridContainer = this.mergeManager.getContainer();
	        this.container.addChild(gridContainer);
	        // Setup UI if enabled
	        if (this.sceneConfig.showScoreUI || this.sceneConfig.showTierUI) {
	            this.createUI();
	        }
	        // Setup event handlers
	        this.setupEventHandlers();
	    }
	    /**
	     * Activate the scene
	     */
	    activate() {
	        super.activate();
	        // Auto center if enabled
	        if (this.sceneConfig.autoCenter) {
	            this.centerGrid();
	        }
	        // Start the game
	        this.mergeManager.start();
	    }
	    /**
	     * Deactivate the scene
	     */
	    deactivate() {
	        super.deactivate();
	        this.mergeManager.pause();
	    }
	    /**
	     * Update the scene
	     */
	    update(deltaTime) {
	        super.update(deltaTime);
	        // Update UI
	        this.updateUI();
	    }
	    /**
	     * Destroy the scene
	     */
	    destroy() {
	        this.mergeManager.destroy();
	        super.destroy();
	    }
	    // ============================================
	    // PUBLIC API
	    // ============================================
	    /**
	     * Get the merge manager
	     */
	    getMergeManager() {
	        return this.mergeManager;
	    }
	    /**
	     * Get the merge grid
	     */
	    getGrid() {
	        return this.mergeManager.getGrid();
	    }
	    /**
	     * Get current score
	     */
	    getScore() {
	        return this.mergeManager.getScore();
	    }
	    /**
	     * Get game state
	     */
	    getState() {
	        return this.mergeManager.getState();
	    }
	    /**
	     * Spawn an item
	     */
	    spawnItem(tier = 1) {
	        return this.mergeManager.spawnItem(tier);
	    }
	    /**
	     * Restart the game
	     */
	    restart() {
	        this.mergeManager.reset();
	        this.mergeManager.start();
	    }
	    /**
	     * Pause the game
	     */
	    pauseGame() {
	        this.mergeManager.pause();
	    }
	    /**
	     * Resume the game
	     */
	    resumeGame() {
	        this.mergeManager.resume();
	    }
	    /**
	     * Center the grid in the scene
	     */
	    centerGrid() {
	        // Get viewport dimensions from renderer or use defaults
	        const width = this.container.width || 800;
	        const height = this.container.height || 600;
	        this.mergeManager.centerIn(width, height);
	        // Apply offset
	        const container = this.mergeManager.getContainer();
	        container.x += this.sceneConfig.gridOffsetX;
	        container.y += this.sceneConfig.gridOffsetY;
	    }
	    /**
	     * Set grid position
	     */
	    setGridPosition(x, y) {
	        this.mergeManager.setPosition(x, y);
	    }
	    // ============================================
	    // PRIVATE METHODS
	    // ============================================
	    /**
	     * Create background
	     */
	    createBackground() {
	        try {
	            this.backgroundGraphics = graphics().createGraphics();
	            this.backgroundGraphics
	                .rect(0, 0, 2000, 2000)
	                .fill({ color: this.sceneConfig.sceneBackgroundColor });
	            this.container.addChildAt(this.backgroundGraphics, 0);
	        }
	        catch {
	            // Graphics engine might not be initialized
	        }
	    }
	    /**
	     * Create UI elements
	     */
	    createUI() {
	        try {
	            this.uiContainer = graphics().createContainer();
	            this.container.addChild(this.uiContainer);
	            if (this.sceneConfig.showScoreUI) {
	                this.scoreText = graphics().createText('Score: 0', {
	                    fontFamily: getFrameworkFontFamily(),
	                    fontSize: 24,
	                    fill: 0xFFFFFF
	                });
	                this.scoreText.x = this.sceneConfig.scorePosition.x;
	                this.scoreText.y = this.sceneConfig.scorePosition.y;
	                this.uiContainer.addChild(this.scoreText);
	            }
	            if (this.sceneConfig.showTierUI) {
	                this.tierText = graphics().createText('Best Tier: 0', {
	                    fontFamily: getFrameworkFontFamily(),
	                    fontSize: 18,
	                    fill: 0xCCCCCC
	                });
	                this.tierText.x = this.sceneConfig.scorePosition.x;
	                this.tierText.y = this.sceneConfig.scorePosition.y + 30;
	                this.uiContainer.addChild(this.tierText);
	            }
	        }
	        catch {
	            // Graphics engine might not be initialized
	        }
	    }
	    /**
	     * Update UI elements
	     */
	    updateUI() {
	        const state = this.mergeManager.getState();
	        if (this.scoreText) {
	            this.scoreText.text = `Score: ${state.score.toLocaleString()}`;
	        }
	        if (this.tierText) {
	            this.tierText.text = `Best Tier: ${state.highestTier}`;
	        }
	    }
	    /**
	     * Setup event handlers
	     */
	    setupEventHandlers() {
	        this.mergeManager.on('merge', (item, tier, score) => {
	            this.sceneConfig.onMerge(item, tier, score);
	            this.emit('merge', item, tier, score);
	        });
	        this.mergeManager.on('game-over', (state) => {
	            this.sceneConfig.onGameOver(state);
	            this.emit('game-over', state);
	        });
	        this.mergeManager.on('max-tier', (item) => {
	            this.sceneConfig.onMaxTier(item);
	            this.emit('max-tier', item);
	        });
	        this.mergeManager.on('score-changed', (score, delta) => {
	            this.sceneConfig.onScoreChange(score, delta);
	            this.emit('score-changed', score, delta);
	        });
	    }
	}
	MergeGameScene.DEFAULT_SCENE_CONFIG = {
	    sceneId: 'merge-game',
	    sceneName: 'Merge Game',
	    showScoreUI: true,
	    showTierUI: true,
	    sceneBackgroundColor: 0x0d0d1a,
	    autoCenter: true,
	    gridOffsetX: 0,
	    gridOffsetY: 50,
	    scorePosition: { x: 20, y: 20 },
	    onMerge: () => { },
	    onGameOver: () => { },
	    onMaxTier: () => { },
	    onScoreChange: () => { }
	};

	/**
	 * Archero-Style Bottom Navigation Menu
	 *
	 * A fully configurable, extendable, and override-capable mobile-optimized (9:16 portrait)
	 * bottom navigation menu system featuring:
	 * - Glossy gold gradient buttons for active state
	 * - Smooth GSAP-powered animations
	 * - Touch/swipe gestures
	 * - Particle effects on interaction
	 * - Dynamic button spacing
	 * - Renderer-agnostic (works with both 2D and 3D)
	 * - Complete style customization
	 * - Per-section style overrides
	 * - Dynamic section management
	 * - Inheritance-friendly architecture
	 *
	 * @example Basic Usage
	 * ```typescript
	 * const menu = new ArcheroMenu({
	 *   sections: [
	 *     { name: 'Shop', icon: 'ðŸª', iconColor: 0xFF6B6B },
	 *     { name: 'Campaign', icon: 'ðŸŽ¯', iconColor: 0xFFD700 }
	 *   ],
	 *   activeSection: 1
	 * });
	 * stage.addChild(menu.getContainer());
	 * ```
	 *
	 * @example Advanced Configuration
	 * ```typescript
	 * const menu = new ArcheroMenu({
	 *   sections: [...],
	 *   style: {
	 *     buttonSize: 200,
	 *     activeButtonSize: 350,
	 *     buttonGradient: {
	 *       topColor: 0xFF6B6B,
	 *       middleColor: 0xFF3B3B,
	 *       bottomColor: 0xCC0000
	 *     },
	 *     transitionDuration: 0.7
	 *   },
	 *   callbacks: {
	 *     onSectionChange: (index, section) => console.log('Changed to:', section.name),
	 *     onBeforeTransition: (from, to) => {
	 *       // Can cancel transition by returning false
	 *       return true;
	 *     }
	 *   }
	 * });
	 * ```
	 *
	 * @example Custom Inheritance
	 * ```typescript
	 * class CustomArcheroMenu extends ArcheroMenu {
	 *   protected createButton(section: MenuSection, index: number): ButtonData {
	 *     // Custom button creation logic
	 *     return super.createButton(section, index);
	 *   }
	 * }
	 * ```
	 */
	/**
	 * Archero-style color palette
	 */
	const ARCHERO_COLORS = {
	    // Navigation bar
	    navBg: 0x0f1624,
	    navBgLight: 0x1a2332,
	    separator: 0x2d3f5f,
	    // Button states
	    activeYellow: 0xFFD700,
	    activeOrange: 0xFFA500,
	    activeLightGold: 0xFFE55C,
	    // Icon colors
	    red: 0xFF3B3B,
	    blue: 0x3B7BFF,
	    purple: 0x9B3BFF,
	    green: 0x3BFF7B,
	    // Effects
	    white: 0xFFFFFF,
	    black: 0x000000,
	    // Label text
	    darkBrown: 0x4A2F1A
	};
	/**
	 * Default style configuration
	 */
	const DEFAULT_STYLE$1 = {
	    // Button Sizes - Adjusted for better balance
	    buttonSize: 130,
	    activeButtonSize: 260,
	    buttonRadius: 30,
	    // Button Colors & Gradients - EXACT vanilla colors
	    buttonGradient: {
	        topColor: 0xFFE55C, // Light gold top (vanilla)
	        middleColor: 0xFFD700, // Gold middle (vanilla)
	        bottomColor: 0xFFA500 // Orange bottom (vanilla)
	    },
	    shineGradient: {
	        topColor: 0xFFFFFF, // Pure white at top (vanilla)
	        middleColor: 0xFFE55C, // Light gold (vanilla)
	        bottomColor: 0xFFD700, // Gold at bottom (vanilla)
	        alpha: 0.5 // Overall shine brightness (vanilla)
	    },
	    // Navigation Bar - More visible and prominent
	    navBarColor: 0x1a1f2e, // Slightly lighter dark blue
	    navBarAlpha: 1.0,
	    navBarOverlayColor: ARCHERO_COLORS.navBgLight,
	    navBarOverlayAlpha: 0.5,
	    separatorColor: 0x3d4f6f, // Lighter separator for better visibility
	    navHeight: 220, // Shorter but more prominent
	    // Icon Styling - Vanilla sizes
	    iconSize: 90, // Inactive icon size (vanilla)
	    activeIconSize: 140, // Active icon size (vanilla)
	    iconYOffset: -10,
	    activeIconYOffset: -35, // Vanilla positioning
	    iconStrokeColor: ARCHERO_COLORS.black,
	    iconStrokeWidth: 8,
	    iconShadowDistance: 6,
	    iconShadowBlur: 4,
	    // Label Styling - Vanilla values
	    labelSize: 40,
	    labelYOffset: 55, // Vanilla Y position
	    labelColor: ARCHERO_COLORS.darkBrown,
	    labelStrokeColor: ARCHERO_COLORS.activeLightGold,
	    labelStrokeWidth: 4,
	    labelFontWeight: '900',
	    labelShadowDistance: 3,
	    labelShadowBlur: 3,
	    // Layout & Spacing - Tighter spacing for better appearance
	    padding: 50, // Increased padding for tighter button spacing
	    elevationOffset: 20, // Less elevation for more natural look
	    // Animation Durations - Smoother and faster
	    transitionDuration: 0.4,
	    iconAnimDuration: 0.25,
	    repositionDuration: 0.35,
	    elevationDuration: 0.4,
	    labelFadeDuration: 0.25,
	    labelFadeDelay: 0.15,
	    // Particle Effects
	    enableParticles: true,
	    particleCount: 30,
	    particleSizeRange: [3, 11],
	    particleSpeedRange: [6, 18],
	    particleColors: []
	};
	/**
	 * Archero-Style Bottom Navigation Menu Component
	 *
	 * Fully configurable and extendable menu system with:
	 * - Complete style customization via ArcheroMenuStyleConfig
	 * - Dynamic section management (add, remove, update, reorder)
	 * - Event callbacks for all interactions
	 * - Inheritance-friendly protected methods
	 * - Backward compatible with legacy API
	 */
	class ArcheroMenu extends EventEmitter {
	    constructor(options) {
	        super();
	        // Button management
	        this.buttons = [];
	        // Particle management
	        this.particles = [];
	        // Animation state
	        this.isAnimating = false;
	        // Touch tracking
	        this.touchStartX = 0;
	        this.touchStartY = 0;
	        // Responsive scaling
	        this.responsiveCalculator = null;
	        // Merge style configuration with defaults
	        this.style = this.mergeStyleConfig(options);
	        // Handle backward compatibility for deprecated options
	        this.callbacks = {
	            ...options.callbacks,
	            onSectionChange: options.callbacks?.onSectionChange || options.onSectionChange
	        };
	        // Set main configuration
	        this.config = {
	            sections: options.sections,
	            activeSection: options.activeSection ?? 0,
	            canvasWidth: options.canvasWidth ?? 1080,
	            canvasHeight: options.canvasHeight ?? 1920,
	            enableSwipe: options.enableSwipe ?? true
	        };
	        this.activeSection = this.config.activeSection;
	        // Initialize responsive calculator if enabled
	        if (options.responsive) {
	            const responsiveConfig = typeof options.responsive === 'boolean'
	                ? { baseWidth: this.config.canvasWidth, baseHeight: this.config.canvasHeight }
	                : options.responsive;
	            this.responsiveCalculator = new ResponsiveScaleCalculator(responsiveConfig);
	            console.log('ðŸ“± ArcheroMenu responsive mode enabled with base size:', responsiveConfig.baseWidth, 'x', responsiveConfig.baseHeight);
	        }
	        // Create containers
	        this.rootContainer = graphics().createContainer();
	        this.navBarContainer = graphics().createContainer();
	        this.particleContainer = graphics().createContainer();
	        // Add to hierarchy
	        this.rootContainer.addChild(this.particleContainer);
	        this.rootContainer.addChild(this.navBarContainer);
	        // Position nav bar at bottom
	        this.navBarContainer.y = this.config.canvasHeight - this.getScaledValue(this.style.navHeight);
	        // Build menu
	        this.buildNavBar();
	        this.buildButtons();
	        // Setup touch handlers if swipe enabled
	        if (this.config.enableSwipe) {
	            this.setupTouchHandlers();
	        }
	    }
	    /**
	     * Get scaled value using responsive calculator (if enabled)
	     */
	    getScaledValue(baseValue) {
	        return this.responsiveCalculator
	            ? this.responsiveCalculator.scale(baseValue)
	            : baseValue;
	    }
	    /**
	     * Merge user style config with defaults
	     */
	    mergeStyleConfig(options) {
	        const style = options.style || {};
	        // Handle backward compatibility
	        const legacyOverrides = {};
	        if (options.enableParticles !== undefined)
	            legacyOverrides.enableParticles = options.enableParticles;
	        if (options.navHeight !== undefined)
	            legacyOverrides.navHeight = options.navHeight;
	        if (options.buttonSize !== undefined)
	            legacyOverrides.buttonSize = options.buttonSize;
	        if (options.activeButtonSize !== undefined)
	            legacyOverrides.activeButtonSize = options.activeButtonSize;
	        if (options.padding !== undefined)
	            legacyOverrides.padding = options.padding;
	        return {
	            ...DEFAULT_STYLE$1,
	            ...legacyOverrides,
	            ...style,
	            buttonGradient: {
	                ...DEFAULT_STYLE$1.buttonGradient,
	                ...style.buttonGradient
	            },
	            shineGradient: {
	                ...DEFAULT_STYLE$1.shineGradient,
	                ...style.shineGradient
	            }
	        };
	    }
	    /**
	     * Get current style configuration
	     */
	    getStyle() {
	        return { ...this.style };
	    }
	    /**
	     * Update style configuration dynamically
	     * @param style Partial style config to update
	     * @param rebuild Whether to rebuild the menu (default: true)
	     */
	    setStyle(style, rebuild = true) {
	        // Deep merge the new style
	        this.style = {
	            ...this.style,
	            ...style,
	            buttonGradient: {
	                ...this.style.buttonGradient,
	                ...style.buttonGradient
	            },
	            shineGradient: {
	                ...this.style.shineGradient,
	                ...style.shineGradient
	            }
	        };
	        if (rebuild) {
	            this.rebuildMenu();
	        }
	    }
	    /**
	     * Rebuild the entire menu (useful after style changes)
	     */
	    rebuildMenu() {
	        // Clear existing buttons
	        for (const button of this.buttons) {
	            button.container.destroy({ children: true });
	        }
	        this.buttons = [];
	        // Clear nav bar children except background
	        while (this.navBarContainer.children.length > 0) {
	            const child = this.navBarContainer.children[0];
	            this.navBarContainer.removeChild(child);
	            child.destroy({ children: true });
	        }
	        // Rebuild
	        this.buildNavBar();
	        this.buildButtons();
	    }
	    /**
	     * Build navigation bar background
	     */
	    buildNavBar() {
	        const navHeight = this.getScaledValue(this.style.navHeight);
	        // Navy blue gradient background
	        const navBg = graphics().createGraphics();
	        navBg.rect(0, 0, this.config.canvasWidth, navHeight);
	        navBg.fill({ color: this.style.navBarColor, alpha: this.style.navBarAlpha });
	        this.navBarContainer.addChild(navBg);
	        // Top separator line - more prominent
	        const separatorHeight = this.getScaledValue(4);
	        const separator = graphics().createGraphics();
	        separator.rect(0, 0, this.config.canvasWidth, separatorHeight);
	        separator.fill({ color: this.style.separatorColor });
	        this.navBarContainer.addChild(separator);
	        // Darker overlay for depth
	        const overlay = graphics().createGraphics();
	        overlay.rect(0, separatorHeight, this.config.canvasWidth, navHeight - separatorHeight);
	        overlay.fill({ color: this.style.navBarOverlayColor, alpha: this.style.navBarOverlayAlpha });
	        this.navBarContainer.addChild(overlay);
	    }
	    /**
	     * Build navigation buttons
	     */
	    buildButtons() {
	        this.config.sections.forEach((section, index) => {
	            const buttonData = this.createButton(section, index);
	            this.buttons.push(buttonData);
	            this.navBarContainer.addChild(buttonData.container);
	        });
	    }
	    /**
	     * Create a single button (override this for custom button rendering)
	     */
	    createButton(section, index) {
	        const isActive = index === this.activeSection;
	        // Apply responsive scaling
	        const navHeight = this.getScaledValue(this.style.navHeight);
	        const elevationOffset = this.getScaledValue(this.style.elevationOffset);
	        // Check for custom renderer
	        if (this.callbacks.renderButton) {
	            const customButton = this.callbacks.renderButton(section, isActive);
	            if (customButton) {
	                // User provided custom button, create minimal ButtonData
	                const xPos = this.calculateButtonX(index);
	                customButton.x = xPos;
	                customButton.y = isActive
	                    ? navHeight / 2 - elevationOffset
	                    : navHeight / 2;
	                return {
	                    container: customButton,
	                    bg: graphics().createGraphics(), // Placeholder
	                    overlay: null,
	                    icon: graphics().createText('', { fontFamily: 'system-ui' }), // Placeholder
	                    label: null,
	                    section,
	                    index
	                };
	            }
	        }
	        // Default button creation with responsive scaling
	        const size = isActive
	            ? this.getScaledValue(this.style.activeButtonSize)
	            : this.getScaledValue(this.style.buttonSize);
	        // Create button container
	        const container = graphics().createContainer();
	        container.eventMode = 'static';
	        container.cursor = 'pointer';
	        // Position button
	        const xPos = this.calculateButtonX(index);
	        container.x = xPos;
	        container.y = isActive
	            ? navHeight / 2 - elevationOffset
	            : navHeight / 2;
	        // Create button background
	        const bg = graphics().createGraphics();
	        this.renderButtonBackground(bg, section, size, isActive);
	        container.addChild(bg);
	        // Create shine overlay for active button
	        let overlay = null;
	        if (isActive) {
	            overlay = this.createShineOverlay(section, size);
	            container.addChild(overlay);
	        }
	        // Create icon
	        const icon = this.createIcon(section, isActive);
	        container.addChild(icon);
	        // Create label for active button
	        let label = null;
	        if (isActive) {
	            label = this.createLabel(section);
	            container.addChild(label);
	        }
	        // Setup interaction
	        this.setupButtonInteraction(container, index);
	        return {
	            container,
	            bg,
	            overlay,
	            icon,
	            label,
	            section,
	            index
	        };
	    }
	    /**
	     * Create icon for button (override for custom icons)
	     */
	    createIcon(section, isActive) {
	        // Check for custom icon renderer
	        if (this.callbacks.renderIcon) {
	            const customIcon = this.callbacks.renderIcon(section, isActive);
	            if (customIcon)
	                return customIcon;
	        }
	        // Use style config values (with vanilla defaults in DEFAULT_STYLE)
	        const fontSize = isActive ? this.style.activeIconSize : this.style.iconSize;
	        const yPosition = isActive ? this.style.activeIconYOffset : this.style.iconYOffset;
	        // Direct PIXI.Text creation (bypass framework abstraction for predictable sizing)
	        const icon = new PIXI__namespace.Text(typeof section.icon === 'string' ? section.icon : '', {
	            fontSize: fontSize,
	            fontFamily: 'system-ui',
	            stroke: { color: this.style.iconStrokeColor, width: this.style.iconStrokeWidth },
	            dropShadow: {
	                angle: 0.523599,
	                distance: this.style.iconShadowDistance,
	                alpha: 0.8,
	                blur: this.style.iconShadowBlur,
	                color: this.style.iconStrokeColor
	            }
	        });
	        icon.anchor.set(0.5);
	        icon.y = yPosition;
	        return icon;
	    }
	    /**
	     * Create label for active button (override for custom labels)
	     */
	    createLabel(section) {
	        // Check for custom label renderer
	        if (this.callbacks.renderLabel) {
	            const customLabel = this.callbacks.renderLabel(section);
	            if (customLabel)
	                return customLabel;
	        }
	        // Apply section-specific style overrides
	        const labelColor = section.customStyle?.labelColor ?? this.style.labelColor;
	        const labelStrokeColor = section.customStyle?.labelStrokeColor ?? this.style.labelStrokeColor;
	        // Direct PIXI.Text creation (bypass framework abstraction for predictable sizing)
	        const label = new PIXI__namespace.Text(section.name, {
	            fontSize: this.style.labelSize,
	            fill: labelColor,
	            fontWeight: this.style.labelFontWeight,
	            stroke: { color: labelStrokeColor, width: this.style.labelStrokeWidth },
	            dropShadow: {
	                angle: 0.523599,
	                distance: this.style.labelShadowDistance,
	                alpha: 0.6,
	                blur: this.style.labelShadowBlur,
	                color: 0x000000
	            }
	        });
	        label.anchor.set(0.5);
	        label.y = this.style.labelYOffset;
	        return label;
	    }
	    /**
	     * Setup button interaction handlers
	     */
	    setupButtonInteraction(container, index) {
	        container.on('pointerdown', () => this.onButtonClick(index));
	        container.on('pointerover', () => this.onButtonHover(index));
	        container.on('pointerout', () => this.onButtonHoverEnd(index));
	    }
	    /**
	     * Render button background (solid or gradient)
	     */
	    renderButtonBackground(bg, section, size, isActive) {
	        bg.clear();
	        if (isActive) {
	            // Apply section-specific gradient override
	            const gradientConfig = section.customStyle?.buttonGradient ?? this.style.buttonGradient;
	            // Ensure gradient colors have defaults
	            const topColor = gradientConfig.topColor ?? 0xFFF4CC;
	            const middleColor = gradientConfig.middleColor ?? 0xFFD700;
	            const bottomColor = gradientConfig.bottomColor ?? 0xFF8C00;
	            // PixiJS v8 FillGradient API (EXACT vanilla syntax)
	            const fillGradient = new PIXI__namespace.FillGradient({
	                type: 'linear',
	                start: { x: 0, y: 0 },
	                end: { x: 0, y: 1 },
	                colorStops: [
	                    { offset: 0, color: topColor },
	                    { offset: 0.5, color: middleColor },
	                    { offset: 1, color: bottomColor }
	                ]
	            });
	            bg.roundRect(-size / 2, -size / 2, size, size, this.getScaledValue(this.style.buttonRadius));
	            bg.fill(fillGradient);
	        }
	        else {
	            // Inactive: Transparent
	            bg.rect(-size / 2, -size / 2, size, size);
	            bg.fill({ color: ARCHERO_COLORS.black, alpha: 0.0 });
	        }
	    }
	    /**
	     * Create glossy shine overlay for active button
	     */
	    createShineOverlay(section, size) {
	        const overlay = graphics().createGraphics();
	        const overlayWidth = size * 0.92;
	        const overlayHeight = size * 0.22;
	        const shine = this.style.shineGradient;
	        // Ensure shine colors have defaults
	        const topColor = shine.topColor ?? 0xFFFFFF;
	        const middleColor = shine.middleColor ?? 0xFFFBE6;
	        const bottomColor = shine.bottomColor ?? 0xFFE55C;
	        const alpha = shine.alpha ?? 0.35;
	        // PixiJS v8 FillGradient API (EXACT vanilla syntax)
	        const overlayTop = -size / 2 + 8;
	        const shineGradient = new PIXI__namespace.FillGradient({
	            type: 'linear',
	            start: { x: 0, y: 0 },
	            end: { x: 0, y: 1 },
	            colorStops: [
	                { offset: 0, color: topColor },
	                { offset: 0.8, color: middleColor },
	                { offset: 1, color: bottomColor }
	            ]
	        });
	        overlay.roundRect(-overlayWidth / 2, overlayTop, overlayWidth, overlayHeight, this.getScaledValue(25));
	        overlay.fill(shineGradient);
	        overlay.alpha = alpha; // Vanilla: simple alpha, no mask
	        return overlay;
	    }
	    /**
	     * Calculate button X position based on index
	     */
	    calculateButtonX(index) {
	        const { sections } = this.config;
	        // Apply responsive scaling to button sizes and padding
	        const buttonSize = this.getScaledValue(this.style.buttonSize);
	        const activeButtonSize = this.getScaledValue(this.style.activeButtonSize);
	        const padding = this.getScaledValue(this.style.padding);
	        // Calculate total width needed
	        const totalButtonsWidth = activeButtonSize + (buttonSize * (sections.length - 1));
	        const availableWidth = this.config.canvasWidth - (padding * 2);
	        const totalSpacing = availableWidth - totalButtonsWidth;
	        const spacingBetweenButtons = totalSpacing / (sections.length - 1);
	        // Calculate position for this button
	        let xPos = padding;
	        for (let i = 0; i < index; i++) {
	            const btnSize = (i === this.activeSection) ? activeButtonSize : buttonSize;
	            xPos += btnSize + spacingBetweenButtons;
	        }
	        // Add half of current button size to center it
	        const currentSize = (index === this.activeSection) ? activeButtonSize : buttonSize;
	        xPos += currentSize / 2;
	        return xPos;
	    }
	    /**
	     * Handle button click
	     */
	    onButtonClick(index) {
	        if (this.isAnimating || index === this.activeSection)
	            return;
	        // Call button press callback
	        if (this.callbacks.onButtonPress) {
	            this.callbacks.onButtonPress(index);
	        }
	        this.switchToSection(index);
	    }
	    /**
	     * Handle button hover
	     */
	    onButtonHover(index) {
	        if (index === this.activeSection)
	            return;
	        const button = this.buttons[index];
	        // Use GSAP if available, fallback to direct scale
	        if (typeof window !== 'undefined' && window.gsap) {
	            window.gsap.to(button.container.scale, {
	                x: 1.1,
	                y: 1.1,
	                duration: 0.2
	            });
	        }
	        else {
	            button.container.scale.x = 1.1;
	            button.container.scale.y = 1.1;
	        }
	    }
	    /**
	     * Handle button hover end
	     */
	    onButtonHoverEnd(index) {
	        if (index === this.activeSection)
	            return;
	        const button = this.buttons[index];
	        // Use GSAP if available, fallback to direct scale
	        if (typeof window !== 'undefined' && window.gsap) {
	            window.gsap.to(button.container.scale, {
	                x: 1.0,
	                y: 1.0,
	                duration: 0.2
	            });
	        }
	        else {
	            button.container.scale.x = 1.0;
	            button.container.scale.y = 1.0;
	        }
	    }
	    /**
	     * Switch to a new section with animation
	     */
	    switchToSection(newIndex) {
	        if (this.isAnimating)
	            return;
	        const oldIndex = this.activeSection;
	        // Check if transition should be cancelled
	        if (this.callbacks.onBeforeTransition) {
	            const shouldContinue = this.callbacks.onBeforeTransition(oldIndex, newIndex);
	            if (shouldContinue === false)
	                return;
	        }
	        this.isAnimating = true;
	        this.activeSection = newIndex;
	        // Create particles if enabled
	        if (this.style.enableParticles) {
	            const button = this.buttons[newIndex];
	            const globalX = button.container.x;
	            const globalY = button.container.y + this.navBarContainer.y;
	            const particleColor = button.section.iconColor || ARCHERO_COLORS.activeYellow;
	            this.createParticles(globalX, globalY, particleColor);
	        }
	        // Animate buttons
	        this.animateToActive(newIndex);
	        this.animateToInactive(oldIndex);
	        this.repositionAllButtons();
	        // Notify listeners after animation duration
	        const animationDuration = Math.max(this.style.transitionDuration, this.style.elevationDuration, this.style.repositionDuration);
	        setTimeout(() => {
	            this.isAnimating = false;
	            // Call section change callback
	            if (this.callbacks.onSectionChange) {
	                this.callbacks.onSectionChange(newIndex, this.config.sections[newIndex]);
	            }
	            // Call after transition callback
	            if (this.callbacks.onAfterTransition) {
	                this.callbacks.onAfterTransition(oldIndex, newIndex);
	            }
	            // Emit event
	            this.emit('section-changed', newIndex, this.config.sections[newIndex]);
	        }, animationDuration * 1000);
	    }
	    /**
	     * Animate button to active state (override for custom animation)
	     */
	    animateToActive(index) {
	        const button = this.buttons[index];
	        const activeButtonSize = this.getScaledValue(this.style.activeButtonSize);
	        // Recreate background as active
	        this.renderButtonBackground(button.bg, button.section, activeButtonSize, true);
	        // Add shine overlay
	        if (!button.overlay) {
	            button.overlay = this.createShineOverlay(button.section, activeButtonSize);
	            // First add as child, then set index
	            button.container.addChild(button.overlay);
	            const bgIndex = button.container.getChildIndex(button.bg);
	            button.container.setChildIndex(button.overlay, bgIndex + 1);
	        }
	        // Apply responsive scaling for animation values
	        const navHeight = this.getScaledValue(this.style.navHeight);
	        const elevationOffset = this.getScaledValue(this.style.elevationOffset);
	        const activeIconYOffset = this.getScaledValue(this.style.activeIconYOffset);
	        const activeIconSize = this.getScaledValue(button.section.customStyle?.activeIconSize ?? this.style.activeIconSize);
	        // Use GSAP if available
	        if (typeof window !== 'undefined' && window.gsap) {
	            const gsap = window.gsap;
	            // Move button up (elevated)
	            gsap.to(button.container, {
	                y: navHeight / 2 - elevationOffset,
	                duration: this.style.elevationDuration,
	                ease: 'elastic.out(1, 0.5)'
	            });
	            // Icon grows and moves up
	            gsap.to(button.icon, {
	                y: activeIconYOffset,
	                duration: this.style.iconAnimDuration,
	                ease: 'back.out(2)'
	            });
	            if (button.icon.style) {
	                gsap.to(button.icon.style, {
	                    fontSize: activeIconSize,
	                    duration: this.style.iconAnimDuration
	                });
	            }
	            // Add label
	            if (!button.label) {
	                button.label = this.createLabel(button.section);
	                button.label.alpha = 0;
	                button.container.addChild(button.label);
	                gsap.to(button.label, {
	                    alpha: 1,
	                    duration: this.style.labelFadeDuration,
	                    delay: this.style.labelFadeDelay
	                });
	            }
	        }
	        else {
	            // Fallback without GSAP
	            button.container.y = navHeight / 2 - elevationOffset;
	            button.icon.y = activeIconYOffset;
	            if (button.icon.style) {
	                button.icon.style.fontSize = activeIconSize;
	            }
	            if (!button.label) {
	                button.label = this.createLabel(button.section);
	                button.container.addChild(button.label);
	            }
	        }
	    }
	    /**
	     * Animate button to inactive state (override for custom animation)
	     */
	    animateToInactive(index) {
	        const button = this.buttons[index];
	        const buttonSize = this.getScaledValue(this.style.buttonSize);
	        // Recreate background as inactive
	        this.renderButtonBackground(button.bg, button.section, buttonSize, false);
	        // Remove shine overlay
	        if (button.overlay) {
	            button.container.removeChild(button.overlay);
	            button.overlay.destroy();
	            button.overlay = null;
	        }
	        // Apply responsive scaling for animation values
	        const navHeight = this.getScaledValue(this.style.navHeight);
	        const iconYOffset = this.getScaledValue(this.style.iconYOffset);
	        const iconSize = this.getScaledValue(button.section.customStyle?.iconSize ?? this.style.iconSize);
	        // Use GSAP if available
	        if (typeof window !== 'undefined' && window.gsap) {
	            const gsap = window.gsap;
	            // Move button down
	            gsap.to(button.container, {
	                y: navHeight / 2,
	                duration: this.style.iconAnimDuration,
	                ease: 'power2.out'
	            });
	            // Icon shrinks and moves to inactive position
	            gsap.to(button.icon, {
	                y: iconYOffset,
	                duration: this.style.iconAnimDuration
	            });
	            if (button.icon.style) {
	                gsap.to(button.icon.style, {
	                    fontSize: iconSize,
	                    duration: this.style.iconAnimDuration
	                });
	            }
	            // Remove label
	            if (button.label) {
	                gsap.to(button.label, {
	                    alpha: 0,
	                    duration: 0.2,
	                    onComplete: () => {
	                        if (button.label) {
	                            button.container.removeChild(button.label);
	                            button.label.destroy();
	                            button.label = null;
	                        }
	                    }
	                });
	            }
	        }
	        else {
	            // Fallback without GSAP
	            button.container.y = navHeight / 2;
	            button.icon.y = iconYOffset;
	            if (button.icon.style) {
	                button.icon.style.fontSize = iconSize;
	            }
	            if (button.label) {
	                button.container.removeChild(button.label);
	                button.label.destroy();
	                button.label = null;
	            }
	        }
	    }
	    /**
	     * Reposition all buttons based on new active index
	     */
	    repositionAllButtons() {
	        this.buttons.forEach((button, index) => {
	            const newX = this.calculateButtonX(index);
	            // Use GSAP if available
	            if (typeof window !== 'undefined' && window.gsap) {
	                window.gsap.to(button.container, {
	                    x: newX,
	                    duration: this.style.repositionDuration,
	                    ease: 'power2.out'
	                });
	            }
	            else {
	                button.container.x = newX;
	            }
	        });
	    }
	    /**
	     * Create particle effects at position
	     */
	    createParticles(x, y, color) {
	        // Apply responsive scaling to particle sizes and speeds
	        const [baseMinSize, baseMaxSize] = this.style.particleSizeRange;
	        const [baseMinSpeed, baseMaxSpeed] = this.style.particleSpeedRange;
	        const minSize = this.getScaledValue(baseMinSize);
	        const maxSize = this.getScaledValue(baseMaxSize);
	        const minSpeed = this.getScaledValue(baseMinSpeed);
	        const maxSpeed = this.getScaledValue(baseMaxSpeed);
	        for (let i = 0; i < this.style.particleCount; i++) {
	            const particle = graphics().createGraphics();
	            const size = Math.random() * (maxSize - minSize) + minSize;
	            // Fill circle
	            particle.circle(0, 0, size);
	            particle.fill({ color, alpha: 1 });
	            // Stroke circle outline
	            particle.circle(0, 0, size);
	            particle.stroke({ color: ARCHERO_COLORS.white, width: this.getScaledValue(2) });
	            particle.x = x;
	            particle.y = y;
	            const angle = Math.random() * Math.PI * 2;
	            const speed = Math.random() * (maxSpeed - minSpeed) + minSpeed;
	            this.particleContainer.addChild(particle);
	            this.particles.push({
	                graphics: particle,
	                vx: Math.cos(angle) * speed,
	                vy: Math.sin(angle) * speed,
	                life: 1.0,
	                startTime: Date.now()
	            });
	        }
	    }
	    /**
	     * Setup touch handlers for swipe gestures
	     */
	    setupTouchHandlers() {
	        this.rootContainer.eventMode = 'static';
	        this.rootContainer.on('pointerdown', (event) => {
	            this.touchStartX = event.global?.x || 0;
	            this.touchStartY = event.global?.y || 0;
	        });
	        this.rootContainer.on('pointerup', (event) => {
	            const touchEndX = event.global?.x || 0;
	            const deltaX = touchEndX - this.touchStartX;
	            // Swipe threshold
	            if (Math.abs(deltaX) > 100) {
	                const direction = deltaX < 0 ? 'left' : 'right';
	                // Call swipe callback
	                if (this.callbacks.onSwipe) {
	                    this.callbacks.onSwipe(direction);
	                }
	                if (deltaX < 0 && this.activeSection < this.config.sections.length - 1) {
	                    // Swipe left - next section
	                    this.switchToSection(this.activeSection + 1);
	                }
	                else if (deltaX > 0 && this.activeSection > 0) {
	                    // Swipe right - previous section
	                    this.switchToSection(this.activeSection - 1);
	                }
	            }
	        });
	    }
	    // ============================================================================
	    // PUBLIC API - Section Management
	    // ============================================================================
	    /**
	     * Add a new section to the menu
	     * @param section Section to add
	     * @param index Optional index to insert at (default: end)
	     */
	    addSection(section, index) {
	        const insertIndex = index !== undefined ? index : this.config.sections.length;
	        this.config.sections.splice(insertIndex, 0, section);
	        this.rebuildMenu();
	    }
	    /**
	     * Remove a section from the menu
	     * @param index Index of section to remove
	     */
	    removeSection(index) {
	        if (index < 0 || index >= this.config.sections.length) {
	            throw new Error(`Invalid section index: ${index}`);
	        }
	        // Don't allow removing the only section
	        if (this.config.sections.length === 1) {
	            throw new Error('Cannot remove the only section');
	        }
	        this.config.sections.splice(index, 1);
	        // Adjust active section if needed
	        if (this.activeSection >= index) {
	            this.activeSection = Math.max(0, this.activeSection - 1);
	        }
	        this.rebuildMenu();
	    }
	    /**
	     * Update an existing section
	     * @param index Index of section to update
	     * @param section Partial section data to merge
	     */
	    updateSection(index, section) {
	        if (index < 0 || index >= this.config.sections.length) {
	            throw new Error(`Invalid section index: ${index}`);
	        }
	        this.config.sections[index] = {
	            ...this.config.sections[index],
	            ...section
	        };
	        this.rebuildMenu();
	    }
	    /**
	     * Reorder sections
	     * @param order Array of indices representing new order
	     */
	    reorderSections(order) {
	        if (order.length !== this.config.sections.length) {
	            throw new Error('Order array must have same length as sections');
	        }
	        const newSections = order.map(i => this.config.sections[i]);
	        this.config.sections = newSections;
	        // Update active section index
	        this.activeSection = order.indexOf(this.activeSection);
	        this.rebuildMenu();
	    }
	    /**
	     * Set the number of sections (adds or removes as needed)
	     * @param count Target number of sections
	     * @param template Template section to use when adding new sections
	     */
	    setSectionCount(count, template) {
	        const currentCount = this.config.sections.length;
	        if (count < 1) {
	            throw new Error('Section count must be at least 1');
	        }
	        if (count > currentCount) {
	            // Add sections
	            const defaultTemplate = {
	                name: 'Section',
	                icon: 'â­',
	                iconColor: ARCHERO_COLORS.activeYellow,
	                ...template
	            };
	            for (let i = currentCount; i < count; i++) {
	                this.config.sections.push({
	                    ...defaultTemplate,
	                    name: `${defaultTemplate.name} ${i + 1}`
	                });
	            }
	        }
	        else if (count < currentCount) {
	            // Remove sections
	            this.config.sections.splice(count);
	            // Adjust active section if needed
	            if (this.activeSection >= count) {
	                this.activeSection = count - 1;
	            }
	        }
	        this.rebuildMenu();
	    }
	    /**
	     * Get all sections
	     */
	    getSections() {
	        return [...this.config.sections];
	    }
	    /**
	     * Get a specific section
	     */
	    getSection(index) {
	        if (index < 0 || index >= this.config.sections.length) {
	            throw new Error(`Invalid section index: ${index}`);
	        }
	        return this.config.sections[index];
	    }
	    // ============================================================================
	    // PUBLIC API - State Management
	    // ============================================================================
	    /**
	     * Update method - call this in game loop for particles
	     */
	    update(deltaTime) {
	        if (!this.style.enableParticles || this.particles.length === 0)
	            return;
	        const dt = deltaTime * 0.016; // Convert to seconds-like scale
	        // Update particles
	        for (let i = this.particles.length - 1; i >= 0; i--) {
	            const p = this.particles[i];
	            // Update position
	            p.graphics.x += p.vx * dt;
	            p.graphics.y += p.vy * dt;
	            p.vy += 0.3; // Gravity
	            // Update life
	            p.life -= dt * 0.02;
	            p.graphics.alpha = p.life;
	            p.graphics.scale.x = p.life;
	            p.graphics.scale.y = p.life;
	            // Remove dead particles
	            if (p.life <= 0) {
	                this.particleContainer.removeChild(p.graphics);
	                p.graphics.destroy();
	                this.particles.splice(i, 1);
	            }
	        }
	    }
	    /**
	     * Get the root container
	     */
	    getContainer() {
	        return this.rootContainer;
	    }
	    /**
	     * Get current active section index
	     */
	    getActiveSection() {
	        return this.activeSection;
	    }
	    /**
	     * Set active section programmatically
	     */
	    setActiveSection(index) {
	        if (index < 0 || index >= this.config.sections.length) {
	            throw new Error(`Invalid section index: ${index}`);
	        }
	        if (index !== this.activeSection) {
	            this.switchToSection(index);
	        }
	    }
	    /**
	     * Destroy menu and clean up resources
	     */
	    destroy() {
	        // Clean up particles
	        for (const particle of this.particles) {
	            particle.graphics.destroy();
	        }
	        this.particles = [];
	        // Clean up buttons
	        for (const button of this.buttons) {
	            button.bg.destroy();
	            if (button.overlay)
	                button.overlay.destroy();
	            button.icon.destroy();
	            if (button.label)
	                button.label.destroy();
	            button.container.destroy({ children: true });
	        }
	        this.buttons = [];
	        // Clean up containers
	        this.particleContainer.destroy({ children: true });
	        this.navBarContainer.destroy({ children: true });
	        this.rootContainer.destroy({ children: true });
	        // Remove all listeners
	        this.removeAllListeners();
	    }
	    // ============================================================================
	    // UTILITY METHODS
	    // ============================================================================
	    /**
	     * Convert hex color to RGB string
	     */
	    hexToRgb(hex) {
	        const r = (hex >> 16) & 255;
	        const g = (hex >> 8) & 255;
	        const b = hex & 255;
	        return `rgb(${r}, ${g}, ${b})`;
	    }
	    /**
	     * Utility: Draw rounded rectangle on canvas
	     */
	    roundRect(ctx, x, y, width, height, radius) {
	        ctx.beginPath();
	        ctx.moveTo(x + radius, y);
	        ctx.lineTo(x + width - radius, y);
	        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
	        ctx.lineTo(x + width, y + height - radius);
	        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
	        ctx.lineTo(x + radius, y + height);
	        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
	        ctx.lineTo(x, y + radius);
	        ctx.quadraticCurveTo(x, y, x + radius, y);
	        ctx.closePath();
	    }
	}

	/**
	 * Animation utilities for UI components
	 */
	/**
	 * Easing functions
	 */
	const Easing = {
	    linear(t) {
	        return t;
	    },
	    easeOutCubic(t) {
	        return 1 - Math.pow(1 - t, 3);
	    },
	    easeInCubic(t) {
	        return t * t * t;
	    },
	    easeOutBack(t) {
	        const c1 = 1.70158;
	        const c3 = c1 + 1;
	        return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
	    },
	};
	/**
	 * Run an animation with the given options
	 */
	function animate(options) {
	    const { duration, easing = Easing.linear, onUpdate, onComplete } = options;
	    return new Promise((resolve) => {
	        const startTime = Date.now();
	        function tick() {
	            const elapsed = Date.now() - startTime;
	            const progress = Math.min(elapsed / duration, 1);
	            const easedProgress = easing(progress);
	            onUpdate(progress, easedProgress);
	            if (progress < 1) {
	                requestAnimationFrame(tick);
	            }
	            else {
	                onComplete?.();
	                resolve();
	            }
	        }
	        requestAnimationFrame(tick);
	    });
	}
	/**
	 * Interpolate between two values
	 */
	function lerp(from, to, progress) {
	    return from + (to - from) * progress;
	}
	/**
	 * Common animation presets
	 */
	const AnimationPresets = {
	    fadeIn(target, duration = 300) {
	        return animate({
	            duration,
	            easing: Easing.easeOutCubic,
	            onUpdate: (_, eased) => {
	                target.alpha = eased;
	            },
	        });
	    },
	    fadeOut(target, duration = 200) {
	        return animate({
	            duration,
	            easing: Easing.easeOutCubic,
	            onUpdate: (_, eased) => {
	                target.alpha = 1 - eased;
	            },
	        });
	    },
	    slideX(target, from, to, duration = 300) {
	        target.x = from;
	        return animate({
	            duration,
	            easing: Easing.easeOutCubic,
	            onUpdate: (_, eased) => {
	                target.x = lerp(from, to, eased);
	            },
	        });
	    },
	    slideY(target, from, to, duration = 300) {
	        target.y = from;
	        return animate({
	            duration,
	            easing: Easing.easeOutCubic,
	            onUpdate: (_, eased) => {
	                target.y = lerp(from, to, eased);
	            },
	        });
	    },
	    scaleIn(target, duration = 250) {
	        target.scale.x = 0.8;
	        target.scale.y = 0.8;
	        target.alpha = 0;
	        return animate({
	            duration,
	            easing: Easing.easeOutBack,
	            onUpdate: (progress, eased) => {
	                const scale = lerp(0.8, 1, eased);
	                target.scale.x = scale;
	                target.scale.y = scale;
	                target.alpha = progress;
	            },
	        });
	    },
	    scaleOut(target, duration = 200) {
	        return animate({
	            duration,
	            easing: Easing.easeInCubic,
	            onUpdate: (progress, eased) => {
	                const scale = lerp(1, 0.8, eased);
	                target.scale.x = scale;
	                target.scale.y = scale;
	                target.alpha = 1 - progress;
	            },
	        });
	    },
	};

	/**
	 * SimpleScreen - A lightweight screen base class for game UI
	 *
	 * Unlike BaseUIScreen which uses the UIComponent system, SimpleScreen
	 * works directly with the graphics abstraction layer (IContainer, IGraphics).
	 *
	 * This is more suitable for game-style screens that need direct control
	 * over rendering and don't need the full UIComponent lifecycle.
	 */
	class SimpleScreen extends EventEmitter {
	    constructor(screenName) {
	        super();
	        this._isVisible = false;
	        this._width = 0;
	        this._height = 0;
	        this.screenName = screenName;
	        this.container = graphics().createContainer();
	        this.container.visible = false;
	    }
	    /**
	     * Initialize the screen with dimensions
	     */
	    initialize(width, height) {
	        this._width = width;
	        this._height = height;
	        this.setup();
	        this.emit('initialized');
	    }
	    /**
	     * Show the screen
	     */
	    async show(data) {
	        this._isVisible = true;
	        this.container.visible = true;
	        await this.animateIn();
	        this.emit('shown', data);
	    }
	    /**
	     * Hide the screen
	     */
	    async hide() {
	        await this.animateOut();
	        this._isVisible = false;
	        this.container.visible = false;
	        this.emit('hidden');
	    }
	    /**
	     * Animate in (can be overridden)
	     */
	    async animateIn() {
	        return AnimationPresets.fadeIn(this.container, 300);
	    }
	    /**
	     * Animate out (can be overridden)
	     */
	    async animateOut() {
	        return AnimationPresets.fadeOut(this.container, 200);
	    }
	    /**
	     * Handle back button (return true if handled)
	     */
	    onBackButton() {
	        return false;
	    }
	    /**
	     * Resize the screen
	     */
	    resize(width, height) {
	        this._width = width;
	        this._height = height;
	        this.onResize(width, height);
	    }
	    /**
	     * Handle resize (can be overridden)
	     */
	    onResize(_width, _height) {
	        // Override in subclasses
	    }
	    /**
	     * Get the screen container
	     */
	    getContainer() {
	        return this.container;
	    }
	    /**
	     * Check if visible
	     */
	    isVisible() {
	        return this._isVisible;
	    }
	    /**
	     * Get screen dimensions
	     */
	    getSize() {
	        return { width: this._width, height: this._height };
	    }
	    /**
	     * Set position
	     */
	    setPosition(x, y) {
	        this.container.x = x;
	        this.container.y = y;
	    }
	    /**
	     * Destroy the screen
	     */
	    destroy() {
	        this.container.destroy({ children: true });
	        this.removeAllListeners();
	    }
	}

	/**
	 * GameTopBar - Game-style top bar with resource displays
	 *
	 * Features:
	 * - Settings gear button (circular, dark background)
	 * - Lives display with heart icon and MAX label
	 * - Coins display with coin icon and add button
	 * - Gems display with gem icon
	 * - Pill-shaped containers with game styling
	 * - Animated value changes
	 *
	 * Inspired by: Brawl Stars, Candy Crush, mobile game top bars
	 *
	 * @example
	 * ```typescript
	 * const topBar = new GameTopBar({
	 *   width: 400,
	 *   resources: [
	 *     { type: 'lives', value: 5, max: 5, label: 'MAX' },
	 *     { type: 'coins', value: 1340, showAddButton: true }
	 *   ],
	 *   showSettings: true,
	 *   onSettingsClick: () => openSettings()
	 * });
	 *
	 * stage.addChild(topBar.getContainer());
	 * ```
	 */
	class GameTopBar extends EventEmitter {
	    constructor(config) {
	        super();
	        this.resourceContainers = new Map();
	        this.resourceTexts = new Map();
	        this.config = {
	            width: config.width,
	            height: config.height || 60,
	            padding: config.padding || 15,
	            resources: config.resources || [],
	            showSettings: config.showSettings ?? true,
	            onSettingsClick: config.onSettingsClick || (() => { }),
	        };
	        this.container = graphics().createContainer();
	        // Create UI elements
	        if (this.config.showSettings) {
	            this.createSettingsButton();
	        }
	        this.createResourceDisplays();
	    }
	    /**
	     * Create circular settings button
	     */
	    createSettingsButton() {
	        const buttonSize = this.config.height - 10;
	        this.settingsButton = graphics().createContainer();
	        this.settingsButton.x = this.config.padding;
	        this.settingsButton.y = this.config.height / 2;
	        // Background circle
	        const bg = graphics().createGraphics();
	        bg.circle(0, 0, buttonSize / 2);
	        bg.fill({ color: 0x2A2A3A, alpha: 0.95 });
	        bg.stroke({ color: 0x1A1A2A, width: 3 });
	        this.settingsButton.addChild(bg);
	        // Gear icon
	        const gear = graphics().createGraphics();
	        this.drawGearIcon(gear, buttonSize * 0.35);
	        this.settingsButton.addChild(gear);
	        // Interactivity
	        this.settingsButton.eventMode = 'static';
	        this.settingsButton.cursor = 'pointer';
	        this.settingsButton.on('pointerdown', () => {
	            this.settingsButton.scale.x = 0.9;
	            this.settingsButton.scale.y = 0.9;
	        });
	        this.settingsButton.on('pointerup', () => {
	            this.settingsButton.scale.x = 1;
	            this.settingsButton.scale.y = 1;
	            this.config.onSettingsClick();
	            this.emit('settings-click');
	        });
	        this.settingsButton.on('pointerupoutside', () => {
	            this.settingsButton.scale.x = 1;
	            this.settingsButton.scale.y = 1;
	        });
	        this.container.addChild(this.settingsButton);
	    }
	    /**
	     * Draw gear/cog icon
	     */
	    drawGearIcon(g, size) {
	        const teeth = 8;
	        const outerRadius = size;
	        const innerRadius = size * 0.7;
	        const centerRadius = size * 0.35;
	        // Draw gear teeth
	        const vertices = [];
	        for (let i = 0; i < teeth * 2; i++) {
	            const angle = (i * Math.PI) / teeth;
	            const r = i % 2 === 0 ? outerRadius : innerRadius;
	            vertices.push(Math.cos(angle) * r);
	            vertices.push(Math.sin(angle) * r);
	        }
	        g.poly(vertices);
	        g.fill({ color: 0xE0E0E0 });
	        // Center hole
	        g.circle(0, 0, centerRadius);
	        g.fill({ color: 0x2A2A3A });
	    }
	    /**
	     * Create resource displays (lives, coins, gems, etc.)
	     */
	    createResourceDisplays() {
	        const { resources, width, height, padding, showSettings } = this.config;
	        const spacing = 10;
	        // Calculate total width needed for resources
	        const resourceWidths = [];
	        resources.forEach((res) => {
	            const w = this.calculateResourceWidth(res);
	            resourceWidths.push(w);
	        });
	        // Position from center-right area
	        const totalResourceWidth = resourceWidths.reduce((a, b) => a + b, 0) + spacing * (resources.length - 1);
	        let currentX = width - padding - totalResourceWidth;
	        resources.forEach((res, index) => {
	            const container = this.createResourceDisplay(res, resourceWidths[index]);
	            container.x = currentX + resourceWidths[index] / 2;
	            container.y = height / 2;
	            this.resourceContainers.set(res.type, container);
	            this.container.addChild(container);
	            currentX += resourceWidths[index] + spacing;
	        });
	    }
	    /**
	     * Calculate width needed for a resource display
	     */
	    calculateResourceWidth(res) {
	        let width = 80; // Base width for icon + value
	        if (res.label)
	            width += 40;
	        if (res.showAddButton)
	            width += 35;
	        if (res.max !== undefined)
	            width += 10;
	        return width;
	    }
	    /**
	     * Create a single resource display
	     */
	    createResourceDisplay(res, width) {
	        const container = graphics().createContainer();
	        // Use custom pillWidth if provided
	        const actualWidth = res.pillWidth || width;
	        const height = this.config.height - 16;
	        const halfWidth = actualWidth / 2;
	        const halfHeight = height / 2;
	        // Background pill shape with configurable colors
	        const bg = graphics().createGraphics();
	        const bgColor = res.backgroundColor || this.getDefaultBgColor(res.type);
	        const borderColor = res.borderColor || this.darkenColor(bgColor, 0.3);
	        // Outer shadow for depth
	        bg.roundRect(-halfWidth - 1, -halfHeight + 2, actualWidth + 2, height, height / 2);
	        bg.fill({ color: 0x000000, alpha: 0.3 });
	        // Main pill
	        bg.roundRect(-halfWidth, -halfHeight, actualWidth, height, height / 2);
	        bg.fill({ color: bgColor, alpha: 0.95 });
	        bg.stroke({ color: borderColor, width: 2 });
	        // Inner highlight at top
	        bg.roundRect(-halfWidth + 4, -halfHeight + 3, actualWidth - 8, height * 0.4, (height * 0.4) / 2);
	        bg.fill({ color: 0xFFFFFF, alpha: 0.15 });
	        container.addChild(bg);
	        // Icon
	        const iconX = -halfWidth + 20;
	        const icon = this.createResourceIcon(res);
	        icon.x = iconX;
	        container.addChild(icon);
	        // Value text
	        const valueText = graphics().createText(this.formatValue(res.value), {
	            fontFamily: '"Lilita One", "Arial Black", sans-serif',
	            fontSize: 18,
	            fontWeight: 'bold',
	            fill: 0xFFFFFF,
	            stroke: 0x000000,
	            strokeThickness: 2
	        });
	        if (valueText.anchor)
	            valueText.anchor.set(0, 0.5);
	        valueText.x = iconX + 25;
	        container.addChild(valueText);
	        this.resourceTexts.set(res.type, valueText);
	        // Max label (e.g., "MAX")
	        if (res.label) {
	            const labelBgColor = res.labelBackgroundColor || this.darkenColor(bgColor, 0.2);
	            const labelBg = graphics().createGraphics();
	            labelBg.roundRect(valueText.x + valueText.width + 5, -10, 36, 20, 5);
	            labelBg.fill({ color: labelBgColor });
	            container.addChild(labelBg);
	            const labelText = graphics().createText(res.label, {
	                fontFamily: '"Lilita One", "Arial Black", sans-serif',
	                fontSize: 12,
	                fontWeight: 'bold',
	                fill: 0xFFFFFF
	            });
	            if (labelText.anchor)
	                labelText.anchor.set(0.5, 0.5);
	            labelText.x = valueText.x + valueText.width + 23;
	            container.addChild(labelText);
	        }
	        // Add button (+)
	        if (res.showAddButton) {
	            const addBtn = this.createAddButton(res);
	            addBtn.x = halfWidth - 18;
	            container.addChild(addBtn);
	        }
	        // Click handler
	        if (res.onClick) {
	            container.eventMode = 'static';
	            container.cursor = 'pointer';
	            container.on('pointerup', res.onClick);
	        }
	        return container;
	    }
	    /**
	     * Create resource icon based on type
	     */
	    createResourceIcon(res) {
	        const iconContainer = graphics().createContainer();
	        const g = graphics().createGraphics();
	        const size = 16;
	        switch (res.icon || res.type) {
	            case 'heart':
	            case 'lives':
	                this.drawHeartIcon(g, size, res.iconColor || 0xFF4081);
	                break;
	            case 'coin':
	            case 'coins':
	                this.drawCoinIcon(g, size, res.iconColor || 0xFFD700);
	                break;
	            case 'gem':
	            case 'gems':
	                this.drawGemIcon(g, size, res.iconColor || 0x9C27B0);
	                break;
	            case 'energy':
	                this.drawEnergyIcon(g, size, res.iconColor || 0x00BCD4);
	                break;
	            default:
	                this.drawCoinIcon(g, size, res.iconColor || 0xFFD700);
	        }
	        iconContainer.addChild(g);
	        return iconContainer;
	    }
	    /**
	     * Draw heart icon
	     */
	    drawHeartIcon(g, size, color) {
	        // Simple heart shape using polygon approximation
	        const s = size;
	        const vertices = [];
	        // Generate heart shape points
	        for (let i = 0; i <= 32; i++) {
	            const t = (i / 32) * 2 * Math.PI;
	            const x = s * 0.8 * Math.sin(t) ** 3;
	            const y = -s * 0.65 * (Math.cos(t) -
	                0.35 * Math.cos(2 * t) -
	                0.14 * Math.cos(3 * t) -
	                0.07 * Math.cos(4 * t));
	            vertices.push(x, y);
	        }
	        g.poly(vertices);
	        g.fill({ color: color });
	        g.stroke({ color: this.darkenColor(color, 0.3), width: 1.5 });
	    }
	    /**
	     * Draw coin icon
	     */
	    drawCoinIcon(g, size, color) {
	        // Outer circle
	        g.circle(0, 0, size);
	        g.fill({ color: color });
	        g.stroke({ color: this.darkenColor(color, 0.3), width: 2 });
	        // Inner highlight
	        g.circle(-size * 0.2, -size * 0.2, size * 0.3);
	        g.fill({ color: 0xFFFFFF, alpha: 0.4 });
	    }
	    /**
	     * Draw gem icon
	     */
	    drawGemIcon(g, size, color) {
	        // Diamond shape
	        const vertices = [
	            0, -size,
	            size * 0.7, 0,
	            0, size,
	            -size * 0.7, 0
	        ];
	        g.poly(vertices);
	        g.fill({ color: color });
	        g.stroke({ color: this.darkenColor(color, 0.3), width: 1.5 });
	        // Highlight
	        const highlightVertices = [
	            0, -size * 0.7,
	            size * 0.35, -size * 0.1,
	            0, size * 0.2,
	            -size * 0.35, -size * 0.1
	        ];
	        g.poly(highlightVertices);
	        g.fill({ color: 0xFFFFFF, alpha: 0.3 });
	    }
	    /**
	     * Draw energy/lightning icon
	     */
	    drawEnergyIcon(g, size, color) {
	        const vertices = [
	            size * 0.2, -size,
	            -size * 0.4, size * 0.1,
	            size * 0.1, size * 0.1,
	            -size * 0.2, size,
	            size * 0.4, -size * 0.1,
	            -size * 0.1, -size * 0.1
	        ];
	        g.poly(vertices);
	        g.fill({ color: color });
	        g.stroke({ color: this.darkenColor(color, 0.3), width: 1 });
	    }
	    /**
	     * Create add/plus button
	     */
	    createAddButton(res) {
	        const container = graphics().createContainer();
	        const size = 28;
	        const addBtnColor = res.addButtonColor || 0x4CAF50;
	        // Background
	        const bg = graphics().createGraphics();
	        bg.roundRect(-size / 2, -size / 2, size, size, 6);
	        bg.fill({ color: addBtnColor });
	        bg.stroke({ color: this.darkenColor(addBtnColor, 0.3), width: 2 });
	        container.addChild(bg);
	        // Plus sign
	        const plus = graphics().createText('+', {
	            fontFamily: getFrameworkFontFamily(),
	            fontSize: 20,
	            fontWeight: 'bold',
	            fill: 0xFFFFFF
	        });
	        if (plus.anchor)
	            plus.anchor.set(0.5, 0.5);
	        container.addChild(plus);
	        // Interactivity
	        container.eventMode = 'static';
	        container.cursor = 'pointer';
	        container.on('pointerdown', () => {
	            container.scale.x = 0.9;
	            container.scale.y = 0.9;
	        });
	        container.on('pointerup', () => {
	            container.scale.x = 1;
	            container.scale.y = 1;
	            if (res.onAddClick) {
	                res.onAddClick();
	            }
	            this.emit('add-click', res.type);
	        });
	        container.on('pointerupoutside', () => {
	            container.scale.x = 1;
	            container.scale.y = 1;
	        });
	        return container;
	    }
	    /**
	     * Get default background color for resource type
	     */
	    getDefaultBgColor(type) {
	        switch (type) {
	            case 'lives':
	                return 0x1A1A2A; // Dark/black
	            case 'coins':
	                return 0x4CAF50; // Green
	            case 'gems':
	                return 0x7B1FA2; // Purple
	            case 'energy':
	                return 0x0288D1; // Blue
	            default:
	                return 0x2C3E50;
	        }
	    }
	    /**
	     * Darken a color
	     */
	    darkenColor(color, amount) {
	        const r = Math.max(0, ((color >> 16) & 0xFF) - Math.floor(255 * amount));
	        const g = Math.max(0, ((color >> 8) & 0xFF) - Math.floor(255 * amount));
	        const b = Math.max(0, (color & 0xFF) - Math.floor(255 * amount));
	        return (r << 16) | (g << 8) | b;
	    }
	    /**
	     * Format value with abbreviation for large numbers
	     */
	    formatValue(value) {
	        if (value >= 1000000) {
	            return (value / 1000000).toFixed(1) + 'M';
	        }
	        if (value >= 1000) {
	            return (value / 1000).toFixed(1) + 'K';
	        }
	        return value.toString();
	    }
	    /**
	     * Public API
	     */
	    updateResource(type, value, animate = true) {
	        const text = this.resourceTexts.get(type);
	        if (text) {
	            const oldValue = parseInt(text.text.replace(/[KM]/g, '')) || 0;
	            text.text = this.formatValue(value);
	            if (animate && value !== oldValue) {
	                // Pop animation
	                const container = this.resourceContainers.get(type);
	                if (container) {
	                    container.scale.x = 1.15;
	                    container.scale.y = 1.15;
	                    setTimeout(() => {
	                        container.scale.x = 1;
	                        container.scale.y = 1;
	                    }, 150);
	                }
	            }
	        }
	        this.emit('resource-updated', type, value);
	        return this;
	    }
	    setPosition(x, y) {
	        this.container.x = x;
	        this.container.y = y;
	        return this;
	    }
	    getContainer() {
	        return this.container;
	    }
	    destroy() {
	        this.container.destroy({ children: true });
	        this.resourceContainers.clear();
	        this.resourceTexts.clear();
	        this.removeAllListeners();
	    }
	}

	/**
	 * Game-style UI theme inspired by mobile games like Brawl Stars, Candy Crush, etc.
	 * Features vibrant colors, multi-layer effects, and bold visual design.
	 */
	class GameStyleUITheme {
	    constructor() {
	        this.name = 'game-style';
	        // Vibrant game-style color palette
	        this.colors = {
	            // Primary action color (bright orange/yellow for Play buttons)
	            primary: { r: 255, g: 180, b: 0, a: 1 }, // Golden yellow
	            secondary: { r: 0, g: 180, b: 255, a: 1 }, // Bright cyan
	            // Background colors (sky blue gradient base)
	            background: { r: 0, g: 140, b: 220, a: 1 }, // Sky blue
	            surface: { r: 30, g: 100, b: 180, a: 1 }, // Darker blue surface
	            // Text colors
	            text: { r: 255, g: 255, b: 255, a: 1 }, // White with stroke
	            textSecondary: { r: 200, g: 220, b: 255, a: 1 }, // Light blue-white
	            // Status colors (game-style vibrant)
	            success: { r: 50, g: 205, b: 50, a: 1 }, // Lime green
	            warning: { r: 255, g: 165, b: 0, a: 1 }, // Orange
	            error: { r: 255, g: 60, b: 60, a: 1 }, // Bright red
	            // Utility
	            overlay: { r: 0, g: 0, b: 0, a: 0.6 }
	        };
	        // Game-style specific colors
	        this.gameColors = {
	            // Button colors
	            buttonYellow: { top: 0xFFD700, bottom: 0xFFA500, border: 0xCC8800 },
	            buttonGreen: { top: 0x50C878, bottom: 0x228B22, border: 0x1A6B1A },
	            buttonBlue: { top: 0x4DA6FF, bottom: 0x0066CC, border: 0x004C99 },
	            buttonRed: { top: 0xFF6B6B, bottom: 0xCC3333, border: 0x992626 },
	            buttonPurple: { top: 0xB388FF, bottom: 0x7C4DFF, border: 0x5C3DB8 },
	            // UI element colors
	            panelDark: 0x1A237E,
	            panelLight: 0x3949AB,
	            borderDark: 0x0D1B2A,
	            borderMedium: 0x1B3A5C,
	            // Resource colors
	            coinGold: 0xFFD700,
	            gemPurple: 0x9C27B0,
	            heartRed: 0xFF4081,
	            energyBlue: 0x00BCD4,
	            // Level path
	            pathActive: 0xFFD54F,
	            pathInactive: 0x5C6BC0,
	            pathCompleted: 0x4CAF50,
	            // Hexagon level button
	            hexBlue: { fill: 0x3D85C6, border: 0x1A3A5C, highlight: 0x6DB3F2 },
	            hexLocked: { fill: 0x5C5C5C, border: 0x3A3A3A, highlight: 0x7A7A7A }
	        };
	        // Bold typography for games
	        this.typography = {
	            fontFamily: '"Lilita One", "Arial Black", sans-serif',
	            sizes: {
	                small: 16,
	                medium: 22,
	                large: 32,
	                xlarge: 48
	            },
	            weights: {
	                normal: 600,
	                bold: 800
	            }
	        };
	        // Generous spacing for touch targets
	        this.spacing = {
	            xs: 6,
	            sm: 12,
	            md: 20,
	            lg: 32,
	            xl: 48
	        };
	        // Rounded corners for game feel
	        this.radius = {
	            sm: 8,
	            md: 16,
	            lg: 24,
	            full: 9999
	        };
	        // Bold shadows for depth
	        this.shadows = {
	            sm: '0 3px 0 rgba(0, 0, 0, 0.3), 0 4px 8px rgba(0, 0, 0, 0.2)',
	            md: '0 5px 0 rgba(0, 0, 0, 0.3), 0 8px 16px rgba(0, 0, 0, 0.25)',
	            lg: '0 8px 0 rgba(0, 0, 0, 0.3), 0 12px 24px rgba(0, 0, 0, 0.3)'
	        };
	        // Bouncy animations
	        this.animations = {
	            fast: 150,
	            normal: 300,
	            slow: 500
	        };
	    }
	}
	/**
	 * Game style color utilities
	 */
	const GameStyleColors = {
	    // Pre-defined button color schemes - No Ads popup style (solid color, black border, jellybean)
	    YELLOW_BUTTON: {
	        gradientTop: 0xFFD966, // Golden yellow (solid)
	        gradientBottom: 0xFFD966, // Same - solid color
	        border: 0x000000, // Black outer border
	        shadow: 0xCC9900, // Darker yellow shadow
	        highlight: 0xFFFFFF, // White highlight (25% alpha applied in code)
	        text: 0xFFFFFF,
	        textStroke: 0x805500,
	        jellybean: 0xFFFBE6 // Light cream jellybean
	    },
	    GREEN_BUTTON: {
	        gradientTop: 0x2DE45A, // Main green (No Ads popup style)
	        gradientBottom: 0x2DE45A, // Same - solid color
	        border: 0x000000, // Black outer border
	        shadow: 0x28A165, // Green shadow/depth
	        highlight: 0xFFFFFF, // White highlight (25% alpha applied in code)
	        text: 0xFFFFFF,
	        textStroke: 0x1A4D1A,
	        jellybean: 0xE6FCE9 // Jellybean gloss color
	    },
	    BLUE_BUTTON: {
	        gradientTop: 0x4DA6FF, // Bright blue (solid)
	        gradientBottom: 0x4DA6FF, // Same - solid color
	        border: 0x000000, // Black outer border
	        shadow: 0x2E7BC9, // Darker blue shadow
	        highlight: 0xFFFFFF, // White highlight (25% alpha applied in code)
	        text: 0xFFFFFF,
	        textStroke: 0x1A4B7A,
	        jellybean: 0xE6F3FF // Light blue jellybean
	    },
	    RED_BUTTON: {
	        gradientTop: 0xE85C5C, // Coral red (solid)
	        gradientBottom: 0xE85C5C, // Same - solid color
	        border: 0x000000, // Black outer border
	        shadow: 0xB34040, // Darker red shadow
	        highlight: 0xFFFFFF, // White highlight (25% alpha applied in code)
	        text: 0xFFFFFF,
	        textStroke: 0x5C0D0D,
	        jellybean: 0xFFE6E6 // Light pink jellybean
	    },
	    PURPLE_BUTTON: {
	        gradientTop: 0xAD6DD6, // Lavender (solid)
	        gradientBottom: 0xAD6DD6, // Same - solid color
	        border: 0x000000, // Black outer border
	        shadow: 0x8050B0, // Darker purple shadow
	        highlight: 0xFFFFFF, // White highlight (25% alpha applied in code)
	        text: 0xFFFFFF,
	        textStroke: 0x3D1A54,
	        jellybean: 0xF3E6FF // Light lavender jellybean
	    },
	    // Cream/Beige Play Button (Candy Crush style - keeps gradient for variety)
	    CREAM_BUTTON: {
	        gradientTop: 0xFFFBF0,
	        gradientBottom: 0xF5E6C8,
	        border: 0x000000, // Black outer border
	        shadow: 0xD4A857,
	        highlight: 0xFFFFFF,
	        text: 0x8B6914,
	        textStroke: 0xD4A857,
	        jellybean: 0xFFFFFF // White jellybean
	    },
	    // Hexagon level colors
	    HEXAGON_BLUE: {
	        fill: 0x3D85C6,
	        border: 0x1A3A5C,
	        highlight: 0x6DB3F2,
	        text: 0xFFFFFF,
	        textStroke: 0x1A3A5C
	    },
	    HEXAGON_LOCKED: {
	        fill: 0x5C6370,
	        border: 0x3A3F47,
	        highlight: 0x7A8089,
	        text: 0xCCCCCC,
	        textStroke: 0x2A2E35
	    },
	    HEXAGON_COMPLETED: {
	        fill: 0x43A047,
	        border: 0x1B5E20,
	        highlight: 0x76D275,
	        text: 0xFFFFFF,
	        textStroke: 0x1B5E20
	    },
	    HEXAGON_CURRENT: {
	        fill: 0x5C6BC0,
	        border: 0x283593,
	        highlight: 0x8E99F3,
	        text: 0xFFFFFF,
	        textStroke: 0x283593
	    },
	    // Candy Crush style hexagon with golden border
	    HEXAGON_CANDY_BLUE: {
	        fill: 0x4A7BB7,
	        border: 0xFFB300,
	        highlight: 0x6B9BD1,
	        text: 0xFFFFFF,
	        textStroke: 0x2D4A6E,
	        outerBorder: 0xCC8800
	    },
	    HEXAGON_CANDY_CURRENT: {
	        fill: 0x5A9BD4,
	        border: 0xFFB300,
	        highlight: 0x7BB8E8,
	        text: 0xFFFFFF,
	        textStroke: 0x2D5A7E,
	        outerBorder: 0xCC8800,
	        glow: 0x00FFFF
	    },
	    HEXAGON_CANDY_LOCKED: {
	        fill: 0x4A5568,
	        border: 0x718096,
	        highlight: 0x5A6578,
	        text: 0xA0AEC0,
	        textStroke: 0x2D3748,
	        outerBorder: 0x4A5568
	    },
	    // Panel color schemes (matches No Ads popup style)
	    PANEL_BLUE: {
	        fillTop: 0x41A7FB, // Light blue (same as No Ads modal bg)
	        fillBottom: 0x41A7FB, // Solid color, no gradient
	        borderOuter: 0x1e3a5f, // Dark navy border
	        borderInner: 0x1e3a5f, // Same - single border layer
	        borderWidth: 4, // Thinner border like No Ads
	        titleColor: 0xFFFFFF,
	        titleStroke: 0x1a2a3a, // Darker stroke for title
	        headerBg: 0x2889F0, // Darker blue header
	        closeButtonBg: 0xE84C4C,
	        closeButtonBorder: 0xA83340,
	        closeButtonX: 0xFFFFFF
	    },
	    PANEL_PURPLE: {
	        fillTop: 0xA478DC,
	        fillBottom: 0x7B4DB8,
	        borderOuter: 0x4A2878,
	        borderInner: 0x5A3888,
	        borderWidth: 8,
	        titleColor: 0xFFFFFF,
	        titleStroke: 0x4A2878,
	        closeButtonBg: 0xE84C4C,
	        closeButtonBorder: 0x8B2020,
	        closeButtonX: 0xFFFFFF
	    },
	    PANEL_GREEN: {
	        fillTop: 0x6FCF6F,
	        fillBottom: 0x4CAF50,
	        borderOuter: 0x2E7D32,
	        borderInner: 0x388E3C,
	        borderWidth: 8,
	        titleColor: 0xFFFFFF,
	        titleStroke: 0x2E7D32,
	        closeButtonBg: 0xE84C4C,
	        closeButtonBorder: 0x8B2020,
	        closeButtonX: 0xFFFFFF
	    },
	    PANEL_ORANGE: {
	        fillTop: 0xFFB74D,
	        fillBottom: 0xFF9800,
	        borderOuter: 0xE65100,
	        borderInner: 0xF57C00,
	        borderWidth: 8,
	        titleColor: 0xFFFFFF,
	        titleStroke: 0xE65100,
	        closeButtonBg: 0xE84C4C,
	        closeButtonBorder: 0x8B2020,
	        closeButtonX: 0xFFFFFF
	    },
	    PANEL_DARK: {
	        fillTop: 0x3D4A5C,
	        fillBottom: 0x2C3E50,
	        borderOuter: 0x1A252F,
	        borderInner: 0x2A3F4F,
	        borderWidth: 8,
	        titleColor: 0xFFFFFF,
	        titleStroke: 0x1A252F,
	        closeButtonBg: 0xE84C4C,
	        closeButtonBorder: 0x8B2020,
	        closeButtonX: 0xFFFFFF
	    },
	    PANEL_RED: {
	        fillTop: 0xE57373,
	        fillBottom: 0xD32F2F,
	        borderOuter: 0x8B1A1A,
	        borderInner: 0xB71C1C,
	        borderWidth: 8,
	        titleColor: 0xFFFFFF,
	        titleStroke: 0x8B1A1A,
	        closeButtonBg: 0x333333,
	        closeButtonBorder: 0x1A1A1A,
	        closeButtonX: 0xFFFFFF
	    },
	    // Top Bar Resource Pill Colors
	    TOP_BAR_LIVES: {
	        background: 0x1A1A2A,
	        border: 0x0D0D15,
	        iconColor: 0xFF4081,
	        textColor: 0xFFFFFF,
	        labelBackground: 0x2A2A3A,
	        labelColor: 0xFFFFFF
	    },
	    TOP_BAR_COINS: {
	        background: 0x4CAF50,
	        border: 0x2E7D32,
	        iconColor: 0xFFD700,
	        textColor: 0xFFFFFF,
	        addButtonBg: 0x66BB6A,
	        addButtonBorder: 0x43A047
	    },
	    // Bottom Navigation Colors
	    BOTTOM_NAV: {
	        background: 0x1A237E,
	        topBorder: 0x3949AB,
	        itemBackground: 0x283593,
	        itemHighlight: 0x3949AB,
	        itemActive: 0x5C6BC0,
	        textColor: 0xFFFFFF,
	        lockedColor: 0x757575
	    }
	};
	/**
	 * Create a canvas gradient for game buttons
	 */
	function createGameButtonGradient(ctx, x, y, width, height, colorTop, colorBottom) {
	    const gradient = ctx.createLinearGradient(x, y, x, y + height);
	    gradient.addColorStop(0, numberToHex(colorTop));
	    gradient.addColorStop(0.5, numberToHex(colorTop));
	    gradient.addColorStop(0.5, numberToHex(colorBottom));
	    gradient.addColorStop(1, numberToHex(colorBottom));
	    return gradient;
	}
	/**
	 * Create a vertical gradient for backgrounds
	 */
	function createSkyGradient(ctx, width, height) {
	    const gradient = ctx.createLinearGradient(0, 0, 0, height);
	    gradient.addColorStop(0, '#0066CC');
	    gradient.addColorStop(0.3, '#0088EE');
	    gradient.addColorStop(0.6, '#00AAFF');
	    gradient.addColorStop(1, '#66CCFF');
	    return gradient;
	}
	/**
	 * Convert hex number to CSS color string
	 */
	function numberToHex(num) {
	    return `#${num.toString(16).padStart(6, '0')}`;
	}
	/**
	 * Lighten a color by a percentage
	 */
	function lightenColor(color, percent) {
	    const r = Math.min(255, ((color >> 16) & 0xFF) + Math.floor(255 * percent));
	    const g = Math.min(255, ((color >> 8) & 0xFF) + Math.floor(255 * percent));
	    const b = Math.min(255, (color & 0xFF) + Math.floor(255 * percent));
	    return (r << 16) | (g << 8) | b;
	}
	/**
	 * Darken a color by a percentage
	 */
	function darkenColor$1(color, percent) {
	    const r = Math.max(0, ((color >> 16) & 0xFF) - Math.floor(255 * percent));
	    const g = Math.max(0, ((color >> 8) & 0xFF) - Math.floor(255 * percent));
	    const b = Math.max(0, (color & 0xFF) - Math.floor(255 * percent));
	    return (r << 16) | (g << 8) | b;
	}

	/**
	 * GameBottomNav - Game-style bottom navigation bar
	 *
	 * Features:
	 * - Three main sections: left icon, center main button, right icon
	 * - Center button is larger and highlighted
	 * - Game-style icons and badges
	 * - Lock states for unavailable items
	 * - Smooth press animations
	 *
	 * Inspired by: Brawl Stars, mobile game navigation
	 *
	 * @example
	 * ```typescript
	 * const bottomNav = new GameBottomNav({
	 *   width: 400,
	 *   items: [
	 *     { id: 'shop', type: 'shop', label: 'Shop' },
	 *     { id: 'play', type: 'play', label: 'Start', highlighted: true },
	 *     { id: 'profile', type: 'profile', locked: true }
	 *   ]
	 * });
	 *
	 * bottomNav.on('item-click', (id) => handleNavClick(id));
	 * stage.addChild(bottomNav.getContainer());
	 * ```
	 */
	class GameBottomNav extends EventEmitter {
	    constructor(config) {
	        super();
	        this.itemContainers = new Map();
	        this.config = {
	            width: config.width,
	            height: config.height || 90,
	            items: config.items,
	            backgroundColor: config.backgroundColor || 0x1A237E,
	            activeIndex: config.activeIndex || 0
	        };
	        this.container = graphics().createContainer();
	        this.backgroundGraphics = graphics().createGraphics();
	        this.container.addChild(this.backgroundGraphics);
	        this.createBackground();
	        this.createNavItems();
	    }
	    /**
	     * Create background with gradient
	     */
	    createBackground() {
	        const { width, height, backgroundColor } = this.config;
	        this.backgroundGraphics.clear();
	        // Main background
	        this.backgroundGraphics.rect(0, 0, width, height);
	        this.backgroundGraphics.fill({ color: backgroundColor });
	        // Top border/highlight
	        this.backgroundGraphics.rect(0, 0, width, 3);
	        this.backgroundGraphics.fill({ color: lightenColor(backgroundColor, 0.2) });
	        // Top shadow line
	        this.backgroundGraphics.rect(0, 3, width, 2);
	        this.backgroundGraphics.fill({ color: darkenColor$1(backgroundColor, 0.3), alpha: 0.5 });
	    }
	    /**
	     * Create navigation items
	     */
	    createNavItems() {
	        const { items, width, height } = this.config;
	        // Calculate positions based on number of items
	        const itemCount = items.length;
	        const sectionWidth = width / itemCount;
	        items.forEach((item, index) => {
	            const x = sectionWidth * index + sectionWidth / 2;
	            const y = height / 2;
	            const itemContainer = this.createNavItem(item, index);
	            itemContainer.x = x;
	            itemContainer.y = y;
	            this.itemContainers.set(item.id, itemContainer);
	            this.container.addChild(itemContainer);
	        });
	    }
	    /**
	     * Create a single nav item
	     */
	    createNavItem(item, index) {
	        const container = graphics().createContainer();
	        const isCenter = item.highlighted || item.type === 'play';
	        const size = isCenter ? 70 : 50;
	        // Background
	        const bg = graphics().createGraphics();
	        if (isCenter) {
	            // Center button has special styling - larger and raised
	            bg.roundRect(-size / 2, -size / 2 - 10, size, size, 16);
	            bg.fill({ color: 0x3949AB });
	            bg.stroke({ color: 0x1A237E, width: 3 });
	            // Add highlight at top
	            bg.roundRect(-size / 2 + 4, -size / 2 - 6, size - 8, size * 0.3, 12);
	            bg.fill({ color: 0x5C6BC0, alpha: 0.5 });
	        }
	        else {
	            // Side buttons
	            bg.roundRect(-size / 2, -size / 2, size, size, 12);
	            bg.fill({ color: 0x283593, alpha: 0.8 });
	        }
	        container.addChild(bg);
	        // Icon
	        const icon = this.createNavIcon(item, size * 0.5);
	        icon.y = isCenter ? -10 : 0;
	        container.addChild(icon);
	        // Lock overlay if locked
	        if (item.locked) {
	            const lockOverlay = this.createLockOverlay(size);
	            lockOverlay.y = isCenter ? -10 : 0;
	            container.addChild(lockOverlay);
	        }
	        // Badge if present
	        if (item.badge && item.badge > 0) {
	            const badge = this.createBadge(item.badge);
	            badge.x = size / 2 - 5;
	            badge.y = -size / 2 + (isCenter ? 0 : 5);
	            container.addChild(badge);
	        }
	        // Label
	        if (item.label) {
	            const label = graphics().createText(item.label, {
	                fontFamily: '"Lilita One", "Arial Black", sans-serif',
	                fontSize: 12,
	                fontWeight: 'bold',
	                fill: 0xFFFFFF,
	                stroke: 0x1A237E,
	                strokeThickness: 2
	            });
	            if (label.anchor)
	                label.anchor.set(0.5, 0);
	            label.y = isCenter ? size / 2 - 5 : size / 2 + 5;
	            container.addChild(label);
	        }
	        // Interactivity
	        if (!item.locked) {
	            container.eventMode = 'static';
	            container.cursor = 'pointer';
	            container.on('pointerdown', () => {
	                container.scale.x = 0.9;
	                container.scale.y = 0.9;
	            });
	            container.on('pointerup', () => {
	                container.scale.x = 1;
	                container.scale.y = 1;
	                if (item.onClick) {
	                    item.onClick();
	                }
	                this.emit('item-click', item.id, item);
	            });
	            container.on('pointerupoutside', () => {
	                container.scale.x = 1;
	                container.scale.y = 1;
	            });
	        }
	        return container;
	    }
	    /**
	     * Create icon based on type
	     */
	    createNavIcon(item, size) {
	        const iconContainer = graphics().createContainer();
	        const g = graphics().createGraphics();
	        switch (item.type) {
	            case 'shop':
	                this.drawShopIcon(g, size);
	                break;
	            case 'play':
	                this.drawPlayIcon(g, size);
	                break;
	            case 'profile':
	                this.drawProfileIcon(g, size);
	                break;
	            case 'leaderboard':
	                this.drawLeaderboardIcon(g, size);
	                break;
	            case 'settings':
	                this.drawSettingsIcon(g, size);
	                break;
	            default:
	                this.drawCustomIcon(g, size);
	        }
	        iconContainer.addChild(g);
	        return iconContainer;
	    }
	    /**
	     * Draw shop/store icon (gift box style)
	     */
	    drawShopIcon(g, size) {
	        const s = size * 0.7;
	        // Box body
	        g.roundRect(-s / 2, -s * 0.1, s, s * 0.55, 4);
	        g.fill({ color: 0xE91E63 });
	        g.stroke({ color: 0xAD1457, width: 2 });
	        // Box lid
	        g.roundRect(-s / 2 - 2, -s * 0.25, s + 4, s * 0.2, 3);
	        g.fill({ color: 0xF48FB1 });
	        g.stroke({ color: 0xAD1457, width: 1.5 });
	        // Ribbon vertical
	        g.rect(-s * 0.08, -s * 0.25, s * 0.16, s * 0.7);
	        g.fill({ color: 0xFFD54F });
	        // Ribbon horizontal
	        g.rect(-s / 2, -s * 0.15, s, s * 0.12);
	        g.fill({ color: 0xFFD54F });
	        // Bow
	        g.ellipse(-s * 0.15, -s * 0.35, s * 0.12, s * 0.08);
	        g.fill({ color: 0xFFD54F });
	        g.ellipse(s * 0.15, -s * 0.35, s * 0.12, s * 0.08);
	        g.fill({ color: 0xFFD54F });
	        g.circle(0, -s * 0.35, s * 0.06);
	        g.fill({ color: 0xFFC107 });
	    }
	    /**
	     * Draw play/character icon (cute mascot style like Brawl Stars)
	     */
	    drawPlayIcon(g, size) {
	        const s = size * 0.85;
	        // Character body (round blob)
	        g.ellipse(0, s * 0.05, s * 0.42, s * 0.38);
	        g.fill({ color: 0x4FC3F7 });
	        g.stroke({ color: 0x0288D1, width: 2.5 });
	        // Body highlight
	        g.ellipse(-s * 0.1, -s * 0.05, s * 0.2, s * 0.15);
	        g.fill({ color: 0x81D4FA, alpha: 0.6 });
	        // Eyes - white backgrounds
	        g.ellipse(-s * 0.14, -s * 0.02, s * 0.12, s * 0.13);
	        g.fill({ color: 0xFFFFFF });
	        g.ellipse(s * 0.14, -s * 0.02, s * 0.12, s * 0.13);
	        g.fill({ color: 0xFFFFFF });
	        // Pupils - looking slightly up and to the side
	        g.circle(-s * 0.12, -s * 0.04, s * 0.055);
	        g.fill({ color: 0x1A1A2A });
	        g.circle(s * 0.16, -s * 0.04, s * 0.055);
	        g.fill({ color: 0x1A1A2A });
	        // Pupil highlights
	        g.circle(-s * 0.14, -s * 0.06, s * 0.02);
	        g.fill({ color: 0xFFFFFF });
	        g.circle(s * 0.14, -s * 0.06, s * 0.02);
	        g.fill({ color: 0xFFFFFF });
	        // Ears/horns (rounder)
	        g.ellipse(-s * 0.32, -s * 0.22, s * 0.1, s * 0.12);
	        g.fill({ color: 0x4FC3F7 });
	        g.stroke({ color: 0x0288D1, width: 1.5 });
	        g.ellipse(s * 0.32, -s * 0.22, s * 0.1, s * 0.12);
	        g.fill({ color: 0x4FC3F7 });
	        g.stroke({ color: 0x0288D1, width: 1.5 });
	    }
	    /**
	     * Draw profile/user icon
	     */
	    drawProfileIcon(g, size) {
	        const s = size * 0.6;
	        // Lock body (since this shows as locked usually)
	        g.roundRect(-s / 2, 0, s, s * 0.7, 6);
	        g.fill({ color: 0x9E9E9E });
	        g.stroke({ color: 0x616161, width: 2 });
	        // Lock shackle (U-shape using poly)
	        const shackleR = s * 0.3;
	        const shacklePoints = [];
	        for (let i = 0; i <= 12; i++) {
	            const angle = Math.PI + (Math.PI * i) / 12;
	            shacklePoints.push(Math.cos(angle) * shackleR, Math.sin(angle) * shackleR);
	        }
	        g.poly(shacklePoints);
	        g.stroke({ color: 0x757575, width: 5 });
	        // Keyhole
	        g.circle(0, s * 0.25, s * 0.1);
	        g.fill({ color: 0x424242 });
	    }
	    /**
	     * Draw leaderboard icon
	     */
	    drawLeaderboardIcon(g, size) {
	        const s = size * 0.7;
	        const barWidth = s / 4;
	        // Three bars representing podium
	        g.rect(-s / 2, s * 0.1, barWidth, s * 0.4);
	        g.fill({ color: 0xFFD54F });
	        g.rect(-barWidth / 2, -s * 0.2, barWidth, s * 0.7);
	        g.fill({ color: 0xFFD54F });
	        g.rect(s / 2 - barWidth, s * 0.2, barWidth, s * 0.3);
	        g.fill({ color: 0xFFD54F });
	    }
	    /**
	     * Draw settings gear icon
	     */
	    drawSettingsIcon(g, size) {
	        const s = size * 0.5;
	        const teeth = 8;
	        const outerRadius = s;
	        const innerRadius = s * 0.7;
	        const vertices = [];
	        for (let i = 0; i < teeth * 2; i++) {
	            const angle = (i * Math.PI) / teeth;
	            const r = i % 2 === 0 ? outerRadius : innerRadius;
	            vertices.push(Math.cos(angle) * r);
	            vertices.push(Math.sin(angle) * r);
	        }
	        g.poly(vertices);
	        g.fill({ color: 0xE0E0E0 });
	        g.stroke({ color: 0x9E9E9E, width: 1 });
	        g.circle(0, 0, s * 0.35);
	        g.fill({ color: 0x283593 });
	    }
	    /**
	     * Draw custom placeholder icon
	     */
	    drawCustomIcon(g, size) {
	        g.circle(0, 0, size * 0.4);
	        g.fill({ color: 0x9E9E9E });
	    }
	    /**
	     * Create lock overlay
	     */
	    createLockOverlay(size) {
	        const container = graphics().createContainer();
	        const g = graphics().createGraphics();
	        // Semi-transparent overlay
	        g.circle(0, 0, size * 0.3);
	        g.fill({ color: 0x000000, alpha: 0.5 });
	        // Lock icon
	        const lockSize = size * 0.25;
	        g.roundRect(-lockSize / 2, lockSize * 0.1, lockSize, lockSize * 0.6, 3);
	        g.fill({ color: 0xFFFFFF });
	        // Lock shackle (U-shape using poly)
	        const shackleR = lockSize * 0.3;
	        const shackleY = lockSize * 0.1;
	        const shacklePoints = [];
	        for (let i = 0; i <= 12; i++) {
	            const angle = Math.PI + (Math.PI * i) / 12;
	            shacklePoints.push(Math.cos(angle) * shackleR, shackleY + Math.sin(angle) * shackleR);
	        }
	        g.poly(shacklePoints);
	        g.stroke({ color: 0xFFFFFF, width: 3 });
	        container.addChild(g);
	        return container;
	    }
	    /**
	     * Create badge (notification count)
	     */
	    createBadge(count) {
	        const container = graphics().createContainer();
	        const g = graphics().createGraphics();
	        const badgeSize = 20;
	        g.circle(0, 0, badgeSize / 2);
	        g.fill({ color: 0xFF5252 });
	        g.stroke({ color: 0xB71C1C, width: 2 });
	        container.addChild(g);
	        const text = graphics().createText(count > 99 ? '99+' : count.toString(), {
	            fontFamily: getFrameworkFontFamily(),
	            fontSize: 10,
	            fontWeight: 'bold',
	            fill: 0xFFFFFF
	        });
	        if (text.anchor)
	            text.anchor.set(0.5, 0.5);
	        container.addChild(text);
	        return container;
	    }
	    /**
	     * Public API
	     */
	    setItemBadge(id, count) {
	        // Re-create the item with the new badge
	        const item = this.config.items.find(i => i.id === id);
	        if (item) {
	            item.badge = count;
	            // Would need to rebuild the item - for now just emit event
	            this.emit('badge-updated', id, count);
	        }
	        return this;
	    }
	    setItemLocked(id, locked) {
	        const item = this.config.items.find(i => i.id === id);
	        if (item) {
	            item.locked = locked;
	            this.emit('lock-updated', id, locked);
	        }
	        return this;
	    }
	    getContainer() {
	        return this.container;
	    }
	    setPosition(x, y) {
	        this.container.x = x;
	        this.container.y = y;
	        return this;
	    }
	    destroy() {
	        this.itemContainers.forEach(c => c.destroy({ children: true }));
	        this.itemContainers.clear();
	        this.container.destroy({ children: true });
	        this.removeAllListeners();
	    }
	}

	/**
	 * HubScreen - Main hub/menu screen with top bar, content area, and bottom nav
	 *
	 * Features:
	 * - GameTopBar with resources and settings
	 * - Tab-based content area
	 * - GameBottomNav with tab switching
	 * - Smooth content transitions
	 *
	 * @example
	 * ```typescript
	 * const hub = new HubScreen({
	 *   topBarResources: [
	 *     { type: 'coins', value: 1234, showAddButton: true }
	 *   ],
	 *   bottomNavItems: [
	 *     { id: 'shop', type: 'shop', label: 'Shop' },
	 *     { id: 'play', type: 'play', label: 'Play', highlighted: true },
	 *     { id: 'profile', type: 'profile', label: 'Profile' }
	 *   ],
	 *   defaultTab: 'play'
	 * });
	 *
	 * screenManager.push(hub);
	 * ```
	 */
	class HubScreen extends SimpleScreen {
	    constructor(config = {}) {
	        super('HubScreen');
	        this.currentTabId = '';
	        // Layout constants
	        this.TOP_BAR_HEIGHT = 60;
	        this.BOTTOM_NAV_HEIGHT = 90;
	        this.hubConfig = {
	            topBarResources: config.topBarResources || [],
	            showSettings: config.showSettings ?? true,
	            onSettingsClick: config.onSettingsClick,
	            bottomNavItems: config.bottomNavItems || this.getDefaultNavItems(),
	            defaultTab: config.defaultTab || 'play',
	            backgroundColor: config.backgroundColor || 0x1a1a2e,
	        };
	        this.tabContents = config.tabContents || new Map();
	        const factory = graphics();
	        // Create background
	        this.background = factory.createGraphics();
	        this.container.addChild(this.background);
	        // Create content area container
	        this.contentArea = factory.createContainer();
	        this.container.addChild(this.contentArea);
	    }
	    /**
	     * Default nav items
	     */
	    getDefaultNavItems() {
	        return [
	            { id: 'shop', type: 'shop', label: 'Shop' },
	            { id: 'play', type: 'play', label: 'Play', highlighted: true },
	            { id: 'profile', type: 'profile', label: 'Profile' },
	        ];
	    }
	    /**
	     * Setup the screen
	     */
	    setup() {
	        const width = this._width;
	        const height = this._height;
	        // Draw background
	        this.drawBackground(width, height);
	        // Create top bar
	        this.createTopBar(width);
	        // Create bottom nav
	        this.createBottomNav(width, height);
	        // Position content area
	        this.contentArea.y = this.TOP_BAR_HEIGHT;
	        // Show default tab
	        if (this.hubConfig.defaultTab) {
	            this.switchTab(this.hubConfig.defaultTab);
	        }
	    }
	    /**
	     * Draw background
	     */
	    drawBackground(width, height) {
	        this.background.clear();
	        this.background.rect(0, 0, width, height);
	        this.background.fill({ color: this.hubConfig.backgroundColor || 0x1a1a2e });
	    }
	    /**
	     * Create top bar
	     */
	    createTopBar(width) {
	        this.topBar = new GameTopBar({
	            width,
	            height: this.TOP_BAR_HEIGHT,
	            resources: this.hubConfig.topBarResources,
	            showSettings: this.hubConfig.showSettings,
	            onSettingsClick: this.hubConfig.onSettingsClick,
	        });
	        this.topBar.setPosition(0, 0);
	        this.container.addChild(this.topBar.getContainer());
	    }
	    /**
	     * Create bottom nav
	     */
	    createBottomNav(width, height) {
	        this.bottomNav = new GameBottomNav({
	            width,
	            height: this.BOTTOM_NAV_HEIGHT,
	            items: this.hubConfig.bottomNavItems || [],
	        });
	        this.bottomNav.setPosition(0, height - this.BOTTOM_NAV_HEIGHT);
	        // Listen for tab changes
	        this.bottomNav.on('item-click', (id) => {
	            this.switchTab(id);
	        });
	        this.container.addChild(this.bottomNav.getContainer());
	    }
	    /**
	     * Switch to a tab
	     */
	    switchTab(tabId) {
	        if (this.currentTabId === tabId)
	            return;
	        // Remove current content
	        if (this.currentContent) {
	            this.contentArea.removeChild(this.currentContent);
	            this.currentContent.destroy({ children: true });
	            this.currentContent = undefined;
	        }
	        // Create new content
	        const contentFactory = this.tabContents.get(tabId);
	        if (contentFactory) {
	            this.currentContent = contentFactory();
	            this.contentArea.addChild(this.currentContent);
	        }
	        this.currentTabId = tabId;
	        this.emit('tab-changed', tabId);
	    }
	    /**
	     * Register tab content
	     */
	    registerTabContent(tabId, factory) {
	        this.tabContents.set(tabId, factory);
	    }
	    /**
	     * Get current tab ID
	     */
	    getCurrentTab() {
	        return this.currentTabId;
	    }
	    /**
	     * Update a resource value
	     */
	    updateResource(type, value) {
	        this.topBar?.updateResource(type, value);
	    }
	    /**
	     * Get the content area container
	     */
	    getContentArea() {
	        return this.contentArea;
	    }
	    /**
	     * Get content area dimensions
	     */
	    getContentAreaSize() {
	        return {
	            width: this._width,
	            height: this._height - this.TOP_BAR_HEIGHT - this.BOTTOM_NAV_HEIGHT,
	        };
	    }
	    /**
	     * Handle resize
	     */
	    onResize(width, height) {
	        // Redraw background
	        this.drawBackground(width, height);
	        // Reposition bottom nav
	        if (this.bottomNav) {
	            this.bottomNav.setPosition(0, height - this.BOTTOM_NAV_HEIGHT);
	        }
	    }
	    /**
	     * Handle back button
	     */
	    onBackButton() {
	        // Hub screen doesn't handle back by itself
	        return false;
	    }
	    /**
	     * Cleanup
	     */
	    destroy() {
	        this.topBar?.destroy();
	        this.bottomNav?.destroy();
	        this.currentContent?.destroy({ children: true });
	        this.tabContents.clear();
	        super.destroy();
	    }
	}

	/**
	 * GameStyleButton - Mobile game style button with multi-layer effects
	 *
	 * Features:
	 * - Multi-layer border (dark outer, light inner)
	 * - Vertical gradient (light top, dark bottom)
	 * - Top shine/highlight effect
	 * - 3D bevel/raised effect
	 * - Drop shadow that moves on press
	 * - Scale animation on press
	 * - Bold text with stroke outline
	 *
	 * Inspired by: Brawl Stars, Candy Crush, Clash Royale style buttons
	 *
	 * @example
	 * ```typescript
	 * const playButton = new GameStyleButton({
	 *   text: 'Play',
	 *   width: 200,
	 *   height: 70,
	 *   colorScheme: GameStyleColors.YELLOW_BUTTON
	 * });
	 *
	 * playButton.on('click', () => startGame());
	 * stage.addChild(playButton.getContainer());
	 * ```
	 */
	class GameStyleButton extends EventEmitter {
	    constructor(config = {}) {
	        super();
	        this.isPressed = false;
	        this.isHovered = false;
	        // Trigger font loading (non-blocking)
	        loadFrameworkFont();
	        // Default configuration - Mobile game style defaults (No Ads popup style)
	        this.config = {
	            text: config.text || 'Button',
	            width: config.width || 200,
	            height: config.height || 70,
	            fontSize: config.fontSize || 28,
	            fontFamily: config.fontFamily || getFrameworkFontFamily(),
	            colorScheme: config.colorScheme || GameStyleColors.GREEN_BUTTON,
	            buttonStyle: config.buttonStyle || 'raised', // 'raised' or 'flat'
	            borderRadius: config.borderRadius || 14,
	            borderWidth: config.borderWidth || 1,
	            shadowOffset: config.shadowOffset || 3,
	            disabled: config.disabled || false,
	            icon: config.icon || ''
	        };
	        // Note: No minimum size constraint - developer controls button size
	        // Create containers and graphics
	        this.container = graphics().createContainer();
	        this.borderGraphics = graphics().createGraphics();
	        this.shadowGraphics = graphics().createGraphics();
	        this.topShineGraphics = graphics().createGraphics();
	        this.mainFillGraphics = graphics().createGraphics();
	        this.highlightGraphics = graphics().createGraphics();
	        this.jellybeanGraphics = graphics().createGraphics();
	        // Build button layers (order matters for z-index) - exactly like no-ads-popup-demo
	        this.container.addChild(this.borderGraphics); // 1. Black outer border
	        this.container.addChild(this.shadowGraphics); // 2. Shadow
	        this.container.addChild(this.topShineGraphics); // 3. Top shine
	        this.container.addChild(this.mainFillGraphics); // 4. Main fill
	        this.container.addChild(this.highlightGraphics); // 5. Highlight
	        this.container.addChild(this.jellybeanGraphics); // 6. Jellybean
	        // Create text
	        if (this.config.text) {
	            this.createText();
	        }
	        // Initial render
	        this.render();
	        // Setup interactivity
	        this.setupInteractivity();
	    }
	    /**
	     * Create styled text with stroke
	     */
	    createText() {
	        const { colorScheme, fontSize, fontFamily, width, height } = this.config;
	        // Determine if we need dark text (for light backgrounds like cream)
	        const isLightBackground = this.isLightColor(colorScheme.gradientTop);
	        const textColor = colorScheme.text;
	        const strokeColor = colorScheme.textStroke;
	        const strokeThickness = isLightBackground
	            ? Math.max(2, fontSize / 12)
	            : Math.max(3, fontSize / 8);
	        this.textField = graphics().createText(this.config.text, {
	            fontFamily: fontFamily,
	            fontSize: fontSize,
	            fontWeight: '700', // Bold - Fredoka's max weight
	            fill: textColor,
	            stroke: strokeColor,
	            strokeThickness: strokeThickness,
	            align: 'center',
	            dropShadow: !isLightBackground,
	            dropShadowAlpha: 0.5,
	            dropShadowAngle: Math.PI / 2,
	            dropShadowBlur: 2,
	            dropShadowColor: 0x000000,
	            dropShadowDistance: 2
	        });
	        if (this.textField.anchor)
	            this.textField.anchor.set(0.5, 0.5);
	        this.textField.x = width / 2;
	        this.textField.y = height / 2;
	        this.container.addChild(this.textField);
	    }
	    /**
	     * Setup touch/mouse events
	     */
	    setupInteractivity() {
	        this.container.eventMode = 'static';
	        this.container.cursor = this.config.disabled ? 'default' : 'pointer';
	        this.container.on('pointerdown', this.onPointerDown.bind(this));
	        this.container.on('pointerup', this.onPointerUp.bind(this));
	        this.container.on('pointerupoutside', this.onPointerUpOutside.bind(this));
	        this.container.on('pointerover', this.onPointerOver.bind(this));
	        this.container.on('pointerout', this.onPointerOut.bind(this));
	    }
	    /**
	     * Render all button graphics - Mobile game style with 3D effect
	     * Supports two styles:
	     * - 'raised': Drop shadow style (Candy Crush)
	     * - 'flat': Bottom edge style (modern mobile games)
	     */
	    render() {
	        const { width, height, borderRadius, borderWidth, shadowOffset, colorScheme, buttonStyle, disabled } = this.config;
	        // Clear all graphics
	        this.borderGraphics.clear();
	        this.shadowGraphics.clear();
	        this.topShineGraphics.clear();
	        this.mainFillGraphics.clear();
	        this.highlightGraphics.clear();
	        this.jellybeanGraphics.clear();
	        // Reset jellybean transform
	        this.jellybeanGraphics.x = 0;
	        this.jellybeanGraphics.y = 0;
	        this.jellybeanGraphics.rotation = 0;
	        // Get colors (grayed out if disabled)
	        const colors = disabled ? this.getDisabledColors() : colorScheme;
	        // Render raised style (No Ads popup style)
	        this.renderRaisedStyle(width, height, borderRadius, borderWidth, shadowOffset, colors);
	    }
	    /**
	     * Render 'raised' style - EXACT copy from no-ads-popup-demo.html
	     * Layer order: border â†’ shadow â†’ topShine â†’ mainFill â†’ highlight â†’ jellybean
	     */
	    renderRaisedStyle(width, height, borderRadius, borderWidth, shadowOffset, colors) {
	        // Demo variables (origin is 0,0 for button-local coordinates)
	        const ctaX = 0;
	        const ctaY = this.isPressed ? shadowOffset - 1 : 0;
	        const ctaWidth = width;
	        const ctaHeight = height;
	        const ctaRadius = borderRadius;
	        const currentShadowOffset = this.isPressed ? 1 : shadowOffset;
	        // 1. Black border (tÃ¼m butonu Ã§erÃ§eveleyen - shadow dahil, 1px)
	        // Demo: ctaOuterBorder.roundRect(ctaX - 1, ctaY - 1, ctaWidth + 2, ctaHeight + shadowOffset + 2, ctaRadius + 1);
	        // Demo: ctaOuterBorder.stroke({ color: 0x000000, width: 1 });
	        this.borderGraphics.roundRect(ctaX - 1, -1, // Always starts at -1 (border is fixed position)
	        ctaWidth + 2, ctaHeight + currentShadowOffset + 2, ctaRadius + 1);
	        this.borderGraphics.stroke({ color: colors.border, width: borderWidth });
	        // 2. Shadow (alt kÄ±sÄ±m - yeÅŸil)
	        // Demo: ctaShadow.roundRect(ctaX, ctaY + shadowOffset, ctaWidth, ctaHeight, ctaRadius);
	        // Demo: ctaShadow.fill(0x28A165);
	        this.shadowGraphics.roundRect(ctaX, currentShadowOffset, // Shadow is always at shadowOffset from top
	        ctaWidth, ctaHeight, ctaRadius);
	        this.shadowGraphics.fill({ color: colors.shadow });
	        // 2.5. Top shine (Ã¼st parlaklÄ±k - border iÃ§inde kalacak, %60 opak)
	        // Demo: ctaTopShine.roundRect(ctaX + 0.5, ctaY - 0.5, ctaWidth - 1, ctaHeight, ctaRadius);
	        // Demo: ctaTopShine.fill({ color: 0xFFFFFF, alpha: 0.60 });
	        this.topShineGraphics.roundRect(ctaX + 0.5, ctaY - 0.5, ctaWidth - 1, ctaHeight, ctaRadius);
	        this.topShineGraphics.fill({ color: 0xFFFFFF, alpha: 0.60 });
	        // 3. Button main (ana yÃ¼zey - yeÅŸil)
	        // Demo: ctaBtn.roundRect(ctaX, ctaY, ctaWidth, ctaHeight, ctaRadius);
	        // Demo: ctaBtn.fill(0x2DE45A);
	        this.mainFillGraphics.roundRect(ctaX, ctaY, ctaWidth, ctaHeight, ctaRadius);
	        this.mainFillGraphics.fill({ color: colors.gradientTop });
	        // 4. Highlight (parlama efekti - Ã¼st kÃ¶ÅŸeler yuvarlak, alt keskin)
	        // Demo: exactly as written
	        if (!this.isPressed) {
	            const hlX = ctaX + 3;
	            const hlY = ctaY + 3;
	            const hlW = ctaWidth - 6;
	            const hlH = ctaHeight * 0.45;
	            const hlR = ctaRadius - 2;
	            this.highlightGraphics.moveTo(hlX + hlR, hlY);
	            this.highlightGraphics.lineTo(hlX + hlW - hlR, hlY);
	            this.highlightGraphics.arc(hlX + hlW - hlR, hlY + hlR, hlR, -Math.PI / 2, 0);
	            this.highlightGraphics.lineTo(hlX + hlW, hlY + hlH);
	            this.highlightGraphics.lineTo(hlX, hlY + hlH);
	            this.highlightGraphics.lineTo(hlX, hlY + hlR);
	            this.highlightGraphics.arc(hlX + hlR, hlY + hlR, hlR, Math.PI, -Math.PI / 2);
	            this.highlightGraphics.closePath();
	            this.highlightGraphics.fill({ color: 0xFFFFFF, alpha: 0.25 });
	        }
	        // 5. Jellybean efekti (sol Ã¼st kÃ¶ÅŸe, orantÄ±lÄ± boyut)
	        // Base size for 58px height button: 3.5x2.6, position: 10,9
	        if (!this.isPressed && colors.jellybean) {
	            const scale = ctaHeight / 58; // Scale relative to standard button height
	            const jbWidth = 3.5 * scale;
	            const jbHeight = 2.6 * scale;
	            const jbX = 10 * scale;
	            const jbY = 9 * scale;
	            this.jellybeanGraphics.ellipse(0, 0, jbWidth, jbHeight);
	            this.jellybeanGraphics.fill({ color: colors.jellybean });
	            this.jellybeanGraphics.x = ctaX + jbX;
	            this.jellybeanGraphics.y = ctaY + jbY;
	            this.jellybeanGraphics.rotation = -25 * Math.PI / 180;
	        }
	        // Update text position for press animation
	        if (this.textField) {
	            this.textField.y = this.config.height / 2 + ctaY;
	        }
	    }
	    /**
	     * Get grayed out colors for disabled state
	     */
	    getDisabledColors() {
	        return {
	            gradientTop: 0x9E9E9E,
	            gradientBottom: 0x757575,
	            border: 0x616161,
	            shadow: 0x424242,
	            highlight: 0xBDBDBD,
	            text: 0xE0E0E0,
	            textStroke: 0x616161
	        };
	    }
	    /**
	     * Check if a color is light (for determining text contrast)
	     */
	    isLightColor(color) {
	        const r = (color >> 16) & 0xFF;
	        const g = (color >> 8) & 0xFF;
	        const b = color & 0xFF;
	        // Using relative luminance formula
	        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
	        return luminance > 0.6;
	    }
	    /**
	     * Get scale offset for press animation (centers the scale transform)
	     */
	    getScaleOffset() {
	        const scale = GameStyleButton.PRESS_SCALE;
	        return {
	            offsetX: this.config.width * (1 - scale) / 2,
	            offsetY: this.config.height * (1 - scale) / 2
	        };
	    }
	    /**
	     * Pointer event handlers
	     */
	    onPointerDown(event) {
	        if (this.config.disabled)
	            return;
	        this.isPressed = true;
	        this.render();
	        // Scale from center - apply scale and offset to compensate
	        const { offsetX, offsetY } = this.getScaleOffset();
	        this.container.scale.x = GameStyleButton.PRESS_SCALE;
	        this.container.scale.y = GameStyleButton.PRESS_SCALE;
	        this.container.x += offsetX;
	        this.container.y += offsetY;
	        this.emit('press', event);
	    }
	    onPointerUp(event) {
	        if (this.config.disabled)
	            return;
	        // Restore position before scale reset
	        const { offsetX, offsetY } = this.getScaleOffset();
	        this.container.x -= offsetX;
	        this.container.y -= offsetY;
	        this.container.scale.x = 1;
	        this.container.scale.y = 1;
	        this.isPressed = false;
	        this.render();
	        this.emit('click', event);
	        this.emit('release', event);
	    }
	    onPointerUpOutside() {
	        if (this.config.disabled)
	            return;
	        // Restore position before scale reset
	        const { offsetX, offsetY } = this.getScaleOffset();
	        this.container.x -= offsetX;
	        this.container.y -= offsetY;
	        this.container.scale.x = 1;
	        this.container.scale.y = 1;
	        this.isPressed = false;
	        this.render();
	        this.emit('cancel');
	    }
	    onPointerOver() {
	        if (this.config.disabled)
	            return;
	        this.isHovered = true;
	        this.emit('hover');
	    }
	    onPointerOut() {
	        if (this.config.disabled)
	            return;
	        this.isHovered = false;
	        this.emit('hoverEnd');
	    }
	    /**
	     * Public API
	     */
	    setText(text) {
	        this.config.text = text;
	        if (this.textField) {
	            this.textField.text = text;
	        }
	        return this;
	    }
	    setDisabled(disabled) {
	        this.config.disabled = disabled;
	        this.container.cursor = disabled ? 'default' : 'pointer';
	        this.render();
	        return this;
	    }
	    setColorScheme(colorScheme) {
	        this.config.colorScheme = colorScheme;
	        this.render();
	        if (this.textField) {
	            this.textField.style.fill = colorScheme.text;
	            this.textField.style.stroke = colorScheme.textStroke;
	            this.textField.style.strokeThickness = this.config.fontSize / 8;
	        }
	        return this;
	    }
	    setPosition(x, y) {
	        this.container.x = x;
	        this.container.y = y;
	        return this;
	    }
	    getContainer() {
	        return this.container;
	    }
	    getWidth() {
	        return this.config.width;
	    }
	    getHeight() {
	        return this.config.height;
	    }
	    destroy() {
	        this.container.destroy({ children: true });
	        this.removeAllListeners();
	    }
	}
	/** Press animation scale factor */
	GameStyleButton.PRESS_SCALE = 0.96;
	/**
	 * Pre-built button factory functions
	 */
	const GameButtons = {
	    /**
	     * Create a yellow "Play" style button
	     */
	    play(text = 'Play', width = 220, height = 70) {
	        return new GameStyleButton({
	            text,
	            width,
	            height,
	            colorScheme: GameStyleColors.YELLOW_BUTTON
	        });
	    },
	    /**
	     * Create a green action button
	     */
	    success(text, width = 160, height = 56) {
	        return new GameStyleButton({
	            text,
	            width,
	            height,
	            colorScheme: GameStyleColors.GREEN_BUTTON
	        });
	    },
	    /**
	     * Create a blue secondary button
	     */
	    secondary(text, width = 160, height = 56) {
	        return new GameStyleButton({
	            text,
	            width,
	            height,
	            colorScheme: GameStyleColors.BLUE_BUTTON
	        });
	    },
	    /**
	     * Create a red warning/cancel button
	     */
	    danger(text, width = 160, height = 56) {
	        return new GameStyleButton({
	            text,
	            width,
	            height,
	            colorScheme: GameStyleColors.RED_BUTTON
	        });
	    },
	    /**
	     * Create a purple special button
	     */
	    special(text, width = 160, height = 56) {
	        return new GameStyleButton({
	            text,
	            width,
	            height,
	            colorScheme: GameStyleColors.PURPLE_BUTTON
	        });
	    },
	    /**
	     * Create a cream/beige "Play" style button (Candy Crush style)
	     */
	    cream(text = 'Play', width = 220, height = 60) {
	        return new GameStyleButton({
	            text,
	            width,
	            height,
	            colorScheme: GameStyleColors.CREAM_BUTTON,
	            borderRadius: 18,
	            shadowOffset: 5
	        });
	    },
	    /**
	     * Create a small square icon button (e.g., close, settings)
	     * Same style as No Ads popup buttons but square
	     * @param icon - Icon character (emoji or text like 'âœ•', 'âš™', 'â¸')
	     * @param colorScheme - Color scheme (default: RED for close buttons)
	     * @param size - Button size (default: 36)
	     */
	    mini(icon, colorScheme = GameStyleColors.RED_BUTTON, size = 36) {
	        return new GameStyleButton({
	            text: icon,
	            width: size,
	            height: size,
	            fontSize: Math.floor(size * 0.55), // Larger font for icons
	            colorScheme,
	            borderRadius: Math.floor(size * 0.22),
	            borderWidth: 1,
	            shadowOffset: 2
	        });
	    },
	    /**
	     * Create a close (X) icon button - red square
	     */
	    close(size = 36) {
	        return GameButtons.mini('X', GameStyleColors.RED_BUTTON, size);
	    },
	    /**
	     * Create a settings (gear) icon button
	     */
	    settings(size = 36) {
	        return GameButtons.mini('âš™', GameStyleColors.BLUE_BUTTON, size);
	    },
	    /**
	     * Create a pause icon button
	     */
	    pause(size = 36) {
	        return GameButtons.mini('â¸', GameStyleColors.YELLOW_BUTTON, size);
	    },
	    /**
	     * Create a play icon button (triangle)
	     */
	    playIcon(size = 36) {
	        return GameButtons.mini('â–¶', GameStyleColors.GREEN_BUTTON, size);
	    },
	    /**
	     * Create an info icon button
	     */
	    info(size = 36) {
	        return GameButtons.mini('â„¹', GameStyleColors.BLUE_BUTTON, size);
	    },
	    /**
	     * Create a home icon button
	     */
	    home(size = 36) {
	        return GameButtons.mini('ðŸ ', GameStyleColors.YELLOW_BUTTON, size);
	    }
	};

	/**
	 * Formatting utilities for UI components
	 */
	/**
	 * Format large numbers with K/M suffix
	 */
	function formatNumber(num) {
	    if (num >= 1000000) {
	        return (num / 1000000).toFixed(1) + 'M';
	    }
	    if (num >= 1000) {
	        return (num / 1000).toFixed(1) + 'K';
	    }
	    return num.toString();
	}
	/**
	 * Format time in seconds to MM:SS
	 */
	function formatTime(seconds) {
	    const mins = Math.floor(seconds / 60);
	    const secs = Math.floor(seconds % 60);
	    return `${mins}:${secs.toString().padStart(2, '0')}`;
	}
	/**
	 * Darken a color by a given amount (0-1)
	 */
	function darkenColor(color, amount) {
	    const r = Math.max(0, ((color >> 16) & 0xff) - Math.floor(255 * amount));
	    const g = Math.max(0, ((color >> 8) & 0xff) - Math.floor(255 * amount));
	    const b = Math.max(0, (color & 0xff) - Math.floor(255 * amount));
	    return (r << 16) | (g << 8) | b;
	}

	/**
	 * GameHUDScreen - Game screen with HUD overlay
	 *
	 * Features:
	 * - Score display
	 * - Timer display
	 * - Pause button
	 * - Lives/hearts display
	 * - Progress bar
	 * - Game content area
	 * - Pause overlay
	 *
	 * @example
	 * ```typescript
	 * const gameScreen = new GameHUDScreen({
	 *   hudConfig: {
	 *     showScore: true,
	 *     showPauseButton: true,
	 *     showLives: true,
	 *     livesMax: 3
	 *   },
	 *   onPause: () => showPauseMenu()
	 * });
	 *
	 * // Add game content
	 * gameScreen.getGameContainer().addChild(myGame);
	 *
	 * screenManager.push(gameScreen);
	 * ```
	 */
	class GameHUDScreen extends SimpleScreen {
	    constructor(config = {}) {
	        super('GameHUDScreen');
	        this._score = 0;
	        this._time = 0;
	        this._lives = 0;
	        this._progress = 0;
	        this._isPaused = false;
	        // Layout constants
	        this.HUD_HEIGHT = 60;
	        this.HUD_PADDING = 15;
	        this.config = config;
	        this.hudConfig = {
	            showScore: config.hudConfig?.showScore ?? true,
	            showTimer: config.hudConfig?.showTimer ?? false,
	            showPauseButton: config.hudConfig?.showPauseButton ?? true,
	            showLives: config.hudConfig?.showLives ?? false,
	            livesMax: config.hudConfig?.livesMax ?? 3,
	            showProgress: config.hudConfig?.showProgress ?? false,
	            progressMax: config.hudConfig?.progressMax ?? 100,
	        };
	        const factory = graphics();
	        // Create background
	        this.background = factory.createGraphics();
	        this.container.addChild(this.background);
	        // Create game container (where actual game goes)
	        this.gameContainer = factory.createContainer();
	        this.container.addChild(this.gameContainer);
	        // Create HUD container (on top)
	        this.hudContainer = factory.createContainer();
	        this.container.addChild(this.hudContainer);
	    }
	    /**
	     * Setup the screen
	     */
	    setup() {
	        const width = this._width;
	        const height = this._height;
	        // Draw background
	        this.drawBackground(width, height);
	        // Position game container
	        this.gameContainer.y = this.HUD_HEIGHT;
	        // Create HUD elements
	        this.createHUD(width);
	    }
	    /**
	     * Draw background
	     */
	    drawBackground(width, height) {
	        this.background.clear();
	        this.background.rect(0, 0, width, height);
	        this.background.fill({ color: this.config.backgroundColor || 0x1a1a2e });
	    }
	    /**
	     * Create HUD elements
	     */
	    createHUD(width) {
	        const factory = graphics();
	        // HUD background
	        const hudBg = factory.createGraphics();
	        hudBg.rect(0, 0, width, this.HUD_HEIGHT);
	        hudBg.fill({ color: 0x000000, alpha: 0.3 });
	        this.hudContainer.addChild(hudBg);
	        let leftX = this.HUD_PADDING;
	        // Score
	        if (this.hudConfig.showScore) {
	            this.scoreText = factory.createText('Score: 0', {
	                fontFamily: '"Lilita One", "Arial Black", sans-serif',
	                fontSize: 22,
	                fontWeight: 'bold',
	                fill: 0xFFFFFF,
	                stroke: 0x000000,
	                strokeThickness: 2,
	            });
	            if (this.scoreText.anchor)
	                this.scoreText.anchor.set(0, 0.5);
	            this.scoreText.x = leftX;
	            this.scoreText.y = this.HUD_HEIGHT / 2;
	            this.hudContainer.addChild(this.scoreText);
	            leftX += 150;
	        }
	        // Timer
	        if (this.hudConfig.showTimer) {
	            this.timerText = factory.createText('0:00', {
	                fontFamily: '"Lilita One", "Arial Black", sans-serif',
	                fontSize: 22,
	                fontWeight: 'bold',
	                fill: 0xFFFFFF,
	                stroke: 0x000000,
	                strokeThickness: 2,
	            });
	            if (this.timerText.anchor)
	                this.timerText.anchor.set(0.5, 0.5);
	            this.timerText.x = width / 2;
	            this.timerText.y = this.HUD_HEIGHT / 2;
	            this.hudContainer.addChild(this.timerText);
	        }
	        // Lives (hearts)
	        if (this.hudConfig.showLives) {
	            this.livesContainer = factory.createContainer();
	            this.livesContainer.x = leftX;
	            this.livesContainer.y = this.HUD_HEIGHT / 2;
	            this.hudContainer.addChild(this.livesContainer);
	            this._lives = this.hudConfig.livesMax;
	            this.renderLives();
	        }
	        // Pause button (right side)
	        if (this.hudConfig.showPauseButton) {
	            this.pauseButton = new GameStyleButton({
	                text: '||',
	                width: 44,
	                height: 44,
	                fontSize: 18,
	                buttonStyle: 'flat',
	                colorScheme: GameStyleColors.BLUE_BUTTON,
	            });
	            this.pauseButton.setPosition(width - 44 - this.HUD_PADDING, (this.HUD_HEIGHT - 44) / 2);
	            this.pauseButton.on('click', () => this.togglePause());
	            this.hudContainer.addChild(this.pauseButton.getContainer());
	        }
	        // Progress bar
	        if (this.hudConfig.showProgress) {
	            this.progressBar = factory.createGraphics();
	            this.progressBar.y = this.HUD_HEIGHT - 6;
	            this.hudContainer.addChild(this.progressBar);
	            this.renderProgress(width);
	        }
	    }
	    /**
	     * Render lives hearts
	     */
	    renderLives() {
	        if (!this.livesContainer)
	            return;
	        this.livesContainer.removeChildren();
	        const factory = graphics();
	        const heartSize = 20;
	        const spacing = 5;
	        for (let i = 0; i < this.hudConfig.livesMax; i++) {
	            const heart = factory.createGraphics();
	            const isFilled = i < this._lives;
	            this.drawHeart(heart, heartSize, isFilled ? 0xFF4081 : 0x444444);
	            heart.x = i * (heartSize + spacing);
	            this.livesContainer.addChild(heart);
	        }
	    }
	    /**
	     * Draw a heart shape
	     */
	    drawHeart(g, size, color) {
	        const vertices = [];
	        for (let i = 0; i <= 32; i++) {
	            const t = (i / 32) * 2 * Math.PI;
	            const x = (size / 2) * 0.8 * Math.sin(t) ** 3;
	            const y = -(size / 2) * 0.65 * (Math.cos(t) -
	                0.35 * Math.cos(2 * t) -
	                0.14 * Math.cos(3 * t) -
	                0.07 * Math.cos(4 * t));
	            vertices.push(x, y);
	        }
	        g.poly(vertices);
	        g.fill({ color });
	    }
	    /**
	     * Render progress bar
	     */
	    renderProgress(width) {
	        if (!this.progressBar)
	            return;
	        const barHeight = 6;
	        const progress = this._progress / this.hudConfig.progressMax;
	        this.progressBar.clear();
	        // Background
	        this.progressBar.rect(0, 0, width, barHeight);
	        this.progressBar.fill({ color: 0x333333 });
	        // Progress
	        this.progressBar.rect(0, 0, width * progress, barHeight);
	        this.progressBar.fill({ color: 0x4CAF50 });
	    }
	    /**
	     * Toggle pause state
	     */
	    togglePause() {
	        if (this._isPaused) {
	            this.resume();
	        }
	        else {
	            this.pause();
	        }
	    }
	    /**
	     * Pause the game
	     */
	    pause() {
	        if (this._isPaused)
	            return;
	        this._isPaused = true;
	        this.showPauseOverlay();
	        this.config.onPause?.();
	        this.emit('pause');
	    }
	    /**
	     * Resume the game
	     */
	    resume() {
	        if (!this._isPaused)
	            return;
	        this._isPaused = false;
	        this.hidePauseOverlay();
	        this.config.onResume?.();
	        this.emit('resume');
	    }
	    /**
	     * Show pause overlay
	     */
	    showPauseOverlay() {
	        if (this.pauseOverlay)
	            return;
	        const factory = graphics();
	        const width = this._width;
	        const height = this._height;
	        this.pauseOverlay = factory.createContainer();
	        // Dark overlay
	        const overlay = factory.createGraphics();
	        overlay.rect(0, 0, width, height);
	        overlay.fill({ color: 0x000000, alpha: 0.7 });
	        this.pauseOverlay.addChild(overlay);
	        // Paused text
	        const pausedText = factory.createText('PAUSED', {
	            fontFamily: '"Lilita One", "Arial Black", sans-serif',
	            fontSize: 48,
	            fontWeight: 'bold',
	            fill: 0xFFFFFF,
	            stroke: 0x000000,
	            strokeThickness: 4,
	        });
	        if (pausedText.anchor)
	            pausedText.anchor.set(0.5, 0.5);
	        pausedText.x = width / 2;
	        pausedText.y = height / 2 - 60;
	        this.pauseOverlay.addChild(pausedText);
	        // Resume button
	        const resumeBtn = new GameStyleButton({
	            text: 'Resume',
	            width: 180,
	            height: 60,
	            fontSize: 24,
	            colorScheme: GameStyleColors.GREEN_BUTTON,
	        });
	        resumeBtn.setPosition(width / 2 - 90, height / 2);
	        resumeBtn.on('click', () => this.resume());
	        this.pauseOverlay.addChild(resumeBtn.getContainer());
	        // Home button
	        const homeBtn = new GameStyleButton({
	            text: 'Home',
	            width: 180,
	            height: 60,
	            fontSize: 24,
	            colorScheme: GameStyleColors.RED_BUTTON,
	        });
	        homeBtn.setPosition(width / 2 - 90, height / 2 + 80);
	        homeBtn.on('click', () => this.emit('home'));
	        this.pauseOverlay.addChild(homeBtn.getContainer());
	        this.container.addChild(this.pauseOverlay);
	    }
	    /**
	     * Hide pause overlay
	     */
	    hidePauseOverlay() {
	        if (this.pauseOverlay) {
	            this.pauseOverlay.destroy({ children: true });
	            this.pauseOverlay = undefined;
	        }
	    }
	    /**
	     * Public API
	     */
	    /**
	     * Get the game container for adding game content
	     */
	    getGameContainer() {
	        return this.gameContainer;
	    }
	    /**
	     * Get game area dimensions
	     */
	    getGameAreaSize() {
	        return {
	            width: this._width,
	            height: this._height - this.HUD_HEIGHT,
	        };
	    }
	    /**
	     * Set score
	     */
	    setScore(score) {
	        this._score = score;
	        if (this.scoreText) {
	            this.scoreText.text = `Score: ${formatNumber(score)}`;
	        }
	        this.emit('score-changed', score);
	    }
	    /**
	     * Add to score
	     */
	    addScore(amount) {
	        this.setScore(this._score + amount);
	    }
	    /**
	     * Get current score
	     */
	    getScore() {
	        return this._score;
	    }
	    /**
	     * Set time (in seconds)
	     */
	    setTime(seconds) {
	        this._time = seconds;
	        if (this.timerText) {
	            this.timerText.text = formatTime(seconds);
	        }
	    }
	    /**
	     * Get current time
	     */
	    getTime() {
	        return this._time;
	    }
	    /**
	     * Set lives
	     */
	    setLives(lives) {
	        this._lives = Math.max(0, Math.min(lives, this.hudConfig.livesMax));
	        this.renderLives();
	        this.emit('lives-changed', this._lives);
	    }
	    /**
	     * Lose a life
	     */
	    loseLife() {
	        this.setLives(this._lives - 1);
	    }
	    /**
	     * Get current lives
	     */
	    getLives() {
	        return this._lives;
	    }
	    /**
	     * Set progress
	     */
	    setProgress(progress) {
	        this._progress = Math.max(0, Math.min(progress, this.hudConfig.progressMax));
	        this.renderProgress(this._width);
	        this.emit('progress-changed', this._progress);
	    }
	    /**
	     * Check if paused
	     */
	    isPaused() {
	        return this._isPaused;
	    }
	    /**
	     * Handle resize
	     */
	    onResize(width, height) {
	        this.drawBackground(width, height);
	    }
	    /**
	     * Handle back button
	     */
	    onBackButton() {
	        if (this._isPaused) {
	            this.resume();
	            return true;
	        }
	        this.pause();
	        return true;
	    }
	    /**
	     * Cleanup
	     */
	    destroy() {
	        this.pauseButton?.destroy();
	        this.hidePauseOverlay();
	        super.destroy();
	    }
	}

	/**
	 * ResultScreen - Game result/end screen
	 *
	 * Features:
	 * - Victory/Defeat display
	 * - Star rating (0-3)
	 * - Score display with best score
	 * - Reward items
	 * - Action buttons (Retry, Next, Home)
	 *
	 * @example
	 * ```typescript
	 * const result = new ResultScreen({
	 *   type: 'victory',
	 *   score: 12450,
	 *   bestScore: 15230,
	 *   stars: 3,
	 *   rewards: [
	 *     { icon: 'ðŸ’°', amount: 500 },
	 *     { icon: 'ðŸ’Ž', amount: 10 }
	 *   ],
	 *   actions: [
	 *     { text: 'Retry', style: 'secondary', onClick: () => retry() },
	 *     { text: 'Next Level', style: 'primary', onClick: () => nextLevel() }
	 *   ]
	 * });
	 *
	 * screenManager.replace(result, 'fade');
	 * ```
	 */
	class ResultScreen extends SimpleScreen {
	    constructor(config) {
	        super('ResultScreen');
	        this.resultConfig = {
	            type: config.type,
	            score: config.score,
	            bestScore: config.bestScore,
	            stars: config.stars ?? 0,
	            rewards: config.rewards || [],
	            actions: config.actions || [],
	            title: config.title,
	            backgroundColor: config.backgroundColor || 0x1a1a2e,
	        };
	        const factory = graphics();
	        // Create background
	        this.background = factory.createGraphics();
	        this.container.addChild(this.background);
	        // Create content container
	        this.contentContainer = factory.createContainer();
	        this.container.addChild(this.contentContainer);
	    }
	    /**
	     * Setup the screen
	     */
	    setup() {
	        const width = this._width;
	        const height = this._height;
	        // Draw background
	        this.drawBackground(width, height);
	        // Create content
	        this.createContent(width, height);
	    }
	    /**
	     * Draw background with gradient
	     */
	    drawBackground(width, height) {
	        this.background.clear();
	        this.background.rect(0, 0, width, height);
	        this.background.fill({ color: this.resultConfig.backgroundColor || 0x1a1a2e });
	        // Add gradient overlay
	        const isVictory = this.resultConfig.type === 'victory';
	        const overlayColor = isVictory ? 0x4CAF50 : 0xE84C4C;
	        // Top gradient
	        this.background.rect(0, 0, width, height * 0.4);
	        this.background.fill({ color: overlayColor, alpha: 0.2 });
	    }
	    /**
	     * Create all content
	     */
	    createContent(width, height) {
	        const factory = graphics();
	        const isVictory = this.resultConfig.type === 'victory';
	        let currentY = height * 0.1;
	        // Title
	        const titleText = this.resultConfig.title || (isVictory ? 'VICTORY!' : 'DEFEAT');
	        const title = factory.createText(titleText, {
	            fontFamily: '"Lilita One", "Arial Black", sans-serif',
	            fontSize: 48,
	            fontWeight: 'bold',
	            fill: isVictory ? 0x4CAF50 : 0xE84C4C,
	            stroke: 0x000000,
	            strokeThickness: 4,
	        });
	        if (title.anchor)
	            title.anchor.set(0.5, 0.5);
	        title.x = width / 2;
	        title.y = currentY;
	        this.contentContainer.addChild(title);
	        currentY += 80;
	        // Stars
	        if (this.resultConfig.stars !== undefined) {
	            const starsContainer = this.createStars(this.resultConfig.stars);
	            starsContainer.x = width / 2;
	            starsContainer.y = currentY;
	            this.contentContainer.addChild(starsContainer);
	            currentY += 80;
	        }
	        // Score
	        if (this.resultConfig.score !== undefined) {
	            const scoreContainer = this.createScoreDisplay(width);
	            scoreContainer.y = currentY;
	            this.contentContainer.addChild(scoreContainer);
	            currentY += 120;
	        }
	        // Rewards
	        if (this.resultConfig.rewards && this.resultConfig.rewards.length > 0) {
	            const rewardsContainer = this.createRewards(width);
	            rewardsContainer.y = currentY;
	            this.contentContainer.addChild(rewardsContainer);
	            currentY += 100;
	        }
	        // Action buttons
	        if (this.resultConfig.actions && this.resultConfig.actions.length > 0) {
	            const actionsContainer = this.createActions(width, height);
	            this.contentContainer.addChild(actionsContainer);
	        }
	    }
	    /**
	     * Create star rating display
	     */
	    createStars(starCount) {
	        const factory = graphics();
	        const container = factory.createContainer();
	        const starSize = 50;
	        const spacing = 15;
	        let x = -180 / 2 + starSize / 2;
	        for (let i = 0; i < 3; i++) {
	            const star = factory.createGraphics();
	            const isFilled = i < starCount;
	            this.drawStar(star, starSize, isFilled ? 0xFFD700 : 0x444444);
	            star.x = x;
	            container.addChild(star);
	            x += starSize + spacing;
	        }
	        return container;
	    }
	    /**
	     * Draw a star shape
	     */
	    drawStar(g, size, color) {
	        const points = 5;
	        const outerRadius = size / 2;
	        const innerRadius = outerRadius * 0.4;
	        const vertices = [];
	        for (let i = 0; i < points * 2; i++) {
	            const radius = i % 2 === 0 ? outerRadius : innerRadius;
	            const angle = (i * Math.PI) / points - Math.PI / 2;
	            vertices.push(Math.cos(angle) * radius);
	            vertices.push(Math.sin(angle) * radius);
	        }
	        g.poly(vertices);
	        g.fill({ color });
	        g.stroke({ color: darkenColor(color, 0.3), width: 2 });
	    }
	    /**
	     * Create score display
	     */
	    createScoreDisplay(width) {
	        const factory = graphics();
	        const container = factory.createContainer();
	        // Score label
	        const scoreLabel = factory.createText('Score', {
	            fontFamily: '"Lilita One", "Arial Black", sans-serif',
	            fontSize: 24,
	            fill: 0x888888,
	        });
	        if (scoreLabel.anchor)
	            scoreLabel.anchor.set(0.5, 0.5);
	        scoreLabel.x = width / 2;
	        scoreLabel.y = 0;
	        container.addChild(scoreLabel);
	        // Score value
	        const scoreValue = factory.createText(formatNumber(this.resultConfig.score || 0), {
	            fontFamily: '"Lilita One", "Arial Black", sans-serif',
	            fontSize: 56,
	            fontWeight: 'bold',
	            fill: 0xFFFFFF,
	            stroke: 0x000000,
	            strokeThickness: 3,
	        });
	        if (scoreValue.anchor)
	            scoreValue.anchor.set(0.5, 0.5);
	        scoreValue.x = width / 2;
	        scoreValue.y = 50;
	        container.addChild(scoreValue);
	        // Best score
	        if (this.resultConfig.bestScore !== undefined) {
	            const isNewBest = (this.resultConfig.score || 0) >= this.resultConfig.bestScore;
	            const bestText = isNewBest ? 'NEW BEST!' : `Best: ${formatNumber(this.resultConfig.bestScore)}`;
	            const bestLabel = factory.createText(bestText, {
	                fontFamily: '"Lilita One", "Arial Black", sans-serif',
	                fontSize: 18,
	                fill: isNewBest ? 0xFFD700 : 0x888888,
	            });
	            if (bestLabel.anchor)
	                bestLabel.anchor.set(0.5, 0.5);
	            bestLabel.x = width / 2;
	            bestLabel.y = 90;
	            container.addChild(bestLabel);
	        }
	        return container;
	    }
	    /**
	     * Create rewards display
	     */
	    createRewards(width) {
	        const factory = graphics();
	        const container = factory.createContainer();
	        const rewards = this.resultConfig.rewards || [];
	        const itemWidth = 80;
	        const spacing = 20;
	        const totalWidth = rewards.length * itemWidth + (rewards.length - 1) * spacing;
	        let x = (width - totalWidth) / 2 + itemWidth / 2;
	        // Rewards label
	        const rewardsLabel = factory.createText('Rewards', {
	            fontFamily: '"Lilita One", "Arial Black", sans-serif',
	            fontSize: 20,
	            fill: 0x888888,
	        });
	        if (rewardsLabel.anchor)
	            rewardsLabel.anchor.set(0.5, 0.5);
	        rewardsLabel.x = width / 2;
	        rewardsLabel.y = 0;
	        container.addChild(rewardsLabel);
	        rewards.forEach((reward) => {
	            const rewardContainer = factory.createContainer();
	            rewardContainer.x = x;
	            rewardContainer.y = 50;
	            // Background
	            const bg = factory.createGraphics();
	            bg.roundRect(-35, -35, 70, 70, 12);
	            bg.fill({ color: 0x2A3142 });
	            bg.stroke({ color: 0x3D4F5F, width: 2 });
	            rewardContainer.addChild(bg);
	            // Icon
	            if (typeof reward.icon === 'string') {
	                const iconText = factory.createText(reward.icon, {
	                    fontFamily: getFrameworkFontFamily(),
	                    fontSize: 32,
	                });
	                if (iconText.anchor)
	                    iconText.anchor.set(0.5, 0.5);
	                iconText.y = -5;
	                rewardContainer.addChild(iconText);
	            }
	            // Amount
	            const amountText = factory.createText(`+${formatNumber(reward.amount)}`, {
	                fontFamily: '"Lilita One", "Arial Black", sans-serif',
	                fontSize: 16,
	                fontWeight: 'bold',
	                fill: 0xFFFFFF,
	                stroke: 0x000000,
	                strokeThickness: 2,
	            });
	            if (amountText.anchor)
	                amountText.anchor.set(0.5, 0.5);
	            amountText.y = 22;
	            rewardContainer.addChild(amountText);
	            container.addChild(rewardContainer);
	            x += itemWidth + spacing;
	        });
	        return container;
	    }
	    /**
	     * Create action buttons
	     */
	    createActions(width, height) {
	        const factory = graphics();
	        const container = factory.createContainer();
	        const actions = this.resultConfig.actions || [];
	        const buttonWidth = 200;
	        const buttonHeight = 60;
	        const spacing = 20;
	        // Position buttons at bottom
	        const startY = height - 150 - (actions.length - 1) * (buttonHeight + spacing);
	        actions.forEach((action, index) => {
	            const isPrimary = action.style !== 'secondary';
	            const colorScheme = isPrimary
	                ? GameStyleColors.GREEN_BUTTON
	                : GameStyleColors.BLUE_BUTTON;
	            const button = new GameStyleButton({
	                text: action.text,
	                width: buttonWidth,
	                height: buttonHeight,
	                fontSize: 24,
	                colorScheme,
	            });
	            button.setPosition((width - buttonWidth) / 2, startY + index * (buttonHeight + spacing));
	            button.on('click', action.onClick);
	            container.addChild(button.getContainer());
	        });
	        return container;
	    }
	    /**
	     * Handle resize
	     */
	    onResize(width, height) {
	        this.contentContainer.removeChildren();
	        this.drawBackground(width, height);
	        this.createContent(width, height);
	    }
	    /**
	     * Animate in with scale
	     */
	    async animateIn() {
	        this.contentContainer.scale.x = 0.8;
	        this.contentContainer.scale.y = 0.8;
	        this.contentContainer.alpha = 0;
	        return animate({
	            duration: 400,
	            easing: Easing.easeOutBack,
	            onUpdate: (progress, eased) => {
	                const scale = lerp(0.8, 1, eased);
	                this.contentContainer.scale.x = scale;
	                this.contentContainer.scale.y = scale;
	                this.contentContainer.alpha = progress;
	            },
	        });
	    }
	    /**
	     * Handle back button
	     */
	    onBackButton() {
	        return false;
	    }
	}

	/**
	 * HexagonLevelButton - Game-style hexagonal level selector
	 *
	 * Features:
	 * - Hexagon shape with multi-layer border
	 * - Level number centered
	 * - States: locked, available, current, completed
	 * - Optional star rating display
	 * - 3D depth effect
	 * - Press animation
	 *
	 * Inspired by: Candy Crush, Homescapes level maps
	 *
	 * @example
	 * ```typescript
	 * const levelButton = new HexagonLevelButton({
	 *   level: 19,
	 *   size: 80,
	 *   state: 'current'
	 * });
	 *
	 * levelButton.on('click', () => startLevel(19));
	 * stage.addChild(levelButton.getContainer());
	 * ```
	 */
	class HexagonLevelButton extends EventEmitter {
	    constructor(config) {
	        super();
	        this.isPressed = false;
	        // Default configuration
	        this.config = {
	            level: config.level,
	            size: config.size || 80,
	            state: config.state || 'available',
	            colorScheme: config.colorScheme || this.getDefaultColorScheme(config.state || 'available'),
	            showStars: config.showStars ?? true,
	            stars: config.stars || 0,
	            fontSize: config.fontSize || Math.round((config.size || 80) * 0.35),
	            fontFamily: config.fontFamily || '"Lilita One", "Arial Black", sans-serif'
	        };
	        // Create container and graphics layers
	        this.container = graphics().createContainer();
	        this.shadowGraphics = graphics().createGraphics();
	        this.borderGraphics = graphics().createGraphics();
	        this.fillGraphics = graphics().createGraphics();
	        this.highlightGraphics = graphics().createGraphics();
	        // Build layers (z-order)
	        this.container.addChild(this.shadowGraphics);
	        this.container.addChild(this.borderGraphics);
	        this.container.addChild(this.fillGraphics);
	        this.container.addChild(this.highlightGraphics);
	        // Create level text
	        this.levelText = this.createLevelText();
	        this.container.addChild(this.levelText);
	        // Create lock icon if locked
	        if (this.config.state === 'locked') {
	            this.createLockIcon();
	        }
	        // Create stars if enabled and completed
	        if (this.config.showStars && this.config.state === 'completed') {
	            this.createStars();
	        }
	        // Create glow for current level
	        if (this.config.state === 'current' && this.config.colorScheme.glow) {
	            this.createGlow();
	        }
	        // Initial render
	        this.render();
	        // Setup interactivity
	        this.setupInteractivity();
	    }
	    /**
	     * Get default color scheme based on state
	     */
	    getDefaultColorScheme(state) {
	        switch (state) {
	            case 'locked':
	                return GameStyleColors.HEXAGON_LOCKED;
	            case 'completed':
	                return GameStyleColors.HEXAGON_COMPLETED;
	            case 'current':
	                return GameStyleColors.HEXAGON_CURRENT;
	            case 'available':
	            default:
	                return GameStyleColors.HEXAGON_BLUE;
	        }
	    }
	    /**
	     * Create level number text
	     */
	    createLevelText() {
	        const { level, fontSize, fontFamily, state, colorScheme } = this.config;
	        const text = graphics().createText(state === 'locked' ? '' : level.toString(), {
	            fontFamily: fontFamily,
	            fontSize: fontSize,
	            fontWeight: 'bold',
	            fill: colorScheme.text,
	            stroke: colorScheme.textStroke,
	            strokeThickness: Math.max(2, fontSize / 10),
	            dropShadow: true,
	            dropShadowAlpha: 0.4,
	            dropShadowAngle: Math.PI / 2,
	            dropShadowBlur: 2,
	            dropShadowColor: 0x000000,
	            dropShadowDistance: 2
	        });
	        if (text.anchor)
	            text.anchor.set(0.5, 0.5);
	        text.x = 0;
	        text.y = 0;
	        return text;
	    }
	    /**
	     * Create lock icon for locked levels
	     */
	    createLockIcon() {
	        const { size } = this.config;
	        const iconSize = size * 0.35;
	        this.lockIcon = graphics().createGraphics();
	        // Lock body
	        this.lockIcon.roundRect(-iconSize / 2, -iconSize / 4, iconSize, iconSize * 0.7, 4);
	        this.lockIcon.fill({ color: 0xE0E0E0 });
	        this.lockIcon.stroke({ color: 0x9E9E9E, width: 2 });
	        // Lock shackle (using poly to simulate arc - U shape)
	        const shackleR = iconSize * 0.35;
	        const shackleY = -iconSize / 4;
	        const shacklePoints = [];
	        for (let i = 0; i <= 12; i++) {
	            const angle = Math.PI + (Math.PI * i) / 12;
	            shacklePoints.push(Math.cos(angle) * shackleR, shackleY + Math.sin(angle) * shackleR);
	        }
	        this.lockIcon.poly(shacklePoints);
	        this.lockIcon.stroke({ color: 0x9E9E9E, width: 4 });
	        // Keyhole
	        this.lockIcon.circle(0, iconSize * 0.1, iconSize * 0.08);
	        this.lockIcon.fill({ color: 0x616161 });
	        this.lockIcon.y = 2;
	        this.container.addChild(this.lockIcon);
	    }
	    /**
	     * Create star rating display
	     */
	    createStars() {
	        const { size, stars } = this.config;
	        this.starsContainer = graphics().createContainer();
	        this.starsContainer.y = size / 2 + 8;
	        const starSize = size * 0.2;
	        const starSpacing = starSize * 1.1;
	        for (let i = 0; i < 3; i++) {
	            const star = graphics().createGraphics();
	            const filled = i < stars;
	            this.drawStar(star, (i - 1) * starSpacing, 0, starSize / 2, filled);
	            this.starsContainer.addChild(star);
	        }
	        this.container.addChild(this.starsContainer);
	    }
	    /**
	     * Create glow effect for current level
	     */
	    createGlow() {
	        const { size, colorScheme } = this.config;
	        const glowColor = colorScheme.glow || 0x00FFFF;
	        this.glowGraphics = graphics().createGraphics();
	        // Multiple glow layers for soft effect
	        for (let i = 4; i >= 0; i--) {
	            const alpha = 0.15 - (i * 0.025);
	            const glowSize = size + (i * 25);
	            this.glowGraphics.circle(0, 0, glowSize / 2);
	            this.glowGraphics.fill({ color: glowColor, alpha: alpha });
	        }
	        // Add glow behind everything
	        this.container.addChild(this.glowGraphics);
	        this.container.setChildIndex(this.glowGraphics, 0);
	    }
	    /**
	     * Animate glow pulsing (call from game update loop)
	     */
	    updateGlow(time) {
	        if (this.glowGraphics) {
	            this.glowGraphics.alpha = 0.6 + Math.sin(time * 0.003) * 0.25;
	            const glowScale = 0.95 + Math.sin(time * 0.0024) * 0.05;
	            this.glowGraphics.scale.x = glowScale;
	            this.glowGraphics.scale.y = glowScale;
	        }
	    }
	    /**
	     * Draw a 5-pointed star
	     */
	    drawStar(g, x, y, radius, filled) {
	        const points = 5;
	        const innerRadius = radius * 0.4;
	        const vertices = [];
	        for (let i = 0; i < points * 2; i++) {
	            const angle = (i * Math.PI) / points - Math.PI / 2;
	            const r = i % 2 === 0 ? radius : innerRadius;
	            vertices.push(x + Math.cos(angle) * r);
	            vertices.push(y + Math.sin(angle) * r);
	        }
	        g.poly(vertices);
	        g.fill({ color: filled ? 0xFFD700 : 0x5A5A5A });
	        g.stroke({ color: filled ? 0xCC9900 : 0x404040, width: 1 });
	    }
	    /**
	     * Setup touch/mouse events
	     */
	    setupInteractivity() {
	        const { state } = this.config;
	        this.container.eventMode = 'static';
	        this.container.cursor = state === 'locked' ? 'default' : 'pointer';
	        if (state !== 'locked') {
	            this.container.on('pointerdown', this.onPointerDown.bind(this));
	            this.container.on('pointerup', this.onPointerUp.bind(this));
	            this.container.on('pointerupoutside', this.onPointerUpOutside.bind(this));
	        }
	    }
	    /**
	     * Render hexagon graphics
	     */
	    render() {
	        const { size, colorScheme, state } = this.config;
	        // Clear graphics
	        this.shadowGraphics.clear();
	        this.borderGraphics.clear();
	        this.fillGraphics.clear();
	        this.highlightGraphics.clear();
	        const pressOffset = this.isPressed ? 2 : 0;
	        const shadowOffset = this.isPressed ? 2 : 6;
	        const borderWidth = colorScheme.outerBorder ? 6 : 4; // Thicker border for candy style
	        // Get colors
	        const colors = colorScheme;
	        // 1. Shadow
	        this.drawHexagon(this.shadowGraphics, 0, shadowOffset, size - 4);
	        this.shadowGraphics.fill({ color: 0x000000, alpha: 0.4 });
	        // 2. Outer border (golden for candy style, dark otherwise)
	        if (colors.outerBorder) {
	            // Draw darker outer ring first (3D effect)
	            this.drawHexagon(this.borderGraphics, 0, pressOffset + 2, size + 4);
	            this.borderGraphics.fill({ color: colors.outerBorder });
	            // Then golden border
	            this.drawHexagon(this.borderGraphics, 0, pressOffset, size);
	            this.borderGraphics.fill({ color: colors.border });
	        }
	        else {
	            this.drawHexagon(this.borderGraphics, 0, pressOffset, size);
	            this.borderGraphics.fill({ color: colors.border });
	        }
	        // 3. Main fill (blue hexagon)
	        this.drawHexagon(this.fillGraphics, 0, pressOffset, size - borderWidth * 2);
	        this.fillGraphics.fill({ color: colors.fill });
	        // 3.5 Inner bevel effect for 3D look
	        if (colors.outerBorder) {
	            // Top inner highlight
	            this.drawHexagonBevel(this.fillGraphics, 0, pressOffset - 3, size - borderWidth * 2 - 6, 0xFFFFFF, 0.2);
	            // Bottom inner shadow
	            this.drawHexagonBevel(this.fillGraphics, 0, pressOffset + 3, size - borderWidth * 2 - 6, 0x000000, 0.15);
	        }
	        // 4. Inner highlight (top half)
	        if (!this.isPressed) {
	            this.drawHexagonHighlight(this.highlightGraphics, 0, pressOffset - 2, size - borderWidth * 2 - 4, colors.highlight);
	        }
	        // Update text position
	        this.levelText.y = pressOffset;
	        if (this.lockIcon) {
	            this.lockIcon.y = pressOffset + 2;
	        }
	    }
	    /**
	     * Draw hexagon bevel effect for 3D depth
	     */
	    drawHexagonBevel(g, cx, cy, size, color, alpha) {
	        const vertices = [];
	        const sides = 6;
	        const angleOffset = Math.PI / 6;
	        // Only draw top portion for highlight, bottom for shadow
	        for (let i = 0; i <= 3; i++) {
	            const angle = (i * 2 * Math.PI) / sides + angleOffset;
	            vertices.push(cx + Math.cos(angle) * (size / 2));
	            vertices.push(cy + Math.sin(angle) * (size / 2));
	        }
	        g.poly(vertices);
	        g.fill({ color: color, alpha: alpha });
	    }
	    /**
	     * Draw hexagon path
	     */
	    drawHexagon(g, cx, cy, size) {
	        const vertices = [];
	        const sides = 6;
	        const angleOffset = Math.PI / 6; // Flat top orientation
	        for (let i = 0; i < sides; i++) {
	            const angle = (i * 2 * Math.PI) / sides + angleOffset;
	            vertices.push(cx + Math.cos(angle) * (size / 2));
	            vertices.push(cy + Math.sin(angle) * (size / 2));
	        }
	        g.poly(vertices);
	    }
	    /**
	     * Draw hexagon highlight (top portion only)
	     */
	    drawHexagonHighlight(g, cx, cy, size, color) {
	        // Create a highlight that covers top half of hexagon
	        const halfSize = size / 2;
	        const angleOffset = Math.PI / 6;
	        // Get top 4 vertices of hexagon
	        const topVertices = [];
	        for (let i = 0; i <= 3; i++) {
	            const angle = (i * 2 * Math.PI) / 6 + angleOffset;
	            topVertices.push(cx + Math.cos(angle) * halfSize * 0.85);
	            topVertices.push(cy + Math.sin(angle) * halfSize * 0.85 - halfSize * 0.1);
	        }
	        g.poly(topVertices);
	        g.fill({ color: 0xFFFFFF, alpha: 0.25 });
	    }
	    /**
	     * Pointer event handlers
	     */
	    onPointerDown(event) {
	        if (this.config.state === 'locked')
	            return;
	        this.isPressed = true;
	        this.render();
	        this.container.scale.x = 0.95;
	        this.container.scale.y = 0.95;
	        this.emit('press', { level: this.config.level, event });
	    }
	    onPointerUp(event) {
	        if (this.config.state === 'locked')
	            return;
	        this.isPressed = false;
	        this.render();
	        this.container.scale.x = 1;
	        this.container.scale.y = 1;
	        this.emit('click', { level: this.config.level, event });
	    }
	    onPointerUpOutside() {
	        if (this.config.state === 'locked')
	            return;
	        this.isPressed = false;
	        this.render();
	        this.container.scale.x = 1;
	        this.container.scale.y = 1;
	        this.emit('cancel');
	    }
	    /**
	     * Public API
	     */
	    setLevel(level) {
	        this.config.level = level;
	        if (this.config.state !== 'locked') {
	            this.levelText.text = level.toString();
	        }
	        return this;
	    }
	    setState(state) {
	        this.config.state = state;
	        this.config.colorScheme = this.getDefaultColorScheme(state);
	        // Update text visibility and lock icon
	        if (state === 'locked') {
	            this.levelText.text = '';
	            if (!this.lockIcon) {
	                this.createLockIcon();
	            }
	        }
	        else {
	            this.levelText.text = this.config.level.toString();
	            if (this.lockIcon) {
	                this.container.removeChild(this.lockIcon);
	                this.lockIcon.destroy();
	                this.lockIcon = undefined;
	            }
	        }
	        // Update interactivity
	        this.container.cursor = state === 'locked' ? 'default' : 'pointer';
	        // Handle glow for current state
	        if (state === 'current' && this.config.colorScheme.glow) {
	            if (!this.glowGraphics) {
	                this.createGlow();
	            }
	        }
	        else if (this.glowGraphics) {
	            this.container.removeChild(this.glowGraphics);
	            this.glowGraphics.destroy();
	            this.glowGraphics = undefined;
	        }
	        this.render();
	        return this;
	    }
	    setStars(stars) {
	        this.config.stars = Math.min(3, Math.max(0, stars));
	        // Recreate stars if needed
	        if (this.starsContainer) {
	            this.container.removeChild(this.starsContainer);
	            this.starsContainer.destroy({ children: true });
	        }
	        if (this.config.showStars && this.config.state === 'completed') {
	            this.createStars();
	        }
	        return this;
	    }
	    setPosition(x, y) {
	        this.container.x = x;
	        this.container.y = y;
	        return this;
	    }
	    getLevel() {
	        return this.config.level;
	    }
	    getState() {
	        return this.config.state;
	    }
	    getContainer() {
	        return this.container;
	    }
	    getSize() {
	        return this.config.size;
	    }
	    destroy() {
	        this.container.destroy({ children: true });
	        this.removeAllListeners();
	    }
	}

	/**
	 * LevelPath - Vertical level selection path like Candy Crush
	 *
	 * Features:
	 * - Vertical scrolling level path
	 * - Rainbow/gradient path trail
	 * - Hexagon level buttons along the path
	 * - Different states: locked, available, current, completed
	 * - Smooth scrolling with touch/drag
	 * - Auto-scroll to current level
	 *
	 * Inspired by: Candy Crush Saga, Homescapes level maps
	 *
	 * @example
	 * ```typescript
	 * const levelPath = new LevelPath({
	 *   width: 300,
	 *   height: 600,
	 *   levels: [
	 *     { level: 1, state: 'completed', stars: 3 },
	 *     { level: 2, state: 'completed', stars: 2 },
	 *     { level: 3, state: 'current' },
	 *     { level: 4, state: 'available' },
	 *     { level: 5, state: 'locked' }
	 *   ],
	 *   currentLevel: 3
	 * });
	 *
	 * levelPath.on('level-click', (level) => startLevel(level));
	 * stage.addChild(levelPath.getContainer());
	 * ```
	 */
	class LevelPath extends EventEmitter {
	    constructor(config) {
	        super();
	        this.hexagonButtons = new Map();
	        this.contentHeight = 0;
	        this.scrollY = 0;
	        this.isDragging = false;
	        this.lastDragY = 0;
	        this.velocity = 0;
	        this.config = {
	            width: config.width,
	            height: config.height,
	            levels: config.levels,
	            currentLevel: config.currentLevel || this.findCurrentLevel(config.levels),
	            hexagonSize: config.hexagonSize || 80,
	            spacing: config.spacing || 120,
	            pathWidth: config.pathWidth || 16,
	            pathColors: config.pathColors || {
	                completed: 0x4CAF50,
	                active: 0xFFD54F,
	                inactive: 0x5C6BC0
	            },
	            scrollable: config.scrollable ?? true
	        };
	        this.container = graphics().createContainer();
	        this.scrollContainer = graphics().createContainer();
	        this.pathGraphics = graphics().createGraphics();
	        // Set up masking for scroll area
	        const mask = graphics().createGraphics();
	        mask.rect(0, 0, config.width, config.height);
	        mask.fill({ color: 0xFFFFFF });
	        this.container.addChild(mask);
	        // Cast to any since PIXI containers do support mask but IContainer doesn't declare it
	        this.scrollContainer.mask = mask;
	        // Build level path
	        this.container.addChild(this.scrollContainer);
	        this.scrollContainer.addChild(this.pathGraphics);
	        this.createLevelPath();
	        this.createHexagonButtons();
	        // Setup scroll interactivity
	        if (this.config.scrollable) {
	            this.setupScrolling();
	        }
	        // Scroll to current level
	        this.scrollToLevel(this.config.currentLevel, false);
	    }
	    /**
	     * Find the current (most recent playable) level
	     */
	    findCurrentLevel(levels) {
	        for (let i = levels.length - 1; i >= 0; i--) {
	            if (levels[i].state === 'current' || levels[i].state === 'available') {
	                return levels[i].level;
	            }
	        }
	        return levels[0]?.level || 1;
	    }
	    /**
	     * Create the path trail
	     */
	    createLevelPath() {
	        const { levels, width, spacing, pathWidth, pathColors, hexagonSize } = this.config;
	        this.pathGraphics.clear();
	        const centerX = width / 2;
	        const startY = hexagonSize;
	        // Calculate content height
	        this.contentHeight = startY + (levels.length * spacing) + hexagonSize;
	        // Create path segments with gradient colors
	        for (let i = 0; i < levels.length - 1; i++) {
	            const currentLevel = levels[i];
	            const y1 = startY + (i * spacing);
	            const y2 = startY + ((i + 1) * spacing);
	            // Calculate x offset for zigzag pattern
	            const x1 = this.getXOffset(i, centerX);
	            const x2 = this.getXOffset(i + 1, centerX);
	            // Determine path color based on level state
	            let pathColor;
	            if (currentLevel.state === 'completed') {
	                pathColor = pathColors.completed;
	            }
	            else if (currentLevel.state === 'current') {
	                pathColor = pathColors.active;
	            }
	            else {
	                pathColor = pathColors.inactive;
	            }
	            // Draw thick path segment
	            this.drawPathSegment(x1, y1, x2, y2, pathWidth, pathColor);
	        }
	    }
	    /**
	     * Get X offset for zigzag pattern
	     */
	    getXOffset(index, centerX) {
	        // Create subtle zigzag pattern
	        const amplitude = this.config.width * 0.15;
	        const pattern = index % 4;
	        switch (pattern) {
	            case 0: return centerX;
	            case 1: return centerX + amplitude;
	            case 2: return centerX;
	            case 3: return centerX - amplitude;
	            default: return centerX;
	        }
	    }
	    /**
	     * Draw a path segment with rounded ends
	     */
	    drawPathSegment(x1, y1, x2, y2, width, color) {
	        // Shadow/outline
	        this.pathGraphics.moveTo(x1, y1);
	        this.pathGraphics.lineTo(x2, y2);
	        this.pathGraphics.stroke({ color: 0x1A1A2A, width: width + 6, cap: 'round' });
	        // Main path
	        this.pathGraphics.moveTo(x1, y1);
	        this.pathGraphics.lineTo(x2, y2);
	        this.pathGraphics.stroke({ color: color, width: width, cap: 'round' });
	        // Highlight
	        this.pathGraphics.moveTo(x1, y1 - 2);
	        this.pathGraphics.lineTo(x2, y2 - 2);
	        this.pathGraphics.stroke({ color: this.lightenColor(color, 0.3), width: width * 0.4, cap: 'round' });
	    }
	    /**
	     * Create hexagon buttons for each level
	     */
	    createHexagonButtons() {
	        const { levels, width, spacing, hexagonSize } = this.config;
	        const centerX = width / 2;
	        const startY = hexagonSize;
	        levels.forEach((levelData, index) => {
	            const x = this.getXOffset(index, centerX);
	            const y = startY + (index * spacing);
	            const hexButton = new HexagonLevelButton({
	                level: levelData.level,
	                size: hexagonSize,
	                state: levelData.state,
	                stars: levelData.stars,
	                showStars: levelData.state === 'completed'
	            });
	            hexButton.setPosition(x, y);
	            // Handle click events
	            hexButton.on('click', ({ level }) => {
	                this.emit('level-click', level, levelData);
	            });
	            this.hexagonButtons.set(levelData.level, hexButton);
	            this.scrollContainer.addChild(hexButton.getContainer());
	        });
	    }
	    /**
	     * Setup touch/mouse scrolling
	     */
	    setupScrolling() {
	        this.container.eventMode = 'static';
	        this.container.on('pointerdown', (e) => {
	            this.isDragging = true;
	            this.lastDragY = e.global.y;
	            this.velocity = 0;
	        });
	        this.container.on('pointermove', (e) => {
	            if (!this.isDragging)
	                return;
	            const deltaY = e.global.y - this.lastDragY;
	            this.velocity = deltaY;
	            this.scroll(deltaY);
	            this.lastDragY = e.global.y;
	        });
	        this.container.on('pointerup', () => {
	            this.isDragging = false;
	            // Apply momentum
	            this.applyMomentum();
	        });
	        this.container.on('pointerupoutside', () => {
	            this.isDragging = false;
	            this.applyMomentum();
	        });
	        // Mouse wheel support
	        this.container.on('wheel', (e) => {
	            this.scroll(-e.deltaY * 0.5);
	        });
	    }
	    /**
	     * Apply momentum scrolling
	     */
	    applyMomentum() {
	        const friction = 0.95;
	        const minVelocity = 0.5;
	        const animate = () => {
	            if (Math.abs(this.velocity) < minVelocity)
	                return;
	            this.scroll(this.velocity);
	            this.velocity *= friction;
	            requestAnimationFrame(animate);
	        };
	        requestAnimationFrame(animate);
	    }
	    /**
	     * Scroll by delta amount
	     */
	    scroll(deltaY) {
	        const maxScroll = 0;
	        const minScroll = -(this.contentHeight - this.config.height);
	        this.scrollY = Math.max(minScroll, Math.min(maxScroll, this.scrollY + deltaY));
	        this.scrollContainer.y = this.scrollY;
	    }
	    /**
	     * Scroll to a specific level
	     */
	    scrollToLevel(level, animate = true) {
	        const { levels, spacing, hexagonSize, height } = this.config;
	        const levelIndex = levels.findIndex(l => l.level === level);
	        if (levelIndex === -1)
	            return;
	        const targetY = hexagonSize + (levelIndex * spacing);
	        const targetScroll = -(targetY - height / 2);
	        // Clamp to valid scroll range
	        const maxScroll = 0;
	        const minScroll = -(this.contentHeight - height);
	        const clampedTarget = Math.max(minScroll, Math.min(maxScroll, targetScroll));
	        if (animate) {
	            this.animateScrollTo(clampedTarget);
	        }
	        else {
	            this.scrollY = clampedTarget;
	            this.scrollContainer.y = this.scrollY;
	        }
	    }
	    /**
	     * Animate scroll to position
	     */
	    animateScrollTo(targetY) {
	        const startY = this.scrollY;
	        const duration = 500;
	        const startTime = Date.now();
	        const animate = () => {
	            const elapsed = Date.now() - startTime;
	            const progress = Math.min(elapsed / duration, 1);
	            // Ease out cubic
	            const eased = 1 - Math.pow(1 - progress, 3);
	            this.scrollY = startY + (targetY - startY) * eased;
	            this.scrollContainer.y = this.scrollY;
	            if (progress < 1) {
	                requestAnimationFrame(animate);
	            }
	        };
	        requestAnimationFrame(animate);
	    }
	    /**
	     * Lighten a color
	     */
	    lightenColor(color, amount) {
	        const r = Math.min(255, ((color >> 16) & 0xFF) + Math.floor(255 * amount));
	        const g = Math.min(255, ((color >> 8) & 0xFF) + Math.floor(255 * amount));
	        const b = Math.min(255, (color & 0xFF) + Math.floor(255 * amount));
	        return (r << 16) | (g << 8) | b;
	    }
	    /**
	     * Public API
	     */
	    setLevelState(level, state, stars) {
	        const hexButton = this.hexagonButtons.get(level);
	        if (hexButton) {
	            hexButton.setState(state);
	            if (stars !== undefined) {
	                hexButton.setStars(stars);
	            }
	        }
	        // Update path
	        const levelData = this.config.levels.find(l => l.level === level);
	        if (levelData) {
	            levelData.state = state;
	            if (stars !== undefined)
	                levelData.stars = stars;
	            this.createLevelPath();
	        }
	        this.emit('level-state-changed', level, state);
	        return this;
	    }
	    unlockLevel(level) {
	        return this.setLevelState(level, 'available');
	    }
	    completeLevel(level, stars = 0) {
	        this.setLevelState(level, 'completed', stars);
	        // Unlock next level if it exists and is locked
	        const nextLevel = level + 1;
	        const nextButton = this.hexagonButtons.get(nextLevel);
	        if (nextButton && nextButton.getState() === 'locked') {
	            this.setLevelState(nextLevel, 'available');
	        }
	        return this;
	    }
	    setCurrentLevel(level) {
	        this.config.currentLevel = level;
	        this.scrollToLevel(level);
	        return this;
	    }
	    getContainer() {
	        return this.container;
	    }
	    setPosition(x, y) {
	        this.container.x = x;
	        this.container.y = y;
	        return this;
	    }
	    destroy() {
	        this.hexagonButtons.forEach(btn => btn.destroy());
	        this.hexagonButtons.clear();
	        this.container.destroy({ children: true });
	        this.removeAllListeners();
	    }
	}

	/**
	 * Game-style panel component with skinnable borders and title bar
	 * Inspired by Candy Crush, Brawl Stars, and Clash Royale
	 *
	 * Features:
	 * - Multi-layer border effect
	 * - Gradient background
	 * - Title bar with close button
	 * - Customizable color schemes
	 * - Drop shadow
	 *
	 * @example
	 * ```typescript
	 * const panel = new GameStylePanel({
	 *   width: 350,
	 *   height: 400,
	 *   title: 'SETTINGS',
	 *   showCloseButton: true,
	 *   colorScheme: GameStyleColors.PANEL_BLUE,
	 *   onClose: () => panel.hide()
	 * });
	 *
	 * stage.addChild(panel.getContainer());
	 * ```
	 */
	class GameStylePanel extends EventEmitter {
	    constructor(config = {}) {
	        super();
	        // Trigger font loading (non-blocking)
	        loadFrameworkFont();
	        this.config = {
	            width: config.width || 350,
	            height: config.height || 400,
	            title: config.title || '',
	            showCloseButton: config.showCloseButton !== false,
	            colorScheme: config.colorScheme || GameStylePanel.DEFAULT_SCHEME,
	            borderRadius: config.borderRadius || 18, // Matches No Ads popup
	            borderWidth: config.borderWidth || 4, // Matches No Ads popup
	            titleFontSize: config.titleFontSize || 28,
	            padding: config.padding || 20,
	            onClose: config.onClose || (() => { }),
	        };
	        const factory = graphics();
	        // Create container hierarchy
	        this.container = factory.createContainer();
	        // Create shadow
	        this.shadowGraphics = factory.createGraphics();
	        this.container.addChild(this.shadowGraphics);
	        // Create border
	        this.borderGraphics = factory.createGraphics();
	        this.container.addChild(this.borderGraphics);
	        // Create background
	        this.backgroundGraphics = factory.createGraphics();
	        this.container.addChild(this.backgroundGraphics);
	        // Create content container
	        this.contentContainer = factory.createContainer();
	        this.container.addChild(this.contentContainer);
	        // Render panel
	        this.render();
	        // Create title if provided
	        if (this.config.title) {
	            this.createTitle();
	        }
	        // Create close button if needed
	        if (this.config.showCloseButton) {
	            this.createCloseButton();
	        }
	    }
	    /**
	     * Render the panel graphics (No Ads popup style)
	     */
	    render() {
	        const { width, height, borderRadius, borderWidth, colorScheme } = this.config;
	        const headerHeight = this.config.title ? 52 : 0;
	        // Clear previous graphics
	        this.shadowGraphics.clear();
	        this.borderGraphics.clear();
	        this.backgroundGraphics.clear();
	        // ==========================================
	        // No Ads popup style rendering
	        // ==========================================
	        // 1. Shadow (8px down, 40% alpha)
	        this.shadowGraphics.roundRect(0, 8, width, height, borderRadius);
	        this.shadowGraphics.fill({ color: 0x000000, alpha: 0.4 });
	        // 2. Border (single dark navy border)
	        this.borderGraphics.roundRect(-borderWidth, -borderWidth, width + borderWidth * 2, height + borderWidth * 2, borderRadius + borderWidth);
	        this.borderGraphics.fill(colorScheme.borderOuter);
	        // 3. Main background (solid color)
	        this.backgroundGraphics.roundRect(0, 0, width, height, borderRadius);
	        this.backgroundGraphics.fill(colorScheme.fillTop);
	        // 4. Header background (darker blue, only if title exists)
	        if (headerHeight > 0 && colorScheme.headerBg) {
	            // Header with rounded top corners, straight bottom
	            this.backgroundGraphics.roundRect(0, 0, width, headerHeight, borderRadius);
	            this.backgroundGraphics.rect(0, headerHeight - borderRadius, width, borderRadius);
	            this.backgroundGraphics.fill(colorScheme.headerBg);
	        }
	        // Remove old gradient sprite if exists (not used in new style)
	        if (this.gradientSprite) {
	            this.container.removeChild(this.gradientSprite);
	            this.gradientSprite = undefined;
	        }
	        // Position content container (below header)
	        this.contentContainer.x = this.config.padding;
	        this.contentContainer.y = headerHeight + this.config.padding;
	    }
	    /**
	     * Create the title text (centered in 52px header, No Ads popup style)
	     */
	    createTitle() {
	        const { width, colorScheme, titleFontSize } = this.config;
	        const headerHeight = 52;
	        // No Ads popup style text - stroke + dropShadow
	        this.titleText = graphics().createText(this.config.title, {
	            fontFamily: getFrameworkFontFamily(),
	            fontSize: titleFontSize,
	            fontWeight: '900',
	            fill: colorScheme.titleColor,
	            stroke: colorScheme.titleStroke,
	            strokeThickness: Math.max(3, titleFontSize * 0.12),
	            align: 'center',
	            dropShadow: true,
	            dropShadowColor: 0x000000,
	            dropShadowBlur: 0,
	            dropShadowDistance: Math.max(2, titleFontSize * 0.06),
	            dropShadowAngle: Math.PI / 2,
	            dropShadowAlpha: 0.5,
	        });
	        // Center title in header
	        const titleWidth = this.titleText.width || 100;
	        const titleHeight = this.titleText.height || titleFontSize;
	        this.titleText.x = (width - titleWidth) / 2;
	        this.titleText.y = (headerHeight - titleHeight) / 2;
	        this.container.addChild(this.titleText);
	    }
	    /**
	     * Create the close button - uses new GameStyleButton (positioned in header)
	     */
	    createCloseButton() {
	        const { width } = this.config;
	        const headerHeight = 52;
	        // Remove existing close button if any
	        if (this.closeButton) {
	            this.container.removeChild(this.closeButton);
	        }
	        // Use the new GameButtons.close() for consistent button style
	        const buttonSize = 38;
	        const closeBtn = GameButtons.close(buttonSize);
	        // Position at top right corner within header
	        const buttonX = width - buttonSize - 8;
	        const buttonY = (headerHeight - buttonSize) / 2;
	        closeBtn.setPosition(buttonX, buttonY);
	        // Wire up click handler
	        closeBtn.on('click', () => {
	            this.emit('close');
	            this.config.onClose();
	        });
	        this.closeButton = closeBtn.getContainer();
	        this.container.addChild(this.closeButton);
	    }
	    /**
	     * Add child to content area
	     */
	    addContent(child) {
	        this.contentContainer.addChild(child);
	    }
	    /**
	     * Remove child from content area
	     */
	    removeContent(child) {
	        this.contentContainer.removeChild(child);
	    }
	    /**
	     * Clear all content
	     */
	    clearContent() {
	        this.contentContainer.removeChildren();
	    }
	    /**
	     * Get the content container for direct manipulation
	     */
	    getContentContainer() {
	        return this.contentContainer;
	    }
	    /**
	     * Set panel position
	     */
	    setPosition(x, y) {
	        this.container.x = x;
	        this.container.y = y;
	    }
	    /**
	     * Get panel position
	     */
	    getPosition() {
	        return { x: this.container.x, y: this.container.y };
	    }
	    /**
	     * Show the panel
	     */
	    show() {
	        this.container.visible = true;
	        this.emit('show');
	    }
	    /**
	     * Hide the panel
	     */
	    hide() {
	        this.container.visible = false;
	        this.emit('hide');
	    }
	    /**
	     * Set panel visibility
	     */
	    setVisible(visible) {
	        this.container.visible = visible;
	    }
	    /**
	     * Get the main container
	     */
	    getContainer() {
	        return this.container;
	    }
	    /**
	     * Set title text
	     */
	    setTitle(title) {
	        if (this.titleText) {
	            this.titleText.text = title;
	            // Re-center
	            const titleWidth = this.titleText.width || 100;
	            this.titleText.x = (this.config.width - titleWidth) / 2;
	        }
	    }
	    /**
	     * Update color scheme
	     */
	    setColorScheme(scheme) {
	        this.config.colorScheme = scheme;
	        this.render();
	        if (this.config.title) {
	            this.createTitle();
	        }
	        if (this.config.showCloseButton) {
	            this.createCloseButton();
	        }
	    }
	    /**
	     * Get panel dimensions
	     */
	    getSize() {
	        return {
	            width: this.config.width,
	            height: this.config.height,
	        };
	    }
	    /**
	     * Get content area dimensions (usable space)
	     */
	    getContentSize() {
	        const titleHeight = this.config.title ? 52 : 0;
	        return {
	            width: this.config.width - this.config.borderWidth * 2 - this.config.padding * 2,
	            height: this.config.height - this.config.borderWidth * 2 - titleHeight - this.config.padding * 2,
	        };
	    }
	    /**
	     * Destroy the panel
	     */
	    destroy() {
	        this.container.destroy();
	        this.removeAllListeners();
	    }
	}
	// Default blue panel color scheme (matches No Ads popup)
	GameStylePanel.DEFAULT_SCHEME = {
	    fillTop: 0x41A7FB, // Light blue modal background
	    fillBottom: 0x41A7FB, // Solid color
	    borderOuter: 0x1e3a5f, // Dark navy border
	    borderInner: 0x1e3a5f, // Same - single border
	    borderWidth: 4,
	    headerBg: 0x2889F0, // Darker blue header
	    titleColor: 0xFFFFFF,
	    titleStroke: 0x1a2a3a,
	    closeButtonBg: 0xE84C4C,
	    closeButtonBorder: 0xA83340,
	    closeButtonX: 0xFFFFFF,
	};

	/**
	 * Creates a horizontal gradient texture for toggle track
	 * @internal
	 */
	function createTrackGradient$1(width, height, colorLeft, colorRight, borderRadius) {
	    const canvas = document.createElement('canvas');
	    canvas.width = width;
	    canvas.height = height;
	    const ctx = canvas.getContext('2d');
	    const leftHex = '#' + colorLeft.toString(16).padStart(6, '0');
	    const rightHex = '#' + colorRight.toString(16).padStart(6, '0');
	    // Vertical gradient (top lighter, bottom darker)
	    const gradient = ctx.createLinearGradient(0, 0, 0, height);
	    gradient.addColorStop(0, leftHex);
	    gradient.addColorStop(1, rightHex);
	    ctx.beginPath();
	    ctx.roundRect(0, 0, width, height, borderRadius);
	    ctx.fillStyle = gradient;
	    ctx.fill();
	    return canvas;
	}
	/**
	 * Game-style toggle switch component
	 * Polished mobile game style with gradients and depth
	 *
	 * Features:
	 * - Gradient track with depth effect
	 * - Glossy thumb with specular highlight
	 * - Smooth press animation
	 * - Touch-friendly size
	 *
	 * @example
	 * ```typescript
	 * const musicToggle = new GameToggle({
	 *   value: true,
	 *   onChange: (value) => setMusicEnabled(value)
	 * });
	 *
	 * stage.addChild(musicToggle.getContainer());
	 * ```
	 */
	class GameToggle extends EventEmitter {
	    constructor(config = {}) {
	        super();
	        this.isPressed = false;
	        this.config = {
	            width: config.width || 70,
	            height: config.height || 36,
	            value: config.value !== undefined ? config.value : false,
	            colorScheme: config.colorScheme || GameToggle.DEFAULT_SCHEME,
	            disabled: config.disabled || false,
	            onChange: config.onChange || (() => { }),
	        };
	        this._value = this.config.value;
	        const factory = graphics();
	        // Create container
	        this.container = factory.createContainer();
	        // Create layers (order matters)
	        this.depthGraphics = factory.createGraphics();
	        this.borderGraphics = factory.createGraphics();
	        this.trackGraphics = factory.createGraphics();
	        this.thumbGraphics = factory.createGraphics();
	        this.container.addChild(this.depthGraphics);
	        this.container.addChild(this.borderGraphics);
	        this.container.addChild(this.trackGraphics);
	        this.container.addChild(this.thumbGraphics);
	        // Render
	        this.render();
	        // Setup interaction
	        this.setupInteraction();
	    }
	    /**
	     * Render the toggle with game-style polish
	     */
	    render() {
	        const { width, height, colorScheme, disabled } = this.config;
	        const radius = height / 2;
	        const borderWidth = 3;
	        const depthOffset = 3;
	        // Clear
	        this.depthGraphics.clear();
	        this.borderGraphics.clear();
	        this.trackGraphics.clear();
	        this.thumbGraphics.clear();
	        // Remove old gradient sprite
	        if (this.trackGradientSprite) {
	            this.container.removeChild(this.trackGradientSprite);
	            this.trackGradientSprite = undefined;
	        }
	        const alpha = disabled ? 0.5 : 1;
	        const thumbScale = this.isPressed ? 0.9 : 1.0;
	        // Determine track colors based on state
	        const trackTopColor = this._value ? colorScheme.trackOnTop : colorScheme.trackOffTop;
	        const trackBottomColor = this._value ? colorScheme.trackOnBottom : colorScheme.trackOffBottom;
	        // Layer 1: Depth (extends below)
	        this.depthGraphics.roundRect(0, 0, width, height + depthOffset, radius);
	        this.depthGraphics.fill({ color: colorScheme.borderDepth, alpha });
	        // Layer 2: Border
	        this.borderGraphics.roundRect(0, 0, width, height, radius);
	        this.borderGraphics.fill({ color: colorScheme.border, alpha });
	        // Layer 3: Track fill with gradient
	        const trackX = borderWidth;
	        const trackY = borderWidth;
	        const trackWidth = width - borderWidth * 2;
	        const trackHeight = height - borderWidth * 2;
	        const trackRadius = radius - borderWidth;
	        // Create gradient sprite for track
	        const gradientCanvas = createTrackGradient$1(trackWidth, trackHeight, trackTopColor, trackBottomColor, trackRadius);
	        const gradientTexture = graphics().createTexture(gradientCanvas);
	        this.trackGradientSprite = graphics().createSprite(gradientTexture);
	        this.trackGradientSprite.x = trackX;
	        this.trackGradientSprite.y = trackY;
	        if (disabled)
	            this.trackGradientSprite.alpha = alpha;
	        // Insert gradient sprite after trackGraphics
	        const trackIndex = this.container.getChildIndex(this.trackGraphics);
	        this.container.addChild(this.trackGradientSprite);
	        this.container.setChildIndex(this.trackGradientSprite, trackIndex + 1);
	        // Inner shadow on track (subtle)
	        this.trackGraphics.roundRect(trackX + 2, trackY + 1, trackWidth - 4, 4, 2);
	        this.trackGraphics.fill({ color: 0x000000, alpha: 0.15 * alpha });
	        // Layer 4: Thumb
	        const thumbBaseRadius = (height - 10) / 2;
	        const thumbRadius = thumbBaseRadius * thumbScale;
	        const thumbX = this._value ? width - thumbBaseRadius - 7 : thumbBaseRadius + 7;
	        const thumbY = height / 2;
	        // Thumb shadow
	        this.thumbGraphics.circle(thumbX + 1, thumbY + 2, thumbRadius);
	        this.thumbGraphics.fill({ color: 0x000000, alpha: 0.25 * alpha });
	        // Thumb base (darker bottom color)
	        this.thumbGraphics.circle(thumbX, thumbY, thumbRadius);
	        this.thumbGraphics.fill({ color: colorScheme.thumbBottom, alpha });
	        // Thumb gradient effect (lighter top half)
	        this.thumbGraphics.ellipse(thumbX, thumbY - thumbRadius * 0.15, thumbRadius * 0.9, thumbRadius * 0.7);
	        this.thumbGraphics.fill({ color: colorScheme.thumbTop, alpha });
	        // Thumb specular highlight (small bright spot)
	        this.thumbGraphics.ellipse(thumbX - thumbRadius * 0.25, thumbY - thumbRadius * 0.35, thumbRadius * 0.35, thumbRadius * 0.2);
	        this.thumbGraphics.fill({ color: 0xFFFFFF, alpha: 0.6 * alpha });
	        // Rim light on thumb
	        this.thumbGraphics.roundRect(thumbX - thumbRadius * 0.6, thumbY - thumbRadius + 2, thumbRadius * 1.2, 2, 1);
	        this.thumbGraphics.fill({ color: 0xFFFFFF, alpha: 0.3 * alpha });
	    }
	    /**
	     * Setup interaction handlers
	     */
	    setupInteraction() {
	        this.container.eventMode = 'static';
	        this.container.cursor = this.config.disabled ? 'default' : 'pointer';
	        const { width, height } = this.config;
	        this.container.hitArea = {
	            contains: (x, y) => {
	                return x >= 0 && x <= width && y >= 0 && y <= height + 3;
	            }
	        };
	        this.container.on('pointerdown', this.onPointerDown.bind(this));
	        this.container.on('pointerup', this.onPointerUp.bind(this));
	        this.container.on('pointerupoutside', this.onPointerUpOutside.bind(this));
	    }
	    onPointerDown() {
	        if (this.config.disabled)
	            return;
	        this.isPressed = true;
	        this.render();
	    }
	    onPointerUp() {
	        if (this.config.disabled)
	            return;
	        this.isPressed = false;
	        this.toggle();
	    }
	    onPointerUpOutside() {
	        if (this.config.disabled)
	            return;
	        this.isPressed = false;
	        this.render();
	    }
	    /**
	     * Toggle the value
	     */
	    toggle() {
	        this._value = !this._value;
	        this.render();
	        this.emit('change', this._value);
	        this.config.onChange(this._value);
	    }
	    /**
	     * Get current value
	     */
	    getValue() {
	        return this._value;
	    }
	    /**
	     * Set value
	     */
	    setValue(value) {
	        if (this._value !== value) {
	            this._value = value;
	            this.render();
	            this.emit('change', this._value);
	        }
	    }
	    /**
	     * Set disabled state
	     */
	    setDisabled(disabled) {
	        this.config.disabled = disabled;
	        this.container.cursor = disabled ? 'default' : 'pointer';
	        this.render();
	    }
	    /**
	     * Check if disabled
	     */
	    isDisabled() {
	        return this.config.disabled;
	    }
	    /**
	     * Set position
	     */
	    setPosition(x, y) {
	        this.container.x = x;
	        this.container.y = y;
	    }
	    /**
	     * Get position
	     */
	    getPosition() {
	        return { x: this.container.x, y: this.container.y };
	    }
	    /**
	     * Get the container
	     */
	    getContainer() {
	        return this.container;
	    }
	    /**
	     * Set color scheme
	     */
	    setColorScheme(scheme) {
	        this.config.colorScheme = scheme;
	        this.render();
	    }
	    /**
	     * Destroy the toggle
	     */
	    destroy() {
	        this.container.destroy();
	        this.removeAllListeners();
	    }
	}
	// Default color scheme - green/gray game style
	GameToggle.DEFAULT_SCHEME = {
	    trackOnTop: 0x7ED321,
	    trackOnBottom: 0x5BA017,
	    trackOffTop: 0x6B7C8A,
	    trackOffBottom: 0x4A5660,
	    thumbTop: 0xFFFFFF,
	    thumbBottom: 0xE8E8E8,
	    border: 0x3D4F5F,
	    borderDepth: 0x2A3640,
	};
	/**
	 * Pre-defined toggle color schemes - game style
	 */
	const GameToggleColors = {
	    // Default green toggle
	    DEFAULT: {
	        trackOnTop: 0x7ED321,
	        trackOnBottom: 0x5BA017,
	        trackOffTop: 0x6B7C8A,
	        trackOffBottom: 0x4A5660,
	        thumbTop: 0xFFFFFF,
	        thumbBottom: 0xE8E8E8,
	        border: 0x3D4F5F,
	        borderDepth: 0x2A3640,
	    },
	    // Blue toggle
	    BLUE: {
	        trackOnTop: 0x5DADE2,
	        trackOnBottom: 0x2E86C1,
	        trackOffTop: 0x6B7C8A,
	        trackOffBottom: 0x4A5660,
	        thumbTop: 0xFFFFFF,
	        thumbBottom: 0xE8E8E8,
	        border: 0x1A5276,
	        borderDepth: 0x0E3249,
	    },
	    // Orange toggle
	    ORANGE: {
	        trackOnTop: 0xF5B041,
	        trackOnBottom: 0xD68910,
	        trackOffTop: 0x6B7C8A,
	        trackOffBottom: 0x4A5660,
	        thumbTop: 0xFFFFFF,
	        thumbBottom: 0xE8E8E8,
	        border: 0xB7950B,
	        borderDepth: 0x7D6608,
	    },
	    // Purple toggle
	    PURPLE: {
	        trackOnTop: 0xBB8FCE,
	        trackOnBottom: 0x8E44AD,
	        trackOffTop: 0x6B7C8A,
	        trackOffBottom: 0x4A5660,
	        thumbTop: 0xFFFFFF,
	        thumbBottom: 0xE8E8E8,
	        border: 0x6C3483,
	        borderDepth: 0x4A235A,
	    },
	};

	/**
	 * Creates a horizontal gradient texture for slider track
	 * @internal
	 */
	function createTrackGradient(width, height, colorTop, colorBottom, borderRadius) {
	    const canvas = document.createElement('canvas');
	    canvas.width = width;
	    canvas.height = height;
	    const ctx = canvas.getContext('2d');
	    const topHex = '#' + colorTop.toString(16).padStart(6, '0');
	    const bottomHex = '#' + colorBottom.toString(16).padStart(6, '0');
	    // Vertical gradient (top lighter, bottom darker)
	    const gradient = ctx.createLinearGradient(0, 0, 0, height);
	    gradient.addColorStop(0, topHex);
	    gradient.addColorStop(1, bottomHex);
	    ctx.beginPath();
	    ctx.roundRect(0, 0, width, height, borderRadius);
	    ctx.fillStyle = gradient;
	    ctx.fill();
	    return canvas;
	}
	/**
	 * Game-style slider component for volume, progress, etc.
	 * Polished mobile game style with gradients and depth
	 *
	 * Features:
	 * - Gradient track with fill indicator
	 * - Glossy draggable thumb
	 * - Smooth drag interaction
	 * - Touch-friendly size
	 *
	 * @example
	 * ```typescript
	 * const volumeSlider = new GameSlider({
	 *   min: 0,
	 *   max: 100,
	 *   value: 75,
	 *   onChange: (value) => setVolume(value / 100)
	 * });
	 *
	 * stage.addChild(volumeSlider.getContainer());
	 * ```
	 */
	class GameSlider extends EventEmitter {
	    constructor(config = {}) {
	        super();
	        this.isDragging = false;
	        this.isPressed = false;
	        this.config = {
	            width: config.width || 200,
	            height: config.height || 36,
	            min: config.min !== undefined ? config.min : 0,
	            max: config.max !== undefined ? config.max : 100,
	            value: config.value !== undefined ? config.value : 50,
	            step: config.step !== undefined ? config.step : 1,
	            colorScheme: config.colorScheme || GameSlider.DEFAULT_SCHEME,
	            disabled: config.disabled || false,
	            onChange: config.onChange || (() => { }),
	        };
	        // Clamp initial value
	        this._value = Math.max(this.config.min, Math.min(this.config.max, this.config.value));
	        const factory = graphics();
	        // Create container
	        this.container = factory.createContainer();
	        // Create layers (order matters)
	        this.depthGraphics = factory.createGraphics();
	        this.borderGraphics = factory.createGraphics();
	        this.trackGraphics = factory.createGraphics();
	        this.fillGraphics = factory.createGraphics();
	        this.thumbGraphics = factory.createGraphics();
	        this.container.addChild(this.depthGraphics);
	        this.container.addChild(this.borderGraphics);
	        this.container.addChild(this.trackGraphics);
	        this.container.addChild(this.fillGraphics);
	        this.container.addChild(this.thumbGraphics);
	        // Render
	        this.render();
	        // Setup interaction
	        this.setupInteraction();
	    }
	    /**
	     * Get the normalized value (0-1)
	     */
	    getNormalizedValue() {
	        const range = this.config.max - this.config.min;
	        if (range === 0)
	            return 0;
	        return (this._value - this.config.min) / range;
	    }
	    /**
	     * Set value from normalized (0-1)
	     */
	    setFromNormalized(normalized) {
	        const range = this.config.max - this.config.min;
	        let newValue = this.config.min + normalized * range;
	        // Apply step
	        if (this.config.step > 0) {
	            newValue = Math.round(newValue / this.config.step) * this.config.step;
	        }
	        // Clamp
	        newValue = Math.max(this.config.min, Math.min(this.config.max, newValue));
	        if (newValue !== this._value) {
	            this._value = newValue;
	            this.render();
	            this.emit('change', this._value);
	            this.config.onChange(this._value);
	        }
	    }
	    /**
	     * Render the slider with game-style polish
	     */
	    render() {
	        const { width, height, colorScheme, disabled } = this.config;
	        const radius = height / 2;
	        const borderWidth = 3;
	        const depthOffset = 3;
	        const trackPadding = 4;
	        // Clear
	        this.depthGraphics.clear();
	        this.borderGraphics.clear();
	        this.trackGraphics.clear();
	        this.fillGraphics.clear();
	        this.thumbGraphics.clear();
	        // Remove old gradient sprites
	        if (this.trackGradientSprite) {
	            this.container.removeChild(this.trackGradientSprite);
	            this.trackGradientSprite = undefined;
	        }
	        if (this.fillGradientSprite) {
	            this.container.removeChild(this.fillGradientSprite);
	            this.fillGradientSprite = undefined;
	        }
	        const alpha = disabled ? 0.5 : 1;
	        const thumbScale = this.isPressed ? 0.9 : 1.0;
	        // Calculate thumb position
	        const trackX = borderWidth + trackPadding;
	        const trackY = borderWidth + trackPadding;
	        const trackWidth = width - (borderWidth + trackPadding) * 2;
	        const trackHeight = height - (borderWidth + trackPadding) * 2;
	        const trackRadius = trackHeight / 2;
	        const thumbBaseRadius = (height - 8) / 2;
	        const thumbRadius = thumbBaseRadius * thumbScale;
	        const thumbMinX = trackX + thumbBaseRadius;
	        const thumbMaxX = width - trackX - thumbBaseRadius;
	        const thumbRange = thumbMaxX - thumbMinX;
	        const thumbX = thumbMinX + this.getNormalizedValue() * thumbRange;
	        const thumbY = height / 2;
	        // Layer 1: Depth (extends below)
	        this.depthGraphics.roundRect(0, 0, width, height + depthOffset, radius);
	        this.depthGraphics.fill({ color: colorScheme.borderDepth, alpha });
	        // Layer 2: Border
	        this.borderGraphics.roundRect(0, 0, width, height, radius);
	        this.borderGraphics.fill({ color: colorScheme.border, alpha });
	        // Layer 3: Track background with gradient
	        const trackBgCanvas = createTrackGradient(trackWidth, trackHeight, colorScheme.trackTop, colorScheme.trackBottom, trackRadius);
	        const trackBgTexture = graphics().createTexture(trackBgCanvas);
	        this.trackGradientSprite = graphics().createSprite(trackBgTexture);
	        this.trackGradientSprite.x = trackX;
	        this.trackGradientSprite.y = trackY;
	        if (disabled)
	            this.trackGradientSprite.alpha = alpha;
	        // Insert after trackGraphics
	        const trackIndex = this.container.getChildIndex(this.trackGraphics);
	        this.container.addChild(this.trackGradientSprite);
	        this.container.setChildIndex(this.trackGradientSprite, trackIndex + 1);
	        // Layer 4: Fill (progress) with gradient
	        const fillWidth = Math.max(trackHeight, (thumbX - trackX + thumbRadius));
	        if (fillWidth > trackHeight) {
	            const fillCanvas = createTrackGradient(fillWidth, trackHeight, colorScheme.fillTop, colorScheme.fillBottom, trackRadius);
	            const fillTexture = graphics().createTexture(fillCanvas);
	            this.fillGradientSprite = graphics().createSprite(fillTexture);
	            this.fillGradientSprite.x = trackX;
	            this.fillGradientSprite.y = trackY;
	            if (disabled)
	                this.fillGradientSprite.alpha = alpha;
	            // Insert after track gradient
	            const fillIndex = this.container.getChildIndex(this.trackGradientSprite);
	            this.container.addChild(this.fillGradientSprite);
	            this.container.setChildIndex(this.fillGradientSprite, fillIndex + 1);
	        }
	        // Inner shadow on track (subtle)
	        this.trackGraphics.roundRect(trackX + 2, trackY + 1, trackWidth - 4, 3, 1.5);
	        this.trackGraphics.fill({ color: 0x000000, alpha: 0.15 * alpha });
	        // Layer 5: Thumb
	        // Thumb shadow
	        this.thumbGraphics.circle(thumbX + 1, thumbY + 2, thumbRadius);
	        this.thumbGraphics.fill({ color: 0x000000, alpha: 0.3 * alpha });
	        // Thumb base (darker bottom color)
	        this.thumbGraphics.circle(thumbX, thumbY, thumbRadius);
	        this.thumbGraphics.fill({ color: colorScheme.thumbBottom, alpha });
	        // Thumb gradient effect (lighter top half)
	        this.thumbGraphics.ellipse(thumbX, thumbY - thumbRadius * 0.15, thumbRadius * 0.9, thumbRadius * 0.7);
	        this.thumbGraphics.fill({ color: colorScheme.thumbTop, alpha });
	        // Thumb specular highlight (small bright spot)
	        this.thumbGraphics.ellipse(thumbX - thumbRadius * 0.25, thumbY - thumbRadius * 0.35, thumbRadius * 0.35, thumbRadius * 0.2);
	        this.thumbGraphics.fill({ color: 0xFFFFFF, alpha: 0.6 * alpha });
	        // Rim light on thumb
	        this.thumbGraphics.roundRect(thumbX - thumbRadius * 0.6, thumbY - thumbRadius + 2, thumbRadius * 1.2, 2, 1);
	        this.thumbGraphics.fill({ color: 0xFFFFFF, alpha: 0.3 * alpha });
	    }
	    /**
	     * Setup interaction handlers
	     */
	    setupInteraction() {
	        this.container.eventMode = 'static';
	        this.container.cursor = this.config.disabled ? 'default' : 'pointer';
	        const { width, height } = this.config;
	        this.container.hitArea = {
	            contains: (x, y) => {
	                return x >= 0 && x <= width && y >= 0 && y <= height + 3;
	            }
	        };
	        this.container.on('pointerdown', this.onPointerDown.bind(this));
	        this.container.on('pointermove', this.onPointerMove.bind(this));
	        this.container.on('pointerup', this.onPointerUp.bind(this));
	        this.container.on('pointerupoutside', this.onPointerUpOutside.bind(this));
	    }
	    onPointerDown(event) {
	        if (this.config.disabled)
	            return;
	        this.isDragging = true;
	        this.isPressed = true;
	        this.updateValueFromPointer(event);
	    }
	    onPointerMove(event) {
	        if (this.config.disabled || !this.isDragging)
	            return;
	        this.updateValueFromPointer(event);
	    }
	    onPointerUp() {
	        if (this.config.disabled)
	            return;
	        this.isDragging = false;
	        this.isPressed = false;
	        this.render();
	    }
	    onPointerUpOutside() {
	        if (this.config.disabled)
	            return;
	        this.isDragging = false;
	        this.isPressed = false;
	        this.render();
	    }
	    updateValueFromPointer(event) {
	        const { width, height } = this.config;
	        const borderWidth = 3;
	        const trackPadding = 4;
	        const thumbRadius = (height - 8) / 2;
	        const thumbMinX = borderWidth + trackPadding + thumbRadius;
	        const thumbMaxX = width - borderWidth - trackPadding - thumbRadius;
	        const thumbRange = thumbMaxX - thumbMinX;
	        // Get local position
	        const localPos = event.getLocalPosition(this.container);
	        const x = localPos.x;
	        // Calculate normalized value
	        let normalized = (x - thumbMinX) / thumbRange;
	        normalized = Math.max(0, Math.min(1, normalized));
	        this.setFromNormalized(normalized);
	    }
	    /**
	     * Get current value
	     */
	    getValue() {
	        return this._value;
	    }
	    /**
	     * Set value
	     */
	    setValue(value) {
	        const clampedValue = Math.max(this.config.min, Math.min(this.config.max, value));
	        if (this._value !== clampedValue) {
	            this._value = clampedValue;
	            this.render();
	            this.emit('change', this._value);
	        }
	    }
	    /**
	     * Set disabled state
	     */
	    setDisabled(disabled) {
	        this.config.disabled = disabled;
	        this.container.cursor = disabled ? 'default' : 'pointer';
	        this.render();
	    }
	    /**
	     * Check if disabled
	     */
	    isDisabled() {
	        return this.config.disabled;
	    }
	    /**
	     * Set position
	     */
	    setPosition(x, y) {
	        this.container.x = x;
	        this.container.y = y;
	    }
	    /**
	     * Get position
	     */
	    getPosition() {
	        return { x: this.container.x, y: this.container.y };
	    }
	    /**
	     * Get the container
	     */
	    getContainer() {
	        return this.container;
	    }
	    /**
	     * Set color scheme
	     */
	    setColorScheme(scheme) {
	        this.config.colorScheme = scheme;
	        this.render();
	    }
	    /**
	     * Get size
	     */
	    getSize() {
	        return { width: this.config.width, height: this.config.height };
	    }
	    /**
	     * Destroy the slider
	     */
	    destroy() {
	        this.container.destroy();
	        this.removeAllListeners();
	    }
	}
	// Default color scheme - blue game style
	GameSlider.DEFAULT_SCHEME = {
	    trackTop: 0x4A5660,
	    trackBottom: 0x3A4650,
	    fillTop: 0x5DADE2,
	    fillBottom: 0x2E86C1,
	    thumbTop: 0xFFFFFF,
	    thumbBottom: 0xE8E8E8,
	    border: 0x3D4F5F,
	    borderDepth: 0x2A3640,
	};
	/**
	 * Pre-defined slider color schemes - game style
	 */
	const GameSliderColors = {
	    // Default blue slider
	    DEFAULT: {
	        trackTop: 0x4A5660,
	        trackBottom: 0x3A4650,
	        fillTop: 0x5DADE2,
	        fillBottom: 0x2E86C1,
	        thumbTop: 0xFFFFFF,
	        thumbBottom: 0xE8E8E8,
	        border: 0x3D4F5F,
	        borderDepth: 0x2A3640,
	    },
	    // Green slider
	    GREEN: {
	        trackTop: 0x4A5660,
	        trackBottom: 0x3A4650,
	        fillTop: 0x7ED321,
	        fillBottom: 0x5BA017,
	        thumbTop: 0xFFFFFF,
	        thumbBottom: 0xE8E8E8,
	        border: 0x3D4F5F,
	        borderDepth: 0x2A3640,
	    },
	    // Orange slider
	    ORANGE: {
	        trackTop: 0x4A5660,
	        trackBottom: 0x3A4650,
	        fillTop: 0xF5B041,
	        fillBottom: 0xD68910,
	        thumbTop: 0xFFFFFF,
	        thumbBottom: 0xE8E8E8,
	        border: 0x3D4F5F,
	        borderDepth: 0x2A3640,
	    },
	    // Purple slider
	    PURPLE: {
	        trackTop: 0x4A5660,
	        trackBottom: 0x3A4650,
	        fillTop: 0xBB8FCE,
	        fillBottom: 0x8E44AD,
	        thumbTop: 0xFFFFFF,
	        thumbBottom: 0xE8E8E8,
	        border: 0x3D4F5F,
	        borderDepth: 0x2A3640,
	    },
	    // Red slider
	    RED: {
	        trackTop: 0x4A5660,
	        trackBottom: 0x3A4650,
	        fillTop: 0xE74C3C,
	        fillBottom: 0xC0392B,
	        thumbTop: 0xFFFFFF,
	        thumbBottom: 0xE8E8E8,
	        border: 0x3D4F5F,
	        borderDepth: 0x2A3640,
	    },
	};

	/**
	 * ScreenManager - Stack-based screen navigation with animated transitions
	 *
	 * Features:
	 * - Stack-based navigation (push, pop, replace)
	 * - Animated transitions (slide, fade)
	 * - Screen lifecycle management
	 * - Back button handling
	 *
	 * @example
	 * ```typescript
	 * const screenManager = new ScreenManager({
	 *   container: stage,
	 *   width: 720,
	 *   height: 1280
	 * });
	 *
	 * // Push a new screen
	 * screenManager.push(new HubScreen());
	 *
	 * // Pop back
	 * screenManager.pop();
	 *
	 * // Replace current screen
	 * screenManager.replace(new GameHUDScreen());
	 * ```
	 */
	class ScreenManager extends EventEmitter {
	    constructor(config) {
	        super();
	        this.screenStack = [];
	        this.isTransitioning = false;
	        this.config = {
	            container: config.container,
	            width: config.width,
	            height: config.height,
	            defaultTransition: config.defaultTransition || 'slide',
	            transitionDuration: config.transitionDuration || 300,
	        };
	        this.parentContainer = config.container;
	        // Create screen container
	        this.screenContainer = graphics().createContainer();
	        this.parentContainer.addChild(this.screenContainer);
	    }
	    /**
	     * Push a new screen onto the stack
	     */
	    async push(screen, transition, data) {
	        if (this.isTransitioning) {
	            console.warn('ScreenManager: Already transitioning, ignoring push');
	            return;
	        }
	        this.isTransitioning = true;
	        const transitionType = transition || this.config.defaultTransition;
	        const currentScreen = this.getCurrentScreen();
	        // Add screen to stack
	        this.screenStack.push(screen);
	        // Initialize screen
	        screen.initialize(this.config.width, this.config.height);
	        this.screenContainer.addChild(screen.getContainer());
	        // Animate transition
	        if (currentScreen && transitionType !== 'none') {
	            await this.animateTransition(currentScreen, screen, transitionType, 'in', data);
	        }
	        else {
	            await screen.show(data);
	        }
	        this.isTransitioning = false;
	        this.emit('screen-pushed', screen);
	    }
	    /**
	     * Pop the current screen from the stack
	     */
	    async pop(transition) {
	        if (this.isTransitioning) {
	            console.warn('ScreenManager: Already transitioning, ignoring pop');
	            return null;
	        }
	        if (this.screenStack.length <= 1) {
	            console.warn('ScreenManager: Cannot pop last screen');
	            return null;
	        }
	        this.isTransitioning = true;
	        const transitionType = transition || this.config.defaultTransition;
	        // Get screens
	        const poppedScreen = this.screenStack.pop();
	        const targetScreen = this.getCurrentScreen();
	        // Animate transition
	        if (transitionType !== 'none') {
	            await this.animateTransition(poppedScreen, targetScreen, transitionType, 'out');
	        }
	        else {
	            await poppedScreen.hide();
	            await targetScreen.show();
	        }
	        // Remove popped screen
	        this.screenContainer.removeChild(poppedScreen.getContainer());
	        poppedScreen.destroy();
	        this.isTransitioning = false;
	        this.emit('screen-popped', poppedScreen);
	        return poppedScreen;
	    }
	    /**
	     * Replace the current screen with a new one
	     */
	    async replace(screen, transition, data) {
	        if (this.isTransitioning) {
	            console.warn('ScreenManager: Already transitioning, ignoring replace');
	            return null;
	        }
	        if (this.screenStack.length === 0) {
	            // No current screen, just push
	            await this.push(screen, transition, data);
	            return null;
	        }
	        this.isTransitioning = true;
	        const transitionType = transition || this.config.defaultTransition;
	        // Get current screen
	        const replacedScreen = this.screenStack.pop();
	        // Add new screen
	        this.screenStack.push(screen);
	        screen.initialize(this.config.width, this.config.height);
	        this.screenContainer.addChild(screen.getContainer());
	        // Animate transition
	        if (transitionType !== 'none') {
	            await this.animateTransition(replacedScreen, screen, transitionType, 'in', data);
	        }
	        else {
	            await replacedScreen.hide();
	            await screen.show(data);
	        }
	        // Remove replaced screen
	        this.screenContainer.removeChild(replacedScreen.getContainer());
	        replacedScreen.destroy();
	        this.isTransitioning = false;
	        this.emit('screen-replaced', { old: replacedScreen, new: screen });
	        return replacedScreen;
	    }
	    /**
	     * Pop all screens and return to the first screen
	     */
	    async popToRoot(transition) {
	        if (this.screenStack.length <= 1)
	            return;
	        while (this.screenStack.length > 1) {
	            const isLast = this.screenStack.length === 2;
	            await this.pop(isLast ? transition : 'none');
	        }
	    }
	    /**
	     * Get the current (top) screen
	     */
	    getCurrentScreen() {
	        return this.screenStack.length > 0
	            ? this.screenStack[this.screenStack.length - 1]
	            : null;
	    }
	    /**
	     * Get the number of screens in the stack
	     */
	    getScreenCount() {
	        return this.screenStack.length;
	    }
	    /**
	     * Check if a screen type exists in the stack
	     */
	    hasScreen(screenName) {
	        return this.screenStack.some((s) => s.screenName === screenName);
	    }
	    /**
	     * Handle back button press
	     */
	    handleBackButton() {
	        const currentScreen = this.getCurrentScreen();
	        if (currentScreen && currentScreen.onBackButton()) {
	            return true;
	        }
	        if (this.screenStack.length > 1) {
	            this.pop();
	            return true;
	        }
	        return false;
	    }
	    /**
	     * Set the default transition type
	     */
	    setDefaultTransition(transition) {
	        this.config.defaultTransition = transition;
	    }
	    /**
	     * Set the transition duration
	     */
	    setTransitionDuration(duration) {
	        this.config.transitionDuration = duration;
	    }
	    /**
	     * Animate transition between screens
	     */
	    async animateTransition(fromScreen, toScreen, type, direction, data) {
	        const duration = this.config.transitionDuration;
	        switch (type) {
	            case 'slide':
	                await this.slideTransition(fromScreen, toScreen, direction, duration, data);
	                break;
	            case 'fade':
	                await this.fadeTransition(fromScreen, toScreen, duration, data);
	                break;
	            default:
	                // No animation
	                await fromScreen.hide();
	                await toScreen.show(data);
	        }
	    }
	    /**
	     * Slide transition animation
	     */
	    async slideTransition(fromScreen, toScreen, direction, duration, data) {
	        const { width } = this.config;
	        const fromContainer = fromScreen.getContainer();
	        const toContainer = toScreen.getContainer();
	        if (direction === 'in') {
	            // New screen slides in from right
	            toContainer.x = width;
	            toContainer.visible = true;
	            toContainer.alpha = 1;
	            await Promise.all([
	                this.animateX(fromContainer, 0, -width, duration),
	                this.animateX(toContainer, width, 0, duration),
	            ]);
	            fromContainer.visible = false;
	            this.emit('transition-complete', { from: fromScreen, to: toScreen });
	        }
	        else {
	            // New screen reveals from left
	            toContainer.x = -width;
	            toContainer.visible = true;
	            toContainer.alpha = 1;
	            await Promise.all([
	                this.animateX(fromContainer, 0, width, duration),
	                this.animateX(toContainer, -width, 0, duration),
	            ]);
	            fromContainer.visible = false;
	            this.emit('transition-complete', { from: fromScreen, to: toScreen });
	        }
	    }
	    /**
	     * Fade transition animation
	     */
	    async fadeTransition(fromScreen, toScreen, duration, data) {
	        const fromContainer = fromScreen.getContainer();
	        const toContainer = toScreen.getContainer();
	        toContainer.alpha = 0;
	        toContainer.visible = true;
	        await Promise.all([
	            this.animateAlpha(fromContainer, 1, 0, duration),
	            this.animateAlpha(toContainer, 0, 1, duration),
	        ]);
	        fromContainer.visible = false;
	        this.emit('transition-complete', { from: fromScreen, to: toScreen });
	    }
	    /**
	     * Animate X position
	     */
	    animateX(container, from, to, duration) {
	        container.x = from;
	        return animate({
	            duration,
	            easing: Easing.easeOutCubic,
	            onUpdate: (_, eased) => {
	                container.x = lerp(from, to, eased);
	            },
	        });
	    }
	    /**
	     * Animate alpha
	     */
	    animateAlpha(container, from, to, duration) {
	        container.alpha = from;
	        return animate({
	            duration,
	            easing: Easing.easeOutCubic,
	            onUpdate: (_, eased) => {
	                container.alpha = lerp(from, to, eased);
	            },
	        });
	    }
	    /**
	     * Resize all screens
	     */
	    resize(width, height) {
	        this.config.width = width;
	        this.config.height = height;
	        this.screenStack.forEach((screen) => {
	            screen.resize(width, height);
	        });
	        this.emit('resize', { width, height });
	    }
	    /**
	     * Destroy the screen manager
	     */
	    destroy() {
	        // Destroy all screens
	        this.screenStack.forEach((screen) => {
	            screen.destroy();
	        });
	        this.screenStack = [];
	        this.screenContainer.destroy({ children: true });
	        this.removeAllListeners();
	    }
	}

	/**
	 * PanelManager - Manages overlay panels (modals, sheets, fullscreen)
	 *
	 * Features:
	 * - Multiple panel support (stacking)
	 * - Z-order management
	 * - Auto-initialization with screen size
	 * - Close all / close top functionality
	 *
	 * @example
	 * ```typescript
	 * const panelManager = new PanelManager({
	 *   container: stage,
	 *   screenWidth: 720,
	 *   screenHeight: 1280
	 * });
	 *
	 * // Show a modal
	 * const modal = new GameModalPanel({ title: 'Settings' });
	 * panelManager.show(modal);
	 *
	 * // Close top panel
	 * panelManager.closeTop();
	 *
	 * // Close all panels
	 * panelManager.closeAll();
	 * ```
	 */
	class PanelManager extends EventEmitter {
	    constructor(config) {
	        super();
	        this.activePanels = [];
	        this.config = config;
	        this.container = config.container;
	        // Create panel container layer
	        this.panelContainer = graphics().createContainer();
	        this.container.addChild(this.panelContainer);
	    }
	    /**
	     * Show a panel
	     */
	    async show(panel) {
	        // Initialize panel with screen dimensions
	        panel.initialize(this.config.screenWidth, this.config.screenHeight);
	        // Add to active panels
	        this.activePanels.push(panel);
	        // Add to container
	        this.panelContainer.addChild(panel.getContainer());
	        // Listen for close event
	        panel.once('close', () => {
	            this.removePanel(panel);
	        });
	        // Show with animation
	        await panel.show();
	        this.emit('panel-shown', panel);
	    }
	    /**
	     * Close the top (most recent) panel
	     */
	    async closeTop() {
	        if (this.activePanels.length === 0) {
	            return null;
	        }
	        const topPanel = this.activePanels[this.activePanels.length - 1];
	        await topPanel.close();
	        return topPanel;
	    }
	    /**
	     * Close all panels
	     */
	    async closeAll() {
	        // Close in reverse order
	        const panels = [...this.activePanels].reverse();
	        for (const panel of panels) {
	            await panel.close();
	        }
	    }
	    /**
	     * Remove a panel from management
	     */
	    removePanel(panel) {
	        const index = this.activePanels.indexOf(panel);
	        if (index !== -1) {
	            this.activePanels.splice(index, 1);
	        }
	        // Remove from container (try to remove, safe if not a child)
	        const container = panel.getContainer();
	        try {
	            this.panelContainer.removeChild(container);
	        }
	        catch {
	            // Panel was not a child of panelContainer, ignore
	        }
	        // Destroy panel to free resources and prevent memory leaks
	        panel.destroy();
	        this.emit('panel-closed', panel);
	    }
	    /**
	     * Close a specific panel
	     */
	    async close(panel) {
	        if (this.activePanels.includes(panel)) {
	            await panel.close();
	        }
	    }
	    /**
	     * Check if any panels are active
	     */
	    hasActivePanels() {
	        return this.activePanels.length > 0;
	    }
	    /**
	     * Get the number of active panels
	     */
	    getPanelCount() {
	        return this.activePanels.length;
	    }
	    /**
	     * Get the top panel
	     */
	    getTopPanel() {
	        return this.activePanels.length > 0
	            ? this.activePanels[this.activePanels.length - 1]
	            : null;
	    }
	    /**
	     * Handle back button (closes top panel if any)
	     */
	    handleBackButton() {
	        if (this.activePanels.length > 0) {
	            this.closeTop();
	            return true;
	        }
	        return false;
	    }
	    /**
	     * Resize panels when screen size changes
	     */
	    resize(screenWidth, screenHeight) {
	        this.config.screenWidth = screenWidth;
	        this.config.screenHeight = screenHeight;
	        // Re-initialize all active panels
	        this.activePanels.forEach((panel) => {
	            panel.initialize(screenWidth, screenHeight);
	        });
	        this.emit('resize', { width: screenWidth, height: screenHeight });
	    }
	    /**
	     * Bring panel container to front
	     */
	    bringToFront() {
	        // Use the stored container reference instead of relying on parent property
	        try {
	            this.container.removeChild(this.panelContainer);
	            this.container.addChild(this.panelContainer);
	        }
	        catch {
	            // panelContainer was not a child of container, ignore
	        }
	    }
	    /**
	     * Destroy the panel manager
	     */
	    destroy() {
	        // Destroy all panels
	        this.activePanels.forEach((panel) => {
	            panel.destroy();
	        });
	        this.activePanels = [];
	        this.panelContainer.destroy({ children: true });
	        this.removeAllListeners();
	    }
	}

	/**
	 * Default panel theme
	 */
	const DEFAULT_PANEL_THEME = {
	    background: 0x2A3142,
	    backgroundAlpha: 0.98,
	    border: 0x3D4F5F,
	    borderWidth: 4,
	    overlay: 0x000000,
	    overlayAlpha: 0.6,
	    title: 0xFFFFFF,
	    titleStroke: 0x1A1A2A,
	};
	/**
	 * GamePanel - Base class for all panel types
	 *
	 * Provides common functionality:
	 * - Container hierarchy (overlay, panel, content)
	 * - Show/hide with animation
	 * - Close button
	 * - Theme support
	 *
	 * @example
	 * ```typescript
	 * // Extend GamePanel for custom panels
	 * class MyPanel extends GamePanel {
	 *   protected async animateShow(): Promise<void> {
	 *     // Custom animation
	 *   }
	 * }
	 * ```
	 */
	class GamePanel extends EventEmitter {
	    constructor(config = {}) {
	        super();
	        this._isVisible = false;
	        this.config = {
	            width: config.width || 350,
	            height: config.height || 400,
	            title: config.title || '',
	            showCloseButton: config.showCloseButton ?? true,
	            closeOnOverlay: config.closeOnOverlay ?? true,
	            theme: config.theme || {},
	            borderRadius: config.borderRadius || 20,
	            onClose: config.onClose || (() => { }),
	        };
	        this.theme = { ...DEFAULT_PANEL_THEME, ...config.theme };
	        const factory = graphics();
	        // Create container hierarchy
	        this.container = factory.createContainer();
	        this.container.visible = false;
	        // Overlay
	        this.overlay = factory.createGraphics();
	        this.container.addChild(this.overlay);
	        // Panel container (for positioning)
	        this.panelContainer = factory.createContainer();
	        this.container.addChild(this.panelContainer);
	        // Background
	        this.backgroundGraphics = factory.createGraphics();
	        this.panelContainer.addChild(this.backgroundGraphics);
	        // Content container
	        this.contentContainer = factory.createContainer();
	        this.panelContainer.addChild(this.contentContainer);
	        // Setup overlay interaction
	        if (this.config.closeOnOverlay) {
	            this.setupOverlayInteraction();
	        }
	    }
	    /**
	     * Initialize panel with screen dimensions
	     */
	    initialize(screenWidth, screenHeight) {
	        // Draw overlay
	        this.drawOverlay(screenWidth, screenHeight);
	        // Draw panel background
	        this.drawBackground();
	        // Create title if provided
	        if (this.config.title) {
	            this.createTitle();
	        }
	        // Create close button
	        if (this.config.showCloseButton) {
	            this.createCloseButton();
	        }
	        // Position content container
	        this.positionContent();
	        // Abstract method for specific positioning
	        this.positionPanel(screenWidth, screenHeight);
	    }
	    /**
	     * Draw the overlay background
	     */
	    drawOverlay(width, height) {
	        this.overlay.clear();
	        this.overlay.rect(0, 0, width, height);
	        this.overlay.fill({
	            color: this.theme.overlay || 0x000000,
	            alpha: this.theme.overlayAlpha || 0.6,
	        });
	    }
	    /**
	     * Draw panel background
	     */
	    drawBackground() {
	        const { width, height, borderRadius } = this.config;
	        this.backgroundGraphics.clear();
	        // Shadow
	        this.backgroundGraphics.roundRect(4, 4, width, height, borderRadius);
	        this.backgroundGraphics.fill({ color: 0x000000, alpha: 0.3 });
	        // Border
	        this.backgroundGraphics.roundRect(0, 0, width, height, borderRadius);
	        this.backgroundGraphics.fill({ color: this.theme.border });
	        // Background
	        const borderWidth = this.theme.borderWidth || 4;
	        this.backgroundGraphics.roundRect(borderWidth, borderWidth, width - borderWidth * 2, height - borderWidth * 2, borderRadius - borderWidth);
	        this.backgroundGraphics.fill({
	            color: this.theme.background,
	            alpha: this.theme.backgroundAlpha,
	        });
	    }
	    /**
	     * Create title text
	     */
	    createTitle() {
	        this.titleText = graphics().createText(this.config.title, {
	            fontFamily: '"Lilita One", "Arial Black", sans-serif',
	            fontSize: 24,
	            fontWeight: 'bold',
	            fill: this.theme.title || 0xFFFFFF,
	            stroke: this.theme.titleStroke || 0x1A1A2A,
	            strokeThickness: 3,
	            align: 'center',
	        });
	        if (this.titleText.anchor) {
	            this.titleText.anchor.set(0.5, 0);
	        }
	        this.titleText.x = this.config.width / 2;
	        this.titleText.y = 15;
	        this.panelContainer.addChild(this.titleText);
	    }
	    /**
	     * Create close button
	     */
	    createCloseButton() {
	        const factory = graphics();
	        this.closeButton = factory.createContainer();
	        const buttonSize = 36;
	        const buttonRadius = buttonSize / 2;
	        // Background
	        const bg = factory.createGraphics();
	        bg.circle(0, 0, buttonRadius);
	        bg.fill({ color: 0xE84C4C });
	        bg.stroke({ color: 0x8B2020, width: 3 });
	        this.closeButton.addChild(bg);
	        // X icon
	        const xGraphics = factory.createGraphics();
	        const xSize = 8;
	        xGraphics.moveTo(-xSize, -xSize);
	        xGraphics.lineTo(xSize, xSize);
	        xGraphics.moveTo(xSize, -xSize);
	        xGraphics.lineTo(-xSize, xSize);
	        xGraphics.stroke({ width: 3, color: 0xFFFFFF, cap: 'round' });
	        this.closeButton.addChild(xGraphics);
	        // Position at top right
	        this.closeButton.x = this.config.width - buttonSize / 2 - 10;
	        this.closeButton.y = buttonSize / 2 + 10;
	        // Interaction
	        this.closeButton.eventMode = 'static';
	        this.closeButton.cursor = 'pointer';
	        this.closeButton.on('pointerdown', () => {
	            this.closeButton.scale.x = 0.9;
	            this.closeButton.scale.y = 0.9;
	        });
	        this.closeButton.on('pointerup', () => {
	            this.closeButton.scale.x = 1;
	            this.closeButton.scale.y = 1;
	            this.close();
	        });
	        this.closeButton.on('pointerupoutside', () => {
	            this.closeButton.scale.x = 1;
	            this.closeButton.scale.y = 1;
	        });
	        this.panelContainer.addChild(this.closeButton);
	    }
	    /**
	     * Setup overlay click to close
	     */
	    setupOverlayInteraction() {
	        this.overlay.eventMode = 'static';
	        this.overlay.cursor = 'pointer';
	        this.overlay.on('pointerup', () => {
	            this.close();
	        });
	    }
	    /**
	     * Position content container
	     */
	    positionContent() {
	        const padding = 20;
	        const titleHeight = this.config.title ? 50 : 0;
	        this.contentContainer.x = padding;
	        this.contentContainer.y = titleHeight + padding;
	    }
	    /**
	     * Show the panel
	     */
	    async show() {
	        if (this._isVisible)
	            return;
	        this._isVisible = true;
	        this.container.visible = true;
	        await this.animateShow();
	        this.emit('show');
	    }
	    /**
	     * Hide the panel
	     */
	    async hide() {
	        if (!this._isVisible)
	            return;
	        await this.animateHide();
	        this._isVisible = false;
	        this.container.visible = false;
	        this.emit('hide');
	    }
	    /**
	     * Close the panel (triggers callback)
	     */
	    async close() {
	        await this.hide();
	        this.config.onClose();
	        this.emit('close');
	    }
	    /**
	     * Add content to the panel
	     */
	    addContent(child) {
	        this.contentContainer.addChild(child);
	    }
	    /**
	     * Remove content from the panel
	     */
	    removeContent(child) {
	        this.contentContainer.removeChild(child);
	    }
	    /**
	     * Clear all content
	     */
	    clearContent() {
	        this.contentContainer.removeChildren();
	    }
	    /**
	     * Get content container for direct manipulation
	     */
	    getContentContainer() {
	        return this.contentContainer;
	    }
	    /**
	     * Get content area dimensions
	     */
	    getContentSize() {
	        const padding = 20;
	        const titleHeight = this.config.title ? 50 : 0;
	        return {
	            width: this.config.width - padding * 2,
	            height: this.config.height - titleHeight - padding * 2,
	        };
	    }
	    /**
	     * Check if panel is visible
	     */
	    isVisible() {
	        return this._isVisible;
	    }
	    /**
	     * Get the main container
	     */
	    getContainer() {
	        return this.container;
	    }
	    /**
	     * Update theme
	     */
	    setTheme(theme) {
	        this.theme = { ...this.theme, ...theme };
	        this.drawBackground();
	        if (this.titleText) {
	            this.titleText.style.fill = this.theme.title || 0xFFFFFF;
	        }
	    }
	    /**
	     * Set title text
	     */
	    setTitle(title) {
	        if (this.titleText) {
	            this.titleText.text = title;
	        }
	    }
	    /**
	     * Destroy the panel
	     */
	    destroy() {
	        this.container.destroy({ children: true });
	        this.removeAllListeners();
	    }
	}

	/**
	 * GameModalPanel - Centered modal panel with scale animation
	 *
	 * Features:
	 * - Centered positioning
	 * - Scale in/out animation
	 * - Dark overlay
	 * - Close on overlay tap
	 *
	 * @example
	 * ```typescript
	 * const modal = new GameModalPanel({
	 *   width: 350,
	 *   height: 400,
	 *   title: 'Settings',
	 *   onClose: () => console.log('Modal closed')
	 * });
	 *
	 * panelManager.show(modal);
	 * ```
	 */
	class GameModalPanel extends GamePanel {
	    constructor(config = {}) {
	        super(config);
	        this.centerX = 0;
	        this.centerY = 0;
	        this.animationDuration = config.animationDuration || 250;
	    }
	    /**
	     * Position panel at center of screen
	     */
	    positionPanel(screenWidth, screenHeight) {
	        // Store the center position for scaling calculations
	        this.centerX = (screenWidth - this.config.width) / 2;
	        this.centerY = (screenHeight - this.config.height) / 2;
	        this.panelContainer.x = this.centerX;
	        this.panelContainer.y = this.centerY;
	    }
	    /**
	     * Helper to set scale and adjust position to scale from center
	     */
	    setScaleFromCenter(scale) {
	        this.panelContainer.scale.x = scale;
	        this.panelContainer.scale.y = scale;
	        // Offset position to maintain visual center during scale
	        const offset = (1 - scale) * this.config.width / 2;
	        const offsetY = (1 - scale) * this.config.height / 2;
	        this.panelContainer.x = this.centerX + offset;
	        this.panelContainer.y = this.centerY + offsetY;
	    }
	    /**
	     * Scale-in animation
	     */
	    async animateShow() {
	        this.setScaleFromCenter(0.8);
	        this.panelContainer.alpha = 0;
	        this.overlay.alpha = 0;
	        const overlayAlpha = this.theme.overlayAlpha || 0.6;
	        return animate({
	            duration: this.animationDuration,
	            easing: Easing.easeOutBack,
	            onUpdate: (progress, eased) => {
	                this.setScaleFromCenter(lerp(0.8, 1, eased));
	                this.panelContainer.alpha = progress;
	                this.overlay.alpha = overlayAlpha * progress;
	            },
	        });
	    }
	    /**
	     * Scale-out animation
	     */
	    async animateHide() {
	        const overlayAlpha = this.theme.overlayAlpha || 0.6;
	        return animate({
	            duration: this.animationDuration * 0.8,
	            easing: Easing.easeInCubic,
	            onUpdate: (progress, eased) => {
	                this.setScaleFromCenter(lerp(1, 0.8, eased));
	                this.panelContainer.alpha = 1 - progress;
	                this.overlay.alpha = overlayAlpha * (1 - progress);
	            },
	        });
	    }
	}

	/**
	 * GameBottomSheet - Slide-up panel from bottom
	 *
	 * Features:
	 * - Slides up from bottom
	 * - Drag handle for closing
	 * - Swipe down to close
	 * - Height options: fixed, auto, half, full
	 *
	 * @example
	 * ```typescript
	 * const sheet = new GameBottomSheet({
	 *   height: 'half',
	 *   title: 'Select Item',
	 *   showHandle: true,
	 *   dragToClose: true
	 * });
	 *
	 * panelManager.show(sheet);
	 * ```
	 */
	class GameBottomSheet extends GamePanel {
	    constructor(config = {}) {
	        // Store original height config for recalculation in initialize()
	        const heightConfig = config.height ?? 'auto';
	        // Use temporary height, will be recalculated in initialize() with actual screen dimensions
	        const numericHeight = GameBottomSheet.resolveHeight(heightConfig, 1280);
	        super({
	            ...config,
	            height: numericHeight,
	            borderRadius: config.borderRadius || 24,
	        });
	        this.screenHeight = 0;
	        this.isDragging = false;
	        this.dragStartY = 0;
	        this.panelStartY = 0;
	        this.originalHeightConfig = heightConfig;
	        this.animationDuration = config.animationDuration || 300;
	        this.showHandle = config.showHandle ?? true;
	        this.dragToClose = config.dragToClose ?? true;
	    }
	    /**
	     * Resolve height value to pixels
	     */
	    static resolveHeight(height, screenHeight) {
	        if (typeof height === 'number') {
	            return height;
	        }
	        switch (height) {
	            case 'half':
	                return screenHeight * 0.5;
	            case 'full':
	                return screenHeight * 0.9;
	            case 'auto':
	            default:
	                return 400;
	        }
	    }
	    /**
	     * Override initialize to handle screen height
	     */
	    initialize(screenWidth, screenHeight) {
	        this.screenHeight = screenHeight;
	        // Recalculate height with actual screen dimensions
	        this.config.height = GameBottomSheet.resolveHeight(this.originalHeightConfig, screenHeight);
	        // Update config width to match screen
	        this.config.width = screenWidth;
	        super.initialize(screenWidth, screenHeight);
	        // Create handle
	        if (this.showHandle) {
	            this.createHandle();
	        }
	        // Setup drag interaction
	        if (this.dragToClose) {
	            this.setupDragInteraction();
	        }
	    }
	    /**
	     * Override background to have top-only rounded corners
	     */
	    drawBackground() {
	        const { width, height, borderRadius } = this.config;
	        this.backgroundGraphics.clear();
	        // Shadow
	        this.backgroundGraphics.roundRect(0, 0, width, height + 50, borderRadius);
	        this.backgroundGraphics.fill({ color: 0x000000, alpha: 0.3 });
	        // Border
	        this.backgroundGraphics.roundRect(0, 0, width, height + 50, borderRadius);
	        this.backgroundGraphics.fill({ color: this.theme.border });
	        // Background (extend beyond bottom)
	        const borderWidth = this.theme.borderWidth || 4;
	        this.backgroundGraphics.roundRect(borderWidth, borderWidth, width - borderWidth * 2, height + 50 - borderWidth, borderRadius - borderWidth);
	        this.backgroundGraphics.fill({
	            color: this.theme.background,
	            alpha: this.theme.backgroundAlpha,
	        });
	    }
	    /**
	     * Create drag handle
	     */
	    createHandle() {
	        this.handle = graphics().createGraphics();
	        const handleWidth = 40;
	        const handleHeight = 5;
	        this.handle.roundRect((this.config.width - handleWidth) / 2, 10, handleWidth, handleHeight, handleHeight / 2);
	        this.handle.fill({ color: 0x888888, alpha: 0.5 });
	        this.panelContainer.addChild(this.handle);
	    }
	    /**
	     * Setup drag to close interaction
	     */
	    setupDragInteraction() {
	        this.panelContainer.eventMode = 'static';
	        this.panelContainer.on('pointerdown', (event) => {
	            // Only start drag from top area (handle region)
	            const localY = event.data?.getLocalPosition?.(this.panelContainer)?.y || event.global?.y || 0;
	            if (localY < 50) {
	                this.isDragging = true;
	                this.dragStartY = event.global?.y || event.clientY || 0;
	                this.panelStartY = this.panelContainer.y;
	            }
	        });
	        this.panelContainer.on('pointermove', (event) => {
	            if (!this.isDragging)
	                return;
	            const currentY = event.global?.y || event.clientY || 0;
	            const deltaY = currentY - this.dragStartY;
	            // Only allow dragging down
	            if (deltaY > 0) {
	                this.panelContainer.y = this.panelStartY + deltaY;
	            }
	        });
	        this.panelContainer.on('pointerup', (event) => {
	            if (!this.isDragging)
	                return;
	            this.isDragging = false;
	            const currentY = event.global?.y || event.clientY || 0;
	            const deltaY = currentY - this.dragStartY;
	            // If dragged more than 100px, close
	            if (deltaY > 100) {
	                this.close();
	            }
	            else {
	                // Snap back
	                this.animateSnapBack();
	            }
	        });
	        this.panelContainer.on('pointerupoutside', () => {
	            if (this.isDragging) {
	                this.isDragging = false;
	                this.animateSnapBack();
	            }
	        });
	    }
	    /**
	     * Animate snap back to original position
	     */
	    animateSnapBack() {
	        const startY = this.panelContainer.y;
	        const targetY = this.screenHeight - this.config.height;
	        animate({
	            duration: 200,
	            easing: Easing.easeOutCubic,
	            onUpdate: (_, eased) => {
	                this.panelContainer.y = lerp(startY, targetY, eased);
	            },
	        });
	    }
	    /**
	     * Position panel at bottom of screen
	     */
	    positionPanel(screenWidth, screenHeight) {
	        this.panelContainer.x = 0;
	        this.panelContainer.y = screenHeight; // Start below screen
	    }
	    /**
	     * Position content with more padding for handle
	     */
	    positionContent() {
	        const padding = 20;
	        const handleHeight = this.showHandle ? 30 : 0;
	        const titleHeight = this.config.title ? 50 : 0;
	        this.contentContainer.x = padding;
	        this.contentContainer.y = handleHeight + titleHeight + padding;
	    }
	    /**
	     * Override title positioning for handle
	     */
	    createTitle() {
	        super.createTitle();
	        if (this.titleText) {
	            this.titleText.y = this.showHandle ? 30 : 15;
	        }
	    }
	    /**
	     * Override close button positioning for handle
	     */
	    createCloseButton() {
	        super.createCloseButton();
	        if (this.closeButton) {
	            this.closeButton.y = this.showHandle ? 40 : 25;
	        }
	    }
	    /**
	     * Slide-up animation
	     */
	    async animateShow() {
	        const targetY = this.screenHeight - this.config.height;
	        const startY = this.screenHeight;
	        const overlayAlpha = this.theme.overlayAlpha || 0.6;
	        this.panelContainer.y = startY;
	        this.overlay.alpha = 0;
	        return animate({
	            duration: this.animationDuration,
	            easing: Easing.easeOutCubic,
	            onUpdate: (progress, eased) => {
	                this.panelContainer.y = lerp(startY, targetY, eased);
	                this.overlay.alpha = overlayAlpha * progress;
	            },
	        });
	    }
	    /**
	     * Slide-down animation
	     */
	    async animateHide() {
	        const startY = this.panelContainer.y;
	        const targetY = this.screenHeight;
	        const overlayAlpha = this.theme.overlayAlpha || 0.6;
	        return animate({
	            duration: this.animationDuration * 0.8,
	            easing: Easing.easeInCubic,
	            onUpdate: (progress, eased) => {
	                this.panelContainer.y = lerp(startY, targetY, eased);
	                this.overlay.alpha = overlayAlpha * (1 - progress);
	            },
	        });
	    }
	}

	/**
	 * Get graphics factory - requires GraphicsEngine to be initialized
	 * Shared utility for all UI effects
	 */
	function getGraphicsFactory() {
	    if (!GraphicsEngine.isInitialized()) {
	        throw new Error('GraphicsEngine not initialized. Call game.initialize() first.');
	    }
	    return GraphicsEngine.getFactory();
	}

	/**
	 * Default confetti configuration
	 */
	const DEFAULT_CONFIG$1 = {
	    colors: [0xFFD700, 0xFF6B6B, 0x6BCB77, 0x4D96FF, 0xFF69B4, 0xFFFFFF],
	    particleCount: 50,
	    duration: 2000,
	    gravity: 0.5,
	    spread: 60,
	    shapes: ['rect', 'circle'],
	    size: { min: 4, max: 12 },
	};
	/**
	 * ConfettiSystem - Handles confetti particle effects for celebrations
	 *
	 * Three modes:
	 * - rain(): Particles fall from top of screen (victory, level complete)
	 * - burst(x, y): Particles explode from a point (star earned, reward)
	 * - fountain(x, y): Particles shoot up then fall (bonus, jackpot)
	 *
	 * @example
	 * ```typescript
	 * const confetti = new ConfettiSystem(stage);
	 *
	 * // Victory celebration
	 * confetti.rain({ particleCount: 80 });
	 *
	 * // Star earned burst
	 * confetti.burst(starX, starY, { colors: [0xFFD700] });
	 *
	 * // Update in game loop
	 * game.on('update', (dt) => confetti.update(dt));
	 * ```
	 */
	class ConfettiSystem extends EventEmitter {
	    constructor(container, screenWidth = 360, screenHeight = 640) {
	        super();
	        this.particles = [];
	        this.isActive = false;
	        this.pendingParticles = 0; // Track particles being created via setTimeout
	        this.container = container;
	        this.screenWidth = screenWidth;
	        this.screenHeight = screenHeight;
	    }
	    /**
	     * Rain mode - Confetti falls from top of screen
	     * Best for: Victory screens, level complete
	     */
	    rain(config = {}) {
	        const cfg = { ...DEFAULT_CONFIG$1, ...config };
	        this.isActive = true;
	        this.pendingParticles = cfg.particleCount; // Track pending particles
	        for (let i = 0; i < cfg.particleCount; i++) {
	            // Stagger particle creation over time for natural rain effect
	            const delay = (i / cfg.particleCount) * 500;
	            setTimeout(() => {
	                this.pendingParticles--; // Decrement pending count
	                if (!this.isActive)
	                    return;
	                const particle = this.createParticle(Math.random() * this.screenWidth, -20 - Math.random() * 100, (Math.random() - 0.5) * 2, // Slight horizontal drift
	                2 + Math.random() * 3, // Downward velocity
	                cfg);
	                this.particles.push(particle);
	            }, delay);
	        }
	        this.emit('rain-started', cfg.particleCount);
	    }
	    /**
	     * Burst mode - Confetti explodes from a point
	     * Best for: Star earned, reward received
	     */
	    burst(x, y, config = {}) {
	        const cfg = { ...DEFAULT_CONFIG$1, ...config };
	        this.isActive = true;
	        const spreadRad = (cfg.spread * Math.PI) / 180;
	        for (let i = 0; i < cfg.particleCount; i++) {
	            const angle = -Math.PI / 2 + (Math.random() - 0.5) * spreadRad * 2;
	            const speed = 4 + Math.random() * 6;
	            const particle = this.createParticle(x, y, Math.cos(angle) * speed, Math.sin(angle) * speed, cfg);
	            this.particles.push(particle);
	        }
	        this.emit('burst-started', { x, y, count: cfg.particleCount });
	    }
	    /**
	     * Fountain mode - Confetti shoots up then falls
	     * Best for: Bonus, jackpot, special rewards
	     */
	    fountain(x, y, config = {}) {
	        const cfg = { ...DEFAULT_CONFIG$1, ...config };
	        this.isActive = true;
	        const spreadRad = (cfg.spread * Math.PI) / 180 / 2;
	        for (let i = 0; i < cfg.particleCount; i++) {
	            // Angle pointing upward with spread
	            const angle = -Math.PI / 2 + (Math.random() - 0.5) * spreadRad;
	            const speed = 8 + Math.random() * 6;
	            const particle = this.createParticle(x + (Math.random() - 0.5) * 20, y, Math.cos(angle) * speed, Math.sin(angle) * speed, cfg);
	            this.particles.push(particle);
	        }
	        this.emit('fountain-started', { x, y, count: cfg.particleCount });
	    }
	    /**
	     * Create a single confetti particle
	     */
	    createParticle(x, y, vx, vy, config) {
	        const factory = getGraphicsFactory();
	        const graphic = factory.createGraphics();
	        const color = config.colors[Math.floor(Math.random() * config.colors.length)];
	        const shape = config.shapes[Math.floor(Math.random() * config.shapes.length)];
	        const size = config.size.min + Math.random() * (config.size.max - config.size.min);
	        // Draw particle shape
	        this.drawParticleShape(graphic, shape, size, color);
	        graphic.x = x;
	        graphic.y = y;
	        this.container.addChild(graphic);
	        return {
	            graphic,
	            x,
	            y,
	            vx,
	            vy,
	            rotation: Math.random() * Math.PI * 2,
	            rotationSpeed: (Math.random() - 0.5) * 0.3,
	            size,
	            life: 0,
	            maxLife: config.duration,
	            wobbleSpeed: 2 + Math.random() * 4,
	            wobblePhase: Math.random() * Math.PI * 2,
	        };
	    }
	    /**
	     * Draw particle shape
	     * Uses Pixi.js v8 Graphics API with chained methods
	     */
	    drawParticleShape(graphic, shape, size, color) {
	        switch (shape) {
	            case 'rect':
	                graphic.rect(-size / 2, -size / 4, size, size / 2).fill(color);
	                break;
	            case 'circle':
	                graphic.circle(0, 0, size / 2).fill(color);
	                break;
	            case 'star':
	                this.drawStar(graphic, 0, 0, size / 2, color);
	                break;
	        }
	    }
	    /**
	     * Draw a star shape
	     */
	    drawStar(graphic, cx, cy, radius, color) {
	        const points = [];
	        const spikes = 5;
	        const innerRadius = radius * 0.5;
	        for (let i = 0; i < spikes * 2; i++) {
	            const r = i % 2 === 0 ? radius : innerRadius;
	            const angle = (i * Math.PI) / spikes - Math.PI / 2;
	            points.push(cx + Math.cos(angle) * r);
	            points.push(cy + Math.sin(angle) * r);
	        }
	        // Pixi v8: poly().fill(color) with direct color number
	        graphic.poly(points).fill(color);
	    }
	    /**
	     * Update all particles - call every frame
	     */
	    update(deltaTime) {
	        const dt = deltaTime / 1000; // Convert to seconds
	        for (let i = this.particles.length - 1; i >= 0; i--) {
	            const p = this.particles[i];
	            // Update life
	            p.life += deltaTime;
	            // Apply gravity
	            p.vy += DEFAULT_CONFIG$1.gravity * dt * 60;
	            // Apply wobble (horizontal oscillation)
	            const wobble = Math.sin(p.life * 0.01 * p.wobbleSpeed + p.wobblePhase) * 0.5;
	            // Update position
	            p.x += (p.vx + wobble) * dt * 60;
	            p.y += p.vy * dt * 60;
	            // Update rotation
	            p.rotation += p.rotationSpeed;
	            // Apply to graphic
	            p.graphic.x = p.x;
	            p.graphic.y = p.y;
	            p.graphic.rotation = p.rotation;
	            // Fade out in last 30% of life
	            const lifeRatio = p.life / p.maxLife;
	            if (lifeRatio > 0.7) {
	                p.graphic.alpha = 1 - ((lifeRatio - 0.7) / 0.3);
	            }
	            // Remove dead particles
	            if (p.life >= p.maxLife || p.y > this.screenHeight + 50) {
	                this.removeParticle(i);
	            }
	        }
	        // Check if all particles are done (and no pending particles being created)
	        if (this.isActive && this.particles.length === 0 && this.pendingParticles <= 0) {
	            this.isActive = false;
	            this.emit('complete');
	        }
	    }
	    /**
	     * Remove a particle
	     */
	    removeParticle(index) {
	        const particle = this.particles[index];
	        this.container.removeChild(particle.graphic);
	        particle.graphic.destroy();
	        this.particles.splice(index, 1);
	    }
	    /**
	     * Clear all particles immediately
	     */
	    clear() {
	        for (let i = this.particles.length - 1; i >= 0; i--) {
	            this.removeParticle(i);
	        }
	        this.isActive = false;
	        this.emit('cleared');
	    }
	    /**
	     * Resize the system
	     */
	    resize(width, height) {
	        this.screenWidth = width;
	        this.screenHeight = height;
	    }
	    /**
	     * Check if confetti is currently active
	     */
	    getIsActive() {
	        return this.isActive;
	    }
	    /**
	     * Get current particle count
	     */
	    getParticleCount() {
	        return this.particles.length;
	    }
	    /**
	     * Destroy the system
	     */
	    destroy() {
	        this.clear();
	        this.removeAllListeners();
	    }
	}

	/**
	 * Default configurations
	 */
	const DEFAULT_SHIMMER = {
	    width: 40,
	    angle: -25,
	    speed: 500,
	    color: 0xFFFFFF,
	    alpha: 1.0,
	    loop: true,
	    loopDelay: 1000,
	};
	const DEFAULT_SPARKLE = {
	    particleCount: 8,
	    colors: [0xFFFFFF, 0xFFD700, 0xFFF8DC],
	    duration: 600,
	    radius: 30,
	    scale: { min: 0.3, max: 1 },
	};
	/**
	 * ShineEffect - Handles shine/sparkle effects for valuable items
	 *
	 * Two effect types:
	 * - shimmer(): Continuous diagonal light sweep (idle state)
	 * - sparkle(): Burst of star particles (interaction/reward)
	 *
	 * @example
	 * ```typescript
	 * const shine = new ShineEffect(stage);
	 *
	 * // Add shimmer to coin icon (idle)
	 * const shimmerInstance = shine.shimmer(coinIcon);
	 *
	 * // Sparkle on coin collected
	 * await shine.sparkle(coinX, coinY);
	 *
	 * // Stop shimmer when needed
	 * shimmerInstance.stop();
	 * ```
	 */
	class ShineEffect extends EventEmitter {
	    constructor(container) {
	        super();
	        this.shimmers = [];
	        this.sparkles = [];
	        this.container = container;
	    }
	    /**
	     * Add shimmer effect to a target object
	     * Creates a simple light sweep animation across the target
	     * Generates texture from target to use as alpha mask (clips to exact shape)
	     */
	    shimmer(target, config = {}) {
	        const cfg = { ...DEFAULT_SHIMMER, ...config };
	        const factory = getGraphicsFactory();
	        // Get target size for shimmer dimensions
	        const size = this.getTargetBounds(target);
	        const targetWidth = size.width || 40;
	        const targetHeight = size.height || 40;
	        // Create container to hold shimmer and mask
	        const shimmerContainer = factory.createContainer();
	        // Create mask from target's shape
	        let mask;
	        const targetAny = target;
	        const renderer = GraphicsEngine.getRenderer();
	        if (GraphicsEngine.getType() === 'PIXI' && renderer) {
	            try {
	                const rendererObj = renderer;
	                const nativeRenderer = rendererObj.getNativeRenderer?.() || renderer;
	                if (targetAny.texture) {
	                    // Target is a Sprite - use its texture
	                    const maskSprite = factory.createSprite(targetAny.texture);
	                    if (targetAny.anchor) {
	                        maskSprite.anchor?.set(targetAny.anchor.x, targetAny.anchor.y);
	                    }
	                    else {
	                        maskSprite.anchor?.set(0.5, 0.5);
	                    }
	                    mask = maskSprite;
	                }
	                else if (nativeRenderer.generateTexture) {
	                    // Target is Text/Container - generate texture from it
	                    const texture = nativeRenderer.generateTexture(target);
	                    const maskSprite = factory.createSprite(texture);
	                    maskSprite.anchor?.set(0.5, 0.5);
	                    mask = maskSprite;
	                }
	                else {
	                    // Fallback to rectangle
	                    mask = factory.createGraphics();
	                    mask.rect(-targetWidth / 2, -targetHeight / 2, targetWidth, targetHeight);
	                    mask.fill(0xFFFFFF);
	                }
	            }
	            catch (e) {
	                console.warn('ShineEffect: mask creation failed', e);
	                mask = factory.createGraphics();
	                mask.rect(-targetWidth / 2, -targetHeight / 2, targetWidth, targetHeight);
	                mask.fill(0xFFFFFF);
	            }
	        }
	        else {
	            // Fallback: rectangular mask
	            mask = factory.createGraphics();
	            mask.rect(-targetWidth / 2, -targetHeight / 2, targetWidth, targetHeight);
	            mask.fill(0xFFFFFF);
	        }
	        // Create shimmer graphic with gradient and dual-streak effect
	        const shimmerGraphic = factory.createGraphics();
	        const streakWidth = cfg.width;
	        const hh = targetHeight * 2;
	        // Primary streak angle
	        const angleRad = (cfg.angle * Math.PI) / 180;
	        const sin1 = Math.sin(angleRad);
	        // Secondary streak angle (offset by 40 degrees for curved surface effect)
	        const angle2Rad = ((cfg.angle + 40) * Math.PI) / 180;
	        const sin2 = Math.sin(angle2Rad);
	        // Draw gradient layers for primary streak (outer to inner, increasing brightness)
	        const layers = [
	            { width: streakWidth * 2.5, alpha: 0.15 },
	            { width: streakWidth * 1.8, alpha: 0.25 },
	            { width: streakWidth * 1.2, alpha: 0.4 },
	            { width: streakWidth * 0.7, alpha: 0.6 },
	            { width: streakWidth * 0.3, alpha: 1.0 },
	        ];
	        // Primary shimmer streak
	        for (const layer of layers) {
	            const hw = layer.width / 2;
	            for (let i = 0; i < 3; i++) { // Triple draw for brightness
	                shimmerGraphic.poly([
	                    -hw + sin1 * hh, -hh,
	                    hw + sin1 * hh, -hh,
	                    hw - sin1 * hh, hh,
	                    -hw - sin1 * hh, hh,
	                ]);
	                shimmerGraphic.fill({ color: 0xFFFFFF, alpha: layer.alpha });
	            }
	        }
	        // Secondary shimmer streak (smaller, offset position)
	        const secondaryOffset = streakWidth * 0.8;
	        const secondaryLayers = [
	            { width: streakWidth * 1.2, alpha: 0.1 },
	            { width: streakWidth * 0.6, alpha: 0.2 },
	            { width: streakWidth * 0.2, alpha: 0.4 },
	        ];
	        for (const layer of secondaryLayers) {
	            const hw = layer.width / 2;
	            for (let i = 0; i < 2; i++) {
	                shimmerGraphic.poly([
	                    -hw + sin2 * hh + secondaryOffset, -hh,
	                    hw + sin2 * hh + secondaryOffset, -hh,
	                    hw - sin2 * hh + secondaryOffset, hh,
	                    -hw - sin2 * hh + secondaryOffset, hh,
	                ]);
	                shimmerGraphic.fill({ color: 0xFFFFFF, alpha: layer.alpha });
	            }
	        }
	        // Use 'add' blend mode for glow effect
	        shimmerGraphic.blendMode = 'add';
	        // Add shimmer to container
	        shimmerContainer.addChild(shimmerGraphic);
	        // Apply Graphics mask - mask must be in display list for Pixi.js
	        shimmerContainer.addChild(mask);
	        shimmerGraphic.mask = mask;
	        // Add container as child of target
	        target.addChild(shimmerContainer);
	        // Force full opacity
	        shimmerGraphic.alpha = 1;
	        // Initial position (local to target, centered)
	        shimmerGraphic.x = -targetWidth / 2 - streakWidth;
	        shimmerGraphic.y = 0;
	        const shimmerData = {
	            target,
	            graphic: shimmerGraphic,
	            mask,
	            container: shimmerContainer,
	            config: cfg,
	            progress: 0,
	            isPaused: false,
	            isActive: true,
	            waitTime: 0,
	            targetWidth,
	            targetHeight,
	        };
	        this.shimmers.push(shimmerData);
	        // Return control instance
	        const instance = {
	            stop: () => this.stopShimmer(shimmerData),
	            pause: () => { shimmerData.isPaused = true; },
	            resume: () => { shimmerData.isPaused = false; },
	            isActive: () => shimmerData.isActive,
	        };
	        this.emit('shimmer-started', target);
	        return instance;
	    }
	    /**
	     * Get target dimensions for shimmer animation
	     */
	    getTargetBounds(target) {
	        // Try to get bounds from target
	        const bounds = target.getLocalBounds?.() || target.getBounds?.();
	        if (bounds) {
	            return {
	                width: bounds.width || 50,
	                height: bounds.height || 50,
	            };
	        }
	        // Fallback
	        return {
	            width: target.width || 50,
	            height: target.height || 50,
	        };
	    }
	    /**
	     * Stop a specific shimmer
	     */
	    stopShimmer(shimmerData) {
	        shimmerData.isActive = false;
	        const index = this.shimmers.indexOf(shimmerData);
	        if (index !== -1) {
	            this.shimmers.splice(index, 1);
	            try {
	                // Remove mask from shimmer
	                shimmerData.graphic.mask = null;
	                // Remove container from target
	                shimmerData.target.removeChild?.(shimmerData.container);
	                // Destroy all
	                shimmerData.graphic.destroy();
	                shimmerData.mask.destroy();
	                shimmerData.container.destroy();
	            }
	            catch {
	                // Ignore removal errors
	            }
	        }
	        this.emit('shimmer-stopped');
	    }
	    /**
	     * Create sparkle burst effect at a point
	     * Returns a promise that resolves when animation completes
	     */
	    sparkle(x, y, config = {}) {
	        const cfg = { ...DEFAULT_SPARKLE, ...config };
	        return new Promise((resolve) => {
	            const factory = getGraphicsFactory();
	            for (let i = 0; i < cfg.particleCount; i++) {
	                const graphic = factory.createGraphics();
	                // Draw star/sparkle shape
	                const color = cfg.colors[Math.floor(Math.random() * cfg.colors.length)];
	                this.drawSparkle(graphic, color);
	                graphic.x = x;
	                graphic.y = y;
	                graphic.alpha = 1;
	                const scale = cfg.scale.min + Math.random() * (cfg.scale.max - cfg.scale.min);
	                graphic.scale.x = 0;
	                graphic.scale.y = 0;
	                this.container.addChild(graphic);
	                // Calculate target position (radial spread)
	                const angle = (i / cfg.particleCount) * Math.PI * 2 + Math.random() * 0.5;
	                const distance = cfg.radius * (0.5 + Math.random() * 0.5);
	                const particle = {
	                    graphic,
	                    x,
	                    y,
	                    targetX: x + Math.cos(angle) * distance,
	                    targetY: y + Math.sin(angle) * distance,
	                    scale,
	                    life: 0,
	                    maxLife: cfg.duration,
	                };
	                this.sparkles.push(particle);
	            }
	            // Set timeout for completion
	            setTimeout(() => {
	                this.emit('sparkle-complete', { x, y });
	                resolve();
	            }, cfg.duration);
	            this.emit('sparkle-started', { x, y, count: cfg.particleCount });
	        });
	    }
	    /**
	     * Draw sparkle/star shape
	     * Uses Pixi.js v8 Graphics API
	     */
	    drawSparkle(graphic, color) {
	        graphic.clear();
	        // Draw 4-pointed star
	        const size = 8;
	        const points = [];
	        const spikes = 4;
	        const innerRadius = size * 0.3;
	        for (let i = 0; i < spikes * 2; i++) {
	            const r = i % 2 === 0 ? size : innerRadius;
	            const angle = (i * Math.PI) / spikes - Math.PI / 2;
	            points.push(Math.cos(angle) * r);
	            points.push(Math.sin(angle) * r);
	        }
	        // Pixi v8: poly().fill(color)
	        graphic.poly(points).fill(color);
	    }
	    /**
	     * Update all effects - call every frame
	     */
	    update(deltaTime) {
	        this.updateShimmers(deltaTime);
	        this.updateSparkles(deltaTime);
	    }
	    /**
	     * Update shimmer effects
	     */
	    updateShimmers(deltaTime) {
	        for (const shimmer of this.shimmers) {
	            if (!shimmer.isActive || shimmer.isPaused)
	                continue;
	            // Handle delay between loops
	            if (shimmer.waitTime > 0) {
	                shimmer.waitTime -= deltaTime;
	                shimmer.graphic.alpha = 0;
	                continue;
	            }
	            // Update progress
	            shimmer.progress += deltaTime / shimmer.config.speed;
	            if (shimmer.progress >= 1) {
	                if (shimmer.config.loop) {
	                    shimmer.progress = 0;
	                    shimmer.waitTime = shimmer.config.loopDelay;
	                }
	                else {
	                    this.stopShimmer(shimmer);
	                    continue;
	                }
	            }
	            // Animate shimmer position across target (from left to right)
	            // Shimmer is a child of target, positions are relative to target center (0,0)
	            const halfWidth = shimmer.targetWidth / 2;
	            const streakWidth = shimmer.config.width;
	            const startX = -halfWidth - streakWidth;
	            const endX = halfWidth + streakWidth;
	            const currentX = startX + shimmer.progress * (endX - startX);
	            shimmer.graphic.x = currentX;
	            shimmer.graphic.alpha = 1; // Always full opacity
	        }
	    }
	    /**
	     * Update sparkle particles
	     */
	    updateSparkles(deltaTime) {
	        for (let i = this.sparkles.length - 1; i >= 0; i--) {
	            const p = this.sparkles[i];
	            p.life += deltaTime;
	            const progress = p.life / p.maxLife;
	            if (progress >= 1) {
	                // Remove particle
	                this.container.removeChild(p.graphic);
	                p.graphic.destroy();
	                this.sparkles.splice(i, 1);
	                continue;
	            }
	            // Ease out cubic for smooth deceleration
	            const eased = 1 - Math.pow(1 - progress, 3);
	            // Scale up then down
	            const scaleProgress = progress < 0.3 ? progress / 0.3 : 1 - ((progress - 0.3) / 0.7);
	            p.graphic.scale.x = p.scale * scaleProgress;
	            p.graphic.scale.y = p.scale * scaleProgress;
	            // Move towards target
	            p.graphic.x = p.x + (p.targetX - p.x) * eased;
	            p.graphic.y = p.y + (p.targetY - p.y) * eased;
	            // Fade out in last 50%
	            if (progress > 0.5) {
	                p.graphic.alpha = 1 - ((progress - 0.5) / 0.5);
	            }
	            // Rotate
	            p.graphic.rotation += 0.1;
	        }
	    }
	    /**
	     * Clear all effects
	     */
	    clear() {
	        // Clear shimmers
	        for (let i = this.shimmers.length - 1; i >= 0; i--) {
	            this.stopShimmer(this.shimmers[i]);
	        }
	        // Clear sparkles
	        for (let i = this.sparkles.length - 1; i >= 0; i--) {
	            const p = this.sparkles[i];
	            this.container.removeChild(p.graphic);
	            p.graphic.destroy();
	        }
	        this.sparkles = [];
	        this.emit('cleared');
	    }
	    /**
	     * Destroy the system
	     */
	    destroy() {
	        this.clear();
	        this.removeAllListeners();
	    }
	}

	/**
	 * Default configuration
	 */
	const DEFAULT_CONFIG = {
	    radius: 30,
	    count: 4,
	    colors: [0xFFFFFF, 0xFFF8DC, 0xFFD700],
	    duration: 800,
	    spawnDelayMin: 100,
	    spawnDelayMax: 400,
	    scale: { min: 0.2, max: 0.6 }, // Reduced: was 0.3-1.0, now 75% smaller max
	    rotationSpeed: 0.025, // Reduced: was 0.05, now 50% slower
	};
	/**
	 * StarBurstEffect - Continuous sparkle effects around valuable items
	 *
	 * Creates a magical "glittering" effect with rotating star particles
	 * that appear randomly around a target area.
	 *
	 * Features:
	 * - Mix of 4-pointed (small, frequent) and 6-pointed (large, rare) stars
	 * - Scale + Rotate + Fade animation
	 * - Configurable per-zone colors and intensity
	 * - Optimized particle pooling
	 *
	 * @example
	 * ```typescript
	 * const starburst = new StarBurstEffect(stage);
	 *
	 * // Add sparkle zone around gold icon
	 * const zone = starburst.addZone(goldIcon, {
	 *   radius: 40,
	 *   count: 5,
	 *   colors: [0xFFD700, 0xFFFFFF]
	 * });
	 *
	 * // Update in game loop
	 * game.on('update', (dt) => starburst.update(dt));
	 *
	 * // Stop when needed
	 * zone.stop();
	 * ```
	 */
	class StarBurstEffect extends EventEmitter {
	    constructor(container) {
	        super();
	        this.zones = [];
	        this.container = container;
	    }
	    /**
	     * Add a sparkle zone around a target object
	     * Sparkles will continuously appear and animate around the target
	     */
	    addZone(target, config = {}) {
	        const cfg = { ...DEFAULT_CONFIG, ...config };
	        const factory = getGraphicsFactory();
	        // Create container for this zone's particles
	        const zoneContainer = factory.createContainer();
	        this.container.addChild(zoneContainer);
	        const zoneData = {
	            target,
	            container: zoneContainer,
	            config: cfg,
	            particles: [],
	            isActive: true,
	            isPaused: false,
	            spawnTimer: 0,
	            nextSpawnDelay: this.getRandomSpawnDelay(cfg),
	        };
	        this.zones.push(zoneData);
	        // Return control instance
	        const instance = {
	            stop: () => this.removeZone(zoneData),
	            pause: () => { zoneData.isPaused = true; },
	            resume: () => { zoneData.isPaused = false; },
	            isActive: () => zoneData.isActive,
	            setConfig: (newConfig) => {
	                Object.assign(zoneData.config, newConfig);
	            },
	        };
	        this.emit('zone-added', target);
	        return instance;
	    }
	    /**
	     * Remove a zone and all its particles
	     */
	    removeZone(zoneData) {
	        zoneData.isActive = false;
	        const index = this.zones.indexOf(zoneData);
	        if (index !== -1) {
	            this.zones.splice(index, 1);
	            // Remove all particles
	            for (const particle of zoneData.particles) {
	                zoneData.container.removeChild(particle.graphic);
	                particle.graphic.destroy();
	            }
	            zoneData.particles = [];
	            // Remove container
	            this.container.removeChild(zoneData.container);
	            zoneData.container.destroy();
	        }
	        this.emit('zone-removed');
	    }
	    /**
	     * Get random spawn delay based on config
	     */
	    getRandomSpawnDelay(config) {
	        return config.spawnDelayMin + Math.random() * (config.spawnDelayMax - config.spawnDelayMin);
	    }
	    /**
	     * Spawn a new sparkle particle in a zone
	     */
	    spawnParticle(zone) {
	        if (zone.particles.length >= zone.config.count)
	            return;
	        const factory = getGraphicsFactory();
	        const graphic = factory.createGraphics();
	        // 70% small (4-pointed), 30% large (6-pointed)
	        const isLarge = Math.random() >= 0.7;
	        const spikes = isLarge ? 6 : 4;
	        const color = zone.config.colors[Math.floor(Math.random() * zone.config.colors.length)];
	        const size = isLarge ? 10 : 8;
	        // Draw the sparkle shape
	        this.drawStar(graphic, spikes, size, color);
	        // Random position within radius
	        const angle = Math.random() * Math.PI * 2;
	        const distance = Math.random() * zone.config.radius;
	        // Get target's global position
	        const targetPos = this.getTargetPosition(zone.target);
	        const x = targetPos.x + Math.cos(angle) * distance;
	        const y = targetPos.y + Math.sin(angle) * distance;
	        graphic.x = x;
	        graphic.y = y;
	        graphic.alpha = 0;
	        graphic.scale.x = 0;
	        graphic.scale.y = 0;
	        zone.container.addChild(graphic);
	        const targetScale = zone.config.scale.min +
	            Math.random() * (zone.config.scale.max - zone.config.scale.min);
	        // Large stars are slower but only slightly bigger
	        const durationMultiplier = isLarge ? 1.3 : 1;
	        const scaleMultiplier = isLarge ? 1.15 : 1;
	        const particle = {
	            graphic,
	            spikes,
	            x,
	            y,
	            targetScale: targetScale * scaleMultiplier,
	            currentScale: 0,
	            rotation: Math.random() * Math.PI * 2,
	            rotationSpeed: zone.config.rotationSpeed * (0.8 + Math.random() * 0.4),
	            life: 0,
	            maxLife: zone.config.duration * durationMultiplier,
	            phase: 'spawn',
	        };
	        zone.particles.push(particle);
	        this.emit('sparkle-spawned', { x, y, spikes });
	    }
	    /**
	     * Draw star shape with configurable spike count
	     * @param spikes Number of points (4 or 6)
	     * @param size Outer radius of the star
	     */
	    drawStar(graphic, spikes, size, color) {
	        graphic.clear();
	        const innerRatio = spikes === 4 ? 0.25 : 0.4;
	        const innerRadius = size * innerRatio;
	        const points = [];
	        for (let i = 0; i < spikes * 2; i++) {
	            const radius = i % 2 === 0 ? size : innerRadius;
	            const angle = (i * Math.PI) / spikes - Math.PI / 2;
	            points.push(Math.cos(angle) * radius);
	            points.push(Math.sin(angle) * radius);
	        }
	        graphic.poly(points).fill(color);
	    }
	    /**
	     * Get target's global position
	     */
	    getTargetPosition(target) {
	        // Try to get global position (Pixi.js DisplayObject method)
	        const targetWithGlobal = target;
	        const globalPos = targetWithGlobal.getGlobalPosition?.();
	        if (globalPos) {
	            return { x: globalPos.x, y: globalPos.y };
	        }
	        // Fallback to direct position
	        return { x: target.x, y: target.y };
	    }
	    /**
	     * Update all zones and particles - call every frame
	     */
	    update(deltaTime) {
	        for (const zone of this.zones) {
	            if (!zone.isActive || zone.isPaused)
	                continue;
	            // Update spawn timer
	            zone.spawnTimer += deltaTime;
	            if (zone.spawnTimer >= zone.nextSpawnDelay) {
	                this.spawnParticle(zone);
	                zone.spawnTimer = 0;
	                zone.nextSpawnDelay = this.getRandomSpawnDelay(zone.config);
	            }
	            // Update particles
	            this.updateParticles(zone, deltaTime);
	        }
	    }
	    /**
	     * Update particles in a zone
	     */
	    updateParticles(zone, deltaTime) {
	        for (let i = zone.particles.length - 1; i >= 0; i--) {
	            const p = zone.particles[i];
	            p.life += deltaTime;
	            const progress = p.life / p.maxLife;
	            // Determine phase
	            if (progress < 0.3) {
	                p.phase = 'spawn';
	            }
	            else if (progress < 0.7) {
	                p.phase = 'hold';
	            }
	            else {
	                p.phase = 'fade';
	            }
	            // Update based on phase
	            switch (p.phase) {
	                case 'spawn': {
	                    // Scale 0â†’1, alpha 0â†’1
	                    const spawnProgress = progress / 0.3;
	                    const eased = this.easeOutBack(spawnProgress);
	                    p.currentScale = p.targetScale * eased;
	                    p.graphic.alpha = spawnProgress;
	                    break;
	                }
	                case 'hold': {
	                    // Rotate, subtle scale pulse
	                    const holdProgress = (progress - 0.3) / 0.4;
	                    const pulse = 1 + Math.sin(holdProgress * Math.PI * 2) * 0.1;
	                    p.currentScale = p.targetScale * pulse;
	                    p.graphic.alpha = 1;
	                    break;
	                }
	                case 'fade': {
	                    // Scale 1â†’0, alpha 1â†’0
	                    const fadeProgress = (progress - 0.7) / 0.3;
	                    const eased = 1 - this.easeInQuad(fadeProgress);
	                    p.currentScale = p.targetScale * eased;
	                    p.graphic.alpha = eased;
	                    break;
	                }
	            }
	            // Apply rotation
	            p.rotation += p.rotationSpeed;
	            // Apply to graphic
	            p.graphic.scale.x = p.currentScale;
	            p.graphic.scale.y = p.currentScale;
	            p.graphic.rotation = p.rotation;
	            // Remove dead particles
	            if (progress >= 1) {
	                zone.container.removeChild(p.graphic);
	                p.graphic.destroy();
	                zone.particles.splice(i, 1);
	            }
	        }
	    }
	    /**
	     * Ease out back - slight overshoot for bouncy feel
	     */
	    easeOutBack(t) {
	        const c1 = 1.70158;
	        const c3 = c1 + 1;
	        return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
	    }
	    /**
	     * Ease in quad - accelerating from zero
	     */
	    easeInQuad(t) {
	        return t * t;
	    }
	    /**
	     * Remove zone by target
	     */
	    removeZoneByTarget(target) {
	        const zone = this.zones.find(z => z.target === target);
	        if (zone) {
	            this.removeZone(zone);
	        }
	    }
	    /**
	     * Check if target has an active zone
	     */
	    hasZone(target) {
	        return this.zones.some(z => z.target === target && z.isActive);
	    }
	    /**
	     * Get active zone count
	     */
	    getZoneCount() {
	        return this.zones.length;
	    }
	    /**
	     * Get total particle count across all zones
	     */
	    getParticleCount() {
	        return this.zones.reduce((sum, zone) => sum + zone.particles.length, 0);
	    }
	    /**
	     * Clear all zones
	     */
	    clear() {
	        for (let i = this.zones.length - 1; i >= 0; i--) {
	            this.removeZone(this.zones[i]);
	        }
	        this.emit('cleared');
	    }
	    /**
	     * Destroy the system
	     */
	    destroy() {
	        this.clear();
	        this.removeAllListeners();
	    }
	}

	/**
	 * Preset configurations for different celebration types
	 */
	const CelebrationPresets = {
	    /** Victory screen celebration */
	    VICTORY: {
	        confetti: {
	            particleCount: 80,
	            duration: 3000,
	            colors: [0xFFD700, 0x4CAF50, 0x6BCB77, 0xFFFFFF, 0xFFF8DC],
	        },
	        sparkle: {
	            particleCount: 12,
	            radius: 40,
	        },
	    },
	    /** Defeat screen - no celebration */
	    DEFEAT: {
	        confetti: null,
	        sparkle: null,
	    },
	    /** Star earned */
	    STAR_EARNED: {
	        confetti: {
	            particleCount: 25,
	            duration: 1500,
	            spread: 45,
	            colors: [0xFFD700, 0xFFF8DC, 0xFFEC8B, 0xFFFFFF],
	        },
	        sparkle: {
	            particleCount: 8,
	            colors: [0xFFD700, 0xFFFFFF],
	            radius: 25,
	        },
	    },
	    /** Level complete */
	    LEVEL_COMPLETE: {
	        confetti: {
	            particleCount: 60,
	            duration: 2500,
	            colors: [0x4CAF50, 0x6BCB77, 0xFFD700, 0xFFFFFF],
	        },
	        sparkle: {
	            particleCount: 10,
	        },
	    },
	    /** Reward received */
	    REWARD: {
	        confetti: {
	            particleCount: 35,
	            duration: 2000,
	            spread: 50,
	            colors: [0xFFD700, 0x9C27B0, 0x00BCD4, 0xFFFFFF],
	        },
	        sparkle: {
	            particleCount: 10,
	            colors: [0xFFD700, 0xFFFFFF, 0x9C27B0],
	        },
	    },
	    /** Jackpot/bonus */
	    JACKPOT: {
	        confetti: {
	            particleCount: 100,
	            duration: 3500,
	            colors: [0xFFD700, 0xFFA500, 0xFFEC8B, 0xFFFFFF, 0xFF69B4],
	        },
	        sparkle: {
	            particleCount: 16,
	            radius: 50,
	            colors: [0xFFD700, 0xFFFFFF],
	        },
	    },
	    /** Coin/gold shimmer */
	    GOLD_SHIMMER: {
	        width: 15,
	        angle: -30,
	        speed: 2000,
	        color: 0xFFFFFF,
	        alpha: 0.5,
	        loopDelay: 1500,
	    },
	    /** Gem shimmer */
	    GEM_SHIMMER: {
	        width: 12,
	        angle: -25,
	        speed: 1800,
	        color: 0xFFFFFF,
	        alpha: 0.4,
	        loopDelay: 2000,
	    },
	    /** Star shimmer */
	    STAR_SHIMMER: {
	        width: 18,
	        angle: -35,
	        speed: 2200,
	        color: 0xFFF8DC,
	        alpha: 0.45,
	        loopDelay: 1200,
	    },
	    /** Gold starburst - for coins, gold items */
	    GOLD_STARBURST: {
	        radius: 35,
	        count: 4,
	        colors: [0xFFFFFF, 0xFFF8DC, 0xFFD700],
	        duration: 800,
	    },
	    /** Gem starburst - for gems, crystals */
	    GEM_STARBURST: {
	        radius: 30,
	        count: 3,
	        colors: [0xFFFFFF, 0x00FFFF, 0xFF69B4],
	        duration: 700,
	    },
	    /** Star starburst - for stars, achievements */
	    STAR_STARBURST: {
	        radius: 40,
	        count: 5,
	        colors: [0xFFFFFF, 0xFFF8DC],
	        duration: 900,
	    },
	    /** Victory starburst - intense celebration */
	    VICTORY_STARBURST: {
	        radius: 50,
	        count: 6,
	        colors: [0xFFFFFF, 0xFFD700, 0x4CAF50],
	        duration: 1000,
	    },
	};
	/**
	 * CelebrationManager - Orchestrates celebration effects
	 *
	 * Provides a simple API for triggering celebrations with
	 * confetti and sparkle effects combined.
	 *
	 * @example
	 * ```typescript
	 * const celebration = new CelebrationManager(stage);
	 *
	 * // Victory celebration
	 * celebration.victory();
	 *
	 * // Star earned at specific position
	 * celebration.starEarned(starX, starY, 1);
	 *
	 * // Add shimmer to valuable items
	 * celebration.addShimmer(coinIcon, 'gold');
	 *
	 * // Update in game loop
	 * game.on('update', (dt) => celebration.update(dt));
	 * ```
	 */
	class CelebrationManager extends EventEmitter {
	    constructor(container, screenWidth = 360, screenHeight = 640, audioManager) {
	        super();
	        this.shimmerInstances = new Map();
	        this.starburstInstances = new Map();
	        this.container = container;
	        this.audioManager = audioManager;
	        this.confetti = new ConfettiSystem(container, screenWidth, screenHeight);
	        this.shine = new ShineEffect(container);
	        this.starburst = new StarBurstEffect(container);
	        // Forward events
	        this.confetti.on('complete', () => this.emit('confetti-complete'));
	        this.shine.on('sparkle-complete', (data) => this.emit('sparkle-complete', data));
	        this.starburst.on('zone-added', (target) => this.emit('starburst-added', target));
	        this.starburst.on('zone-removed', () => this.emit('starburst-removed'));
	    }
	    /**
	     * Victory celebration
	     * - Confetti rain from top
	     * - Sound effect (if audio manager provided)
	     */
	    victory(config = {}) {
	        const { confetti = true, sound = true } = config;
	        if (confetti && CelebrationPresets.VICTORY.confetti) {
	            this.confetti.rain(CelebrationPresets.VICTORY.confetti);
	        }
	        if (sound) {
	            this.playSound('victory');
	        }
	        this.emit('victory');
	    }
	    /**
	     * Defeat - no celebration by default
	     */
	    defeat(config = {}) {
	        const { sound = true } = config;
	        if (sound) {
	            this.playSound('defeat');
	        }
	        this.emit('defeat');
	    }
	    /**
	     * Star earned celebration
	     * - Confetti burst from star position
	     * - Sparkle effect
	     * - Sound effect
	     *
	     * @param x Star X position
	     * @param y Star Y position
	     * @param starIndex Which star (1, 2, or 3) - affects intensity
	     */
	    async starEarned(x, y, starIndex, config = {}) {
	        const { confetti = true, sparkle = true, sound = true } = config;
	        // Adjust particle count based on star index
	        const preset = { ...CelebrationPresets.STAR_EARNED };
	        if (preset.confetti) {
	            preset.confetti = {
	                ...preset.confetti,
	                particleCount: preset.confetti.particleCount + (starIndex - 1) * 10,
	            };
	        }
	        if (confetti && preset.confetti) {
	            this.confetti.burst(x, y, preset.confetti);
	        }
	        if (sparkle && preset.sparkle) {
	            await this.shine.sparkle(x, y, preset.sparkle);
	        }
	        if (sound) {
	            this.playSound(`star_${starIndex}`);
	        }
	        this.emit('star-earned', { x, y, starIndex });
	    }
	    /**
	     * Level complete celebration
	     * - Confetti rain
	     * - Sound effect
	     */
	    levelComplete(config = {}) {
	        const { confetti = true, sound = true } = config;
	        if (confetti && CelebrationPresets.LEVEL_COMPLETE.confetti) {
	            this.confetti.rain(CelebrationPresets.LEVEL_COMPLETE.confetti);
	        }
	        if (sound) {
	            this.playSound('level_complete');
	        }
	        this.emit('level-complete');
	    }
	    /**
	     * Reward received celebration
	     * - Confetti burst from reward position
	     * - Sparkle effect
	     * - Sound effect
	     */
	    async rewardReceived(x, y, config = {}) {
	        const { confetti = true, sparkle = true, sound = true } = config;
	        if (confetti && CelebrationPresets.REWARD.confetti) {
	            this.confetti.burst(x, y, CelebrationPresets.REWARD.confetti);
	        }
	        if (sparkle && CelebrationPresets.REWARD.sparkle) {
	            await this.shine.sparkle(x, y, CelebrationPresets.REWARD.sparkle);
	        }
	        if (sound) {
	            this.playSound('reward');
	        }
	        this.emit('reward-received', { x, y });
	    }
	    /**
	     * Jackpot/bonus celebration
	     * - Confetti fountain from position
	     * - Extra sparkles
	     * - Sound effect
	     */
	    async jackpot(x, y, config = {}) {
	        const { confetti = true, sparkle = true, sound = true } = config;
	        if (confetti && CelebrationPresets.JACKPOT.confetti) {
	            this.confetti.fountain(x, y, CelebrationPresets.JACKPOT.confetti);
	        }
	        if (sparkle && CelebrationPresets.JACKPOT.sparkle) {
	            // Multiple sparkle bursts
	            await this.shine.sparkle(x, y, CelebrationPresets.JACKPOT.sparkle);
	            setTimeout(() => {
	                this.shine.sparkle(x - 20, y - 20, CelebrationPresets.JACKPOT.sparkle);
	            }, 100);
	            setTimeout(() => {
	                this.shine.sparkle(x + 20, y - 20, CelebrationPresets.JACKPOT.sparkle);
	            }, 200);
	        }
	        if (sound) {
	            this.playSound('jackpot');
	        }
	        this.emit('jackpot', { x, y });
	    }
	    /**
	     * Add shimmer effect to a valuable item
	     *
	     * @param target Display object to add shimmer to
	     * @param type Type of shimmer preset ('gold', 'gem', 'star') or custom config
	     */
	    addShimmer(target, type = 'gold') {
	        this.removeShimmer(target);
	        const shimmerPresets = {
	            gold: CelebrationPresets.GOLD_SHIMMER,
	            gem: CelebrationPresets.GEM_SHIMMER,
	            star: CelebrationPresets.STAR_SHIMMER,
	        };
	        const config = typeof type === 'string' ? shimmerPresets[type] : type;
	        const instance = this.shine.shimmer(target, config);
	        this.shimmerInstances.set(target, instance);
	        this.emit('shimmer-added', target);
	        return instance;
	    }
	    /**
	     * Remove shimmer from a target
	     */
	    removeShimmer(target) {
	        const instance = this.shimmerInstances.get(target);
	        if (instance) {
	            instance.stop();
	            this.shimmerInstances.delete(target);
	            this.emit('shimmer-removed', target);
	        }
	    }
	    /**
	     * Add starburst effect to a valuable item
	     * Creates continuous sparkle particles around the target
	     *
	     * @param target Display object to add starburst to
	     * @param type Type of starburst preset ('gold', 'gem', 'star', 'victory') or custom config
	     */
	    addStarburst(target, type = 'gold') {
	        this.removeStarburst(target);
	        const starburstPresets = {
	            gold: CelebrationPresets.GOLD_STARBURST,
	            gem: CelebrationPresets.GEM_STARBURST,
	            star: CelebrationPresets.STAR_STARBURST,
	            victory: CelebrationPresets.VICTORY_STARBURST,
	        };
	        const config = typeof type === 'string' ? starburstPresets[type] : type;
	        const instance = this.starburst.addZone(target, config);
	        this.starburstInstances.set(target, instance);
	        return instance;
	    }
	    /**
	     * Remove starburst from a target
	     */
	    removeStarburst(target) {
	        const instance = this.starburstInstances.get(target);
	        if (instance) {
	            instance.stop();
	            this.starburstInstances.delete(target);
	        }
	    }
	    /**
	     * Trigger sparkle effect at a point
	     */
	    async sparkle(x, y, config) {
	        await this.shine.sparkle(x, y, config);
	    }
	    /**
	     * Trigger confetti rain
	     */
	    confettiRain(config) {
	        this.confetti.rain(config);
	    }
	    /**
	     * Trigger confetti burst
	     */
	    confettiBurst(x, y, config) {
	        this.confetti.burst(x, y, config);
	    }
	    /**
	     * Trigger confetti fountain
	     */
	    confettiFountain(x, y, config) {
	        this.confetti.fountain(x, y, config);
	    }
	    /**
	     * Play sound effect (if audio manager provided)
	     */
	    playSound(soundId) {
	        if (this.audioManager?.playSound) {
	            try {
	                this.audioManager.playSound(soundId);
	            }
	            catch {
	                // Ignore audio errors
	            }
	        }
	    }
	    /**
	     * Update all effects - call every frame
	     */
	    update(deltaTime) {
	        this.confetti.update(deltaTime);
	        this.shine.update(deltaTime);
	        this.starburst.update(deltaTime);
	    }
	    /**
	     * Resize the system
	     */
	    resize(width, height) {
	        this.confetti.resize(width, height);
	    }
	    /**
	     * Clear all active effects
	     */
	    clear() {
	        this.confetti.clear();
	        this.shine.clear();
	        this.starburst.clear();
	        // Clear shimmer instances
	        for (const [target] of this.shimmerInstances) {
	            this.removeShimmer(target);
	        }
	        // Clear starburst instances
	        for (const [target] of this.starburstInstances) {
	            this.removeStarburst(target);
	        }
	        this.emit('cleared');
	    }
	    /**
	     * Destroy the manager
	     */
	    destroy() {
	        this.clear();
	        this.confetti.destroy();
	        this.shine.destroy();
	        this.starburst.destroy();
	        this.removeAllListeners();
	    }
	}

	/**
	 * Mobile-optimized input system with gesture recognition
	 */
	class GameByteUIInputSystem extends EventEmitter {
	    constructor(element) {
	        super();
	        // Input state
	        this.pointers = new Map();
	        this.currentFocus = null;
	        this.gestureData = null;
	        // Configuration
	        this.tapThreshold = 10; // pixels
	        this.longPressThreshold = 500; // milliseconds
	        this.doubleTapThreshold = 300; // milliseconds
	        this.swipeThreshold = 50; // pixels
	        this.pinchThreshold = 0.1; // scale difference
	        // Gesture detection
	        this.lastTapTime = 0;
	        this.lastTapPosition = { x: 0, y: 0 };
	        this.longPressTimer = null;
	        // Target element for event capture
	        this.element = null;
	        // Bind event handlers
	        this.boundPointerDown = this.onPointerDown.bind(this);
	        this.boundPointerMove = this.onPointerMove.bind(this);
	        this.boundPointerUp = this.onPointerUp.bind(this);
	        this.boundPointerCancel = this.onPointerCancel.bind(this);
	        this.boundTouchStart = this.handleTouchStart.bind(this);
	        this.boundTouchMove = this.handleTouchMove.bind(this);
	        this.boundTouchEnd = this.handleTouchEnd.bind(this);
	        this.boundTouchCancel = this.handleTouchCancel.bind(this);
	        this.boundMouseDown = this.handleMouseDown.bind(this);
	        this.boundMouseMove = this.handleMouseMove.bind(this);
	        this.boundMouseUp = this.handleMouseUp.bind(this);
	        this.boundContextMenu = (e) => e.preventDefault();
	        if (element) {
	            this.attachToElement(element);
	        }
	    }
	    /**
	     * Attach input system to a DOM element
	     */
	    attachToElement(element) {
	        if (this.element) {
	            this.detachFromElement();
	        }
	        this.element = element;
	        this.setupEventListeners();
	    }
	    /**
	     * Detach from current element
	     */
	    detachFromElement() {
	        if (this.element) {
	            this.removeEventListeners();
	            this.element = null;
	        }
	    }
	    /**
	     * Handle pointer down events
	     */
	    onPointerDown(event) {
	        event.preventDefault();
	        const pointer = {
	            id: event.pointerId,
	            position: { x: event.clientX, y: event.clientY },
	            startPosition: { x: event.clientX, y: event.clientY },
	            startTime: Date.now(),
	            lastPosition: { x: event.clientX, y: event.clientY },
	            lastTime: Date.now(),
	            isDown: true
	        };
	        this.pointers.set(event.pointerId, pointer);
	        // Start gesture tracking
	        this.startGesture(pointer);
	        // Emit interaction event
	        const interactionEvent = {
	            type: 'down',
	            position: pointer.position,
	            target: null,
	            timestamp: pointer.startTime,
	            pointerID: event.pointerId
	        };
	        this.emit('pointer-down', interactionEvent);
	    }
	    /**
	     * Handle pointer move events
	     */
	    onPointerMove(event) {
	        const pointer = this.pointers.get(event.pointerId);
	        if (!pointer)
	            return;
	        pointer.lastPosition = { ...pointer.position };
	        pointer.lastTime = Date.now();
	        pointer.position = { x: event.clientX, y: event.clientY };
	        // Update gesture data
	        this.updateGesture(pointer);
	        // Check for gesture recognition
	        this.recognizeGestures();
	        // Emit interaction event
	        const interactionEvent = {
	            type: 'move',
	            position: pointer.position,
	            target: null,
	            timestamp: pointer.lastTime,
	            pointerID: event.pointerId
	        };
	        this.emit('pointer-move', interactionEvent);
	    }
	    /**
	     * Handle pointer up events
	     */
	    onPointerUp(event) {
	        const pointer = this.pointers.get(event.pointerId);
	        if (!pointer)
	            return;
	        pointer.isDown = false;
	        pointer.position = { x: event.clientX, y: event.clientY };
	        const currentTime = Date.now();
	        const duration = currentTime - pointer.startTime;
	        const distance = this.calculateDistance(pointer.startPosition, pointer.position);
	        // Clear long press timer
	        if (this.longPressTimer) {
	            clearTimeout(this.longPressTimer);
	            this.longPressTimer = null;
	        }
	        // Detect tap gestures
	        if (distance < this.tapThreshold && duration < 300) {
	            this.handleTap(pointer, currentTime);
	        }
	        // Calculate velocity for swipe detection
	        const timeDelta = currentTime - pointer.lastTime;
	        const velocity = {
	            x: timeDelta > 0 ? (pointer.position.x - pointer.lastPosition.x) / timeDelta : 0,
	            y: timeDelta > 0 ? (pointer.position.y - pointer.lastPosition.y) / timeDelta : 0
	        };
	        // Detect swipe
	        if (distance >= this.swipeThreshold) {
	            this.onSwipe(pointer.startPosition, pointer.position, velocity);
	        }
	        // End gesture
	        this.endGesture();
	        // Emit interaction event
	        const interactionEvent = {
	            type: 'up',
	            position: pointer.position,
	            target: null,
	            timestamp: currentTime,
	            pointerID: event.pointerId
	        };
	        this.emit('pointer-up', interactionEvent);
	        // Remove pointer
	        this.pointers.delete(event.pointerId);
	    }
	    /**
	     * Handle pointer cancel events
	     */
	    onPointerCancel(event) {
	        const pointer = this.pointers.get(event.pointerId);
	        if (!pointer)
	            return;
	        // Clear long press timer
	        if (this.longPressTimer) {
	            clearTimeout(this.longPressTimer);
	            this.longPressTimer = null;
	        }
	        // End gesture
	        this.endGesture();
	        // Emit interaction event
	        const interactionEvent = {
	            type: 'cancel',
	            position: pointer.position,
	            target: null,
	            timestamp: Date.now(),
	            pointerID: event.pointerId
	        };
	        this.emit('pointer-cancel', interactionEvent);
	        // Remove pointer
	        this.pointers.delete(event.pointerId);
	    }
	    /**
	     * Handle tap gesture
	     */
	    onTap(position) {
	        this.emit('tap', { position, timestamp: Date.now() });
	    }
	    /**
	     * Handle double tap gesture
	     */
	    onDoubleTap(position) {
	        this.emit('double-tap', { position, timestamp: Date.now() });
	    }
	    /**
	     * Handle long press gesture
	     */
	    onLongPress(position) {
	        this.emit('long-press', { position, timestamp: Date.now() });
	    }
	    /**
	     * Handle pinch gesture
	     */
	    onPinch(center, scale) {
	        this.emit('pinch', { center, scale, timestamp: Date.now() });
	    }
	    /**
	     * Handle swipe gesture
	     */
	    onSwipe(start, end, velocity) {
	        const direction = this.getSwipeDirection(start, end);
	        this.emit('swipe', { start, end, velocity, direction, timestamp: Date.now() });
	    }
	    /**
	     * Set focus to a component
	     */
	    setFocus(component) {
	        const previousFocus = this.currentFocus;
	        this.currentFocus = component;
	        if (previousFocus) {
	            previousFocus.emit('focus-lost');
	        }
	        if (component) {
	            component.emit('focus-gained');
	        }
	        this.emit('focus-changed', { previous: previousFocus, current: component });
	    }
	    /**
	     * Get currently focused component
	     */
	    getFocus() {
	        return this.currentFocus;
	    }
	    /**
	     * Configuration methods
	     */
	    setTapThreshold(pixels) {
	        this.tapThreshold = pixels;
	    }
	    setLongPressThreshold(milliseconds) {
	        this.longPressThreshold = milliseconds;
	    }
	    setPinchThreshold(scale) {
	        this.pinchThreshold = scale;
	    }
	    setSwipeThreshold(pixels) {
	        this.swipeThreshold = pixels;
	    }
	    /**
	     * Start gesture tracking
	     */
	    startGesture(pointer) {
	        this.gestureData = {
	            startPosition: { ...pointer.startPosition },
	            startTime: pointer.startTime,
	            currentPosition: { ...pointer.position },
	            velocity: { x: 0, y: 0 },
	            pointerCount: this.pointers.size
	        };
	        // Setup long press detection
	        this.longPressTimer = window.setTimeout(() => {
	            if (this.gestureData) {
	                this.onLongPress(this.gestureData.startPosition);
	            }
	        }, this.longPressThreshold);
	        // Setup multi-touch data
	        if (this.pointers.size === 2) {
	            const pointers = Array.from(this.pointers.values());
	            this.gestureData.initialDistance = this.calculateDistance(pointers[0].position, pointers[1].position);
	            this.gestureData.initialAngle = this.calculateAngle(pointers[0].position, pointers[1].position);
	        }
	    }
	    /**
	     * Update gesture data
	     */
	    updateGesture(pointer) {
	        if (!this.gestureData)
	            return;
	        this.gestureData.currentPosition = { ...pointer.position };
	        // Calculate velocity
	        const timeDelta = pointer.lastTime - pointer.startTime;
	        if (timeDelta > 0) {
	            this.gestureData.velocity = {
	                x: (pointer.position.x - pointer.startPosition.x) / timeDelta,
	                y: (pointer.position.y - pointer.startPosition.y) / timeDelta
	            };
	        }
	        this.gestureData.pointerCount = this.pointers.size;
	    }
	    /**
	     * Recognize gestures based on current data
	     */
	    recognizeGestures() {
	        if (!this.gestureData)
	            return;
	        // Pinch/zoom detection for two fingers
	        if (this.pointers.size === 2 && this.gestureData.initialDistance) {
	            const pointers = Array.from(this.pointers.values());
	            const currentDistance = this.calculateDistance(pointers[0].position, pointers[1].position);
	            const scale = currentDistance / this.gestureData.initialDistance;
	            if (Math.abs(scale - 1) > this.pinchThreshold) {
	                const center = {
	                    x: (pointers[0].position.x + pointers[1].position.x) / 2,
	                    y: (pointers[0].position.y + pointers[1].position.y) / 2
	                };
	                this.onPinch(center, scale);
	            }
	        }
	    }
	    /**
	     * End gesture tracking
	     */
	    endGesture() {
	        this.gestureData = null;
	        if (this.longPressTimer) {
	            clearTimeout(this.longPressTimer);
	            this.longPressTimer = null;
	        }
	    }
	    /**
	     * Handle tap detection and double tap
	     */
	    handleTap(pointer, currentTime) {
	        const timeSinceLastTap = currentTime - this.lastTapTime;
	        const distanceFromLastTap = this.calculateDistance(pointer.position, this.lastTapPosition);
	        // Check for double tap
	        if (timeSinceLastTap < this.doubleTapThreshold && distanceFromLastTap < this.tapThreshold) {
	            this.onDoubleTap(pointer.position);
	        }
	        else {
	            this.onTap(pointer.position);
	        }
	        this.lastTapTime = currentTime;
	        this.lastTapPosition = { ...pointer.position };
	    }
	    /**
	     * Get swipe direction
	     */
	    getSwipeDirection(start, end) {
	        const deltaX = end.x - start.x;
	        const deltaY = end.y - start.y;
	        if (Math.abs(deltaX) > Math.abs(deltaY)) {
	            return deltaX > 0 ? 'right' : 'left';
	        }
	        else {
	            return deltaY > 0 ? 'down' : 'up';
	        }
	    }
	    /**
	     * Calculate distance between two points
	     */
	    calculateDistance(point1, point2) {
	        const deltaX = point2.x - point1.x;
	        const deltaY = point2.y - point1.y;
	        return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
	    }
	    /**
	     * Calculate angle between two points
	     */
	    calculateAngle(point1, point2) {
	        return Math.atan2(point2.y - point1.y, point2.x - point1.x);
	    }
	    /**
	     * Setup DOM event listeners
	     */
	    setupEventListeners() {
	        if (!this.element)
	            return;
	        const element = this.element; // Create local reference for type narrowing
	        // Pointer events (modern standard)
	        if ('onpointerdown' in element) {
	            element.addEventListener('pointerdown', this.boundPointerDown);
	            element.addEventListener('pointermove', this.boundPointerMove);
	            element.addEventListener('pointerup', this.boundPointerUp);
	            element.addEventListener('pointercancel', this.boundPointerCancel);
	        }
	        else {
	            // Fallback to touch and mouse events
	            element.addEventListener('touchstart', this.boundTouchStart);
	            element.addEventListener('touchmove', this.boundTouchMove);
	            element.addEventListener('touchend', this.boundTouchEnd);
	            element.addEventListener('touchcancel', this.boundTouchCancel);
	            element.addEventListener('mousedown', this.boundMouseDown);
	            element.addEventListener('mousemove', this.boundMouseMove);
	            element.addEventListener('mouseup', this.boundMouseUp);
	        }
	        // Prevent default context menu
	        element.addEventListener('contextmenu', this.boundContextMenu);
	    }
	    /**
	     * Remove DOM event listeners
	     */
	    removeEventListeners() {
	        if (!this.element)
	            return;
	        // Remove all event listeners using bound references
	        this.element.removeEventListener('pointerdown', this.boundPointerDown);
	        this.element.removeEventListener('pointermove', this.boundPointerMove);
	        this.element.removeEventListener('pointerup', this.boundPointerUp);
	        this.element.removeEventListener('pointercancel', this.boundPointerCancel);
	        this.element.removeEventListener('touchstart', this.boundTouchStart);
	        this.element.removeEventListener('touchmove', this.boundTouchMove);
	        this.element.removeEventListener('touchend', this.boundTouchEnd);
	        this.element.removeEventListener('touchcancel', this.boundTouchCancel);
	        this.element.removeEventListener('mousedown', this.boundMouseDown);
	        this.element.removeEventListener('mousemove', this.boundMouseMove);
	        this.element.removeEventListener('mouseup', this.boundMouseUp);
	        this.element.removeEventListener('contextmenu', this.boundContextMenu);
	    }
	    /**
	     * Touch event fallback handlers
	     */
	    handleTouchStart(event) {
	        event.preventDefault();
	        for (let i = 0; i < event.changedTouches.length; i++) {
	            const touch = event.changedTouches[i];
	            this.onPointerDown(this.touchToPointerEvent(touch, 'pointerdown'));
	        }
	    }
	    handleTouchMove(event) {
	        for (let i = 0; i < event.changedTouches.length; i++) {
	            const touch = event.changedTouches[i];
	            this.onPointerMove(this.touchToPointerEvent(touch, 'pointermove'));
	        }
	    }
	    handleTouchEnd(event) {
	        for (let i = 0; i < event.changedTouches.length; i++) {
	            const touch = event.changedTouches[i];
	            this.onPointerUp(this.touchToPointerEvent(touch, 'pointerup'));
	        }
	    }
	    handleTouchCancel(event) {
	        for (let i = 0; i < event.changedTouches.length; i++) {
	            const touch = event.changedTouches[i];
	            this.onPointerCancel(this.touchToPointerEvent(touch, 'pointercancel'));
	        }
	    }
	    /**
	     * Mouse event fallback handlers
	     */
	    handleMouseDown(event) {
	        this.onPointerDown(this.mouseToPointerEvent(event, 'pointerdown'));
	    }
	    handleMouseMove(event) {
	        this.onPointerMove(this.mouseToPointerEvent(event, 'pointermove'));
	    }
	    handleMouseUp(event) {
	        this.onPointerUp(this.mouseToPointerEvent(event, 'pointerup'));
	    }
	    /**
	     * Convert touch event to pointer event
	     */
	    touchToPointerEvent(touch, type) {
	        return {
	            pointerId: touch.identifier,
	            clientX: touch.clientX,
	            clientY: touch.clientY,
	            type,
	            preventDefault: () => { }
	        };
	    }
	    /**
	     * Convert mouse event to pointer event
	     */
	    mouseToPointerEvent(mouse, type) {
	        return {
	            pointerId: 0, // Mouse always has ID 0
	            clientX: mouse.clientX,
	            clientY: mouse.clientY,
	            type,
	            preventDefault: () => mouse.preventDefault()
	        };
	    }
	    /**
	     * Destroy input system
	     */
	    destroy() {
	        this.detachFromElement();
	        this.pointers.clear();
	        this.currentFocus = null;
	        this.gestureData = null;
	        if (this.longPressTimer) {
	            clearTimeout(this.longPressTimer);
	            this.longPressTimer = null;
	        }
	        this.removeAllListeners();
	    }
	}

	/**
	 * Responsive layout manager with constraint-based positioning
	 */
	class ResponsiveLayoutManager {
	    constructor(deviceInfo) {
	        // Breakpoints for responsive design
	        this.breakpoints = {
	            small: 480,
	            medium: 768,
	            large: 1024,
	            xlarge: 1200
	        };
	        this.deviceInfo = deviceInfo;
	    }
	    /**
	     * Calculate layout for a component and its children
	     */
	    calculateLayout(component, availableSize) {
	        // Update constraints based on device info
	        this.updateConstraints(component, this.deviceInfo);
	        // Calculate component size based on constraints
	        const calculatedSize = this.calculateComponentSize(component, availableSize);
	        // Apply calculated size
	        component.setSize(calculatedSize.width, calculatedSize.height);
	        // Calculate position based on constraints
	        const calculatedPosition = this.calculateComponentPosition(component, availableSize);
	        component.setPosition(calculatedPosition.x, calculatedPosition.y);
	        // Layout children recursively
	        this.layoutChildren(component);
	        return calculatedSize;
	    }
	    /**
	     * Update constraints based on device capabilities
	     */
	    updateConstraints(component, deviceInfo) {
	        this.deviceInfo = deviceInfo;
	        // Apply responsive adjustments
	        this.applyResponsiveConstraints(component);
	        // Apply safe area constraints
	        this.applySafeAreaConstraints(component);
	        // Apply performance-based constraints
	        this.applyPerformanceConstraints(component);
	    }
	    /**
	     * Handle orientation change
	     */
	    handleOrientationChange(orientation) {
	        this.deviceInfo.orientation = orientation;
	        // Swap screen dimensions if needed
	        if (orientation === 'landscape') {
	            const { width, height } = this.deviceInfo.screenSize;
	            if (height > width) {
	                this.deviceInfo.screenSize = { width: height, height: width };
	            }
	        }
	        else {
	            const { width, height } = this.deviceInfo.screenSize;
	            if (width > height) {
	                this.deviceInfo.screenSize = { width: height, height: width };
	            }
	        }
	    }
	    /**
	     * Calculate component size based on constraints
	     */
	    calculateComponentSize(component, availableSize) {
	        const { width: widthConstraint, height: heightConstraint } = component.constraints;
	        const calculatedWidth = this.calculateDimension(widthConstraint, availableSize.width, component.size.width, 'width', component);
	        const calculatedHeight = this.calculateDimension(heightConstraint, availableSize.height, component.size.height, 'height', component);
	        return {
	            width: Math.max(0, calculatedWidth),
	            height: Math.max(0, calculatedHeight)
	        };
	    }
	    /**
	     * Calculate component position based on constraints
	     */
	    calculateComponentPosition(component, availableSize) {
	        const { x: xConstraint, y: yConstraint } = component.constraints;
	        const calculatedX = this.calculateDimension(xConstraint, availableSize.width, component.position.x, 'x', component);
	        const calculatedY = this.calculateDimension(yConstraint, availableSize.height, component.position.y, 'y', component);
	        return {
	            x: calculatedX,
	            y: calculatedY
	        };
	    }
	    /**
	     * Calculate a single dimension based on constraint
	     */
	    calculateDimension(constraint, available, current, dimension, component) {
	        let result = current;
	        switch (constraint.type) {
	            case 'fixed':
	                result = constraint.value || 0;
	                break;
	            case 'percentage':
	                result = available * ((constraint.value || 0) / 100);
	                break;
	            case 'fill':
	                if (dimension === 'width' || dimension === 'height') {
	                    const margin = dimension === 'width'
	                        ? component.margin.left + component.margin.right
	                        : component.margin.top + component.margin.bottom;
	                    result = available - margin;
	                }
	                else {
	                    result = 0; // Fill doesn't apply to position
	                }
	                break;
	            case 'wrap':
	                if (dimension === 'width' || dimension === 'height') {
	                    result = this.calculateWrapSize(component, dimension);
	                }
	                break;
	            case 'aspect-ratio':
	                if (constraint.value && (dimension === 'width' || dimension === 'height')) {
	                    const aspectRatio = constraint.value;
	                    if (dimension === 'width') {
	                        result = component.size.height * aspectRatio;
	                    }
	                    else {
	                        result = component.size.width / aspectRatio;
	                    }
	                }
	                break;
	            case 'safe-area':
	                if (dimension === 'x') {
	                    result = this.deviceInfo.safeArea.left;
	                }
	                else if (dimension === 'y') {
	                    result = this.deviceInfo.safeArea.top;
	                }
	                else if (dimension === 'width') {
	                    result = available - this.deviceInfo.safeArea.left - this.deviceInfo.safeArea.right;
	                }
	                else if (dimension === 'height') {
	                    result = available - this.deviceInfo.safeArea.top - this.deviceInfo.safeArea.bottom;
	                }
	                break;
	            case 'center':
	                if (dimension === 'x') {
	                    result = (available - component.size.width) / 2;
	                }
	                else if (dimension === 'y') {
	                    result = (available - component.size.height) / 2;
	                }
	                break;
	            case 'stretch':
	                if (dimension === 'width' || dimension === 'height') {
	                    result = available;
	                }
	                break;
	        }
	        // Apply min/max constraints
	        if (constraint.min !== undefined) {
	            result = Math.max(result, constraint.min);
	        }
	        if (constraint.max !== undefined) {
	            result = Math.min(result, constraint.max);
	        }
	        return result;
	    }
	    /**
	     * Calculate wrap size based on content
	     */
	    calculateWrapSize(component, dimension) {
	        let size = 0;
	        // For containers, calculate based on children
	        if (component.children.length > 0) {
	            let maxSize = 0;
	            let totalSize = 0;
	            for (const child of component.children) {
	                const childBounds = child.getBounds();
	                if (dimension === 'width') {
	                    maxSize = Math.max(maxSize, childBounds.x + childBounds.width);
	                    totalSize += childBounds.width;
	                }
	                else {
	                    maxSize = Math.max(maxSize, childBounds.y + childBounds.height);
	                    totalSize += childBounds.height;
	                }
	            }
	            // Use maximum extent for wrap size
	            size = maxSize;
	        }
	        // Add padding
	        if (dimension === 'width') {
	            size += component.padding.left + component.padding.right;
	        }
	        else {
	            size += component.padding.top + component.padding.bottom;
	        }
	        return size;
	    }
	    /**
	     * Layout children components
	     */
	    layoutChildren(component) {
	        const contentSize = {
	            width: component.size.width - component.padding.left - component.padding.right,
	            height: component.size.height - component.padding.top - component.padding.bottom
	        };
	        for (const child of component.children) {
	            this.calculateLayout(child, contentSize);
	        }
	    }
	    /**
	     * Apply responsive design constraints
	     */
	    applyResponsiveConstraints(component) {
	        const screenWidth = Math.min(this.deviceInfo.screenSize.width, this.deviceInfo.screenSize.height);
	        // Apply size adjustments based on screen size
	        if (screenWidth <= this.breakpoints.small) {
	            this.applySmallScreenConstraints(component);
	        }
	        else if (screenWidth <= this.breakpoints.medium) {
	            this.applyMediumScreenConstraints(component);
	        }
	        else {
	            this.applyLargeScreenConstraints(component);
	        }
	    }
	    /**
	     * Apply small screen optimizations
	     */
	    applySmallScreenConstraints(component) {
	        // Increase touch targets for small screens
	        if (component.interactive) {
	            const minTouchSize = 44; // Apple's recommendation
	            if (component.constraints.width.type === 'fixed' &&
	                (component.constraints.width.value || 0) < minTouchSize) {
	                component.constraints.width.value = minTouchSize;
	            }
	            if (component.constraints.height.type === 'fixed' &&
	                (component.constraints.height.value || 0) < minTouchSize) {
	                component.constraints.height.value = minTouchSize;
	            }
	        }
	    }
	    /**
	     * Apply medium screen optimizations
	     */
	    applyMediumScreenConstraints(component) {
	        // Medium screens can have slightly smaller touch targets
	        const minTouchSize = 40;
	        if (component.interactive) {
	            if (component.constraints.width.type === 'fixed' &&
	                (component.constraints.width.value || 0) < minTouchSize) {
	                component.constraints.width.value = minTouchSize;
	            }
	            if (component.constraints.height.type === 'fixed' &&
	                (component.constraints.height.value || 0) < minTouchSize) {
	                component.constraints.height.value = minTouchSize;
	            }
	        }
	    }
	    /**
	     * Apply large screen optimizations
	     */
	    applyLargeScreenConstraints(component) {
	        // Large screens can have normal touch targets
	        // No specific adjustments needed
	    }
	    /**
	     * Apply safe area constraints
	     */
	    applySafeAreaConstraints(component) {
	        // Apply safe area padding to root-level components
	        if (!component.parent) {
	            const safeArea = this.deviceInfo.safeArea;
	            // Adjust margins to account for safe areas
	            component.margin = {
	                top: Math.max(component.margin.top, safeArea.top),
	                right: Math.max(component.margin.right, safeArea.right),
	                bottom: Math.max(component.margin.bottom, safeArea.bottom),
	                left: Math.max(component.margin.left, safeArea.left)
	            };
	        }
	    }
	    /**
	     * Apply performance-based constraints
	     */
	    applyPerformanceConstraints(component) {
	        if (this.deviceInfo.performanceTier === 'low') {
	            // Reduce complexity for low-performance devices
	            // This could involve reducing animation complexity, 
	            // simplifying visual effects, etc.
	            component.emit('performance-optimization', { tier: 'low' });
	        }
	    }
	    /**
	     * Create a constraint-based layout system for common patterns
	     */
	    static createFlexLayout(component, direction = 'column', justify = 'start', align = 'start') {
	        // This would implement flexbox-like behavior using constraints
	        // For brevity, this is a simplified implementation
	        const children = component.children;
	        if (children.length === 0)
	            return;
	        const isRow = direction === 'row';
	        const availableSize = isRow ? component.size.width : component.size.height;
	        const childCount = children.length;
	        let position = 0;
	        const spacing = justify === 'space-between' ?
	            (availableSize - children.reduce((total, child) => total + (isRow ? child.size.width : child.size.height), 0)) / (childCount - 1) : 0;
	        children.forEach((child, index) => {
	            if (isRow) {
	                child.setPosition(position, 0);
	                position += child.size.width + spacing;
	            }
	            else {
	                child.setPosition(0, position);
	                position += child.size.height + spacing;
	            }
	            // Apply alignment
	            if (align === 'center') {
	                if (isRow) {
	                    child.setPosition(child.position.x, (component.size.height - child.size.height) / 2);
	                }
	                else {
	                    child.setPosition((component.size.width - child.size.width) / 2, child.position.y);
	                }
	            }
	        });
	    }
	    /**
	     * Create a grid layout system
	     */
	    static createGridLayout(component, columns, rows, spacing = 0) {
	        const children = component.children;
	        if (children.length === 0)
	            return;
	        const actualRows = rows || Math.ceil(children.length / columns);
	        const cellWidth = (component.size.width - (spacing * (columns - 1))) / columns;
	        const cellHeight = (component.size.height - (spacing * (actualRows - 1))) / actualRows;
	        children.forEach((child, index) => {
	            const row = Math.floor(index / columns);
	            const col = index % columns;
	            const x = col * (cellWidth + spacing);
	            const y = row * (cellHeight + spacing);
	            child.setPosition(x, y);
	            child.setSize(cellWidth, cellHeight);
	        });
	    }
	}

	/**
	 * Default joystick style - minimal/modern look
	 */
	const DEFAULT_STYLE = {
	    baseColor: 0x000000,
	    baseAlpha: 0.3,
	    knobColor: 0xFFFFFF,
	    knobAlpha: 0.8,
	    borderColor: 0xFFFFFF,
	    borderWidth: 2,
	    borderAlpha: 0.5,
	};
	/**
	 * VirtualJoystick - Touch-based joystick for mobile game controls
	 *
	 * Supports two modes:
	 * - **fixed**: Always visible at a set position
	 * - **dynamic**: Appears where the user touches within the activation zone
	 *
	 * @example
	 * ```typescript
	 * // Dynamic joystick (appears on touch)
	 * const joystick = new VirtualJoystick({
	 *   mode: 'dynamic',
	 *   activationZone: { x: 0, y: 0, width: 0.5, height: 1 }
	 * });
	 *
	 * joystick.on('move', (data) => {
	 *   player.velocity.x = data.vector.x * speed;
	 *   player.velocity.y = data.vector.y * speed;
	 * });
	 *
	 * scene.addChild(joystick.getContainer());
	 *
	 * // Fixed joystick
	 * const fixedJoystick = new VirtualJoystick({
	 *   mode: 'fixed',
	 *   position: { x: 100, y: 500 },
	 *   size: 140
	 * });
	 * ```
	 */
	class VirtualJoystick extends EventEmitter {
	    constructor(config) {
	        super();
	        // State
	        this.isActive = false;
	        this.activePointerId = null;
	        this.centerPosition = { x: 0, y: 0 };
	        this.knobPosition = { x: 0, y: 0 };
	        // Animation
	        this.fadeAnimation = null;
	        this.currentAlpha = 1;
	        // Screen dimensions cache
	        this.screenWidth = window.innerWidth;
	        this.screenHeight = window.innerHeight;
	        // Merge config with defaults
	        this.config = {
	            mode: config.mode,
	            position: config.position || { x: 100, y: window.innerHeight - 200 },
	            activationZone: config.activationZone || { x: 0, y: 0, width: 0.5, height: 1 },
	            size: config.size || 120,
	            knobSize: config.knobSize || (config.size || 120) * 0.4,
	            deadZone: config.deadZone ?? 0.1,
	            maxDistance: config.maxDistance || (config.size || 120) * 0.4,
	            style: config.style || {},
	            hideWhenIdle: config.hideWhenIdle ?? true,
	            fadeInDuration: config.fadeInDuration ?? 100,
	            fadeOutDuration: config.fadeOutDuration ?? 200,
	        };
	        // Merge style with defaults
	        this.style = { ...DEFAULT_STYLE, ...this.config.style };
	        // Initialize move data
	        this.currentData = {
	            vector: { x: 0, y: 0 },
	            angle: 0,
	            magnitude: 0,
	            direction: 'idle',
	            rawPosition: { x: 0, y: 0 },
	        };
	        // Create graphics
	        const factory = graphics();
	        this.container = factory.createContainer();
	        this.baseGraphics = factory.createGraphics();
	        this.knobGraphics = factory.createGraphics();
	        this.container.addChild(this.baseGraphics);
	        this.container.addChild(this.knobGraphics);
	        // Bind event handlers
	        this.boundPointerDown = this.handlePointerDown.bind(this);
	        this.boundPointerMove = this.handlePointerMove.bind(this);
	        this.boundPointerUp = this.handlePointerUp.bind(this);
	        // Initial render
	        this.render();
	        // Setup based on mode
	        if (this.config.mode === 'fixed') {
	            this.centerPosition = { ...this.config.position };
	            this.updatePosition();
	            this.container.alpha = 1;
	        }
	        else {
	            // Dynamic mode - hide initially if configured
	            if (this.config.hideWhenIdle) {
	                this.container.alpha = 0;
	                this.container.visible = false;
	            }
	        }
	        // Setup event listeners
	        this.setupEventListeners();
	        // Listen for resize
	        window.addEventListener('resize', this.handleResize.bind(this));
	    }
	    /**
	     * Render the joystick graphics
	     */
	    render() {
	        const { size, knobSize } = this.config;
	        const halfSize = size / 2;
	        const halfKnob = knobSize / 2;
	        // Clear previous graphics
	        this.baseGraphics.clear();
	        this.knobGraphics.clear();
	        // Draw base circle
	        this.baseGraphics.circle(0, 0, halfSize);
	        this.baseGraphics.fill({ color: this.style.baseColor, alpha: this.style.baseAlpha });
	        this.baseGraphics.circle(0, 0, halfSize);
	        this.baseGraphics.stroke({
	            color: this.style.borderColor,
	            width: this.style.borderWidth,
	            alpha: this.style.borderAlpha
	        });
	        // Draw knob circle
	        this.knobGraphics.circle(0, 0, halfKnob);
	        this.knobGraphics.fill({ color: this.style.knobColor, alpha: this.style.knobAlpha });
	    }
	    /**
	     * Setup pointer event listeners
	     */
	    setupEventListeners() {
	        // Use document to capture all pointer events
	        document.addEventListener('pointerdown', this.boundPointerDown);
	        document.addEventListener('pointermove', this.boundPointerMove);
	        document.addEventListener('pointerup', this.boundPointerUp);
	        document.addEventListener('pointercancel', this.boundPointerUp);
	    }
	    /**
	     * Remove event listeners
	     */
	    removeEventListeners() {
	        document.removeEventListener('pointerdown', this.boundPointerDown);
	        document.removeEventListener('pointermove', this.boundPointerMove);
	        document.removeEventListener('pointerup', this.boundPointerUp);
	        document.removeEventListener('pointercancel', this.boundPointerUp);
	    }
	    /**
	     * Handle pointer down event
	     */
	    handlePointerDown(event) {
	        // Already tracking a pointer
	        if (this.activePointerId !== null)
	            return;
	        const pos = { x: event.clientX, y: event.clientY };
	        if (this.config.mode === 'dynamic') {
	            // Check if touch is within activation zone
	            if (!this.isInActivationZone(pos))
	                return;
	            // Set center to touch position
	            this.centerPosition = { ...pos };
	            this.updatePosition();
	            // Show joystick
	            this.showJoystick();
	        }
	        else {
	            // Fixed mode - check if touch is on the joystick
	            if (!this.isInJoystickArea(pos))
	                return;
	        }
	        // Start tracking
	        this.isActive = true;
	        this.activePointerId = event.pointerId;
	        // Update knob position
	        this.updateKnob(pos);
	        this.emit('start');
	    }
	    /**
	     * Handle pointer move event
	     */
	    handlePointerMove(event) {
	        if (!this.isActive || event.pointerId !== this.activePointerId)
	            return;
	        const pos = { x: event.clientX, y: event.clientY };
	        this.updateKnob(pos);
	    }
	    /**
	     * Handle pointer up event
	     */
	    handlePointerUp(event) {
	        if (event.pointerId !== this.activePointerId)
	            return;
	        this.isActive = false;
	        this.activePointerId = null;
	        // Reset knob to center
	        this.resetKnob();
	        // Hide joystick in dynamic mode
	        if (this.config.mode === 'dynamic' && this.config.hideWhenIdle) {
	            this.hideJoystick();
	        }
	        this.emit('end');
	    }
	    /**
	     * Check if position is within activation zone
	     */
	    isInActivationZone(pos) {
	        const zone = this.config.activationZone;
	        const zoneX = zone.x * this.screenWidth;
	        const zoneY = zone.y * this.screenHeight;
	        const zoneW = zone.width * this.screenWidth;
	        const zoneH = zone.height * this.screenHeight;
	        return pos.x >= zoneX && pos.x <= zoneX + zoneW &&
	            pos.y >= zoneY && pos.y <= zoneY + zoneH;
	    }
	    /**
	     * Check if position is within joystick area (fixed mode)
	     */
	    isInJoystickArea(pos) {
	        const dx = pos.x - this.centerPosition.x;
	        const dy = pos.y - this.centerPosition.y;
	        const distance = Math.sqrt(dx * dx + dy * dy);
	        return distance <= this.config.size / 2;
	    }
	    /**
	     * Update container position based on center
	     */
	    updatePosition() {
	        this.container.x = this.centerPosition.x;
	        this.container.y = this.centerPosition.y;
	    }
	    /**
	     * Update knob position based on pointer position
	     */
	    updateKnob(pointerPos) {
	        const dx = pointerPos.x - this.centerPosition.x;
	        const dy = pointerPos.y - this.centerPosition.y;
	        const distance = Math.sqrt(dx * dx + dy * dy);
	        // Clamp to max distance
	        const maxDist = this.config.maxDistance;
	        const clampedDistance = Math.min(distance, maxDist);
	        // Calculate normalized direction
	        let normalizedX = 0;
	        let normalizedY = 0;
	        if (distance > 0) {
	            normalizedX = dx / distance;
	            normalizedY = dy / distance;
	        }
	        // Calculate knob position
	        this.knobPosition = {
	            x: normalizedX * clampedDistance,
	            y: normalizedY * clampedDistance,
	        };
	        // Update knob graphics position
	        this.knobGraphics.x = this.knobPosition.x;
	        this.knobGraphics.y = this.knobPosition.y;
	        // Calculate magnitude (0-1)
	        const magnitude = clampedDistance / maxDist;
	        // Apply dead zone
	        const effectiveMagnitude = magnitude < this.config.deadZone ? 0 :
	            (magnitude - this.config.deadZone) / (1 - this.config.deadZone);
	        // Calculate output vector
	        const outputX = effectiveMagnitude > 0 ? normalizedX * effectiveMagnitude : 0;
	        const outputY = effectiveMagnitude > 0 ? normalizedY * effectiveMagnitude : 0;
	        // Calculate angle (0-360, 0 = right, 90 = down)
	        let angle = 0;
	        if (effectiveMagnitude > 0) {
	            angle = Math.atan2(normalizedY, normalizedX) * (180 / Math.PI);
	            if (angle < 0)
	                angle += 360;
	        }
	        // Calculate direction
	        const direction = this.calculateDirection(outputX, outputY, effectiveMagnitude);
	        // Update current data
	        this.currentData = {
	            vector: { x: outputX, y: outputY },
	            angle,
	            magnitude: effectiveMagnitude,
	            direction,
	            rawPosition: { x: this.knobPosition.x, y: this.knobPosition.y },
	        };
	        // Emit move event
	        this.emit('move', this.currentData);
	    }
	    /**
	     * Calculate 8-way direction from vector
	     */
	    calculateDirection(x, y, magnitude) {
	        if (magnitude < 0.01)
	            return 'idle';
	        const angle = Math.atan2(y, x) * (180 / Math.PI);
	        // 8-way direction based on 45-degree segments
	        if (angle >= -22.5 && angle < 22.5)
	            return 'right';
	        if (angle >= 22.5 && angle < 67.5)
	            return 'down-right';
	        if (angle >= 67.5 && angle < 112.5)
	            return 'down';
	        if (angle >= 112.5 && angle < 157.5)
	            return 'down-left';
	        if (angle >= 157.5 || angle < -157.5)
	            return 'left';
	        if (angle >= -157.5 && angle < -112.5)
	            return 'up-left';
	        if (angle >= -112.5 && angle < -67.5)
	            return 'up';
	        if (angle >= -67.5 && angle < -22.5)
	            return 'up-right';
	        return 'idle';
	    }
	    /**
	     * Reset knob to center position
	     */
	    resetKnob() {
	        this.knobPosition = { x: 0, y: 0 };
	        this.knobGraphics.x = 0;
	        this.knobGraphics.y = 0;
	        // Reset data
	        this.currentData = {
	            vector: { x: 0, y: 0 },
	            angle: 0,
	            magnitude: 0,
	            direction: 'idle',
	            rawPosition: { x: 0, y: 0 },
	        };
	        // Emit final move with zero values
	        this.emit('move', this.currentData);
	    }
	    /**
	     * Show joystick with fade animation
	     */
	    showJoystick() {
	        if (this.fadeAnimation !== null) {
	            cancelAnimationFrame(this.fadeAnimation);
	        }
	        this.container.visible = true;
	        const startAlpha = this.currentAlpha;
	        const targetAlpha = 1;
	        const duration = this.config.fadeInDuration;
	        const startTime = performance.now();
	        const animate = (currentTime) => {
	            const elapsed = currentTime - startTime;
	            const progress = Math.min(elapsed / duration, 1);
	            this.currentAlpha = startAlpha + (targetAlpha - startAlpha) * progress;
	            this.container.alpha = this.currentAlpha;
	            if (progress < 1) {
	                this.fadeAnimation = requestAnimationFrame(animate);
	            }
	            else {
	                this.fadeAnimation = null;
	            }
	        };
	        this.fadeAnimation = requestAnimationFrame(animate);
	    }
	    /**
	     * Hide joystick with fade animation
	     */
	    hideJoystick() {
	        if (this.fadeAnimation !== null) {
	            cancelAnimationFrame(this.fadeAnimation);
	        }
	        const startAlpha = this.currentAlpha;
	        const targetAlpha = 0;
	        const duration = this.config.fadeOutDuration;
	        const startTime = performance.now();
	        const animate = (currentTime) => {
	            const elapsed = currentTime - startTime;
	            const progress = Math.min(elapsed / duration, 1);
	            this.currentAlpha = startAlpha + (targetAlpha - startAlpha) * progress;
	            this.container.alpha = this.currentAlpha;
	            if (progress < 1) {
	                this.fadeAnimation = requestAnimationFrame(animate);
	            }
	            else {
	                this.fadeAnimation = null;
	                this.container.visible = false;
	            }
	        };
	        this.fadeAnimation = requestAnimationFrame(animate);
	    }
	    /**
	     * Handle window resize
	     */
	    handleResize() {
	        this.screenWidth = window.innerWidth;
	        this.screenHeight = window.innerHeight;
	    }
	    // =====================
	    // Public API
	    // =====================
	    /**
	     * Get the container for adding to scene
	     */
	    getContainer() {
	        return this.container;
	    }
	    /**
	     * Get current joystick data
	     */
	    getData() {
	        return { ...this.currentData };
	    }
	    /**
	     * Get current vector value
	     */
	    getVector() {
	        return { ...this.currentData.vector };
	    }
	    /**
	     * Check if joystick is currently active (being touched)
	     */
	    isPressed() {
	        return this.isActive;
	    }
	    /**
	     * Set joystick position (fixed mode) or center position (dynamic mode)
	     */
	    setPosition(x, y) {
	        this.config.position = { x, y };
	        if (this.config.mode === 'fixed') {
	            this.centerPosition = { x, y };
	            this.updatePosition();
	        }
	    }
	    /**
	     * Set activation zone (dynamic mode)
	     */
	    setActivationZone(zone) {
	        this.config.activationZone = zone;
	    }
	    /**
	     * Update joystick style
	     */
	    setStyle(style) {
	        this.style = { ...this.style, ...style };
	        this.render();
	    }
	    /**
	     * Set joystick size
	     */
	    setSize(size, knobSize) {
	        this.config.size = size;
	        this.config.knobSize = knobSize || size * 0.4;
	        this.config.maxDistance = size * 0.4;
	        this.render();
	    }
	    /**
	     * Set dead zone threshold
	     */
	    setDeadZone(deadZone) {
	        this.config.deadZone = Math.max(0, Math.min(1, deadZone));
	    }
	    /**
	     * Show the joystick
	     */
	    show() {
	        this.container.visible = true;
	        this.container.alpha = 1;
	        this.currentAlpha = 1;
	    }
	    /**
	     * Hide the joystick
	     */
	    hide() {
	        this.container.visible = false;
	        this.container.alpha = 0;
	        this.currentAlpha = 0;
	    }
	    /**
	     * Enable the joystick
	     */
	    enable() {
	        this.setupEventListeners();
	    }
	    /**
	     * Disable the joystick
	     */
	    disable() {
	        this.removeEventListeners();
	        if (this.isActive) {
	            this.isActive = false;
	            this.activePointerId = null;
	            this.resetKnob();
	        }
	    }
	    /**
	     * Update joystick (call in game loop if needed for animations)
	     */
	    update(_deltaTime) {
	        // Currently animations are handled via requestAnimationFrame
	        // This method is provided for future extensions
	    }
	    /**
	     * Destroy the joystick and clean up resources
	     */
	    destroy() {
	        // Cancel any pending animation
	        if (this.fadeAnimation !== null) {
	            cancelAnimationFrame(this.fadeAnimation);
	            this.fadeAnimation = null;
	        }
	        // Remove event listeners
	        this.removeEventListeners();
	        window.removeEventListener('resize', this.handleResize.bind(this));
	        // Destroy graphics
	        this.container.destroy();
	        // Remove all event listeners
	        this.removeAllListeners();
	    }
	}

	/**
	 * Safe Area Layout System
	 *
	 * Provides a "Safe Area + Letterbox" approach for responsive game layouts.
	 * Similar to Candy Crush and other mobile games, this system:
	 * - Defines a "design resolution" (e.g., 390x844)
	 * - Scales content to fit the screen while maintaining aspect ratio
	 * - Centers the game content
	 * - Fills letterbox areas with background color/pattern
	 */
	/**
	 * SafeAreaLayout
	 *
	 * Manages responsive game layout using the Safe Area + Letterbox approach.
	 * Creates a PIXI container structure that automatically handles:
	 * - Scaling to fit the screen
	 * - Centering the game content
	 * - Drawing letterbox areas
	 */
	class SafeAreaLayout {
	    constructor(config) {
	        this.resizeCallbacks = [];
	        // PIXI objects (typed as any to avoid PIXI dependency)
	        this.PIXI = null;
	        this.mainContainer = null;
	        this.letterboxGraphics = null;
	        this.gameContainer = null;
	        this.resizeHandler = null;
	        this.config = {
	            designWidth: config.designWidth,
	            designHeight: config.designHeight,
	            minAspectRatio: config.minAspectRatio ?? 0.4,
	            maxAspectRatio: config.maxAspectRatio ?? 1.0,
	            backgroundColor: config.backgroundColor ?? 0x1a1a2e,
	            showPattern: config.showPattern ?? false,
	            patternOpacity: config.patternOpacity ?? 0.05
	        };
	        // Initialize with a placeholder bounds
	        this.currentBounds = {
	            x: 0,
	            y: 0,
	            width: this.config.designWidth,
	            height: this.config.designHeight,
	            scale: 1,
	            screenWidth: this.config.designWidth,
	            screenHeight: this.config.designHeight,
	            isVerticalLetterbox: true
	        };
	    }
	    /**
	     * Initialize the layout system with PIXI
	     * @param PIXI - The PIXI namespace object
	     */
	    initialize(PIXI) {
	        this.PIXI = PIXI;
	        // Create main container that holds everything
	        this.mainContainer = new PIXI.Container();
	        // Create graphics for letterbox background
	        this.letterboxGraphics = new PIXI.Graphics();
	        this.mainContainer.addChild(this.letterboxGraphics);
	        // Create game container that will be positioned in the safe area
	        this.gameContainer = new PIXI.Container();
	        this.mainContainer.addChild(this.gameContainer);
	        // Set up resize handler
	        this.resizeHandler = () => {
	            this.updateLayout(window.innerWidth, window.innerHeight);
	        };
	        window.addEventListener('resize', this.resizeHandler);
	        // Initial layout
	        this.updateLayout(window.innerWidth, window.innerHeight);
	    }
	    /**
	     * Calculate the safe area bounds for given screen dimensions
	     */
	    calculateBounds(screenWidth, screenHeight) {
	        const designAspect = this.config.designWidth / this.config.designHeight;
	        const screenAspect = screenWidth / screenHeight;
	        let scale;
	        let safeWidth;
	        let safeHeight;
	        let isVerticalLetterbox;
	        // Determine scaling based on aspect ratio comparison
	        if (screenAspect > designAspect) {
	            // Screen is wider than design - fit to height, pillarbox (left/right bars)
	            scale = screenHeight / this.config.designHeight;
	            safeHeight = screenHeight;
	            safeWidth = this.config.designWidth * scale;
	            isVerticalLetterbox = false;
	        }
	        else {
	            // Screen is taller than design - fit to width, letterbox (top/bottom bars)
	            scale = screenWidth / this.config.designWidth;
	            safeWidth = screenWidth;
	            safeHeight = this.config.designHeight * scale;
	            isVerticalLetterbox = true;
	        }
	        // Calculate centered position
	        const x = (screenWidth - safeWidth) / 2;
	        const y = (screenHeight - safeHeight) / 2;
	        return {
	            x,
	            y,
	            width: safeWidth,
	            height: safeHeight,
	            scale,
	            screenWidth,
	            screenHeight,
	            isVerticalLetterbox
	        };
	    }
	    /**
	     * Update the layout for new screen dimensions
	     */
	    updateLayout(screenWidth, screenHeight) {
	        this.currentBounds = this.calculateBounds(screenWidth, screenHeight);
	        // Update game container position and scale
	        if (this.gameContainer) {
	            this.gameContainer.x = this.currentBounds.x;
	            this.gameContainer.y = this.currentBounds.y;
	            this.gameContainer.scale.set(this.currentBounds.scale);
	        }
	        // Redraw letterbox
	        this.drawLetterbox();
	        // Notify listeners
	        this.resizeCallbacks.forEach(callback => callback(this.currentBounds));
	    }
	    /**
	     * Draw the letterbox background with optional pattern
	     */
	    drawLetterbox() {
	        if (!this.letterboxGraphics || !this.PIXI)
	            return;
	        const g = this.letterboxGraphics;
	        const bounds = this.currentBounds;
	        g.clear();
	        // Fill entire screen with background color
	        g.rect(0, 0, bounds.screenWidth, bounds.screenHeight);
	        g.fill({ color: this.config.backgroundColor });
	        // Draw pattern if enabled
	        if (this.config.showPattern) {
	            this.drawPattern();
	        }
	        // Draw a slightly darker overlay on the letterbox areas only
	        // This makes the safe area appear slightly brighter/distinct
	        const overlayAlpha = 0.1;
	        if (bounds.isVerticalLetterbox) {
	            // Top and bottom bars
	            if (bounds.y > 0) {
	                // Top bar
	                g.rect(0, 0, bounds.screenWidth, bounds.y);
	                g.fill({ color: 0x000000, alpha: overlayAlpha });
	                // Bottom bar
	                g.rect(0, bounds.y + bounds.height, bounds.screenWidth, bounds.screenHeight - bounds.y - bounds.height);
	                g.fill({ color: 0x000000, alpha: overlayAlpha });
	            }
	        }
	        else {
	            // Left and right bars
	            if (bounds.x > 0) {
	                // Left bar
	                g.rect(0, 0, bounds.x, bounds.screenHeight);
	                g.fill({ color: 0x000000, alpha: overlayAlpha });
	                // Right bar
	                g.rect(bounds.x + bounds.width, 0, bounds.screenWidth - bounds.x - bounds.width, bounds.screenHeight);
	                g.fill({ color: 0x000000, alpha: overlayAlpha });
	            }
	        }
	    }
	    /**
	     * Draw a subtle square pattern in the letterbox areas
	     */
	    drawPattern() {
	        if (!this.letterboxGraphics)
	            return;
	        const g = this.letterboxGraphics;
	        const bounds = this.currentBounds;
	        const patternSize = 20;
	        const squareSize = 4;
	        const opacity = this.config.patternOpacity;
	        // Helper to draw pattern in a region
	        const drawPatternInRegion = (rx, ry, rw, rh) => {
	            if (rw <= 0 || rh <= 0)
	                return;
	            for (let px = rx; px < rx + rw; px += patternSize) {
	                for (let py = ry; py < ry + rh; py += patternSize) {
	                    g.rect(px, py, squareSize, squareSize);
	                    g.fill({ color: 0xffffff, alpha: opacity });
	                }
	            }
	        };
	        if (bounds.isVerticalLetterbox) {
	            // Draw pattern in top and bottom bars
	            if (bounds.y > 0) {
	                drawPatternInRegion(0, 0, bounds.screenWidth, bounds.y);
	                drawPatternInRegion(0, bounds.y + bounds.height, bounds.screenWidth, bounds.screenHeight - bounds.y - bounds.height);
	            }
	        }
	        else {
	            // Draw pattern in left and right bars
	            if (bounds.x > 0) {
	                drawPatternInRegion(0, 0, bounds.x, bounds.screenHeight);
	                drawPatternInRegion(bounds.x + bounds.width, 0, bounds.screenWidth - bounds.x - bounds.width, bounds.screenHeight);
	            }
	        }
	    }
	    /**
	     * Register a callback for resize events
	     */
	    onResize(callback) {
	        this.resizeCallbacks.push(callback);
	    }
	    /**
	     * Remove a resize callback
	     */
	    offResize(callback) {
	        const index = this.resizeCallbacks.indexOf(callback);
	        if (index !== -1) {
	            this.resizeCallbacks.splice(index, 1);
	        }
	    }
	    /**
	     * Get the main container (includes letterbox and game container)
	     * Add this to your PIXI stage
	     */
	    getContainer() {
	        return this.mainContainer;
	    }
	    /**
	     * Get the game container (safe area)
	     * Add game content as children of this container
	     */
	    getGameContainer() {
	        return this.gameContainer;
	    }
	    /**
	     * Add a child to the game container
	     */
	    addChild(child) {
	        if (this.gameContainer) {
	            return this.gameContainer.addChild(child);
	        }
	        return child;
	    }
	    /**
	     * Remove a child from the game container
	     */
	    removeChild(child) {
	        if (this.gameContainer) {
	            return this.gameContainer.removeChild(child);
	        }
	        return child;
	    }
	    /**
	     * Get current safe area bounds
	     */
	    getBounds() {
	        return { ...this.currentBounds };
	    }
	    /**
	     * Get design width
	     */
	    getDesignWidth() {
	        return this.config.designWidth;
	    }
	    /**
	     * Get design height
	     */
	    getDesignHeight() {
	        return this.config.designHeight;
	    }
	    /**
	     * Convert screen coordinates to design coordinates
	     * Useful for handling input events
	     */
	    screenToDesign(screenX, screenY) {
	        const bounds = this.currentBounds;
	        return {
	            x: (screenX - bounds.x) / bounds.scale,
	            y: (screenY - bounds.y) / bounds.scale
	        };
	    }
	    /**
	     * Convert design coordinates to screen coordinates
	     * Useful for positioning UI elements outside the game container
	     */
	    designToScreen(designX, designY) {
	        const bounds = this.currentBounds;
	        return {
	            x: designX * bounds.scale + bounds.x,
	            y: designY * bounds.scale + bounds.y
	        };
	    }
	    /**
	     * Check if a screen point is within the safe area
	     */
	    isPointInSafeArea(screenX, screenY) {
	        const bounds = this.currentBounds;
	        return (screenX >= bounds.x &&
	            screenX <= bounds.x + bounds.width &&
	            screenY >= bounds.y &&
	            screenY <= bounds.y + bounds.height);
	    }
	    /**
	     * Get the current scale factor
	     */
	    getScale() {
	        return this.currentBounds.scale;
	    }
	    /**
	     * Update background color
	     */
	    setBackgroundColor(color) {
	        this.config.backgroundColor = color;
	        this.drawLetterbox();
	    }
	    /**
	     * Toggle pattern visibility
	     */
	    setShowPattern(show) {
	        this.config.showPattern = show;
	        this.drawLetterbox();
	    }
	    /**
	     * Set pattern opacity
	     */
	    setPatternOpacity(opacity) {
	        this.config.patternOpacity = Math.max(0, Math.min(1, opacity));
	        this.drawLetterbox();
	    }
	    /**
	     * Destroy and clean up all resources
	     */
	    destroy() {
	        // Remove resize listener
	        if (this.resizeHandler) {
	            window.removeEventListener('resize', this.resizeHandler);
	            this.resizeHandler = null;
	        }
	        // Clear callbacks
	        this.resizeCallbacks = [];
	        // Destroy PIXI objects
	        if (this.letterboxGraphics) {
	            this.letterboxGraphics.destroy();
	            this.letterboxGraphics = null;
	        }
	        if (this.gameContainer) {
	            this.gameContainer.destroy({ children: true });
	            this.gameContainer = null;
	        }
	        if (this.mainContainer) {
	            this.mainContainer.destroy({ children: true });
	            this.mainContainer = null;
	        }
	        this.PIXI = null;
	    }
	}
	/**
	 * Create a SafeAreaLayout with default configuration
	 * Defaults to iPhone-style dimensions (390x844)
	 */
	function createSafeAreaLayout(config) {
	    return new SafeAreaLayout({
	        designWidth: config?.designWidth ?? 390,
	        designHeight: config?.designHeight ?? 844,
	        minAspectRatio: config?.minAspectRatio ?? 0.4,
	        maxAspectRatio: config?.maxAspectRatio ?? 1.0,
	        backgroundColor: config?.backgroundColor ?? 0x1a1a2e,
	        showPattern: config?.showPattern ?? false,
	        patternOpacity: config?.patternOpacity ?? 0.05
	    });
	}

	/**
	 * Three.js Graphics Factory Implementation
	 *
	 * Provides Three.js-based implementations of framework graphics primitives.
	 * Uses CSS2DRenderer for UI elements, allowing HTML/CSS-based UI in 3D scenes.
	 */
	/**
	 * Base Three.js Display Object Wrapper
	 */
	class ThreeDisplayObjectBase extends EventEmitter {
	    constructor(element) {
	        super();
	        this.element = element;
	        this.css2dObject = new CSS2DRenderer_js.CSS2DObject(element);
	        // Apply default styles for consistent behavior
	        this.element.style.position = 'absolute';
	        this.element.style.pointerEvents = 'auto';
	    }
	    get x() {
	        return this.css2dObject.position.x;
	    }
	    set x(value) {
	        this.css2dObject.position.x = value;
	    }
	    get y() {
	        return this.css2dObject.position.y;
	    }
	    set y(value) {
	        this.css2dObject.position.y = value;
	    }
	    get rotation() {
	        return this.css2dObject.rotation.z;
	    }
	    set rotation(value) {
	        this.css2dObject.rotation.z = value;
	    }
	    get scale() {
	        return {
	            x: this.css2dObject.scale.x,
	            y: this.css2dObject.scale.y,
	        };
	    }
	    set scale(value) {
	        this.css2dObject.scale.set(value.x, value.y, 1);
	    }
	    get alpha() {
	        return parseFloat(this.element.style.opacity || '1');
	    }
	    set alpha(value) {
	        this.element.style.opacity = value.toString();
	    }
	    get visible() {
	        return this.css2dObject.visible;
	    }
	    set visible(value) {
	        this.css2dObject.visible = value;
	        this.element.style.display = value ? 'block' : 'none';
	    }
	    get interactive() {
	        return this.element.style.pointerEvents === 'auto';
	    }
	    set interactive(value) {
	        this.element.style.pointerEvents = value ? 'auto' : 'none';
	    }
	    get cursor() {
	        return this.element.style.cursor;
	    }
	    set cursor(value) {
	        this.element.style.cursor = value || 'default';
	    }
	    getCSS2DObject() {
	        return this.css2dObject;
	    }
	    destroy() {
	        this.element.remove();
	        this.removeAllListeners();
	    }
	}
	/**
	 * Three.js Container Wrapper
	 */
	class ThreeContainerWrapper extends ThreeDisplayObjectBase {
	    constructor() {
	        const div = document.createElement('div');
	        div.style.transformStyle = 'preserve-3d';
	        super(div);
	        this.children = [];
	    }
	    addChild(child) {
	        this.children.push(child);
	        // Add CSS2D object if it's a Three wrapper
	        if (child.getCSS2DObject) {
	            this.css2dObject.add(child.getCSS2DObject());
	        }
	        return child;
	    }
	    removeChild(child) {
	        const index = this.children.indexOf(child);
	        if (index !== -1) {
	            this.children.splice(index, 1);
	            if (child.getCSS2DObject) {
	                this.css2dObject.remove(child.getCSS2DObject());
	            }
	        }
	        return child;
	    }
	    removeChildren() {
	        while (this.children.length > 0) {
	            this.removeChild(this.children[0]);
	        }
	    }
	    getChildAt(index) {
	        return this.children[index];
	    }
	    getChildIndex(child) {
	        return this.children.indexOf(child);
	    }
	    setChildIndex(child, index) {
	        const currentIndex = this.children.indexOf(child);
	        if (currentIndex !== -1) {
	            this.children.splice(currentIndex, 1);
	            this.children.splice(index, 0, child);
	        }
	    }
	}
	/**
	 * Three.js Graphics Wrapper (HTML Canvas-based)
	 * Implements Pixi v8 modern API using HTML5 Canvas
	 */
	class ThreeGraphicsWrapper extends ThreeDisplayObjectBase {
	    constructor() {
	        const canvas = document.createElement('canvas');
	        canvas.width = 800;
	        canvas.height = 600;
	        super(canvas);
	        this.pathStarted = false;
	        this.canvas = canvas;
	        this.ctx = canvas.getContext('2d');
	    }
	    clear() {
	        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
	        return this;
	    }
	    // Pixi v8 Modern API - Shape methods
	    rect(x, y, width, height) {
	        this.ctx.beginPath();
	        this.ctx.rect(x, y, width, height);
	        this.pathStarted = true;
	        return this;
	    }
	    roundRect(x, y, width, height, radius) {
	        this.ctx.beginPath();
	        this.ctx.roundRect(x, y, width, height, radius);
	        this.pathStarted = true;
	        return this;
	    }
	    circle(x, y, radius) {
	        this.ctx.beginPath();
	        this.ctx.arc(x, y, radius, 0, Math.PI * 2);
	        this.pathStarted = true;
	        return this;
	    }
	    ellipse(x, y, width, height) {
	        this.ctx.beginPath();
	        this.ctx.ellipse(x, y, width / 2, height / 2, 0, 0, Math.PI * 2);
	        this.pathStarted = true;
	        return this;
	    }
	    poly(points) {
	        this.ctx.beginPath();
	        if (Array.isArray(points) && typeof points[0] === 'number') {
	            const numPoints = points;
	            this.ctx.moveTo(numPoints[0], numPoints[1]);
	            for (let i = 2; i < numPoints.length; i += 2) {
	                this.ctx.lineTo(numPoints[i], numPoints[i + 1]);
	            }
	        }
	        else {
	            const objPoints = points;
	            this.ctx.moveTo(objPoints[0].x, objPoints[0].y);
	            for (let i = 1; i < objPoints.length; i++) {
	                this.ctx.lineTo(objPoints[i].x, objPoints[i].y);
	            }
	        }
	        this.ctx.closePath();
	        this.pathStarted = true;
	        return this;
	    }
	    // Fill and stroke
	    fill(options) {
	        if (options) {
	            const color = options.color !== undefined ? options.color : 0xffffff;
	            const alpha = options.alpha !== undefined ? options.alpha : 1;
	            this.ctx.fillStyle = this.colorToHex(color);
	            this.ctx.globalAlpha = alpha;
	        }
	        this.ctx.fill();
	        this.ctx.globalAlpha = 1;
	        this.pathStarted = false;
	        return this;
	    }
	    stroke(options) {
	        if (options) {
	            if (options.color !== undefined) {
	                this.ctx.strokeStyle = this.colorToHex(options.color);
	            }
	            if (options.width !== undefined) {
	                this.ctx.lineWidth = options.width;
	            }
	            if (options.alpha !== undefined) {
	                this.ctx.globalAlpha = options.alpha;
	            }
	        }
	        this.ctx.stroke();
	        this.ctx.globalAlpha = 1;
	        this.pathStarted = false;
	        return this;
	    }
	    // Line drawing
	    moveTo(x, y) {
	        if (!this.pathStarted) {
	            this.ctx.beginPath();
	            this.pathStarted = true;
	        }
	        this.ctx.moveTo(x, y);
	        return this;
	    }
	    lineTo(x, y) {
	        if (!this.pathStarted) {
	            this.ctx.beginPath();
	            this.pathStarted = true;
	        }
	        this.ctx.lineTo(x, y);
	        return this;
	    }
	    // Arc and path methods
	    arc(cx, cy, radius, startAngle, endAngle, anticlockwise) {
	        if (!this.pathStarted) {
	            this.ctx.beginPath();
	            this.pathStarted = true;
	        }
	        this.ctx.arc(cx, cy, radius, startAngle, endAngle, anticlockwise);
	        return this;
	    }
	    closePath() {
	        this.ctx.closePath();
	        return this;
	    }
	    // Texture support
	    texture(texture) {
	        // For Three.js/CSS2D Canvas, we can't directly use Pixi textures
	        // This is a no-op for CSS-based graphics
	        return this;
	    }
	    colorToHex(color) {
	        return '#' + color.toString(16).padStart(6, '0');
	    }
	}
	/**
	 * Three.js Text Wrapper
	 */
	class ThreeTextWrapper extends ThreeDisplayObjectBase {
	    constructor(text, style) {
	        const div = document.createElement('div');
	        super(div);
	        this._text = text;
	        this._style = style || {};
	        this.element.textContent = text;
	        this.applyStyle(this._style);
	        this.initializeAnchor();
	    }
	    initializeAnchor() {
	        this._anchor = {
	            x: 0,
	            y: 0,
	            set: (x, y) => {
	                const yVal = y !== undefined ? y : x;
	                this.element.style.transformOrigin = `${x * 100}% ${yVal * 100}%`;
	                this._anchor.x = x;
	                this._anchor.y = yVal;
	            }
	        };
	    }
	    get text() {
	        return this._text;
	    }
	    set text(value) {
	        this._text = value;
	        this.element.textContent = value;
	    }
	    get style() {
	        return this._style;
	    }
	    set style(value) {
	        this._style = value;
	        this.applyStyle(value);
	    }
	    get width() {
	        return this.element.offsetWidth;
	    }
	    get height() {
	        return this.element.offsetHeight;
	    }
	    get anchor() {
	        return this._anchor;
	    }
	    set anchor(value) {
	        if (value && this._anchor) {
	            this._anchor.x = value.x;
	            this._anchor.y = value.y;
	            this.element.style.transformOrigin = `${value.x * 100}% ${value.y * 100}%`;
	        }
	    }
	    applyStyle(style) {
	        if (style.fontFamily)
	            this.element.style.fontFamily = style.fontFamily;
	        if (style.fontSize)
	            this.element.style.fontSize = `${style.fontSize}px`;
	        if (style.fontWeight)
	            this.element.style.fontWeight = style.fontWeight;
	        if (style.fill !== undefined) {
	            if (typeof style.fill === 'number') {
	                this.element.style.color = '#' + style.fill.toString(16).padStart(6, '0');
	            }
	            else {
	                this.element.style.color = style.fill;
	            }
	        }
	        if (style.align)
	            this.element.style.textAlign = style.align;
	        if (style.wordWrap)
	            this.element.style.whiteSpace = 'normal';
	        if (style.wordWrapWidth)
	            this.element.style.maxWidth = `${style.wordWrapWidth}px`;
	        if (style.dropShadow && style.dropShadowColor && style.dropShadowDistance) {
	            const color = typeof style.dropShadowColor === 'number'
	                ? '#' + style.dropShadowColor.toString(16).padStart(6, '0')
	                : style.dropShadowColor;
	            this.element.style.textShadow = `${style.dropShadowDistance}px ${style.dropShadowDistance}px ${style.dropShadowBlur || 0}px ${color}`;
	        }
	    }
	}
	/**
	 * Three.js Sprite Wrapper
	 */
	class ThreeSpriteWrapper extends ThreeDisplayObjectBase {
	    constructor(texture) {
	        const img = document.createElement('img');
	        super(img);
	        this._width = 0;
	        this._height = 0;
	        this.img = img;
	        this.initializeAnchor();
	        if (typeof texture === 'string') {
	            this.img.src = texture;
	            this._texture = { width: 0, height: 0, destroy: () => { } };
	        }
	        else {
	            this._texture = texture;
	            // Texture should be a canvas or image URL
	        }
	    }
	    initializeAnchor() {
	        this._anchor = {
	            x: 0,
	            y: 0,
	            set: (x, y) => {
	                this.element.style.transformOrigin = `${x * 100}% ${y * 100}%`;
	                this._anchor.x = x;
	                this._anchor.y = y;
	            }
	        };
	    }
	    get texture() {
	        return this._texture;
	    }
	    set texture(value) {
	        this._texture = value;
	    }
	    get width() {
	        return this._width || this.img.width;
	    }
	    set width(value) {
	        this._width = value;
	        this.img.width = value;
	    }
	    get height() {
	        return this._height || this.img.height;
	    }
	    set height(value) {
	        this._height = value;
	        this.img.height = value;
	    }
	    get anchor() {
	        return this._anchor;
	    }
	    set anchor(value) {
	        if (value && this._anchor) {
	            this._anchor.x = value.x;
	            this._anchor.y = value.y;
	            this.element.style.transformOrigin = `${value.x * 100}% ${value.y * 100}%`;
	        }
	    }
	    get tint() {
	        return undefined; // TODO: Implement color filter
	    }
	    set tint(value) {
	        // TODO: Implement color filter
	    }
	}
	/**
	 * Three.js Texture Wrapper
	 */
	class ThreeTextureWrapper {
	    constructor(source) {
	        this.source = source;
	    }
	    get width() {
	        if (typeof this.source === 'string')
	            return 0;
	        return this.source.width;
	    }
	    get height() {
	        if (typeof this.source === 'string')
	            return 0;
	        return this.source.height;
	    }
	    destroy() {
	        // Nothing to clean up for DOM elements
	    }
	    getSource() {
	        return this.source;
	    }
	}
	/**
	 * Three.js Graphics Factory
	 */
	class ThreeGraphicsFactory {
	    createContainer() {
	        return new ThreeContainerWrapper();
	    }
	    createGraphics() {
	        return new ThreeGraphicsWrapper();
	    }
	    createText(text, style) {
	        return new ThreeTextWrapper(text, style);
	    }
	    createSprite(texture) {
	        return new ThreeSpriteWrapper(texture);
	    }
	    createTexture(source) {
	        return new ThreeTextureWrapper(source);
	    }
	    createCanvasTexture(width, height, draw) {
	        const canvas = document.createElement('canvas');
	        canvas.width = width;
	        canvas.height = height;
	        const ctx = canvas.getContext('2d');
	        if (ctx) {
	            draw(ctx);
	        }
	        return new ThreeTextureWrapper(canvas);
	    }
	}

	var ThreeGraphicsFactory$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ThreeGraphicsFactory: ThreeGraphicsFactory
	});

	/**
	 * GameByte Framework - Main Entry Point
	 *
	 * A comprehensive JavaScript game engine framework that unifies 2D and 3D
	 * game development with Laravel-inspired architecture.
	 */
	// Core Framework
	function createGame(config) {
	    // If config provided, use quick setup
	    if (config) {
	        return GameByte.quick(config);
	    }
	    // Traditional setup - just create and register providers
	    const app = GameByte.create();
	    // Register core service providers
	    app.register(new RenderingServiceProvider());
	    app.register(new SceneServiceProvider());
	    app.register(new PluginServiceProvider());
	    app.register(new AssetServiceProvider());
	    app.register(new UIServiceProvider());
	    app.register(new InputServiceProvider());
	    app.register(new PhysicsServiceProvider());
	    app.register(new PerformanceServiceProvider());
	    app.register(new AudioServiceProvider());
	    return app;
	}
	// Utility function to create a GameByte instance with UI system optimized for mobile games
	function createMobileGame() {
	    const app = createGame();
	    // Additional mobile optimizations could be applied here
	    // such as specific renderer configurations, performance settings, etc.
	    return app;
	}
	/**
	 * Create a GameByte instance pre-configured for merge puzzle games.
	 *
	 * @example
	 * ```typescript
	 * const game = createMergeGame();
	 * await game.initialize(canvas, '2d');
	 *
	 * // Use the Merge facade
	 * Merge.createGame({ rows: 5, cols: 5 });
	 * scene.addChild(Merge.getContainer());
	 * Merge.start();
	 *
	 * game.start();
	 * ```
	 */
	function createMergeGame() {
	    const app = createGame();
	    // Register merge service provider
	    const { MergeServiceProvider: MSP } = require('./services/MergeServiceProvider');
	    app.register(new MSP());
	    return app;
	}
	// Default export for convenient importing
	const GameByteFramework = {
	    GameByte,
	    createGame,
	    createMobileGame,
	    RenderingMode: exports.RenderingMode,
	    ServiceContainer,
	    Assets,
	    // Facades for static access
	    Renderer: null, // Will be set after app initialization
	    Scenes: null, // Will be set after app initialization
	    Plugins: null, // Will be set after app initialization
	    UI: null, // Will be set after app initialization
	    Animations: null, // Will be set after app initialization
	    Themes: null, // Will be set after app initialization
	    Input: null, // Will be set after app initialization
	    Physics: null, // Will be set after app initialization
	    Performance: null, // Will be set after app initialization
	    Audio: null, // Will be set after app initialization
	    Merge: null // Will be set after app initialization
	};
	/**
	 * Initialize facades with a GameByte application instance.
	 * This should be called after creating your GameByte app.
	 */
	function initializeFacades(app) {
	    // Import facades (already imported at the top of this file)
	    Facade.setApplication(app);
	    // Update default export facades
	    GameByteFramework.Renderer = Renderer;
	    GameByteFramework.Scenes = Scenes;
	    GameByteFramework.Plugins = Plugins;
	    GameByteFramework.UI = UI;
	    GameByteFramework.Animations = Animations;
	    GameByteFramework.Themes = Themes;
	    GameByteFramework.Input = Input;
	    GameByteFramework.Physics = Physics;
	    GameByteFramework.Performance = Performance;
	    GameByteFramework.Audio = Audio;
	    GameByteFramework.Merge = Merge;
	}

	exports.ARCHERO_COLORS = ARCHERO_COLORS;
	exports.AbstractServiceProvider = AbstractServiceProvider;
	exports.Animations = Animations;
	exports.ArcheroMenu = ArcheroMenu;
	exports.AssetServiceProvider = AssetServiceProvider;
	exports.Assets = Assets;
	exports.AudioFacade = Audio;
	exports.AudioServiceProvider = AudioServiceProvider;
	exports.BaseScene = BaseScene;
	exports.BaseScene3D = BaseScene3D;
	exports.BaseUIComponent = BaseUIComponent;
	exports.BaseUIScreen = BaseUIScreen;
	exports.BrowserFeatureDetector = BrowserFeatureDetector;
	exports.Cannon3DBody = Cannon3DBody;
	exports.Cannon3DConstraint = Cannon3DConstraint;
	exports.Cannon3DEngine = Cannon3DEngine;
	exports.Cannon3DWorld = Cannon3DWorld;
	exports.CelebrationManager = CelebrationManager;
	exports.CelebrationPresets = CelebrationPresets;
	exports.ConfettiSystem = ConfettiSystem;
	exports.DEFAULT_PANEL_THEME = DEFAULT_PANEL_THEME;
	exports.DarkGamingUITheme = DarkGamingUITheme;
	exports.DefaultSceneManager = DefaultSceneManager;
	exports.DefaultUITheme = DefaultUITheme;
	exports.DeviceDetector = DeviceDetector;
	exports.EventEmitter = EventEmitter;
	exports.Facade = Facade;
	exports.FrameRateManagerClass = FrameRateManager;
	exports.FrameworkCompatibility = FrameworkCompatibility;
	exports.GameBottomNav = GameBottomNav;
	exports.GameBottomSheet = GameBottomSheet;
	exports.GameButtons = GameButtons;
	exports.GameByte = GameByte;
	exports.GameByteAssetManager = GameByteAssetManager;
	exports.GameByteAudioAnalytics = GameByteAudioAnalytics;
	exports.GameByteAudioBus = GameByteAudioBus;
	exports.GameByteAudioEffectsProcessor = GameByteAudioEffectsProcessor;
	exports.GameByteAudioManager = GameByteAudioManager;
	exports.GameByteAudioSource = GameByteAudioSource;
	exports.GameByteCameraInputHandler = GameByteCameraInputHandler;
	exports.GameByteInputManager = GameByteInputManager;
	exports.GameByteInputMappingManager = GameByteInputMappingManager;
	exports.GameByteInputPerformanceManager = GameByteInputPerformanceManager;
	exports.GameByteMobileOptimizer = GameByteMobileOptimizer;
	exports.GameByteParticleSystem = GameByteParticleSystem;
	exports.GameBytePlatformerHelper = GameBytePlatformerHelper;
	exports.GameBytePlatformerInputHandler = GameBytePlatformerInputHandler;
	exports.GameBytePlayerMovementHandler = GameBytePlayerMovementHandler;
	exports.GameByteProceduralAudioGenerator = GameByteProceduralAudioGenerator;
	exports.GameByteTopDownHelper = GameByteTopDownHelper;
	exports.GameByteTouchInputHandler = GameByteTouchInputHandler;
	exports.GameByteTriggerZone = GameByteTriggerZone;
	exports.GameByteUIAnimationSystem = GameByteUIAnimationSystem;
	exports.GameByteUIInputSystem = GameByteUIInputSystem;
	exports.GameByteUIManager = GameByteUIManager;
	exports.GameByteUINavigationHandler = GameByteUINavigationHandler;
	exports.GameByteUITimeline = GameByteUITimeline;
	exports.GameByteVirtualControlsManager = GameByteVirtualControlsManager;
	exports.GameHUDScreen = GameHUDScreen;
	exports.GameLoopOptimizer = GameLoopOptimizer;
	exports.GameModalPanel = GameModalPanel;
	exports.GamePanel = GamePanel;
	exports.GameSlider = GameSlider;
	exports.GameSliderColors = GameSliderColors;
	exports.GameStyleButton = GameStyleButton;
	exports.GameStyleColors = GameStyleColors;
	exports.GameStylePanel = GameStylePanel;
	exports.GameStyleUITheme = GameStyleUITheme;
	exports.GameToggle = GameToggle;
	exports.GameToggleColors = GameToggleColors;
	exports.GameTopBar = GameTopBar;
	exports.GraphicsEngine = GraphicsEngine;
	exports.HexagonLevelButton = HexagonLevelButton;
	exports.HubScreen = HubScreen;
	exports.HybridRenderer = HybridRenderer;
	exports.Input = Input;
	exports.InputServiceProvider = InputServiceProvider;
	exports.LevelPath = LevelPath;
	exports.Matter2DBody = Matter2DBody;
	exports.Matter2DConstraint = Matter2DConstraint;
	exports.Matter2DEngine = Matter2DEngine;
	exports.Matter2DWorld = Matter2DWorld;
	exports.MemoryOptimizerClass = MemoryOptimizer;
	exports.Merge = Merge;
	exports.MergeCell = MergeCell;
	exports.MergeGameScene = MergeGameScene;
	exports.MergeGrid = MergeGrid;
	exports.MergeItem = MergeItem;
	exports.MergeManager = MergeManager;
	exports.MergeServiceProvider = MergeServiceProvider;
	exports.MinimalUITheme = MinimalUITheme;
	exports.MobileOptimizerClass = MobileOptimizer;
	exports.Music = MusicSystemFacade;
	exports.PanelManager = PanelManager;
	exports.Performance = Performance;
	exports.PerformanceDebugOverlayClass = PerformanceDebugOverlay;
	exports.PerformanceFacade = PerformanceFacade;
	exports.PerformanceMonitor = PerformanceMonitor;
	exports.PerformanceProfilerClass = PerformanceProfiler;
	exports.PerformanceServiceProvider = PerformanceServiceProvider;
	exports.Physics = Physics;
	exports.PhysicsManagerClass = PhysicsManager;
	exports.PhysicsServiceProvider = PhysicsServiceProvider;
	exports.PixiCompatibility = PixiCompatibility;
	exports.PixiGraphicsFactory = PixiGraphicsFactory;
	exports.PixiRenderer = PixiRenderer;
	exports.PixiVersionDetector = PixiVersionDetector;
	exports.PluginManager = PluginManager;
	exports.PluginServiceProvider = PluginServiceProvider;
	exports.Plugins = Plugins;
	exports.RendererFacade = Renderer;
	exports.RendererFactory = RendererFactory;
	exports.RenderingCompatibility = RenderingCompatibility;
	exports.RenderingOptimizerClass = RenderingOptimizer;
	exports.RenderingServiceProvider = RenderingServiceProvider;
	exports.ResponsiveCanvas = ResponsiveCanvas;
	exports.ResponsiveContainer = ResponsiveContainer;
	exports.ResponsiveLayoutManager = ResponsiveLayoutManager;
	exports.ResponsiveScaleCalculator = ResponsiveScaleCalculator;
	exports.ResultScreen = ResultScreen;
	exports.SFX = SFXSystemFacade;
	exports.SafeAreaLayout = SafeAreaLayout;
	exports.SceneServiceProvider = SceneServiceProvider;
	exports.Scenes = Scenes;
	exports.ScreenManager = ScreenManager;
	exports.ServiceContainer = ServiceContainer;
	exports.ShineEffect = ShineEffect;
	exports.SimpleScreen = SimpleScreen;
	exports.Spatial = SpatialAudioFacade;
	exports.SplashScreen = SplashScreen;
	exports.Themes = Themes;
	exports.ThreeCompatibility = ThreeCompatibility;
	exports.ThreeGraphicsFactory = ThreeGraphicsFactory;
	exports.ThreeRenderer = ThreeRenderer;
	exports.ThreeVersionDetector = ThreeVersionDetector;
	exports.TopBar = TopBar;
	exports.UI = UI;
	exports.UIButton = UIButton;
	exports.UIContainer = UIContainer;
	exports.UIPanel = UIPanel;
	exports.UIProgressBar = UIProgressBar;
	exports.UIServiceProvider = UIServiceProvider;
	exports.UIText = UIText;
	exports.UIThemeManager = UIThemeManager;
	exports.VibrantUITheme = VibrantUITheme;
	exports.VirtualJoystick = VirtualJoystick;
	exports.createGame = createGame;
	exports.createGameButtonGradient = createGameButtonGradient;
	exports.createMergeGame = createMergeGame;
	exports.createMobileGame = createMobileGame;
	exports.createResponsiveCalculator = createResponsiveCalculator;
	exports.createSafeAreaLayout = createSafeAreaLayout;
	exports.createSkyGradient = createSkyGradient;
	exports.darkenColor = darkenColor$1;
	exports.default = GameByteFramework;
	exports.drawToTexture = drawToTexture;
	exports.getFrameworkFontFamily = getFrameworkFontFamily;
	exports.graphics = graphics;
	exports.initializeFacades = initializeFacades;
	exports.isFontReady = isFontReady;
	exports.lightenColor = lightenColor;
	exports.loadFrameworkFont = loadFrameworkFont;
	exports.numberToHex = numberToHex;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=gamebyte.umd.js.map
