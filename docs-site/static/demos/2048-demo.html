<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GameByte - 2048 Demo</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        h1 { color: #fff; margin-bottom: 10px; font-size: 24px; }
        p { color: #8892b0; margin-bottom: 20px; font-size: 14px; }
        #game-container { border-radius: 12px; overflow: hidden; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4); }
        canvas { display: block; }
        .info { color: #8892b0; margin-top: 20px; font-size: 12px; text-align: center; }
    </style>
</head>
<body>
    <h1>2048</h1>
    <p>GameByte Layout System - Grid & Dynamic Repositioning</p>
    <div id="game-container"></div>
    <div class="info">Arrow keys or swipe to slide tiles. Merge equal numbers!</div>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8/dist/pixi.min.js"></script>
    <script src="/gamebyte.umd.js"></script>
    <script>
    const {
        createGame, graphics, loadFrameworkFont,
        SplashScreen, GameStyleButton, GameStyleColors,
        GameTopBar, ResultScreen, CelebrationManager
    } = GameByteFramework;

    // Tile colors
    const TILE_COLORS = {
        2: 0xeee4da, 4: 0xede0c8, 8: 0xf2b179, 16: 0xf59563,
        32: 0xf67c5f, 64: 0xf65e3b, 128: 0xedcf72, 256: 0xedcc61,
        512: 0xedc850, 1024: 0xedc53f, 2048: 0xedc22e
    };

    // Game state
    let gameState = 'splash';
    let grid = [];
    let score = 0;
    let tiles = [];
    let isAnimating = false;
    let hasWon = false;

    // Grid config
    const GRID_SIZE = 4;
    const CELL_SIZE = 100;
    const CELL_GAP = 10;
    const GRID_PADDING = 10;
    const GRID_TOTAL = GRID_PADDING * 2 + CELL_SIZE * GRID_SIZE + CELL_GAP * (GRID_SIZE - 1);

    // Containers
    let gameContainer, gridContainer, tilesContainer, uiContainer;
    let topBar, celebrationMgr;
    let game;

    // Initialize game
    async function init() {
        await loadFrameworkFont();

        game = await createGame({
            container: '#game-container',
            width: 500,
            height: 600,
            mode: '2d',
            backgroundColor: 0x16213e,
            antialias: true
        });

        const factory = graphics();
        gameContainer = factory.createContainer();
        game.stage.addChild(gameContainer);

        showSplash();
        setupInput();
    }

    // Splash screen
    function showSplash() {
        gameState = 'splash';
        gameContainer.removeChildren();

        const factory = graphics();
        const splash = new SplashScreen({
            appName: '2048',
            subtitle: 'Merge tiles to reach 2048!',
            durationMs: 2000
        });

        const splashContainer = splash.getContainer();
        splashContainer.position.set(250, 300);
        gameContainer.addChild(splashContainer);

        setTimeout(() => showMenu(), 2000);
    }

    // Menu screen
    function showMenu() {
        gameState = 'menu';
        gameContainer.removeChildren();

        const factory = graphics();
        uiContainer = factory.createContainer();

        // Title
        const title = factory.createText('2048', {
            fontFamily: 'Lilita One, sans-serif',
            fontSize: 80,
            fill: 0xffffff,
            align: 'center'
        });
        title.anchor.set(0.5);
        title.position.set(250, 150);
        uiContainer.addChild(title);

        // Instructions
        const inst = factory.createText('Swipe or use arrow keys\nto merge tiles!', {
            fontFamily: 'Lilita One, sans-serif',
            fontSize: 18,
            fill: 0x8892b0,
            align: 'center'
        });
        inst.anchor.set(0.5);
        inst.position.set(250, 280);
        uiContainer.addChild(inst);

        // Play button
        const playBtn = new GameStyleButton({ text: 'PLAY', width: 200, height: 60 });
        const btnContainer = playBtn.getContainer();
        btnContainer.position.set(150, 380);
        playBtn.on('click', startGame);
        uiContainer.addChild(btnContainer);

        gameContainer.addChild(uiContainer);
    }

    // Start game
    function startGame() {
        gameState = 'playing';
        score = 0;
        hasWon = false;
        gameContainer.removeChildren();

        const factory = graphics();

        // UI container
        uiContainer = factory.createContainer();

        // Top bar
        topBar = new GameTopBar({ lives: 0, score: 0 });
        const topBarContainer = topBar.getContainer();
        topBarContainer.position.set(0, 0);
        uiContainer.addChild(topBarContainer);

        // Grid container
        gridContainer = factory.createContainer();
        gridContainer.position.set((500 - GRID_TOTAL) / 2, 100);
        drawGrid();

        // Tiles container
        tilesContainer = factory.createContainer();
        tilesContainer.position.set((500 - GRID_TOTAL) / 2, 100);

        gameContainer.addChild(uiContainer);
        gameContainer.addChild(gridContainer);
        gameContainer.addChild(tilesContainer);

        // Celebration manager
        celebrationMgr = new CelebrationManager(gameContainer, 500, 600);

        // Initialize grid
        initGrid();
        addRandomTile();
        addRandomTile();
        updateTiles();
    }

    // Draw grid background
    function drawGrid() {
        const factory = graphics();

        // Grid background
        const bg = factory.createGraphics();
        bg.roundRect(0, 0, GRID_TOTAL, GRID_TOTAL, 10);
        bg.fill({ color: 0x3d3a33 });
        gridContainer.addChild(bg);

        // Empty cells
        for (let row = 0; row < GRID_SIZE; row++) {
            for (let col = 0; col < GRID_SIZE; col++) {
                const cell = factory.createGraphics();
                const x = GRID_PADDING + col * (CELL_SIZE + CELL_GAP);
                const y = GRID_PADDING + row * (CELL_SIZE + CELL_GAP);
                cell.roundRect(x, y, CELL_SIZE, CELL_SIZE, 8);
                cell.fill({ color: 0x2a2722 });
                gridContainer.addChild(cell);
            }
        }
    }

    // Initialize grid
    function initGrid() {
        grid = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
        tiles = [];
    }

    // Add random tile
    function addRandomTile() {
        const empty = [];
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                if (grid[r][c] === 0) empty.push({ r, c });
            }
        }
        if (empty.length === 0) return;

        const { r, c } = empty[Math.floor(Math.random() * empty.length)];
        const value = Math.random() < 0.9 ? 2 : 4;
        grid[r][c] = value;

        createTile(r, c, value, true);
    }

    // Create tile visual
    function createTile(row, col, value, animate = false) {
        const factory = graphics();
        const tile = factory.createContainer();

        const bg = factory.createGraphics();
        bg.roundRect(0, 0, CELL_SIZE, CELL_SIZE, 8);
        const color = TILE_COLORS[value] || 0xedc22e;
        bg.fill({ color });

        const fontSize = value >= 1000 ? 36 : value >= 100 ? 42 : 48;
        const text = factory.createText(value.toString(), {
            fontFamily: 'Lilita One, sans-serif',
            fontSize,
            fill: value <= 4 ? 0x776e65 : 0xffffff,
            align: 'center'
        });
        text.anchor.set(0.5);
        text.position.set(CELL_SIZE / 2, CELL_SIZE / 2);

        tile.addChild(bg);
        tile.addChild(text);

        const x = GRID_PADDING + col * (CELL_SIZE + CELL_GAP);
        const y = GRID_PADDING + row * (CELL_SIZE + CELL_GAP);
        tile.position.set(x, y);

        if (animate) {
            tile.scale.set(0);
            animateScale(tile, 0, 1, 100);
        }

        tilesContainer.addChild(tile);
        tiles.push({ row, col, value, container: tile });
    }

    // Update all tiles
    function updateTiles() {
        tiles.forEach(tile => {
            const x = GRID_PADDING + tile.col * (CELL_SIZE + CELL_GAP);
            const y = GRID_PADDING + tile.row * (CELL_SIZE + CELL_GAP);
            animateMove(tile.container, x, y, 150);
        });
    }

    // Animate move
    function animateMove(obj, targetX, targetY, duration) {
        const startX = obj.x;
        const startY = obj.y;
        const startTime = Date.now();

        function update() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = 1 - Math.pow(1 - progress, 3);

            obj.x = startX + (targetX - startX) * eased;
            obj.y = startY + (targetY - startY) * eased;

            if (progress < 1) requestAnimationFrame(update);
        }
        update();
    }

    // Animate scale
    function animateScale(obj, from, to, duration) {
        const startTime = Date.now();

        function update() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = 1 - Math.pow(1 - progress, 3);

            obj.scale.set(from + (to - from) * eased);

            if (progress < 1) requestAnimationFrame(update);
        }
        update();
    }

    // Handle move
    async function handleMove(direction) {
        if (isAnimating || gameState !== 'playing') return;

        const oldGrid = grid.map(row => [...row]);
        let moved = false;

        if (direction === 'up') moved = slideUp();
        else if (direction === 'down') moved = slideDown();
        else if (direction === 'left') moved = slideLeft();
        else if (direction === 'right') moved = slideRight();

        if (!moved) return;

        isAnimating = true;
        syncTiles();
        updateTiles();

        await new Promise(r => setTimeout(r, 150));

        addRandomTile();
        if (topBar) topBar.updateScore(score);

        // Check win
        if (!hasWon && grid.flat().includes(2048)) {
            hasWon = true;
            celebrationMgr.victory();
        }

        // Check game over
        if (isGameOver()) {
            await new Promise(r => setTimeout(r, 500));
            showGameOver();
        }

        isAnimating = false;
    }

    // Slide functions
    function slideLeft() {
        let moved = false;
        for (let r = 0; r < GRID_SIZE; r++) {
            const row = grid[r].filter(v => v !== 0);
            for (let i = 0; i < row.length - 1; i++) {
                if (row[i] === row[i + 1]) {
                    row[i] *= 2;
                    row.splice(i + 1, 1);
                    score += row[i];
                }
            }
            while (row.length < GRID_SIZE) row.push(0);
            if (grid[r].some((v, i) => v !== row[i])) moved = true;
            grid[r] = row;
        }
        return moved;
    }

    function slideRight() {
        let moved = false;
        for (let r = 0; r < GRID_SIZE; r++) {
            const row = grid[r].filter(v => v !== 0);
            for (let i = row.length - 1; i > 0; i--) {
                if (row[i] === row[i - 1]) {
                    row[i] *= 2;
                    row.splice(i - 1, 1);
                    score += row[i];
                    i--;
                }
            }
            while (row.length < GRID_SIZE) row.unshift(0);
            if (grid[r].some((v, i) => v !== row[i])) moved = true;
            grid[r] = row;
        }
        return moved;
    }

    function slideUp() {
        let moved = false;
        for (let c = 0; c < GRID_SIZE; c++) {
            const col = [];
            for (let r = 0; r < GRID_SIZE; r++) {
                if (grid[r][c] !== 0) col.push(grid[r][c]);
            }
            for (let i = 0; i < col.length - 1; i++) {
                if (col[i] === col[i + 1]) {
                    col[i] *= 2;
                    col.splice(i + 1, 1);
                    score += col[i];
                }
            }
            while (col.length < GRID_SIZE) col.push(0);
            for (let r = 0; r < GRID_SIZE; r++) {
                if (grid[r][c] !== col[r]) moved = true;
                grid[r][c] = col[r];
            }
        }
        return moved;
    }

    function slideDown() {
        let moved = false;
        for (let c = 0; c < GRID_SIZE; c++) {
            const col = [];
            for (let r = 0; r < GRID_SIZE; r++) {
                if (grid[r][c] !== 0) col.push(grid[r][c]);
            }
            for (let i = col.length - 1; i > 0; i--) {
                if (col[i] === col[i - 1]) {
                    col[i] *= 2;
                    col.splice(i - 1, 1);
                    score += col[i];
                    i--;
                }
            }
            while (col.length < GRID_SIZE) col.unshift(0);
            for (let r = 0; r < GRID_SIZE; r++) {
                if (grid[r][c] !== col[r]) moved = true;
                grid[r][c] = col[r];
            }
        }
        return moved;
    }

    // Sync tiles with grid
    function syncTiles() {
        tiles.forEach(t => tilesContainer.removeChild(t.container));
        tiles = [];

        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                if (grid[r][c] !== 0) {
                    createTile(r, c, grid[r][c]);
                }
            }
        }
    }

    // Check game over
    function isGameOver() {
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                if (grid[r][c] === 0) return false;
                if (c < GRID_SIZE - 1 && grid[r][c] === grid[r][c + 1]) return false;
                if (r < GRID_SIZE - 1 && grid[r][c] === grid[r + 1][c]) return false;
            }
        }
        return true;
    }

    // Game over
    function showGameOver() {
        gameState = 'gameover';
        const maxTile = Math.max(...grid.flat());
        const stars = maxTile >= 2048 ? 3 : maxTile >= 1024 ? 2 : maxTile >= 512 ? 1 : 0;

        const result = new ResultScreen({
            title: hasWon ? 'You Won!' : 'Game Over',
            score,
            stars,
            showNextLevel: false
        });

        const resultContainer = result.getContainer();
        resultContainer.position.set(250, 300);
        gameContainer.addChild(resultContainer);

        result.on('retry', showMenu);
    }

    // Input handling
    function setupInput() {
        // Keyboard
        window.addEventListener('keydown', (e) => {
            if (gameState !== 'playing') return;
            if (e.key === 'ArrowUp') handleMove('up');
            else if (e.key === 'ArrowDown') handleMove('down');
            else if (e.key === 'ArrowLeft') handleMove('left');
            else if (e.key === 'ArrowRight') handleMove('right');
        });

        // Touch swipe
        let touchStartX = 0, touchStartY = 0;
        window.addEventListener('pointerdown', (e) => {
            touchStartX = e.clientX;
            touchStartY = e.clientY;
        });
        window.addEventListener('pointerup', (e) => {
            if (gameState !== 'playing') return;
            const dx = e.clientX - touchStartX;
            const dy = e.clientY - touchStartY;
            const threshold = 30;

            if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > threshold) {
                handleMove(dx > 0 ? 'right' : 'left');
            } else if (Math.abs(dy) > threshold) {
                handleMove(dy > 0 ? 'down' : 'up');
            }
        });
    }

    init();
    </script>
</body>
</html>
