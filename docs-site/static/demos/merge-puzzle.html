<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>GameByte - Merge Puzzle Game</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: linear-gradient(180deg, #1A237E 0%, #3949AB 50%, #5C6BC0 100%);
      font-family: 'Fredoka One', 'Arial Black', sans-serif;
    }

    #game-container {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    #game-canvas {
      touch-action: none;
      border-radius: 20px;
      box-shadow:
        0 0 0 4px #1A237E,
        0 8px 0 #0D1642,
        0 12px 30px rgba(0, 0, 0, 0.4);
    }

    .game-ui {
      position: absolute;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      z-index: 100;
    }

    .ui-panel {
      background: linear-gradient(180deg, #3949AB 0%, #3949AB 45%, #283593 55%, #283593 100%);
      border: 3px solid #1A237E;
      border-radius: 16px;
      padding: 10px 20px;
      color: white;
      font-size: 16px;
      font-weight: bold;
      display: flex;
      align-items: center;
      gap: 8px;
      box-shadow:
        0 4px 0 #0D1642,
        0 6px 12px rgba(0,0,0,0.3);
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }

    .ui-panel::before {
      content: '';
      position: absolute;
      top: 3px;
      left: 10%;
      right: 10%;
      height: 30%;
      background: linear-gradient(180deg, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 100%);
      border-radius: 10px;
      pointer-events: none;
    }

    .score-icon, .level-icon {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .score-value {
      color: #FFD700;
      text-shadow: 1px 1px 0 #B8860B;
    }

    .level-value {
      color: #76FF03;
      text-shadow: 1px 1px 0 #33691E;
    }

    .spawn-btn {
      position: absolute;
      bottom: 25px;
      left: 50%;
      transform: translateX(-50%);
      padding: 16px 50px;
      font-size: 22px;
      font-weight: bold;
      font-family: 'Fredoka One', 'Arial Black', sans-serif;
      background: linear-gradient(180deg, #7DD87D 0%, #7DD87D 45%, #4CAF50 55%, #4CAF50 100%);
      color: white;
      text-shadow: 2px 2px 0 #1B5E20;
      border: 4px solid #2E7D32;
      border-radius: 20px;
      cursor: pointer;
      box-shadow:
        0 6px 0 #1B5E20,
        0 10px 20px rgba(0, 0, 0, 0.3);
      transition: transform 0.1s, box-shadow 0.1s;
      z-index: 100;
    }

    .spawn-btn::before {
      content: '';
      position: absolute;
      top: 4px;
      left: 8px;
      right: 8px;
      height: 35%;
      background: linear-gradient(180deg, rgba(255,255,255,0.4) 0%, rgba(255,255,255,0) 100%);
      border-radius: 12px;
      pointer-events: none;
    }

    .spawn-btn:active {
      transform: translateX(-50%) translateY(4px);
      box-shadow:
        0 2px 0 #1B5E20,
        0 4px 10px rgba(0, 0, 0, 0.2);
    }

    .spawn-btn:disabled {
      background: linear-gradient(180deg, #9E9E9E 0%, #9E9E9E 45%, #757575 55%, #757575 100%);
      border-color: #616161;
      box-shadow:
        0 6px 0 #424242,
        0 10px 20px rgba(0, 0, 0, 0.3);
      cursor: not-allowed;
      text-shadow: 1px 1px 0 #424242;
    }

    .instructions {
      position: absolute;
      bottom: 90px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.85);
      font-size: 14px;
      text-align: center;
      z-index: 100;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
      background: rgba(26, 35, 126, 0.5);
      padding: 8px 20px;
      border-radius: 10px;
    }

    /* Decorative elements */
    .decoration {
      position: absolute;
      width: 30px;
      height: 30px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 50%;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <!-- Decorative bubbles -->
    <div class="decoration" style="top: 10%; left: 5%;"></div>
    <div class="decoration" style="top: 30%; right: 8%;"></div>
    <div class="decoration" style="top: 60%; left: 3%;"></div>
    <div class="decoration" style="top: 80%; right: 5%;"></div>

    <canvas id="game-canvas"></canvas>

    <div class="game-ui">
      <div class="ui-panel">
        <span class="score-icon">&#11088;</span>
        Score: <span class="score-value" id="score">0</span>
      </div>
      <div class="ui-panel">
        <span class="level-icon">&#9733;</span>
        Level: <span class="level-value" id="level">1</span>
      </div>
    </div>

    <p class="instructions">Drag items to merge! Same tier items combine into higher tier.</p>

    <button class="spawn-btn" id="spawn-btn">+ Spawn</button>
  </div>

  <script type="module">
    import * as PIXI from 'https://cdn.jsdelivr.net/npm/pixi.js@8/dist/pixi.min.mjs';

    // Game state
    let score = 0;
    let level = 1;
    let mergeCount = 0;

    // Initialize Pixi.js Application
    const app = new PIXI.Application();
    await app.init({
      canvas: document.getElementById('game-canvas'),
      width: 420,
      height: 520,
      backgroundColor: 0x283593,
      antialias: true,
      resolution: window.devicePixelRatio || 1,
      autoDensity: true
    });

    // Grid configuration
    const GRID_ROWS = 5;
    const GRID_COLS = 5;
    const CELL_SIZE = 65;
    const CELL_GAP = 8;
    const GRID_PADDING = 20;

    // Tier colors (vibrant mobile game palette with gradients)
    const TIER_COLORS = [
      { main: 0x9E9E9E, light: 0xBDBDBD, dark: 0x757575 },  // Tier 0: Gray
      { main: 0x4CAF50, light: 0x81C784, dark: 0x388E3C },  // Tier 1: Green
      { main: 0x2196F3, light: 0x64B5F6, dark: 0x1976D2 },  // Tier 2: Blue
      { main: 0x9C27B0, light: 0xBA68C8, dark: 0x7B1FA2 },  // Tier 3: Purple
      { main: 0xFF9800, light: 0xFFB74D, dark: 0xF57C00 },  // Tier 4: Orange
      { main: 0xF44336, light: 0xE57373, dark: 0xD32F2F },  // Tier 5: Red
      { main: 0xFFEB3B, light: 0xFFF176, dark: 0xFBC02D },  // Tier 6: Yellow
      { main: 0x00BCD4, light: 0x4DD0E1, dark: 0x0097A7 },  // Tier 7: Cyan
      { main: 0xE91E63, light: 0xF06292, dark: 0xC2185B },  // Tier 8: Pink
      { main: 0x673AB7, light: 0x9575CD, dark: 0x512DA8 },  // Tier 9: Deep Purple
      { main: 0xFFD700, light: 0xFFE066, dark: 0xB8860B },  // Tier 10+: Gold
    ];

    // Grid state
    const grid = [];
    const items = [];
    let draggedItem = null;
    let draggedFromCell = null;
    let highlightedCell = null;

    // Create grid container
    const gridContainer = new PIXI.Container();
    const gridWidth = GRID_COLS * CELL_SIZE + (GRID_COLS - 1) * CELL_GAP + GRID_PADDING * 2;
    const gridHeight = GRID_ROWS * CELL_SIZE + (GRID_ROWS - 1) * CELL_GAP + GRID_PADDING * 2;

    gridContainer.x = (app.screen.width - gridWidth) / 2;
    gridContainer.y = (app.screen.height - gridHeight) / 2;

    // Draw grid background with game style
    const gridBg = new PIXI.Graphics();
    // Shadow
    gridBg.roundRect(3, 6, gridWidth, gridHeight, 16);
    gridBg.fill({ color: 0x0D1642, alpha: 0.5 });
    // Main background
    gridBg.roundRect(0, 0, gridWidth, gridHeight, 16);
    gridBg.fill({ color: 0x1A237E });
    gridBg.stroke({ color: 0x3949AB, width: 3 });
    gridContainer.addChild(gridBg);

    // Create cells
    for (let row = 0; row < GRID_ROWS; row++) {
      grid[row] = [];
      for (let col = 0; col < GRID_COLS; col++) {
        const cell = createCell(row, col);
        grid[row][col] = cell;
        gridContainer.addChild(cell.graphics);
      }
    }

    // Items container (for z-ordering during drag)
    const itemsContainer = new PIXI.Container();
    gridContainer.addChild(itemsContainer);

    app.stage.addChild(gridContainer);

    // Create a cell
    function createCell(row, col) {
      const x = GRID_PADDING + col * (CELL_SIZE + CELL_GAP);
      const y = GRID_PADDING + row * (CELL_SIZE + CELL_GAP);

      const graphics = new PIXI.Graphics();
      drawCell(graphics, x, y, false);

      return {
        row,
        col,
        x,
        y,
        graphics,
        item: null,
        highlighted: false
      };
    }

    function drawCell(graphics, x, y, highlighted, canDrop = true) {
      graphics.clear();

      // Cell shadow
      graphics.roundRect(x + 2, y + 3, CELL_SIZE, CELL_SIZE, 10);
      graphics.fill({ color: 0x0D1642, alpha: 0.4 });

      // Cell background
      const bgColor = highlighted
        ? (canDrop ? 0x4CAF50 : 0xF44336)
        : 0x3949AB;

      graphics.roundRect(x, y, CELL_SIZE, CELL_SIZE, 10);
      graphics.fill({ color: bgColor, alpha: highlighted ? 0.6 : 0.8 });
      graphics.stroke({ color: highlighted ? (canDrop ? 0x2E7D32 : 0xB71C1C) : 0x5C6BC0, width: 2 });

      if (!highlighted) {
        // Inner highlight
        graphics.roundRect(x + 3, y + 3, CELL_SIZE - 6, CELL_SIZE * 0.3, 8);
        graphics.fill({ color: 0x7986CB, alpha: 0.3 });

        // Empty indicator
        graphics.circle(x + CELL_SIZE/2, y + CELL_SIZE/2, 8);
        graphics.fill({ color: 0x5C6BC0, alpha: 0.5 });
      }
    }

    // Create a merge item with game style
    function createItem(tier, cell) {
      const size = CELL_SIZE * 0.72;
      const container = new PIXI.Container();
      container.x = cell.x + CELL_SIZE / 2;
      container.y = cell.y + CELL_SIZE / 2;

      const graphics = new PIXI.Graphics();
      drawItem(graphics, tier, size);
      container.addChild(graphics);

      // Tier label
      const label = new PIXI.Text({
        text: tier.toString(),
        style: {
          fontFamily: 'Fredoka One, Arial Black',
          fontSize: size * 0.45,
          fill: 0xFFFFFF,
          fontWeight: 'bold',
          stroke: { color: getTierColors(tier).dark, width: 3 },
          dropShadow: {
            alpha: 0.5,
            angle: Math.PI / 2,
            blur: 2,
            color: 0x000000,
            distance: 2
          }
        }
      });
      label.anchor.set(0.5);
      container.addChild(label);

      // Make interactive
      container.eventMode = 'static';
      container.cursor = 'pointer';

      const item = {
        tier,
        container,
        graphics,
        label,
        cell,
        size
      };

      // Drag events
      container.on('pointerdown', (e) => onDragStart(e, item));
      container.on('pointermove', (e) => onDragMove(e, item));
      container.on('pointerup', (e) => onDragEnd(e, item));
      container.on('pointerupoutside', (e) => onDragEnd(e, item));

      items.push(item);
      itemsContainer.addChild(container);
      cell.item = item;

      // Spawn animation
      container.scale.set(0);
      animateScale(container, 1, 0.3, 'backOut');

      return item;
    }

    function getTierColors(tier) {
      const colorIndex = Math.min(tier, TIER_COLORS.length - 1);
      return TIER_COLORS[colorIndex];
    }

    function drawItem(graphics, tier, size) {
      const colors = getTierColors(tier);

      graphics.clear();

      // Shadow
      graphics.roundRect(-size/2 + 3, -size/2 + 4, size, size, size * 0.22);
      graphics.fill({ color: 0x000000, alpha: 0.35 });

      // Border/outer
      graphics.roundRect(-size/2 - 2, -size/2 - 2, size + 4, size + 4, size * 0.24);
      graphics.fill({ color: colors.dark });

      // Main shape (top half lighter)
      graphics.roundRect(-size/2, -size/2, size, size/2, size * 0.2);
      graphics.fill({ color: colors.light });

      // Main shape (bottom half darker)
      graphics.roundRect(-size/2, 0, size, size/2, size * 0.2);
      graphics.fill({ color: colors.main });

      // Connect the two halves
      graphics.rect(-size/2, 0, size, 2);
      graphics.fill({ color: colors.main });

      // Top highlight
      graphics.roundRect(-size/2 + 4, -size/2 + 4, size - 8, size * 0.28, size * 0.12);
      graphics.fill({ color: 0xFFFFFF, alpha: 0.4 });
    }

    // Drag handlers
    function onDragStart(e, item) {
      draggedItem = item;
      draggedFromCell = item.cell;

      item.originalPos = { x: item.container.x, y: item.container.y };

      item.cell.item = null;
      item.cell = null;

      itemsContainer.setChildIndex(item.container, itemsContainer.children.length - 1);

      animateScale(item.container, 1.15, 0.1);
    }

    function onDragMove(e, item) {
      if (draggedItem !== item) return;

      const pos = e.getLocalPosition(gridContainer);
      item.container.x = pos.x;
      item.container.y = pos.y;

      const cellUnder = getCellAt(pos.x, pos.y);

      if (highlightedCell && highlightedCell !== cellUnder) {
        drawCell(highlightedCell.graphics, highlightedCell.x, highlightedCell.y, false);
        highlightedCell.highlighted = false;
      }

      if (cellUnder && cellUnder !== highlightedCell) {
        const canDrop = !cellUnder.item || (cellUnder.item && cellUnder.item.tier === item.tier);
        drawCell(cellUnder.graphics, cellUnder.x, cellUnder.y, true, canDrop);
        cellUnder.highlighted = true;
        highlightedCell = cellUnder;
      }
    }

    function onDragEnd(e, item) {
      if (draggedItem !== item) return;

      if (highlightedCell) {
        drawCell(highlightedCell.graphics, highlightedCell.x, highlightedCell.y, false);
        highlightedCell.highlighted = false;
        highlightedCell = null;
      }

      animateScale(item.container, 1, 0.1);

      const pos = e.getLocalPosition(gridContainer);
      const targetCell = getCellAt(pos.x, pos.y);

      if (targetCell) {
        if (!targetCell.item) {
          placeItemInCell(item, targetCell);
        } else if (targetCell.item.tier === item.tier) {
          performMerge(item, targetCell.item, targetCell);
        } else {
          returnToCell(item, draggedFromCell);
        }
      } else {
        returnToCell(item, draggedFromCell);
      }

      draggedItem = null;
      draggedFromCell = null;
    }

    function getCellAt(x, y) {
      for (let row = 0; row < GRID_ROWS; row++) {
        for (let col = 0; col < GRID_COLS; col++) {
          const cell = grid[row][col];
          if (x >= cell.x && x <= cell.x + CELL_SIZE &&
              y >= cell.y && y <= cell.y + CELL_SIZE) {
            return cell;
          }
        }
      }
      return null;
    }

    function placeItemInCell(item, cell) {
      item.cell = cell;
      cell.item = item;
      animatePosition(item.container, cell.x + CELL_SIZE/2, cell.y + CELL_SIZE/2, 0.15);
    }

    function returnToCell(item, cell) {
      if (cell) {
        placeItemInCell(item, cell);
      }
    }

    function performMerge(droppedItem, existingItem, cell) {
      const newTier = existingItem.tier + 1;

      animateScale(droppedItem.container, 0, 0.2);
      animateScale(existingItem.container, 0, 0.2);

      setTimeout(() => {
        removeItem(droppedItem);
        removeItem(existingItem);

        const newItem = createItem(newTier, cell);

        score += newTier * 100;
        mergeCount++;
        updateUI();

        if (mergeCount >= level * 5) {
          level++;
          updateUI();
        }

        if (newTier >= 10) {
          showMaxTierCelebration();
        }
      }, 200);
    }

    function removeItem(item) {
      const index = items.indexOf(item);
      if (index > -1) {
        items.splice(index, 1);
      }
      if (item.cell) {
        item.cell.item = null;
      }
      item.container.destroy();
    }

    // Animation helpers
    function animateScale(target, toScale, duration, easing = 'linear') {
      const startScale = target.scale.x;
      const startTime = performance.now();
      const durationMs = duration * 1000;

      function update() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / durationMs, 1);

        let easedProgress = progress;
        if (easing === 'backOut') {
          const c1 = 1.70158;
          const c3 = c1 + 1;
          easedProgress = 1 + c3 * Math.pow(progress - 1, 3) + c1 * Math.pow(progress - 1, 2);
        }

        target.scale.set(startScale + (toScale - startScale) * easedProgress);

        if (progress < 1) {
          requestAnimationFrame(update);
        }
      }

      requestAnimationFrame(update);
    }

    function animatePosition(target, toX, toY, duration) {
      const startX = target.x;
      const startY = target.y;
      const startTime = performance.now();
      const durationMs = duration * 1000;

      function update() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / durationMs, 1);

        const easedProgress = 1 - Math.pow(1 - progress, 3);

        target.x = startX + (toX - startX) * easedProgress;
        target.y = startY + (toY - startY) * easedProgress;

        if (progress < 1) {
          requestAnimationFrame(update);
        }
      }

      requestAnimationFrame(update);
    }

    // UI Updates
    function updateUI() {
      document.getElementById('score').textContent = score.toLocaleString();
      document.getElementById('level').textContent = level;
    }

    function showMaxTierCelebration() {
      console.log('MAX TIER REACHED!');
    }

    // Spawn button
    document.getElementById('spawn-btn').addEventListener('click', () => {
      spawnRandomItem();
    });

    function spawnRandomItem() {
      const emptyCells = [];
      for (let row = 0; row < GRID_ROWS; row++) {
        for (let col = 0; col < GRID_COLS; col++) {
          if (!grid[row][col].item) {
            emptyCells.push(grid[row][col]);
          }
        }
      }

      if (emptyCells.length === 0) {
        document.getElementById('spawn-btn').disabled = true;
        return;
      }

      const cell = emptyCells[Math.floor(Math.random() * emptyCells.length)];

      const tierRoll = Math.random();
      let tier = 1;
      if (tierRoll > 0.9) tier = 3;
      else if (tierRoll > 0.7) tier = 2;

      createItem(tier, cell);

      if (emptyCells.length <= 1) {
        document.getElementById('spawn-btn').disabled = true;
      }
    }

    // Initial spawn
    spawnRandomItem();
    spawnRandomItem();
    spawnRandomItem();

    // Enable spawn button when cells become available after merge
    app.ticker.add(() => {
      const emptyCells = [];
      for (let row = 0; row < GRID_ROWS; row++) {
        for (let col = 0; col < GRID_COLS; col++) {
          if (!grid[row][col].item) {
            emptyCells.push(grid[row][col]);
          }
        }
      }
      document.getElementById('spawn-btn').disabled = emptyCells.length === 0;
    });
  </script>
</body>
</html>
