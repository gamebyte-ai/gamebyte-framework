<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GameStyleButton Demo - GameByte Framework</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #1a1a2e; transition: background 0.3s ease; }
        body.light-theme { background: #e8eef5; }
        canvas { display: block; margin: 0 auto; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8/dist/pixi.min.js"></script>
    <script src="/gamebyte.umd.js"></script>

    <script>
        // =====================================================
        // GameStyleButton Demo - Using Framework Abstractions
        // =====================================================
        // This demo showcases:
        // - GameStyleButton component with all color variants
        // - GameButtons helper for common mini buttons
        // - graphics() abstraction instead of direct PIXI usage
        // =====================================================

        const {
            createGame,
            GameStyleButton,
            GameStyleColors,
            GameButtons,
            graphics,
            loadFrameworkFont
        } = GameByteFramework;

        const CONFIG = { width: 500, height: 680 };

        // ===== THEME DETECTION =====
        function detectTheme() {
            try {
                if (window.parent && window.parent.document) {
                    const parentTheme = window.parent.document.documentElement.getAttribute('data-theme');
                    if (parentTheme) return parentTheme;
                }
            } catch (e) { /* Cross-origin */ }

            const urlParams = new URLSearchParams(window.location.search);
            const themeParam = urlParams.get('theme');
            if (themeParam) return themeParam;

            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) {
                return 'light';
            }
            return 'dark';
        }

        let currentTheme = detectTheme();

        function setupThemeListener() {
            try {
                if (window.parent && window.parent.document) {
                    const observer = new MutationObserver((mutations) => {
                        mutations.forEach((mutation) => {
                            if (mutation.attributeName === 'data-theme') {
                                const newTheme = window.parent.document.documentElement.getAttribute('data-theme');
                                if (newTheme && newTheme !== currentTheme) {
                                    currentTheme = newTheme;
                                    applyTheme();
                                }
                            }
                        });
                    });
                    observer.observe(window.parent.document.documentElement, { attributes: true });
                }
            } catch (e) {
                window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', (e) => {
                    currentTheme = e.matches ? 'light' : 'dark';
                    applyTheme();
                });
            }
        }

        // ===== THEME COLOR PALETTES =====
        const THEME_COLORS = {
            dark: {
                bgColor: 0x1a1a2e,
                titleColor: 0xffffff,
                labelColor: 0x888888
            },
            light: {
                bgColor: 0xe8eef5,
                titleColor: 0x2d2d44,
                labelColor: 0x6b7280
            }
        };

        function getColors() {
            return THEME_COLORS[currentTheme] || THEME_COLORS.dark;
        }

        const canvas = document.createElement('canvas');
        canvas.width = CONFIG.width;
        canvas.height = CONFIG.height;
        document.body.appendChild(canvas);

        const game = createGame();
        let renderer, stage;

        let isRecreating = false;
        async function applyTheme() {
            if (isRecreating) return;
            isRecreating = true;

            document.body.classList.toggle('light-theme', currentTheme === 'light');
            if (stage && window.createScreen) {
                await loadFrameworkFont();
                window.createScreen();
            }
            setTimeout(() => { isRecreating = false; }, 100);
        }

        (async () => {
            // Load framework font
            await loadFrameworkFont();

            await game.initialize(canvas, '2d');
            renderer = game.make('renderer');
            stage = renderer.getStage();

            setupThemeListener();

            function createScreen() {
                const colors = getColors();
                const gfx = graphics(); // Get graphics factory

                // Clear stage
                while (stage.children.length > 0) {
                    stage.removeChildAt(0);
                }

                // ===== BACKGROUND - Using graphics() abstraction =====
                const bg = gfx.createGraphics();
                bg.rect(0, 0, CONFIG.width, CONFIG.height);
                bg.fill(colors.bgColor);
                stage.addChild(bg);

                // ===== TITLE - Using graphics() abstraction =====
                const title = gfx.createText('GameStyleButton', {
                    fontSize: 24,
                    fill: colors.titleColor
                });
                title.x = CONFIG.width / 2 - title.width / 2;
                title.y = 15;
                stage.addChild(title);

                // ===== BUTTON SHOWCASE =====
                const buttonConfigs = [
                    { text: 'Play', colorScheme: GameStyleColors.YELLOW_BUTTON },
                    { text: 'Continue', colorScheme: GameStyleColors.GREEN_BUTTON },
                    { text: 'Shop', colorScheme: GameStyleColors.BLUE_BUTTON },
                    { text: 'Cancel', colorScheme: GameStyleColors.RED_BUTTON },
                    { text: 'Special', colorScheme: GameStyleColors.PURPLE_BUTTON },
                ];

                const startY = 55;
                const buttonHeight = 58;
                const buttonWidth = 240;
                const gap = 12;

                // Create styled buttons
                buttonConfigs.forEach((config, index) => {
                    const btn = new GameStyleButton({
                        text: config.text,
                        width: buttonWidth,
                        height: buttonHeight,
                        fontSize: 24,
                        colorScheme: config.colorScheme
                    });
                    btn.setPosition((CONFIG.width - buttonWidth) / 2, startY + index * (buttonHeight + gap));
                    btn.on('click', () => console.log(`${config.text} clicked!`));
                    stage.addChild(btn.getContainer());
                });

                // Disabled button example
                const disabledBtn = new GameStyleButton({
                    text: 'Locked',
                    width: buttonWidth,
                    height: buttonHeight,
                    fontSize: 24,
                    disabled: true
                });
                disabledBtn.setPosition((CONFIG.width - buttonWidth) / 2, startY + 5 * (buttonHeight + gap));
                stage.addChild(disabledBtn.getContainer());

                // ===== MINI BUTTONS SECTION =====
                const miniLabel = gfx.createText('Mini Buttons:', {
                    fontFamily: 'monospace',
                    fontSize: 14,
                    fill: colors.labelColor
                });
                miniLabel.x = 30;
                miniLabel.y = startY + 6 * (buttonHeight + gap) + 10;
                stage.addChild(miniLabel);

                const miniY = startY + 6 * (buttonHeight + gap) + 35;
                const miniSize = 36;
                const miniGap = 10;

                // GameButtons helper for common mini buttons
                const miniButtons = [
                    { create: () => GameButtons.close(miniSize), label: 'Close' },
                    { create: () => GameButtons.settings(miniSize), label: 'Settings' },
                    { create: () => GameButtons.pause(miniSize), label: 'Pause' },
                    { create: () => GameButtons.playIcon(miniSize), label: 'Play' },
                    { create: () => GameButtons.info(miniSize), label: 'Info' },
                    { create: () => GameButtons.home(miniSize), label: 'Home' },
                    { create: () => GameButtons.mini('\u2665', GameStyleColors.PURPLE_BUTTON, miniSize), label: 'Heart' },
                ];

                miniButtons.forEach((config, index) => {
                    const btn = config.create();
                    btn.setPosition(30 + index * (miniSize + miniGap), miniY);
                    btn.on('click', () => console.log(`${config.label} clicked`));
                    stage.addChild(btn.getContainer());
                });
            }

            window.createScreen = createScreen;
            document.body.classList.toggle('light-theme', currentTheme === 'light');
            createScreen();
            game.start();
        })();
    </script>
</body>
</html>
