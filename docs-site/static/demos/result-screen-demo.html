<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ResultScreen Demo - GameByte Framework</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #1a1a2e; }
        canvas { display: block; margin: 0 auto; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8/dist/pixi.min.js"></script>
    <script src="/gamebyte.umd.js"></script>

    <script>
        const { createGame, CelebrationManager, CelebrationPresets } = GameByteFramework;

        const CONFIG = { width: 360, height: 640 };

        const canvas = document.createElement('canvas');
        canvas.width = CONFIG.width;
        canvas.height = CONFIG.height;
        document.body.appendChild(canvas);

        const game = createGame();

        let isVictory = true;
        let celebration = null;

        (async () => {
            await game.initialize(canvas, '2d');
            const renderer = game.make('renderer');
            const stage = renderer.getStage();

            // Create celebration manager
            celebration = new CelebrationManager(stage, CONFIG.width, CONFIG.height);

            function createResultScreen(victory) {
                // Clear stage
                while (stage.children.length > 0) {
                    stage.removeChildAt(0);
                }

                // Clear any running effects
                celebration.clear();

                // Background with gradient effect
                const bg = new PIXI.Graphics();
                bg.rect(0, 0, CONFIG.width, CONFIG.height);
                bg.fill(0x1a1a2e);
                stage.addChild(bg);

                // Light rays background (for victory)
                if (victory) {
                    const rays = new PIXI.Graphics();
                    const centerX = CONFIG.width / 2;
                    const centerY = 200;
                    const rayCount = 12;

                    // Draw rays centered at (0, 0)
                    for (let i = 0; i < rayCount; i++) {
                        const angle = (i / rayCount) * Math.PI * 2;
                        const nextAngle = ((i + 0.5) / rayCount) * Math.PI * 2;

                        rays.moveTo(0, 0);
                        rays.lineTo(Math.cos(angle) * 400, Math.sin(angle) * 400);
                        rays.lineTo(Math.cos(nextAngle) * 400, Math.sin(nextAngle) * 400);
                        rays.fill({ color: 0xFFD700, alpha: 0.08 });
                    }

                    // Position rays at center
                    rays.x = centerX;
                    rays.y = centerY;
                    stage.addChild(rays);

                    // Animate rays rotation
                    game.on('update', () => {
                        rays.rotation += 0.002;
                    });
                }

                // Title with glow effect
                const titleGlow = new PIXI.Graphics();
                titleGlow.circle(CONFIG.width / 2, 80, 60);
                titleGlow.fill({ color: victory ? 0x4CAF50 : 0xE84C4C, alpha: 0.3 });
                stage.addChild(titleGlow);

                const title = new PIXI.Text({
                    text: victory ? 'VICTORY!' : 'DEFEAT',
                    style: {
                        fontFamily: 'Arial',
                        fontSize: 48,
                        fontWeight: 'bold',
                        fill: victory ? 0x4CAF50 : 0xE84C4C,
                        dropShadow: true,
                        dropShadowColor: 0x000000,
                        dropShadowDistance: 4,
                        dropShadowBlur: 4
                    }
                });
                title.anchor.set(0.5);
                title.x = CONFIG.width / 2;
                title.y = 80;
                stage.addChild(title);

                // Title scale animation
                let titleScale = 1;
                let titleScaleDir = 0.02;
                game.on('update', () => {
                    titleScale += titleScaleDir;
                    if (titleScale > 1.05 || titleScale < 0.95) titleScaleDir *= -1;
                    title.scale.set(titleScale);
                });

                // Stars container with animated reveal
                const starsContainer = new PIXI.Container();
                starsContainer.x = CONFIG.width / 2;
                starsContainer.y = 160;
                stage.addChild(starsContainer);

                const starCount = victory ? 3 : 1;
                const starGraphics = [];

                for (let i = 0; i < 3; i++) {
                    const starContainer = new PIXI.Container();
                    starContainer.x = (i - 1) * 60;
                    starContainer.y = i === 1 ? -10 : 0;
                    starContainer.scale.set(0); // Start hidden

                    // Star glow (for earned stars)
                    if (i < starCount) {
                        const glow = new PIXI.Graphics();
                        glow.circle(0, 0, 30);
                        glow.fill({ color: 0xFFD700, alpha: 0.3 });
                        starContainer.addChild(glow);
                    }

                    // Star shape
                    const star = new PIXI.Text({
                        text: i < starCount ? 'â­' : 'â˜†',
                        style: { fontSize: i === 1 ? 56 : 44 }
                    });
                    star.anchor.set(0.5);
                    starContainer.addChild(star);

                    starsContainer.addChild(starContainer);
                    starGraphics.push({ container: starContainer, earned: i < starCount, index: i });
                }

                // Animate stars appearing with celebration
                if (victory) {
                    starGraphics.forEach((starData, i) => {
                        setTimeout(() => {
                            // Scale up animation
                            animateScale(starData.container, 0, 1.2, 200, () => {
                                animateScale(starData.container, 1.2, 1, 100);
                            });

                            // Trigger celebration for earned stars
                            if (starData.earned) {
                                const worldX = starsContainer.x + starData.container.x;
                                const worldY = starsContainer.y + starData.container.y;
                                celebration.starEarned(worldX, worldY, (i + 1));
                            }
                        }, 300 + i * 400);
                    });
                } else {
                    // Just show first star immediately for defeat
                    starGraphics[0].container.scale.set(1);
                }

                // Score panel with border decoration
                const scorePanelBorder = new PIXI.Graphics();
                scorePanelBorder.roundRect(CONFIG.width / 2 - 105, 215, 210, 70, 14);
                scorePanelBorder.fill(0x3d3d5c);
                stage.addChild(scorePanelBorder);

                const scorePanel = new PIXI.Graphics();
                scorePanel.roundRect(CONFIG.width / 2 - 100, 220, 200, 60, 12);
                scorePanel.fill(0x2d2d44);
                stage.addChild(scorePanel);

                const scoreLabel = new PIXI.Text({
                    text: 'SCORE',
                    style: { fontFamily: 'Arial', fontSize: 14, fill: 0x888888 }
                });
                scoreLabel.anchor.set(0.5);
                scoreLabel.x = CONFIG.width / 2;
                scoreLabel.y = 235;
                stage.addChild(scoreLabel);

                const scoreValue = new PIXI.Text({
                    text: victory ? '12,450' : '3,200',
                    style: { fontFamily: 'Arial', fontSize: 28, fontWeight: 'bold', fill: 0xffffff }
                });
                scoreValue.anchor.set(0.5);
                scoreValue.x = CONFIG.width / 2;
                scoreValue.y = 262;
                stage.addChild(scoreValue);

                // Best score
                const bestScore = new PIXI.Text({
                    text: 'Best: 15,230',
                    style: { fontFamily: 'Arial', fontSize: 14, fill: 0x888888 }
                });
                bestScore.anchor.set(0.5);
                bestScore.x = CONFIG.width / 2;
                bestScore.y = 295;
                stage.addChild(bestScore);

                // Rewards section
                const rewardsTitle = new PIXI.Text({
                    text: 'REWARDS',
                    style: { fontFamily: 'Arial', fontSize: 16, fontWeight: 'bold', fill: 0xffffff }
                });
                rewardsTitle.anchor.set(0.5);
                rewardsTitle.x = CONFIG.width / 2;
                rewardsTitle.y = 340;
                stage.addChild(rewardsTitle);

                const rewards = victory
                    ? [{ icon: 'ðŸª™', amount: 500, type: 'gold' }, { icon: 'ðŸ’Ž', amount: 10, type: 'gem' }, { icon: 'â­', amount: 3, type: 'star' }]
                    : [{ icon: 'ðŸª™', amount: 100, type: 'gold' }];

                const rewardWidth = 80;
                const totalWidth = rewards.length * rewardWidth;
                const startX = CONFIG.width / 2 - totalWidth / 2 + rewardWidth / 2;

                rewards.forEach((reward, i) => {
                    // Reward card border
                    const rewardBorder = new PIXI.Graphics();
                    rewardBorder.roundRect(startX + i * rewardWidth - 33, 362, 66, 76, 12);
                    rewardBorder.fill(0x4d4d6c);
                    stage.addChild(rewardBorder);

                    // Reward card
                    const rewardBg = new PIXI.Graphics();
                    rewardBg.roundRect(startX + i * rewardWidth - 30, 365, 60, 70, 10);
                    rewardBg.fill(0x3d3d5c);
                    stage.addChild(rewardBg);

                    // Icon container for shimmer
                    const iconContainer = new PIXI.Container();
                    iconContainer.x = startX + i * rewardWidth;
                    iconContainer.y = 390;
                    stage.addChild(iconContainer);

                    const icon = new PIXI.Text({
                        text: reward.icon,
                        style: { fontSize: 28 }
                    });
                    icon.anchor.set(0.5);
                    iconContainer.addChild(icon);

                    // Add shimmer and starburst to reward icons
                    setTimeout(() => {
                        if (reward.type === 'gold') {
                            celebration.addShimmer(iconContainer, 'gold');
                            celebration.addStarburst(iconContainer, 'gold');
                        } else if (reward.type === 'gem') {
                            celebration.addShimmer(iconContainer, 'gem');
                            celebration.addStarburst(iconContainer, 'gem');
                        } else if (reward.type === 'star') {
                            celebration.addShimmer(iconContainer, 'star');
                            celebration.addStarburst(iconContainer, 'star');
                        }
                    }, 1500 + i * 200);

                    const amount = new PIXI.Text({
                        text: `+${reward.amount}`,
                        style: { fontFamily: 'Arial', fontSize: 14, fontWeight: 'bold', fill: 0xffffff }
                    });
                    amount.anchor.set(0.5);
                    amount.x = startX + i * rewardWidth;
                    amount.y = 420;
                    stage.addChild(amount);
                });

                // Buttons with gradient effect
                // Retry button
                const retryBtnShadow = new PIXI.Graphics();
                retryBtnShadow.roundRect(40, 485, 130, 55, 12);
                retryBtnShadow.fill(0x2a2a3a);
                stage.addChild(retryBtnShadow);

                const retryBtn = new PIXI.Graphics();
                retryBtn.roundRect(40, 480, 130, 55, 12);
                retryBtn.fill(0x4b5563);
                retryBtn.eventMode = 'static';
                retryBtn.cursor = 'pointer';
                stage.addChild(retryBtn);

                const retryText = new PIXI.Text({
                    text: 'Retry',
                    style: { fontFamily: 'Arial', fontSize: 18, fontWeight: 'bold', fill: 0xffffff }
                });
                retryText.anchor.set(0.5);
                retryText.x = 105;
                retryText.y = 507;
                stage.addChild(retryText);

                // Next/Home button with color
                const nextBtnShadow = new PIXI.Graphics();
                nextBtnShadow.roundRect(190, 485, 130, 55, 12);
                nextBtnShadow.fill(victory ? 0x2E7D32 : 0x3949AB);
                stage.addChild(nextBtnShadow);

                const nextBtn = new PIXI.Graphics();
                nextBtn.roundRect(190, 480, 130, 55, 12);
                nextBtn.fill(victory ? 0x4CAF50 : 0x6366f1);
                nextBtn.eventMode = 'static';
                nextBtn.cursor = 'pointer';
                stage.addChild(nextBtn);

                const nextText = new PIXI.Text({
                    text: victory ? 'Next Level' : 'Home',
                    style: { fontFamily: 'Arial', fontSize: 18, fontWeight: 'bold', fill: 0xffffff }
                });
                nextText.anchor.set(0.5);
                nextText.x = 255;
                nextText.y = 507;
                stage.addChild(nextText);

                // Toggle button (demo only)
                const toggleBtn = new PIXI.Graphics();
                toggleBtn.roundRect(CONFIG.width / 2 - 80, 570, 160, 40, 8);
                toggleBtn.fill(0x2d2d44);
                toggleBtn.eventMode = 'static';
                toggleBtn.cursor = 'pointer';
                stage.addChild(toggleBtn);

                const toggleText = new PIXI.Text({
                    text: victory ? 'Show Defeat' : 'Show Victory',
                    style: { fontFamily: 'Arial', fontSize: 14, fill: 0x888888 }
                });
                toggleText.anchor.set(0.5);
                toggleText.x = CONFIG.width / 2;
                toggleText.y = 590;
                stage.addChild(toggleText);

                toggleBtn.on('pointerdown', () => {
                    isVictory = !isVictory;
                    createResultScreen(isVictory);
                });

                // Trigger victory celebration
                if (victory) {
                    setTimeout(() => {
                        celebration.victory();
                    }, 100);
                }
            }

            // Helper function for scale animation
            function animateScale(target, from, to, duration, onComplete) {
                const startTime = Date.now();
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = 1 - Math.pow(1 - progress, 3); // easeOutCubic
                    const scale = from + (to - from) * eased;
                    target.scale.set(scale);

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else if (onComplete) {
                        onComplete();
                    }
                };
                animate();
            }

            // Game loop for celebration updates
            game.on('update', (deltaTime) => {
                celebration.update(deltaTime);
            });

            createResultScreen(true);
            game.start();
        })();
    </script>
</body>
</html>
