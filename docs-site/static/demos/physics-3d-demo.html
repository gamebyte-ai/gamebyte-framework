<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GameByte - 3D Physics Demo (Cannon.js)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        h1 { color: #fff; margin-bottom: 10px; font-size: 24px; }
        p { color: #8892b0; margin-bottom: 20px; font-size: 14px; }
        #game-container {
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
            position: relative;
        }
        canvas { display: block; }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .btn:hover { transform: translateY(-2px); }
        .btn:active { transform: translateY(0); }
        .btn-blue { background: #3498DB; color: white; }
        .btn-green { background: #2ECC71; color: white; }
        .btn-red { background: #E74C3C; color: white; }
        .btn-purple { background: #9B59B6; color: white; }
        .info { color: #8892b0; margin-top: 20px; font-size: 12px; text-align: center; }
        .stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <h1>3D Physics with Cannon.js</h1>
    <p>Real-time 3D physics simulation with Three.js rendering</p>
    <div id="game-container">
        <div class="stats" id="stats">
            Bodies: <span id="body-count">0</span> |
            FPS: <span id="fps">60</span>
        </div>
        <div class="controls">
            <button class="btn btn-blue" id="spawn-box">üì¶ Box</button>
            <button class="btn btn-green" id="spawn-sphere">‚ö™ Sphere</button>
            <button class="btn btn-purple" id="spawn-cylinder">üõ¢Ô∏è Cylinder</button>
            <button class="btn btn-red" id="clear">üóëÔ∏è Clear</button>
        </div>
    </div>
    <div class="info">
        Click buttons to spawn 3D physics objects! Powered by Cannon.js + Three.js
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js"></script>

    <script>
        const CONFIG = { width: 500, height: 500 };
        const container = document.getElementById('game-container');

        // Three.js setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        const camera = new THREE.PerspectiveCamera(60, CONFIG.width / CONFIG.height, 0.1, 1000);
        camera.position.set(0, 8, 15);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(CONFIG.width, CONFIG.height);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.insertBefore(renderer.domElement, container.firstChild);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -15;
        directionalLight.shadow.camera.right = 15;
        directionalLight.shadow.camera.top = 15;
        directionalLight.shadow.camera.bottom = -15;
        scene.add(directionalLight);

        // Cannon.js physics world
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;

        // Ground plane
        const groundGeometry = new THREE.PlaneGeometry(20, 20);
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x3D4F5F,
            roughness: 0.8
        });
        const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);

        // Ground physics body
        const groundBody = new CANNON.Body({
            type: CANNON.Body.STATIC,
            shape: new CANNON.Plane()
        });
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);

        // Grid helper
        const gridHelper = new THREE.GridHelper(20, 20, 0x5D6D7E, 0x2a2a4e);
        gridHelper.position.y = 0.01;
        scene.add(gridHelper);

        // Physics objects array
        const physicsObjects = [];
        const colors = [0xE74C3C, 0x3498DB, 0x2ECC71, 0x9B59B6, 0xF39C12, 0x1ABC9C];

        function getRandomColor() {
            return colors[Math.floor(Math.random() * colors.length)];
        }

        function spawnBox() {
            const size = 0.5 + Math.random() * 0.5;
            const color = getRandomColor();

            // Three.js mesh
            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = new THREE.MeshStandardMaterial({ color, roughness: 0.5 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // Cannon.js body
            const halfSize = size / 2;
            const shape = new CANNON.Box(new CANNON.Vec3(halfSize, halfSize, halfSize));
            const body = new CANNON.Body({
                mass: 1,
                shape: shape,
                position: new CANNON.Vec3(
                    (Math.random() - 0.5) * 4,
                    5 + Math.random() * 3,
                    (Math.random() - 0.5) * 4
                )
            });
            body.angularVelocity.set(
                Math.random() * 2 - 1,
                Math.random() * 2 - 1,
                Math.random() * 2 - 1
            );
            world.addBody(body);

            physicsObjects.push({ mesh, body });
            updateBodyCount();
        }

        function spawnSphere() {
            const radius = 0.3 + Math.random() * 0.3;
            const color = getRandomColor();

            // Three.js mesh
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshStandardMaterial({ color, roughness: 0.3 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // Cannon.js body
            const shape = new CANNON.Sphere(radius);
            const body = new CANNON.Body({
                mass: 1,
                shape: shape,
                position: new CANNON.Vec3(
                    (Math.random() - 0.5) * 4,
                    5 + Math.random() * 3,
                    (Math.random() - 0.5) * 4
                )
            });
            world.addBody(body);

            physicsObjects.push({ mesh, body });
            updateBodyCount();
        }

        function spawnCylinder() {
            const radiusTop = 0.25 + Math.random() * 0.15;
            const radiusBottom = radiusTop;
            const height = 0.5 + Math.random() * 0.5;
            const color = getRandomColor();

            // Three.js mesh
            const geometry = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, 16);
            const material = new THREE.MeshStandardMaterial({ color, roughness: 0.4 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // Cannon.js body
            const shape = new CANNON.Cylinder(radiusTop, radiusBottom, height, 16);
            const body = new CANNON.Body({
                mass: 1,
                shape: shape,
                position: new CANNON.Vec3(
                    (Math.random() - 0.5) * 4,
                    5 + Math.random() * 3,
                    (Math.random() - 0.5) * 4
                )
            });
            body.angularVelocity.set(
                Math.random() * 2 - 1,
                Math.random() * 2 - 1,
                Math.random() * 2 - 1
            );
            world.addBody(body);

            physicsObjects.push({ mesh, body });
            updateBodyCount();
        }

        function clearObjects() {
            physicsObjects.forEach(obj => {
                scene.remove(obj.mesh);
                world.removeBody(obj.body);
            });
            physicsObjects.length = 0;
            updateBodyCount();
        }

        function updateBodyCount() {
            document.getElementById('body-count').textContent = physicsObjects.length;
        }

        // Button events
        document.getElementById('spawn-box').addEventListener('click', spawnBox);
        document.getElementById('spawn-sphere').addEventListener('click', spawnSphere);
        document.getElementById('spawn-cylinder').addEventListener('click', spawnCylinder);
        document.getElementById('clear').addEventListener('click', clearObjects);

        // Click to spawn on canvas
        renderer.domElement.addEventListener('click', (e) => {
            const rect = renderer.domElement.getBoundingClientRect();
            const y = e.clientY - rect.top;
            if (y < rect.height - 80) { // Not clicking on controls
                const rand = Math.random();
                if (rand < 0.33) spawnBox();
                else if (rand < 0.66) spawnSphere();
                else spawnCylinder();
            }
        });

        // Simple orbit control with mouse drag
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraAngle = { theta: 0, phi: Math.PI / 4 };
        const cameraRadius = 18;

        renderer.domElement.addEventListener('mousedown', (e) => {
            if (e.button === 2) { // Right click for rotation
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                cameraAngle.theta -= deltaX * 0.01;
                cameraAngle.phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, cameraAngle.phi - deltaY * 0.01));

                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        renderer.domElement.addEventListener('mouseup', () => { isDragging = false; });
        renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

        // Spawn initial objects
        for (let i = 0; i < 5; i++) {
            setTimeout(() => {
                if (Math.random() > 0.5) spawnBox();
                else spawnSphere();
            }, i * 200);
        }

        // FPS tracking
        let frameCount = 0;
        let lastTime = performance.now();

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update physics
            world.step(1 / 60);

            // Update meshes to match physics bodies
            physicsObjects.forEach(obj => {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);

                // Remove if fallen below ground
                if (obj.body.position.y < -10) {
                    scene.remove(obj.mesh);
                    world.removeBody(obj.body);
                }
            });

            // Clean up fallen objects
            const before = physicsObjects.length;
            for (let i = physicsObjects.length - 1; i >= 0; i--) {
                if (physicsObjects[i].body.position.y < -10) {
                    physicsObjects.splice(i, 1);
                }
            }
            if (physicsObjects.length !== before) updateBodyCount();

            // Update camera position
            camera.position.x = Math.sin(cameraAngle.theta) * Math.cos(cameraAngle.phi) * cameraRadius;
            camera.position.y = Math.sin(cameraAngle.phi) * cameraRadius;
            camera.position.z = Math.cos(cameraAngle.theta) * Math.cos(cameraAngle.phi) * cameraRadius;
            camera.lookAt(0, 0, 0);

            // FPS calculation
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = now;
            }

            renderer.render(scene, camera);
        }

        animate();
        console.log('3D Physics demo initialized!');
    </script>
</body>
</html>
