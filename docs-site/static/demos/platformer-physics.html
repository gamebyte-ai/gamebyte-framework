<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Platformer - GameByte Framework</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #1a1a2e;
            touch-action: none;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Load dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8/dist/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
    <script src="/gamebyte.umd.js"></script>

    <script>
        // GameByte Platformer Example
        // Demonstrates: Splash -> Loading -> Menu -> Game -> GameOver flow

        const { createGame } = GameByteFramework;

        // Game configuration
        const CONFIG = {
            width: 800,
            height: 600,
            playerSpeed: 5,
            jumpForce: -15,
            maxJumpHoldTime: 0.3,
            gravity: 1,
            coinValue: 100
        };

        // Game state
        const gameState = {
            score: 0,
            coins: 0,
            isGrounded: false,
            isJumping: false,
            jumpHoldTime: 0,
            gameOver: false
        };

        // Create game instance
        const game = createGame();

        // Create canvas
        const canvas = document.createElement('canvas');
        canvas.width = CONFIG.width;
        canvas.height = CONFIG.height;
        document.body.appendChild(canvas);

        // Main initialization
        (async () => {
            await game.initialize(canvas, '2d');

            // Get services
            const renderer = game.make('renderer');
            const physicsManager = game.make('physics');
            const inputManager = game.make('input');
            const stage = renderer.getStage();

            // Scene containers
            const scenes = {
                splash: new PIXI.Container(),
                loading: new PIXI.Container(),
                menu: new PIXI.Container(),
                game: new PIXI.Container(),
                gameOver: new PIXI.Container()
            };

            let currentScene = null;
            let playerBody = null;
            let playerSprite = null;
            let topBar = null;
            let coins = [];

            // ============================================
            // SCENE: SPLASH
            // ============================================
            function createSplashScene() {
                const container = scenes.splash;
                container.removeChildren();

                // Gradient background
                const bg = new PIXI.Graphics();
                bg.rect(0, 0, CONFIG.width, CONFIG.height);
                bg.fill(0x1a1a2e);
                container.addChild(bg);

                // Logo container (white background for visibility)
                const logoContainer = new PIXI.Container();
                logoContainer.x = CONFIG.width / 2;
                logoContainer.y = CONFIG.height / 2 - 30;

                // Create logo from SVG paths
                const logo = new PIXI.Graphics();
                // Simplified logo representation (square blocks pattern)
                logo.rect(-60, -20, 30, 40);
                logo.fill(0xffffff);
                logo.rect(-20, -40, 30, 40);
                logo.fill(0xffffff);
                logo.rect(-20, 10, 30, 40);
                logo.fill(0xffffff);
                logo.rect(20, -20, 80, 40);
                logo.fill(0xffffff);

                logoContainer.addChild(logo);
                container.addChild(logoContainer);

                // Brand text
                const brandText = new PIXI.Text({
                    text: 'GameByte',
                    style: {
                        fontFamily: 'Arial Black, Arial',
                        fontSize: 36,
                        fill: 0xffffff,
                        fontWeight: 'bold'
                    }
                });
                brandText.anchor.set(0.5);
                brandText.x = CONFIG.width / 2;
                brandText.y = CONFIG.height / 2 + 60;
                container.addChild(brandText);

                // Auto-advance after 2 seconds
                setTimeout(() => {
                    switchScene('loading');
                }, 2000);
            }

            // ============================================
            // SCENE: LOADING
            // ============================================
            function createLoadingScene() {
                const container = scenes.loading;
                container.removeChildren();

                // Gradient background
                const bg = new PIXI.Graphics();
                bg.rect(0, 0, CONFIG.width, CONFIG.height);
                bg.fill(0x1a1a2e);
                container.addChild(bg);

                // Loading text at bottom
                const loadingText = new PIXI.Text({
                    text: 'Loading',
                    style: {
                        fontFamily: 'Arial',
                        fontSize: 24,
                        fill: 0xffffff
                    }
                });
                loadingText.anchor.set(0.5);
                loadingText.x = CONFIG.width / 2;
                loadingText.y = CONFIG.height - 60;
                container.addChild(loadingText);

                // Simulate loading (in real game, load assets here)
                setTimeout(() => {
                    switchScene('menu');
                }, 1500);
            }

            // ============================================
            // SCENE: MENU
            // ============================================
            function createMenuScene() {
                const container = scenes.menu;
                container.removeChildren();

                // Background
                const bg = new PIXI.Graphics();
                bg.rect(0, 0, CONFIG.width, CONFIG.height);
                bg.fill(0x1a1a2e);
                container.addChild(bg);

                // Title
                const title = new PIXI.Text({
                    text: 'PLATFORMER',
                    style: {
                        fontFamily: 'Arial Black, Arial',
                        fontSize: 48,
                        fill: 0xffffff,
                        fontWeight: 'bold'
                    }
                });
                title.anchor.set(0.5);
                title.x = CONFIG.width / 2;
                title.y = 150;
                container.addChild(title);

                // Subtitle
                const subtitle = new PIXI.Text({
                    text: 'A GameByte Framework Demo',
                    style: {
                        fontFamily: 'Arial',
                        fontSize: 18,
                        fill: 0x888888
                    }
                });
                subtitle.anchor.set(0.5);
                subtitle.x = CONFIG.width / 2;
                subtitle.y = 200;
                container.addChild(subtitle);

                // Play button
                const playButton = createButton('PLAY', CONFIG.width / 2, 320, 0x4CAF50, () => {
                    resetGame();
                    switchScene('game');
                });
                container.addChild(playButton);

                // Controls info
                const controls = new PIXI.Text({
                    text: 'Controls: A/D or Arrows to move, Space to jump',
                    style: {
                        fontFamily: 'Arial',
                        fontSize: 14,
                        fill: 0x666666
                    }
                });
                controls.anchor.set(0.5);
                controls.x = CONFIG.width / 2;
                controls.y = CONFIG.height - 40;
                container.addChild(controls);
            }

            // ============================================
            // SCENE: GAME
            // ============================================
            function createGameScene() {
                const container = scenes.game;
                container.removeChildren();

                // Background
                const bg = new PIXI.Graphics();
                bg.rect(0, 0, CONFIG.width, CONFIG.height);
                bg.fill(0x2c3e50);
                container.addChild(bg);

                // Create TopBar
                topBar = createTopBar();
                container.addChild(topBar);

                // Create ground
                createGround(container);

                // Create platforms
                createPlatforms(container);

                // Create coins
                createCoins(container);

                // Create player
                createPlayer(container);

                // Create enemy
                createEnemy(container);
            }

            function createTopBar() {
                const bar = new PIXI.Container();

                // Background
                const bg = new PIXI.Graphics();
                bg.rect(0, 0, CONFIG.width, 60);
                bg.fill({ color: 0x000000, alpha: 0.7 });
                bar.addChild(bg);

                // Score
                const scoreText = new PIXI.Text({
                    text: 'Score: 0',
                    style: {
                        fontFamily: 'Arial',
                        fontSize: 24,
                        fill: 0xffffff,
                        fontWeight: 'bold'
                    }
                });
                scoreText.x = 20;
                scoreText.y = 15;
                scoreText.name = 'scoreText';
                bar.addChild(scoreText);

                // Coins
                const coinIcon = new PIXI.Graphics();
                coinIcon.circle(0, 0, 12);
                coinIcon.fill(0xFFD700);
                coinIcon.x = CONFIG.width - 120;
                coinIcon.y = 30;
                bar.addChild(coinIcon);

                const coinText = new PIXI.Text({
                    text: '0',
                    style: {
                        fontFamily: 'Arial',
                        fontSize: 24,
                        fill: 0xFFD700,
                        fontWeight: 'bold'
                    }
                });
                coinText.x = CONFIG.width - 100;
                coinText.y = 15;
                coinText.name = 'coinText';
                bar.addChild(coinText);

                return bar;
            }

            function createGround(container) {
                const groundBody = physicsManager.createBody({
                    shape: 'rectangle',
                    width: CONFIG.width,
                    height: 40,
                    x: CONFIG.width / 2,
                    y: CONFIG.height - 20,
                    options: {
                        isStatic: true,
                        label: 'ground'
                    }
                });

                const groundSprite = new PIXI.Graphics();
                groundSprite.rect(0, CONFIG.height - 40, CONFIG.width, 40);
                groundSprite.fill(0x8B4513);
                container.addChild(groundSprite);
            }

            function createPlatforms(container) {
                const platformData = [
                    { x: 150, y: 480, width: 150 },
                    { x: 400, y: 380, width: 200 },
                    { x: 650, y: 280, width: 150 },
                    { x: 300, y: 180, width: 180 }
                ];

                platformData.forEach(platform => {
                    physicsManager.createBody({
                        shape: 'rectangle',
                        width: platform.width,
                        height: 20,
                        x: platform.x,
                        y: platform.y,
                        options: {
                            isStatic: true,
                            label: 'ground'
                        }
                    });

                    const sprite = new PIXI.Graphics();
                    sprite.rect(platform.x - platform.width / 2, platform.y - 10, platform.width, 20);
                    sprite.fill(0x8B4513);
                    container.addChild(sprite);
                });
            }

            function createCoins(container) {
                coins = [];
                const coinPositions = [
                    { x: 150, y: 440 },
                    { x: 400, y: 340 },
                    { x: 650, y: 240 },
                    { x: 300, y: 140 },
                    { x: 500, y: 500 }
                ];

                coinPositions.forEach((pos, index) => {
                    const coinSprite = new PIXI.Graphics();
                    coinSprite.circle(0, 0, 15);
                    coinSprite.fill(0xFFD700);
                    coinSprite.x = pos.x;
                    coinSprite.y = pos.y;
                    coinSprite.name = `coin_${index}`;
                    container.addChild(coinSprite);

                    coins.push({
                        sprite: coinSprite,
                        x: pos.x,
                        y: pos.y,
                        collected: false
                    });
                });
            }

            function createPlayer(container) {
                playerBody = physicsManager.createBody({
                    shape: 'rectangle',
                    width: 40,
                    height: 60,
                    x: 100,
                    y: 400,
                    options: {
                        friction: 0.1,
                        frictionAir: 0.01,
                        label: 'player'
                    }
                });

                playerSprite = new PIXI.Graphics();
                playerSprite.rect(-20, -30, 40, 60);
                playerSprite.fill(0x4CAF50);
                // Eyes
                playerSprite.circle(-8, -15, 5);
                playerSprite.fill(0xffffff);
                playerSprite.circle(8, -15, 5);
                playerSprite.fill(0xffffff);
                playerSprite.circle(-8, -15, 2);
                playerSprite.fill(0x000000);
                playerSprite.circle(8, -15, 2);
                playerSprite.fill(0x000000);

                container.addChild(playerSprite);

                // Setup collision detection
                const world = physicsManager.getActiveWorld();
                world.on('collision-active', (event) => {
                    const { bodyA, bodyB } = event;
                    if (bodyA === playerBody || bodyB === playerBody) {
                        const otherBody = bodyA === playerBody ? bodyB : bodyA;
                        const label = otherBody.userData?.label;
                        if (label === 'ground') {
                            gameState.isGrounded = true;
                        }
                        if (label === 'enemy') {
                            triggerGameOver();
                        }
                    }
                });

                world.on('collision-end', (event) => {
                    const { bodyA, bodyB } = event;
                    if (bodyA === playerBody || bodyB === playerBody) {
                        const otherBody = bodyA === playerBody ? bodyB : bodyA;
                        if (otherBody.userData?.label === 'ground') {
                            gameState.isGrounded = false;
                        }
                    }
                });
            }

            let enemyBody = null;
            let enemySprite = null;
            let enemyDirection = 1;

            function createEnemy(container) {
                enemyBody = physicsManager.createBody({
                    shape: 'rectangle',
                    width: 40,
                    height: 40,
                    x: 500,
                    y: 520,
                    options: {
                        friction: 0.1,
                        frictionAir: 0.01,
                        label: 'enemy'
                    }
                });

                enemySprite = new PIXI.Graphics();
                enemySprite.rect(-20, -20, 40, 40);
                enemySprite.fill(0xe74c3c);
                // Evil eyes
                enemySprite.circle(-8, -5, 5);
                enemySprite.fill(0xffffff);
                enemySprite.circle(8, -5, 5);
                enemySprite.fill(0xffffff);
                enemySprite.circle(-8, -5, 2);
                enemySprite.fill(0x000000);
                enemySprite.circle(8, -5, 2);
                enemySprite.fill(0x000000);

                container.addChild(enemySprite);
            }

            // ============================================
            // SCENE: GAME OVER
            // ============================================
            function createGameOverScene() {
                const container = scenes.gameOver;
                container.removeChildren();

                // Dark overlay
                const bg = new PIXI.Graphics();
                bg.rect(0, 0, CONFIG.width, CONFIG.height);
                bg.fill({ color: 0x000000, alpha: 0.8 });
                container.addChild(bg);

                // Game Over text
                const gameOverText = new PIXI.Text({
                    text: 'GAME OVER',
                    style: {
                        fontFamily: 'Arial Black, Arial',
                        fontSize: 64,
                        fill: 0xe74c3c,
                        fontWeight: 'bold'
                    }
                });
                gameOverText.anchor.set(0.5);
                gameOverText.x = CONFIG.width / 2;
                gameOverText.y = 180;
                container.addChild(gameOverText);

                // Score
                const scoreText = new PIXI.Text({
                    text: `Final Score: ${gameState.score}`,
                    style: {
                        fontFamily: 'Arial',
                        fontSize: 32,
                        fill: 0xffffff
                    }
                });
                scoreText.anchor.set(0.5);
                scoreText.x = CONFIG.width / 2;
                scoreText.y = 280;
                container.addChild(scoreText);

                // Coins
                const coinText = new PIXI.Text({
                    text: `Coins: ${gameState.coins}`,
                    style: {
                        fontFamily: 'Arial',
                        fontSize: 24,
                        fill: 0xFFD700
                    }
                });
                coinText.anchor.set(0.5);
                coinText.x = CONFIG.width / 2;
                coinText.y = 330;
                container.addChild(coinText);

                // Retry button
                const retryButton = createButton('RETRY', CONFIG.width / 2, 420, 0x4CAF50, () => {
                    resetGame();
                    switchScene('game');
                });
                container.addChild(retryButton);

                // Menu button
                const menuButton = createButton('MENU', CONFIG.width / 2, 500, 0x3498db, () => {
                    switchScene('menu');
                });
                container.addChild(menuButton);
            }

            // ============================================
            // HELPER FUNCTIONS
            // ============================================
            function createButton(text, x, y, color, onClick) {
                const button = new PIXI.Container();
                button.x = x;
                button.y = y;

                // Background
                const bg = new PIXI.Graphics();
                bg.roundRect(-100, -25, 200, 50, 12);
                bg.fill(color);
                button.addChild(bg);

                // Text
                const label = new PIXI.Text({
                    text: text,
                    style: {
                        fontFamily: 'Arial Black, Arial',
                        fontSize: 24,
                        fill: 0xffffff,
                        fontWeight: 'bold'
                    }
                });
                label.anchor.set(0.5);
                button.addChild(label);

                // Interactivity
                button.eventMode = 'static';
                button.cursor = 'pointer';

                button.on('pointerdown', () => {
                    button.scale.set(0.95);
                });

                button.on('pointerup', () => {
                    button.scale.set(1);
                    onClick();
                });

                button.on('pointerupoutside', () => {
                    button.scale.set(1);
                });

                return button;
            }

            function switchScene(sceneName) {
                // Remove current scene
                if (currentScene) {
                    stage.removeChild(currentScene);
                }

                // Create and add new scene
                switch (sceneName) {
                    case 'splash':
                        createSplashScene();
                        break;
                    case 'loading':
                        createLoadingScene();
                        break;
                    case 'menu':
                        createMenuScene();
                        break;
                    case 'game':
                        createGameScene();
                        break;
                    case 'gameOver':
                        createGameOverScene();
                        break;
                }

                currentScene = scenes[sceneName];
                stage.addChild(currentScene);
            }

            function resetGame() {
                gameState.score = 0;
                gameState.coins = 0;
                gameState.isGrounded = false;
                gameState.isJumping = false;
                gameState.jumpHoldTime = 0;
                gameState.gameOver = false;

                // Reset physics world
                const world = physicsManager.getActiveWorld();
                world.clear();
            }

            function triggerGameOver() {
                if (gameState.gameOver) return;
                gameState.gameOver = true;
                switchScene('gameOver');
            }

            function updateTopBar() {
                if (!topBar) return;
                const scoreText = topBar.getChildByName('scoreText');
                const coinText = topBar.getChildByName('coinText');
                if (scoreText) scoreText.text = `Score: ${gameState.score}`;
                if (coinText) coinText.text = `${gameState.coins}`;
            }

            function checkCoinCollection() {
                if (!playerBody) return;
                const playerPos = playerBody.position;

                coins.forEach(coin => {
                    if (coin.collected) return;

                    const dx = playerPos.x - coin.x;
                    const dy = playerPos.y - coin.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 40) {
                        coin.collected = true;
                        coin.sprite.visible = false;
                        gameState.coins++;
                        gameState.score += CONFIG.coinValue;
                        updateTopBar();
                    }
                });

                // Check if all coins collected
                if (coins.every(c => c.collected)) {
                    gameState.score += 500; // Bonus
                    triggerGameOver();
                }
            }

            // ============================================
            // INPUT HANDLING
            // ============================================
            const keys = {
                left: false,
                right: false,
                jump: false
            };

            inputManager.on('keydown', (event) => {
                if (gameState.gameOver) return;

                switch (event.key) {
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        keys.left = true;
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        keys.right = true;
                        break;
                    case ' ':
                    case 'w':
                    case 'W':
                    case 'ArrowUp':
                        if (!keys.jump && gameState.isGrounded) {
                            keys.jump = true;
                            gameState.isJumping = true;
                            gameState.jumpHoldTime = 0;
                            playerBody.velocity = {
                                x: playerBody.velocity.x,
                                y: CONFIG.jumpForce
                            };
                        }
                        break;
                }
            });

            inputManager.on('keyup', (event) => {
                switch (event.key) {
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        keys.left = false;
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        keys.right = false;
                        break;
                    case ' ':
                    case 'w':
                    case 'W':
                    case 'ArrowUp':
                        keys.jump = false;
                        gameState.isJumping = false;
                        break;
                }
            });

            // ============================================
            // UPDATE LOOP
            // ============================================
            game.on('update', (deltaTime) => {
                if (currentScene !== scenes.game || gameState.gameOver) return;

                // Player movement
                if (playerBody) {
                    if (keys.left) {
                        playerBody.velocity = {
                            x: -CONFIG.playerSpeed,
                            y: playerBody.velocity.y
                        };
                    } else if (keys.right) {
                        playerBody.velocity = {
                            x: CONFIG.playerSpeed,
                            y: playerBody.velocity.y
                        };
                    } else {
                        playerBody.velocity = {
                            x: playerBody.velocity.x * 0.9,
                            y: playerBody.velocity.y
                        };
                    }

                    // Variable jump height
                    if (gameState.isJumping && keys.jump && gameState.jumpHoldTime < CONFIG.maxJumpHoldTime) {
                        gameState.jumpHoldTime += deltaTime / 1000;
                        playerBody.applyForce({ x: 0, y: -0.005 });
                    }

                    // Update player sprite
                    playerSprite.x = playerBody.position.x;
                    playerSprite.y = playerBody.position.y;
                    playerSprite.rotation = playerBody.rotation;

                    // Keep player in bounds
                    if (playerBody.position.x < 20) {
                        playerBody.position = { x: 20, y: playerBody.position.y };
                    }
                    if (playerBody.position.x > CONFIG.width - 20) {
                        playerBody.position = { x: CONFIG.width - 20, y: playerBody.position.y };
                    }

                    // Fall detection
                    if (playerBody.position.y > CONFIG.height + 50) {
                        triggerGameOver();
                    }
                }

                // Enemy movement (simple patrol)
                if (enemyBody && enemySprite) {
                    enemyBody.velocity = {
                        x: 2 * enemyDirection,
                        y: enemyBody.velocity.y
                    };

                    // Reverse direction at boundaries
                    if (enemyBody.position.x < 350 || enemyBody.position.x > 650) {
                        enemyDirection *= -1;
                    }

                    enemySprite.x = enemyBody.position.x;
                    enemySprite.y = enemyBody.position.y;
                }

                // Check coin collection
                checkCoinCollection();

                // Update score over time
                gameState.score += Math.floor(deltaTime / 100);
                updateTopBar();
            });

            // ============================================
            // START GAME
            // ============================================
            switchScene('splash');
            game.start();

        })();
    </script>
</body>
</html>
