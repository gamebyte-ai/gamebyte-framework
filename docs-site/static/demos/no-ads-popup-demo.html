<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>No Ads Popup Demo - GameByte Framework</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #0f1923; transition: background 0.3s ease; }
        body.light-theme { background: #e8eef5; }
        canvas { display: block; margin: 0 auto; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8/dist/pixi.min.js"></script>
    <script src="/gamebyte.umd.js"></script>

    <script>
        // =====================================================
        // No Ads Popup Demo - Using Framework Abstractions
        // =====================================================
        // This demo showcases:
        // - Complex modal popup with light rays
        // - Prohibition badge with sparkle effects
        // - GameStyleButton-like CTA styling
        // - graphics() abstraction instead of direct PIXI usage
        // =====================================================

        const {
            createGame,
            graphics,
            loadFrameworkFont,
            getFrameworkFontFamily
        } = GameByteFramework;

        const CONFIG = { width: 390, height: 720 };

        // ===== THEME DETECTION =====
        function detectTheme() {
            try {
                if (window.parent && window.parent.document) {
                    const parentTheme = window.parent.document.documentElement.getAttribute('data-theme');
                    if (parentTheme) return parentTheme;
                }
            } catch (e) { /* Cross-origin */ }

            const urlParams = new URLSearchParams(window.location.search);
            const themeParam = urlParams.get('theme');
            if (themeParam) return themeParam;

            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) {
                return 'light';
            }
            return 'dark';
        }

        let currentTheme = detectTheme();

        function setupThemeListener() {
            try {
                if (window.parent && window.parent.document) {
                    const observer = new MutationObserver((mutations) => {
                        mutations.forEach((mutation) => {
                            if (mutation.attributeName === 'data-theme') {
                                const newTheme = window.parent.document.documentElement.getAttribute('data-theme');
                                if (newTheme && newTheme !== currentTheme) {
                                    currentTheme = newTheme;
                                    applyTheme();
                                }
                            }
                        });
                    });
                    observer.observe(window.parent.document.documentElement, { attributes: true });
                }
            } catch (e) {
                window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', (e) => {
                    currentTheme = e.matches ? 'light' : 'dark';
                    applyTheme();
                });
            }
        }

        // ===== THEME COLOR PALETTES =====
        const THEME_COLORS = {
            dark: {
                bgDark: 0x0f1923,
                modalBorder: 0x1e3a5f,
                modalBg: 0x41A7FB,
                headerBg: 0x2889F0,
                panelBg: 0x2484D3,
                panelBorder: 0x0A5BA1,
                prohibitRed: 0xe63946,
                prohibitRedDark: 0xa82d38,
                prohibitRedLight: 0xf07080,
                ctaGreen: 0x2DE45A,
                ctaGreenDark: 0x28A165,
                closeBtnRed: 0xE84C4C,
                closeBtnRedDark: 0xA83340,
                iconGreen: 0x4CAF50,
                iconPurple: 0x5a6a7a,
                glowColor: 0xFFFAE6,
                textStroke: 0x1a2a3a,
                adsTextStroke: 0x2a4a60
            },
            light: {
                bgDark: 0xe8eef5,
                modalBorder: 0x3060a0,
                modalBg: 0x60c0f8,
                headerBg: 0x50b0e8,
                panelBg: 0x40a0e0,
                panelBorder: 0x2080c0,
                prohibitRed: 0xf04050,
                prohibitRedDark: 0xc83848,
                prohibitRedLight: 0xff7080,
                ctaGreen: 0x40f070,
                ctaGreenDark: 0x30b060,
                closeBtnRed: 0xf05868,
                closeBtnRedDark: 0xc04858,
                iconGreen: 0x5cbf60,
                iconPurple: 0x7a8a9a,
                glowColor: 0xFFF8E0,
                textStroke: 0x2060a0,
                adsTextStroke: 0x3a5a70
            }
        };

        function getColors() {
            return THEME_COLORS[currentTheme] || THEME_COLORS.dark;
        }

        const canvas = document.createElement('canvas');
        canvas.width = CONFIG.width;
        canvas.height = CONFIG.height;
        document.body.appendChild(canvas);

        const game = createGame();
        let renderer, stage;

        // Sparkle system state
        let sparkles = [];
        let sparkleContainer = null;
        let spawnTimer = 0;
        let nextSpawnDelay = 200;
        let badgeCenterX = 0;
        let badgeCenterY = 0;

        const sparkleConfig = {
            radius: 75,
            count: 1,
            color: 0xFFFFFF,
            duration: 600,
            spawnDelayMin: 200,
            spawnDelayMax: 500,
            scaleMin: 0.6,
            scaleMax: 1.0,
            rotationSpeed: 0.005
        };

        // Text style factory
        function createTextStyle(fontSize) {
            const colors = getColors();
            return {
                fontFamily: getFrameworkFontFamily(),
                fontSize: fontSize,
                fontWeight: '900',
                fill: 0xffffff,
                stroke: { color: colors.textStroke, width: Math.max(3, fontSize * 0.12) },
                dropShadow: {
                    color: 0x000000,
                    blur: 0,
                    distance: Math.max(2, fontSize * 0.06),
                    angle: Math.PI / 2,
                    alpha: 0.5
                }
            };
        }

        // Draw star shape
        function drawStar(gfx, graphicsObj, spikes, size, color) {
            graphicsObj.clear();
            const innerRatio = spikes === 4 ? 0.25 : 0.4;
            const innerRadius = size * innerRatio;
            const points = [];

            for (let i = 0; i < spikes * 2; i++) {
                const radius = i % 2 === 0 ? size : innerRadius;
                const angle = (i * Math.PI) / spikes - Math.PI / 2;
                points.push(Math.cos(angle) * radius);
                points.push(Math.sin(angle) * radius);
            }

            graphicsObj.poly(points).fill(color);
        }

        // Sparkle spawn
        function spawnSparkle(gfx) {
            if (!sparkleContainer || sparkles.length >= sparkleConfig.count) return;

            const graphic = gfx.createGraphics();
            const size = 14;

            drawStar(gfx, graphic, 4, size, sparkleConfig.color);

            const angle = Math.random() * Math.PI * 2;
            const distance = 30 + Math.random() * sparkleConfig.radius;

            graphic.x = badgeCenterX + Math.cos(angle) * distance;
            graphic.y = badgeCenterY + Math.sin(angle) * distance;
            graphic.alpha = 0;
            graphic.scale.set(0);

            sparkleContainer.addChild(graphic);

            const targetScale = sparkleConfig.scaleMin + Math.random() * (sparkleConfig.scaleMax - sparkleConfig.scaleMin);

            sparkles.push({
                graphic,
                targetScale,
                currentScale: 0,
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: sparkleConfig.rotationSpeed,
                life: 0,
                maxLife: sparkleConfig.duration,
                phase: 'spawn'
            });
        }

        // Sparkle update
        function updateSparkles(deltaTime, gfx) {
            spawnTimer += deltaTime;
            if (spawnTimer >= nextSpawnDelay) {
                spawnSparkle(gfx);
                spawnTimer = 0;
                nextSpawnDelay = sparkleConfig.spawnDelayMin + Math.random() * (sparkleConfig.spawnDelayMax - sparkleConfig.spawnDelayMin);
            }

            for (let i = sparkles.length - 1; i >= 0; i--) {
                const p = sparkles[i];
                p.life += deltaTime;
                const progress = p.life / p.maxLife;

                if (progress < 0.15) {
                    p.phase = 'spawn';
                } else if (progress < 0.35) {
                    p.phase = 'hold';
                } else {
                    p.phase = 'fade';
                }

                switch (p.phase) {
                    case 'spawn': {
                        const spawnProgress = progress / 0.15;
                        p.currentScale = p.targetScale * spawnProgress;
                        p.graphic.alpha = spawnProgress;
                        break;
                    }
                    case 'hold': {
                        p.currentScale = p.targetScale;
                        p.graphic.alpha = 1;
                        break;
                    }
                    case 'fade': {
                        const fadeProgress = (progress - 0.35) / 0.65;
                        const eased = 1 - fadeProgress;
                        p.currentScale = p.targetScale * eased;
                        p.graphic.alpha = eased;
                        break;
                    }
                }

                p.rotation += p.rotationSpeed;
                p.graphic.scale.set(p.currentScale);
                p.graphic.rotation = p.rotation;

                if (progress >= 1) {
                    sparkleContainer.removeChild(p.graphic);
                    p.graphic.destroy();
                    sparkles.splice(i, 1);
                }
            }
        }

        function createNoAdsPopup() {
            const colors = getColors();
            const gfx = graphics();

            // Clear stage and sparkles
            while (stage.children.length > 0) {
                stage.removeChildAt(0);
            }
            sparkles = [];
            spawnTimer = 0;

            // Modal dimensions
            const modalWidth = 340;
            const modalHeight = 560;
            const modalX = (CONFIG.width - modalWidth) / 2;
            const modalY = 70;
            const modalRadius = 18;
            const borderWidth = 4;

            // Background
            const bg = gfx.createGraphics();
            bg.rect(0, 0, CONFIG.width, CONFIG.height);
            bg.fill(colors.bgDark);
            stage.addChild(bg);

            // Modal shadow
            const modalShadow = gfx.createGraphics();
            modalShadow.roundRect(modalX, modalY + 8, modalWidth, modalHeight, modalRadius);
            modalShadow.fill({ color: 0x000000, alpha: 0.4 });
            stage.addChild(modalShadow);

            // Modal border
            const modalBorder = gfx.createGraphics();
            modalBorder.roundRect(
                modalX - borderWidth,
                modalY - borderWidth,
                modalWidth + borderWidth * 2,
                modalHeight + borderWidth * 2,
                modalRadius + borderWidth
            );
            modalBorder.fill(colors.modalBorder);
            stage.addChild(modalBorder);

            // Modal background
            const modalBg = gfx.createGraphics();
            modalBg.roundRect(modalX, modalY, modalWidth, modalHeight, modalRadius);
            modalBg.fill(colors.modalBg);
            stage.addChild(modalBg);

            // Header
            const headerHeight = 52;
            const headerBg = gfx.createGraphics();
            headerBg.roundRect(modalX, modalY, modalWidth, headerHeight, modalRadius);
            headerBg.rect(modalX, modalY + headerHeight - modalRadius, modalWidth, modalRadius);
            headerBg.fill(colors.headerBg);
            stage.addChild(headerBg);

            // Light rays
            const raysContainer = gfx.createContainer();
            const raysCenterX = modalX + modalWidth / 2;
            const raysCenterY = modalY + 200;

            const raysMask = gfx.createGraphics();
            raysMask.rect(modalX, modalY + headerHeight, modalWidth, modalHeight * 0.6 - headerHeight);
            raysMask.fill(0xffffff);
            stage.addChild(raysMask);

            const glowCircle = gfx.createGraphics();
            glowCircle.circle(0, 0, 110);
            glowCircle.fill({ color: colors.glowColor, alpha: 0.75 });
            glowCircle.x = raysCenterX;
            glowCircle.y = raysCenterY;
            // Note: BlurFilter uses direct PIXI.js as framework filter abstraction is not yet available
            glowCircle.filters = [new PIXI.BlurFilter({ strength: 60, quality: 4 })];
            glowCircle.mask = raysMask;
            stage.addChild(glowCircle);

            const rayAngles = [0, 58, 120, 178, 240, 300];
            const rayWidth = 28;
            const rayLength = 220;

            for (let i = 0; i < rayAngles.length; i++) {
                const startAngle = (rayAngles[i] - rayWidth / 2) * Math.PI / 180;
                const endAngle = (rayAngles[i] + rayWidth / 2) * Math.PI / 180;

                const ray = gfx.createGraphics();
                const segments = 10;

                for (let s = 0; s < segments; s++) {
                    const innerR = (rayLength / segments) * s;
                    const outerR = (rayLength / segments) * (s + 1);
                    const alpha = 0.35 * (1 - s / segments);

                    ray.moveTo(Math.cos(startAngle) * innerR, Math.sin(startAngle) * innerR);
                    ray.lineTo(Math.cos(startAngle) * outerR, Math.sin(startAngle) * outerR);
                    ray.lineTo(Math.cos(endAngle) * outerR, Math.sin(endAngle) * outerR);
                    ray.lineTo(Math.cos(endAngle) * innerR, Math.sin(endAngle) * innerR);
                    ray.closePath();
                    ray.fill({ color: 0xffffff, alpha: alpha });
                }

                raysContainer.addChild(ray);
            }

            raysContainer.x = raysCenterX;
            raysContainer.y = raysCenterY;
            raysContainer.mask = raysMask;
            stage.addChild(raysContainer);
            window.raysContainer = raysContainer;

            // ADS badge
            badgeCenterX = modalX + modalWidth / 2;
            badgeCenterY = modalY + 200;
            const badgeOuterRadius = 80;
            const badgeInnerRadius = 55;
            const stripeWidth = 22;

            // Badge shadow
            const badgeShadow = gfx.createGraphics();
            badgeShadow.circle(badgeCenterX, badgeCenterY + 6, badgeOuterRadius);
            badgeShadow.fill({ color: 0x000000, alpha: 0.35 });
            stage.addChild(badgeShadow);

            // Prohibition sign container
            const prohibitSign = gfx.createContainer();
            prohibitSign.x = badgeCenterX;
            prohibitSign.y = badgeCenterY;

            const ringThickness = badgeOuterRadius - badgeInnerRadius;
            const ringMidRadius = (badgeOuterRadius + badgeInnerRadius) / 2;

            // Ring outer
            const ringOuter = gfx.createGraphics();
            ringOuter.circle(0, 0, ringMidRadius);
            ringOuter.stroke({ color: colors.prohibitRedDark, width: ringThickness + 4 });
            prohibitSign.addChild(ringOuter);

            // Ring main
            const ringMain = gfx.createGraphics();
            ringMain.circle(0, 0, ringMidRadius);
            ringMain.stroke({ color: colors.prohibitRed, width: ringThickness - 2 });
            prohibitSign.addChild(ringMain);

            // Ring highlight
            const ringHighlight = gfx.createGraphics();
            ringHighlight.arc(0, 0, ringMidRadius, -Math.PI * 0.85, -Math.PI * 0.15);
            ringHighlight.stroke({ color: colors.prohibitRedLight, width: ringThickness * 0.4, alpha: 0.6 });
            prohibitSign.addChild(ringHighlight);

            // Stripe
            const stripeAngle = Math.PI / 4;
            const stripeLength = badgeOuterRadius * 1.6;

            const stripeDark = gfx.createGraphics();
            stripeDark.rect(-stripeLength / 2, -stripeWidth / 2 - 2, stripeLength, stripeWidth + 4);
            stripeDark.fill(colors.prohibitRedDark);
            stripeDark.rotation = stripeAngle;
            prohibitSign.addChild(stripeDark);

            const stripeMain = gfx.createGraphics();
            stripeMain.rect(-stripeLength / 2, -stripeWidth / 2, stripeLength, stripeWidth);
            stripeMain.fill(colors.prohibitRed);
            stripeMain.rotation = stripeAngle;
            prohibitSign.addChild(stripeMain);

            const stripeHighlight = gfx.createGraphics();
            stripeHighlight.rect(-stripeLength / 2, -stripeWidth / 2, stripeLength, 5);
            stripeHighlight.fill({ color: colors.prohibitRedLight, alpha: 0.5 });
            stripeHighlight.rotation = stripeAngle;
            prohibitSign.addChild(stripeHighlight);

            stage.addChild(prohibitSign);

            // ADS text shadow
            const adsTextShadow = gfx.createText('ADS', {
                fontFamily: getFrameworkFontFamily(),
                fontSize: 78,
                fontWeight: '900',
                fontStyle: 'italic',
                fill: 0x000000
            });
            adsTextShadow.anchor.set(0.5);
            adsTextShadow.x = badgeCenterX;
            adsTextShadow.y = badgeCenterY + 5;
            adsTextShadow.rotation = -20 * Math.PI / 180;
            adsTextShadow.alpha = 0.4;
            stage.addChild(adsTextShadow);

            // ADS text
            const adsText = gfx.createText('ADS', {
                fontFamily: getFrameworkFontFamily(),
                fontSize: 78,
                fontWeight: '900',
                fontStyle: 'italic',
                fill: 0xffffff,
                stroke: { color: colors.adsTextStroke, width: 7 }
            });
            adsText.anchor.set(0.5);
            adsText.x = badgeCenterX;
            adsText.y = badgeCenterY;
            adsText.rotation = -20 * Math.PI / 180;
            stage.addChild(adsText);

            // Sparkle container
            sparkleContainer = gfx.createContainer();
            stage.addChild(sparkleContainer);

            // Feature panel
            const panelX = modalX + 18;
            const panelY = modalY + 320;
            const panelWidth = modalWidth - 36;
            const panelHeight = 152;
            const panelRadius = 14;

            const featurePanel = gfx.createGraphics();
            featurePanel.roundRect(panelX, panelY, panelWidth, panelHeight, panelRadius);
            featurePanel.fill(colors.panelBg);
            stage.addChild(featurePanel);

            const panelBorderG = gfx.createGraphics();
            panelBorderG.roundRect(panelX, panelY, panelWidth, panelHeight, panelRadius);
            panelBorderG.stroke({ color: colors.panelBorder, width: 2 });
            stage.addChild(panelBorderG);

            // Feature list
            const features = [
                { icon: '\ud83d\udcfa', text: 'Remove all intrusive ads\nforever!', iconBg: colors.iconGreen, hasBlock: true },
                { icon: '\ud83d\udcf6', text: 'Play without internet\nconnection!', iconBg: colors.iconGreen, hasX: true },
                { icon: '\ud83c\udfac', text: 'Keep optional ads for\nrewards!', iconBg: colors.iconPurple }
            ];

            const featureStartY = panelY + 11;
            const featureSpacing = 42;

            features.forEach((feature, i) => {
                const y = featureStartY + i * featureSpacing;

                const iconBg = gfx.createGraphics();
                iconBg.roundRect(panelX + 12, y, 34, 34, 8);
                iconBg.fill(feature.iconBg);
                stage.addChild(iconBg);

                const icon = gfx.createText(feature.icon, { fontSize: 20 });
                icon.anchor.set(0.5);
                icon.x = panelX + 29;
                icon.y = y + 17;
                stage.addChild(icon);

                if (feature.hasBlock) {
                    const block = gfx.createText('\u26d4', { fontSize: 12 });
                    block.anchor.set(0.5);
                    block.x = panelX + 38;
                    block.y = y + 26;
                    stage.addChild(block);
                }
                if (feature.hasX) {
                    const xMark = gfx.createText('\u2715', {
                        fontSize: 12,
                        fill: colors.prohibitRed,
                        fontWeight: 'bold'
                    });
                    xMark.anchor.set(0.5);
                    xMark.x = panelX + 40;
                    xMark.y = y + 26;
                    stage.addChild(xMark);
                }

                const featureText = gfx.createText(feature.text, {
                    fontFamily: getFrameworkFontFamily(),
                    fontSize: 15,
                    fontWeight: '900',
                    fill: 0xffffff,
                    stroke: { color: colors.textStroke, width: 3 },
                    lineHeight: 18
                });
                featureText.x = panelX + 55;
                featureText.y = y + 2;
                stage.addChild(featureText);
            });

            // CTA Button
            const ctaWidth = 240;
            const ctaHeight = 58;
            const ctaX = modalX + (modalWidth - ctaWidth) / 2;
            const ctaY = modalY + 485;
            const ctaRadius = 14;
            const shadowOffset = 3;

            const ctaOuterBorder = gfx.createGraphics();
            ctaOuterBorder.roundRect(ctaX - 1, ctaY - 1, ctaWidth + 2, ctaHeight + shadowOffset + 2, ctaRadius + 1);
            ctaOuterBorder.stroke({ color: 0x000000, width: 1 });
            stage.addChild(ctaOuterBorder);

            const ctaShadow = gfx.createGraphics();
            ctaShadow.roundRect(ctaX, ctaY + shadowOffset, ctaWidth, ctaHeight, ctaRadius);
            ctaShadow.fill(colors.ctaGreenDark);
            stage.addChild(ctaShadow);

            const ctaTopShine = gfx.createGraphics();
            ctaTopShine.roundRect(ctaX + 0.5, ctaY - 0.5, ctaWidth - 1, ctaHeight, ctaRadius);
            ctaTopShine.fill({ color: 0xFFFFFF, alpha: 0.60 });
            stage.addChild(ctaTopShine);

            const ctaBtn = gfx.createGraphics();
            ctaBtn.roundRect(ctaX, ctaY, ctaWidth, ctaHeight, ctaRadius);
            ctaBtn.fill(colors.ctaGreen);
            ctaBtn.eventMode = 'static';
            ctaBtn.cursor = 'pointer';
            stage.addChild(ctaBtn);

            // CTA highlight
            const hlX = ctaX + 3;
            const hlY = ctaY + 3;
            const hlW = ctaWidth - 6;
            const hlH = ctaHeight * 0.45;
            const hlR = ctaRadius - 2;

            const ctaHighlightTop = gfx.createGraphics();
            ctaHighlightTop.moveTo(hlX + hlR, hlY);
            ctaHighlightTop.lineTo(hlX + hlW - hlR, hlY);
            ctaHighlightTop.arc(hlX + hlW - hlR, hlY + hlR, hlR, -Math.PI / 2, 0);
            ctaHighlightTop.lineTo(hlX + hlW, hlY + hlH);
            ctaHighlightTop.lineTo(hlX, hlY + hlH);
            ctaHighlightTop.lineTo(hlX, hlY + hlR);
            ctaHighlightTop.arc(hlX + hlR, hlY + hlR, hlR, Math.PI, -Math.PI / 2);
            ctaHighlightTop.closePath();
            ctaHighlightTop.fill({ color: 0xFFFFFF, alpha: 0.25 });
            stage.addChild(ctaHighlightTop);

            // CTA jellybean
            const ctaJellybean = gfx.createGraphics();
            ctaJellybean.ellipse(0, 0, 3.5, 2.6);
            ctaJellybean.fill(0xE6FCE9);
            ctaJellybean.x = ctaX + 10;
            ctaJellybean.y = ctaY + 9;
            ctaJellybean.rotation = -25 * Math.PI / 180;
            stage.addChild(ctaJellybean);

            const ctaText = gfx.createText('TRY 399.99', createTextStyle(28));
            ctaText.anchor.set(0.5);
            ctaText.x = ctaX + ctaWidth / 2;
            ctaText.y = ctaY + ctaHeight / 2;
            stage.addChild(ctaText);

            // Header text
            const headerText = gfx.createText('NO ADS', createTextStyle(30));
            headerText.anchor.set(0.5);
            headerText.x = modalX + modalWidth / 2;
            headerText.y = modalY + headerHeight / 2;
            stage.addChild(headerText);

            // Close button
            const closeBtnSize = 38;
            const closeBtnX = modalX + modalWidth - closeBtnSize - 8;
            const closeBtnY = modalY + (headerHeight - closeBtnSize) / 2;
            const closeBtnRadius = 10;
            const closeShadowOffset = 3;

            const closeOuterBorder = gfx.createGraphics();
            closeOuterBorder.roundRect(closeBtnX - 1, closeBtnY - 1, closeBtnSize + 2, closeBtnSize + closeShadowOffset + 2, closeBtnRadius + 1);
            closeOuterBorder.stroke({ color: 0x000000, width: 1 });
            stage.addChild(closeOuterBorder);

            const closeShadow = gfx.createGraphics();
            closeShadow.roundRect(closeBtnX, closeBtnY + closeShadowOffset, closeBtnSize, closeBtnSize, closeBtnRadius);
            closeShadow.fill(colors.closeBtnRedDark);
            stage.addChild(closeShadow);

            const closeTopShine = gfx.createGraphics();
            closeTopShine.roundRect(closeBtnX + 0.5, closeBtnY - 0.5, closeBtnSize - 1, closeBtnSize, closeBtnRadius);
            closeTopShine.fill({ color: 0xFFFFFF, alpha: 0.60 });
            stage.addChild(closeTopShine);

            const closeBtn = gfx.createGraphics();
            closeBtn.roundRect(closeBtnX, closeBtnY, closeBtnSize, closeBtnSize, closeBtnRadius);
            closeBtn.fill(colors.closeBtnRed);
            closeBtn.eventMode = 'static';
            closeBtn.cursor = 'pointer';
            stage.addChild(closeBtn);

            // Close highlight
            const closeHlX = closeBtnX + 3;
            const closeHlY = closeBtnY + 3;
            const closeHlW = closeBtnSize - 6;
            const closeHlH = closeBtnSize * 0.45;
            const closeHlR = closeBtnRadius - 2;

            const closeHighlight = gfx.createGraphics();
            closeHighlight.moveTo(closeHlX + closeHlR, closeHlY);
            closeHighlight.lineTo(closeHlX + closeHlW - closeHlR, closeHlY);
            closeHighlight.arc(closeHlX + closeHlW - closeHlR, closeHlY + closeHlR, closeHlR, -Math.PI / 2, 0);
            closeHighlight.lineTo(closeHlX + closeHlW, closeHlY + closeHlH);
            closeHighlight.lineTo(closeHlX, closeHlY + closeHlH);
            closeHighlight.lineTo(closeHlX, closeHlY + closeHlR);
            closeHighlight.arc(closeHlX + closeHlR, closeHlY + closeHlR, closeHlR, Math.PI, -Math.PI / 2);
            closeHighlight.closePath();
            closeHighlight.fill({ color: 0xFFFFFF, alpha: 0.25 });
            stage.addChild(closeHighlight);

            // Close jellybean
            const closeJellybean = gfx.createGraphics();
            closeJellybean.ellipse(0, 0, 3, 2.2);
            closeJellybean.fill(0xFFE6E6);
            closeJellybean.x = closeBtnX + 9;
            closeJellybean.y = closeBtnY + 8;
            closeJellybean.rotation = -25 * Math.PI / 180;
            stage.addChild(closeJellybean);

            const closeX = gfx.createText('\u2715', {
                fontFamily: getFrameworkFontFamily(),
                fontSize: 20,
                fontWeight: '900',
                fill: 0xffffff,
                stroke: { color: 0x000000, width: 1 }
            });
            closeX.anchor.set(0.5);
            closeX.x = closeBtnX + closeBtnSize / 2;
            closeX.y = closeBtnY + closeBtnSize / 2;
            stage.addChild(closeX);

            // Interactions
            closeBtn.on('pointerdown', () => console.log('Close clicked'));
            ctaBtn.on('pointerdown', () => console.log('Purchase clicked: TRY 399.99'));

            // Store gfx for animation
            window.gfx = gfx;
        }

        let isRecreating = false;
        async function applyTheme() {
            if (isRecreating) return;
            isRecreating = true;

            document.body.classList.toggle('light-theme', currentTheme === 'light');
            if (stage && window.createNoAdsPopup) {
                await loadFrameworkFont();
                window.createNoAdsPopup();
            }
            setTimeout(() => { isRecreating = false; }, 100);
        }

        (async () => {
            await loadFrameworkFont();
            await game.initialize(canvas, '2d');
            renderer = game.make('renderer');
            stage = renderer.getStage();

            setupThemeListener();

            window.createNoAdsPopup = createNoAdsPopup;

            // Animation loop
            let lastTime = performance.now();
            function animate() {
                const now = performance.now();
                const deltaTime = now - lastTime;
                lastTime = now;

                // Rays rotation
                if (window.raysContainer) {
                    window.raysContainer.rotation += 0.002;
                }

                if (window.gfx) {
                    updateSparkles(deltaTime, window.gfx);
                }

                requestAnimationFrame(animate);
            }

            document.body.classList.toggle('light-theme', currentTheme === 'light');
            createNoAdsPopup();
            game.start();
            animate();
        })();
    </script>
</body>
</html>
