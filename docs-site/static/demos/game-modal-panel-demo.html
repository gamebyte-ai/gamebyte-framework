<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GameModalPanel Demo - GameByte Framework</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #1a1a2e; transition: background 0.3s ease; }
        body.light-theme { background: #e8ecf4; }
        canvas { display: block; margin: 0 auto; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8/dist/pixi.min.js"></script>
    <script src="/gamebyte.umd.js"></script>

    <script>
        // =====================================================
        // GameModalPanel Framework Component Demo
        // =====================================================
        // This demo showcases the GameModalPanel framework component:
        // - Using GameModalPanel class with proper configuration
        // - Adding custom content using addContent() API
        // - Show/hide animations with scale effects
        // - Settings toggles with sparkle effects
        // - CelebrationManager for confetti
        // - Theme support (light/dark)
        // =====================================================

        const { createGame, GameModalPanel, CelebrationManager, graphics, loadFrameworkFont } = GameByteFramework;

        const CONFIG = { width: 400, height: 500 };

        // ===== THEME DETECTION =====
        function detectTheme() {
            try {
                if (window.parent && window.parent.document) {
                    const parentTheme = window.parent.document.documentElement.getAttribute('data-theme');
                    if (parentTheme) return parentTheme;
                }
            } catch (e) { /* Cross-origin */ }

            const urlParams = new URLSearchParams(window.location.search);
            const themeParam = urlParams.get('theme');
            if (themeParam) return themeParam;

            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) {
                return 'light';
            }
            return 'dark';
        }

        let currentTheme = detectTheme();

        function setupThemeListener() {
            try {
                if (window.parent && window.parent.document) {
                    const observer = new MutationObserver((mutations) => {
                        mutations.forEach((mutation) => {
                            if (mutation.attributeName === 'data-theme') {
                                const newTheme = window.parent.document.documentElement.getAttribute('data-theme');
                                if (newTheme && newTheme !== currentTheme) {
                                    currentTheme = newTheme;
                                    applyTheme();
                                }
                            }
                        });
                    });
                    observer.observe(window.parent.document.documentElement, { attributes: true });
                }
            } catch (e) {
                window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', (e) => {
                    currentTheme = e.matches ? 'light' : 'dark';
                    applyTheme();
                });
            }
        }

        // ===== THEME COLOR PALETTES =====
        const THEME_COLORS = {
            dark: {
                mainBg: 0x1a1a2e,
                dotColor: 0xffffff,
                dotAlpha: 0.1,
                btnGlow: 0x6366f1,
                btnGlowAlpha: 0.3,
                btnBorder: 0x4F51C5,
                btnBg: 0x6366f1,
                panelBg: 0x2A3142,
                panelBorder: 0x3D4F5F,
                overlay: 0x000000,
                overlayAlpha: 0.6,
                title: 0xffffff,
                titleStroke: 0x1A1A2A,
                rowBg: 0x3d3d5c,
                rowBgAlpha: 0.5,
                labelText: 0xffffff,
                toggleOnBorder: 0x2E7D32,
                toggleOffBorder: 0x3d3d5c,
                toggleOnBg: 0x4CAF50,
                toggleOffBg: 0x4b5563,
                textWhite: 0xffffff,
                instructionText: 0x888888,
                confettiColors: [0x6366f1, 0x8B5CF6, 0xffffff]
            },
            light: {
                mainBg: 0xe8ecf4,
                dotColor: 0x5a6a8a,
                dotAlpha: 0.15,
                btnGlow: 0x7376f5,
                btnGlowAlpha: 0.35,
                btnBorder: 0x5F61D5,
                btnBg: 0x7376f5,
                panelBg: 0xf0f4fa,
                panelBorder: 0x8a9abc,
                overlay: 0x1a2a4a,
                overlayAlpha: 0.5,
                title: 0x2a3a5a,
                titleStroke: 0xf0f4fa,
                rowBg: 0xd8dce8,
                rowBgAlpha: 0.7,
                labelText: 0x2a3a5a,
                toggleOnBorder: 0x3E8D42,
                toggleOffBorder: 0xb8c0d0,
                toggleOnBg: 0x5CBF60,
                toggleOffBg: 0x9ba5b8,
                textWhite: 0xffffff,
                instructionText: 0x6a7a9a,
                confettiColors: [0x7376f5, 0x9B6CF8, 0xffffff]
            }
        };

        function getColors() {
            return THEME_COLORS[currentTheme] || THEME_COLORS.dark;
        }

        const canvas = document.createElement('canvas');
        canvas.width = CONFIG.width;
        canvas.height = CONFIG.height;
        document.body.appendChild(canvas);

        const game = createGame();
        let celebration = null;
        let renderer, stage;
        let modal = null;

        let isRecreating = false;
        async function applyTheme() {
            if (isRecreating) return;
            isRecreating = true;

            document.body.classList.toggle('light-theme', currentTheme === 'light');
            if (stage && window.createModalScreen) {
                await loadFrameworkFont();
                window.createModalScreen();
            }
            setTimeout(() => { isRecreating = false; }, 100);
        }

        // ===== CREATE TOGGLE COMPONENT =====
        function createToggle(label, icon, initialValue, y, colors, celebration, modalContainer) {
            const factory = graphics();
            const toggleContainer = factory.createContainer();

            // Row background
            const rowBg = factory.createGraphics();
            rowBg.roundRect(0, 0, 260, 50, 10);
            rowBg.fill({ color: colors.rowBg, alpha: colors.rowBgAlpha });
            toggleContainer.addChild(rowBg);

            // Icon
            const iconText = factory.createText(icon, { fontSize: 20 });
            iconText.x = 20;
            iconText.y = 16;
            toggleContainer.addChild(iconText);

            // Label
            const labelText = factory.createText(label, {
                fontSize: 18,
                fill: colors.labelText
            });
            labelText.x = 50;
            labelText.y = 18;
            toggleContainer.addChild(labelText);

            // Toggle state
            let isOn = initialValue;

            // Toggle background border
            const toggleBorder = factory.createGraphics();
            toggleBorder.roundRect(198, 11, 64, 34, 17);
            toggleBorder.fill(isOn ? colors.toggleOnBorder : colors.toggleOffBorder);
            toggleContainer.addChild(toggleBorder);

            // Toggle background
            const toggleBg = factory.createGraphics();
            toggleBg.roundRect(200, 13, 60, 30, 15);
            toggleBg.fill(isOn ? colors.toggleOnBg : colors.toggleOffBg);
            toggleBg.eventMode = 'static';
            toggleBg.cursor = 'pointer';
            toggleContainer.addChild(toggleBg);

            // Knob shadow
            const knobShadow = factory.createGraphics();
            knobShadow.circle(isOn ? 246 : 216, 29, 11);
            knobShadow.fill({ color: 0x000000, alpha: 0.2 });
            toggleContainer.addChild(knobShadow);

            // Knob
            const knob = factory.createGraphics();
            knob.circle(isOn ? 245 : 215, 28, 11);
            knob.fill(0xffffff);
            toggleContainer.addChild(knob);

            // Toggle interaction
            toggleBg.on('pointerdown', () => {
                isOn = !isOn;

                // Update graphics
                toggleBorder.clear();
                toggleBorder.roundRect(198, 11, 64, 34, 17);
                toggleBorder.fill(isOn ? colors.toggleOnBorder : colors.toggleOffBorder);

                toggleBg.clear();
                toggleBg.roundRect(200, 13, 60, 30, 15);
                toggleBg.fill(isOn ? colors.toggleOnBg : colors.toggleOffBg);

                knobShadow.clear();
                knobShadow.circle(isOn ? 246 : 216, 29, 11);
                knobShadow.fill({ color: 0x000000, alpha: 0.2 });

                knob.clear();
                knob.circle(isOn ? 245 : 215, 28, 11);
                knob.fill(0xffffff);

                // Celebration effect when toggled on
                if (isOn) {
                    const sparkleX = modalContainer.x + toggleContainer.x + 230;
                    const sparkleY = modalContainer.y + toggleContainer.y + 28;
                    celebration.rewardReceived(sparkleX, sparkleY);
                }
            });

            toggleContainer.y = y;
            return toggleContainer;
        }

        (async () => {
            await loadFrameworkFont();
            await game.initialize(canvas, '2d');
            renderer = game.make('renderer');
            stage = renderer.getStage();

            celebration = new CelebrationManager(stage, CONFIG.width, CONFIG.height);
            setupThemeListener();

            function createModalScreen() {
                const colors = getColors();
                const gfx = graphics();

                // Clear stage
                while (stage.children.length > 0) {
                    stage.removeChildAt(0);
                }
                celebration.clear();

                // Destroy old modal if exists
                if (modal) {
                    modal.destroy();
                    modal = null;
                }

                // Background
                const bg = gfx.createGraphics();
                bg.rect(0, 0, CONFIG.width, CONFIG.height);
                bg.fill(colors.mainBg);
                stage.addChild(bg);

                // Background dots pattern
                for (let x = 0; x < CONFIG.width; x += 30) {
                    for (let y = 0; y < CONFIG.height; y += 30) {
                        const dot = gfx.createGraphics();
                        dot.circle(x, y, 2);
                        dot.fill({ color: colors.dotColor, alpha: colors.dotAlpha });
                        stage.addChild(dot);
                    }
                }

                // Show Modal button with glow
                const btnGlow = gfx.createGraphics();
                btnGlow.roundRect(CONFIG.width / 2 - 85, CONFIG.height / 2 - 35, 170, 70, 16);
                btnGlow.fill({ color: colors.btnGlow, alpha: colors.btnGlowAlpha });
                stage.addChild(btnGlow);

                const showBtnBorder = gfx.createGraphics();
                showBtnBorder.roundRect(CONFIG.width / 2 - 83, CONFIG.height / 2 - 33, 166, 66, 14);
                showBtnBorder.fill(colors.btnBorder);
                stage.addChild(showBtnBorder);

                const showBtn = gfx.createGraphics();
                showBtn.roundRect(CONFIG.width / 2 - 80, CONFIG.height / 2 - 30, 160, 60, 12);
                showBtn.fill(colors.btnBg);
                showBtn.eventMode = 'static';
                showBtn.cursor = 'pointer';
                stage.addChild(showBtn);

                const showText = gfx.createText('Show Modal', {
                    fontSize: 20,
                    fontWeight: 'bold',
                    fill: colors.textWhite
                });
                showText.anchor.set(0.5);
                showText.x = CONFIG.width / 2;
                showText.y = CONFIG.height / 2;
                stage.addChild(showText);

                // Create GameModalPanel with configuration
                modal = new GameModalPanel({
                    width: 300,
                    height: 340,
                    title: 'âš™ï¸ Settings',
                    showCloseButton: true,
                    closeOnOverlay: true,
                    theme: {
                        background: colors.panelBg,
                        border: colors.panelBorder,
                        overlay: colors.overlay,
                        overlayAlpha: colors.overlayAlpha,
                        title: colors.title,
                        titleStroke: colors.titleStroke
                    },
                    onClose: () => {
                        console.log('Modal closed');
                    }
                });

                // Initialize modal with screen dimensions
                modal.initialize(CONFIG.width, CONFIG.height);

                // Add modal container to stage
                stage.addChild(modal.getContainer());

                // Get modal panel container for celebration positioning
                const modalPanelContainer = modal.getContainer().children[1];

                // Create and add custom content (toggles)
                const toggle1 = createToggle('Music', 'ðŸŽµ', true, 0, colors, celebration, modalPanelContainer);
                modal.addContent(toggle1);

                const toggle2 = createToggle('Sound Effects', 'ðŸ”Š', true, 70, colors, celebration, modalPanelContainer);
                modal.addContent(toggle2);

                const toggle3 = createToggle('Vibration', 'ðŸ“³', false, 140, colors, celebration, modalPanelContainer);
                modal.addContent(toggle3);

                // Show modal button interaction
                showBtn.on('pointerdown', async () => {
                    await modal.show();
                    // Confetti when modal appears
                    celebration.confettiBurst(CONFIG.width / 2, CONFIG.height / 2, {
                        particleCount: 20,
                        spread: 360,
                        colors: colors.confettiColors
                    });
                });

                // Instructions
                const instr = gfx.createText('Click to show GameModalPanel with framework API', {
                    fontSize: 12,
                    fill: colors.instructionText
                });
                instr.anchor.set(0.5);
                instr.x = CONFIG.width / 2;
                instr.y = CONFIG.height - 30;
                stage.addChild(instr);
            }

            window.createModalScreen = createModalScreen;

            game.on('update', (deltaTime) => {
                celebration.update(deltaTime);
            });

            document.body.classList.toggle('light-theme', currentTheme === 'light');
            createModalScreen();
            game.start();
        })();
    </script>
</body>
</html>
