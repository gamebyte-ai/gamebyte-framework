<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Native Gradient Test - Pixi.js v8</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: auto;
            background: #1a1a2e;
            font-family: system-ui, sans-serif;
            color: #fff;
            padding: 20px;
        }
        h1 { text-align: center; margin-bottom: 20px; color: #818cf8; }
        h2 { margin: 20px 0 10px; color: #a5b4fc; font-size: 18px; }
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        .test-item {
            background: #2d3748;
            border-radius: 12px;
            padding: 15px;
        }
        .test-item h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #ffd700;
        }
        .test-item p {
            font-size: 12px;
            color: #a0aec0;
            margin-bottom: 10px;
        }
        canvas {
            display: block;
            background: #1a202c;
            border-radius: 8px;
        }
        .code-hint {
            font-family: monospace;
            font-size: 11px;
            background: #1a202c;
            padding: 8px;
            border-radius: 4px;
            margin-top: 10px;
            color: #68d391;
            white-space: pre-wrap;
            overflow-x: auto;
        }
        .section { margin-bottom: 30px; }
        .best-tag {
            background: #22c55e;
            color: #000;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 8px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Pixi.js v8 Native FillGradient Test</h1>

    <!-- Section 1: Ray/Wedge Techniques -->
    <div class="section">
        <h2>Ray/Wedge Gradient Techniques</h2>
        <div class="test-grid">
            <div class="test-item">
                <h3>Single Graphics + Global Radial</h3>
                <p>All rays in one Graphics, global radial gradient</p>
                <canvas id="rays-global" width="280" height="200"></canvas>
                <div class="code-hint">textureSpace: 'global' + centered radial</div>
            </div>
            <div class="test-item">
                <h3>Mask + Radial Gradient Circle <span class="best-tag">BEST</span></h3>
                <p>Rays as mask over radial gradient circle - best for rotating</p>
                <canvas id="rays-mask" width="280" height="200"></canvas>
                <div class="code-hint">Radial circle masked by ray shapes</div>
            </div>
            <div class="test-item">
                <h3>Per-Ray Angled Linear</h3>
                <p>Each ray gets linear gradient along its angle</p>
                <canvas id="rays-linear" width="280" height="200"></canvas>
                <div class="code-hint">start/end calculated per ray angle</div>
            </div>
            <div class="test-item">
                <h3>Segmented (20 segments)</h3>
                <p>More segments = smoother fade</p>
                <canvas id="rays-segmented" width="280" height="200"></canvas>
                <div class="code-hint">Power curve easing for smooth fade</div>
            </div>
        </div>
    </div>

    <!-- Section 2: Basic Gradients -->
    <div class="section">
        <h2>Basic Gradients</h2>
        <div class="test-grid">
            <div class="test-item">
                <h3>Linear Vertical</h3>
                <p>Default vertical gradient (top to bottom)</p>
                <canvas id="linear-v" width="280" height="150"></canvas>
                <div class="code-hint">type: 'linear', end: {x:0, y:1}</div>
            </div>
            <div class="test-item">
                <h3>Radial Alpha Fade</h3>
                <p>Radial gradient fading to transparent</p>
                <canvas id="radial-alpha" width="280" height="150"></canvas>
                <div class="code-hint">rgba() colorStops for alpha</div>
            </div>
        </div>
    </div>

    <!-- Section 3: Glow + Rays Combined -->
    <div class="section">
        <h2>Glow + Rays Combined (Best Practice)</h2>
        <div class="test-grid">
            <div class="test-item">
                <h3>Radial Glow + Masked Rays <span class="best-tag">RECOMMENDED</span></h3>
                <p>Radial glow base with masked gradient rays on top</p>
                <canvas id="glow-rays" width="280" height="200"></canvas>
                <div class="code-hint">Radial for glow + mask for rays</div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.15.0/dist/pixi.min.js"></script>
    <script>
        async function runTests() {
            const { Application, Graphics, FillGradient, Container } = PIXI;

            async function createApp(canvasId) {
                const canvas = document.getElementById(canvasId);
                if (!canvas) {
                    console.error(`Canvas "${canvasId}" not found`);
                    return null;
                }
                const app = new Application();
                await app.init({
                    canvas,
                    width: canvas.width,
                    height: canvas.height,
                    backgroundColor: 0x1a202c,
                    antialias: true
                });
                return app;
            }

            // ===== RAY TECHNIQUES =====

            // 1. Single Graphics + Global Radial
            {
                const app = await createApp('rays-global');
                if (!app) return;

                const centerX = 140, centerY = 100;
                const rayCount = 12, innerRadius = 15, outerRadius = 85, rayWidth = 0.18;

                const radialGradient = new FillGradient({
                    type: 'radial',
                    center: { x: centerX, y: centerY },
                    innerRadius: 0,
                    outerCenter: { x: centerX, y: centerY },
                    outerRadius: outerRadius,
                    colorStops: [
                        { offset: 0, color: 'rgba(255, 215, 0, 0.9)' },
                        { offset: 0.3, color: 'rgba(255, 215, 0, 0.6)' },
                        { offset: 0.7, color: 'rgba(255, 215, 0, 0.2)' },
                        { offset: 1, color: 'rgba(255, 215, 0, 0)' }
                    ],
                    textureSpace: 'global'
                });

                const rays = new Graphics();
                for (let i = 0; i < rayCount; i++) {
                    const angle = (i / rayCount) * Math.PI * 2;
                    const sa = angle - rayWidth / 2, ea = angle + rayWidth / 2;
                    rays.moveTo(centerX + Math.cos(sa) * innerRadius, centerY + Math.sin(sa) * innerRadius);
                    rays.lineTo(centerX + Math.cos(sa) * outerRadius, centerY + Math.sin(sa) * outerRadius);
                    rays.lineTo(centerX + Math.cos(ea) * outerRadius, centerY + Math.sin(ea) * outerRadius);
                    rays.lineTo(centerX + Math.cos(ea) * innerRadius, centerY + Math.sin(ea) * innerRadius);
                    rays.closePath();
                }
                rays.fill(radialGradient);
                app.stage.addChild(rays);

                const dot = new Graphics();
                dot.circle(centerX, centerY, 8).fill(0xffffff);
                app.stage.addChild(dot);
            }

            // 2. Mask + Radial Gradient Circle
            {
                const app = await createApp('rays-mask');
                if (!app) return;

                const centerX = 140, centerY = 100;
                const rayCount = 12, outerRadius = 85, rayWidth = 0.18;

                const circleGradient = new FillGradient({
                    type: 'radial',
                    center: { x: 0.5, y: 0.5 },
                    innerRadius: 0,
                    outerCenter: { x: 0.5, y: 0.5 },
                    outerRadius: 0.5,
                    colorStops: [
                        { offset: 0, color: 'rgba(255, 215, 0, 1)' },
                        { offset: 0.2, color: 'rgba(255, 215, 0, 0.8)' },
                        { offset: 0.5, color: 'rgba(255, 215, 0, 0.4)' },
                        { offset: 1, color: 'rgba(255, 215, 0, 0)' }
                    ]
                });

                const gradientCircle = new Graphics();
                gradientCircle.circle(centerX, centerY, outerRadius).fill(circleGradient);

                const rayMask = new Graphics();
                for (let i = 0; i < rayCount; i++) {
                    const angle = (i / rayCount) * Math.PI * 2;
                    const sa = angle - rayWidth / 2, ea = angle + rayWidth / 2;
                    rayMask.moveTo(centerX, centerY);
                    rayMask.lineTo(centerX + Math.cos(sa) * (outerRadius + 10), centerY + Math.sin(sa) * (outerRadius + 10));
                    rayMask.lineTo(centerX + Math.cos(ea) * (outerRadius + 10), centerY + Math.sin(ea) * (outerRadius + 10));
                    rayMask.closePath();
                }
                rayMask.fill(0xffffff);

                gradientCircle.mask = rayMask;
                app.stage.addChild(rayMask);
                app.stage.addChild(gradientCircle);

                const dot = new Graphics();
                dot.circle(centerX, centerY, 10).fill(0xffffff);
                app.stage.addChild(dot);
            }

            // 3. Per-Ray Angled Linear
            {
                const app = await createApp('rays-linear');
                if (!app) return;

                const centerX = 140, centerY = 100;
                const rayCount = 12, innerRadius = 15, outerRadius = 85, rayWidth = 0.18;

                for (let i = 0; i < rayCount; i++) {
                    const angle = (i / rayCount) * Math.PI * 2;
                    const sa = angle - rayWidth / 2, ea = angle + rayWidth / 2;
                    const cosA = Math.cos(angle), sinA = Math.sin(angle);

                    const rayGradient = new FillGradient({
                        type: 'linear',
                        start: { x: 0.5 - cosA * 0.4, y: 0.5 - sinA * 0.4 },
                        end: { x: 0.5 + cosA * 0.5, y: 0.5 + sinA * 0.5 },
                        colorStops: [
                            { offset: 0, color: 'rgba(255, 215, 0, 0.8)' },
                            { offset: 0.4, color: 'rgba(255, 215, 0, 0.5)' },
                            { offset: 1, color: 'rgba(255, 215, 0, 0)' }
                        ]
                    });

                    const ray = new Graphics();
                    ray.moveTo(centerX + Math.cos(sa) * innerRadius, centerY + Math.sin(sa) * innerRadius);
                    ray.lineTo(centerX + Math.cos(sa) * outerRadius, centerY + Math.sin(sa) * outerRadius);
                    ray.lineTo(centerX + Math.cos(ea) * outerRadius, centerY + Math.sin(ea) * outerRadius);
                    ray.lineTo(centerX + Math.cos(ea) * innerRadius, centerY + Math.sin(ea) * innerRadius);
                    ray.closePath();
                    ray.fill(rayGradient);
                    app.stage.addChild(ray);
                }

                const dot = new Graphics();
                dot.circle(centerX, centerY, 8).fill(0xffffff);
                app.stage.addChild(dot);
            }

            // 4. Segmented
            {
                const app = await createApp('rays-segmented');
                if (!app) return;

                const centerX = 140, centerY = 100;
                const rayCount = 12, innerRadius = 15, outerRadius = 85, rayWidth = 0.18;
                const segments = 20, baseAlpha = 0.7;

                for (let i = 0; i < rayCount; i++) {
                    const angle = (i / rayCount) * Math.PI * 2;
                    const sa = angle - rayWidth / 2, ea = angle + rayWidth / 2;
                    const ray = new Graphics();

                    for (let s = 0; s < segments; s++) {
                        const innerR = innerRadius + (outerRadius - innerRadius) * (s / segments);
                        const outerR = innerRadius + (outerRadius - innerRadius) * ((s + 1) / segments);
                        const progress = s / segments;
                        const segAlpha = baseAlpha * (1 - Math.pow(progress, 0.7));

                        ray.moveTo(centerX + Math.cos(sa) * innerR, centerY + Math.sin(sa) * innerR);
                        ray.lineTo(centerX + Math.cos(sa) * outerR, centerY + Math.sin(sa) * outerR);
                        ray.lineTo(centerX + Math.cos(ea) * outerR, centerY + Math.sin(ea) * outerR);
                        ray.lineTo(centerX + Math.cos(ea) * innerR, centerY + Math.sin(ea) * innerR);
                        ray.closePath();
                        ray.fill({ color: 0xffd700, alpha: segAlpha });
                    }
                    app.stage.addChild(ray);
                }

                const dot = new Graphics();
                dot.circle(centerX, centerY, 8).fill(0xffffff);
                app.stage.addChild(dot);
            }

            // ===== BASIC GRADIENTS =====

            // Linear Vertical
            {
                const app = await createApp('linear-v');
                if (!app) return;

                const g = new Graphics();
                const gradient = new FillGradient({
                    type: 'linear',
                    start: { x: 0, y: 0 },
                    end: { x: 0, y: 1 },
                    colorStops: [
                        { offset: 0, color: '#ffd700' },
                        { offset: 1, color: '#4f46e5' }
                    ]
                });
                g.roundRect(20, 20, 240, 110, 10).fill(gradient);
                app.stage.addChild(g);
            }

            // Radial Alpha Fade
            {
                const app = await createApp('radial-alpha');
                if (!app) return;

                const bg = new Graphics();
                bg.rect(0, 0, 280, 150).fill(0x4f46e5);
                app.stage.addChild(bg);

                const g = new Graphics();
                const gradient = new FillGradient({
                    type: 'radial',
                    center: { x: 0.5, y: 0.5 },
                    innerRadius: 0,
                    outerCenter: { x: 0.5, y: 0.5 },
                    outerRadius: 0.5,
                    colorStops: [
                        { offset: 0, color: 'rgba(255, 215, 0, 1)' },
                        { offset: 0.5, color: 'rgba(255, 215, 0, 0.5)' },
                        { offset: 1, color: 'rgba(255, 215, 0, 0)' }
                    ]
                });
                g.circle(140, 75, 60).fill(gradient);
                app.stage.addChild(g);
            }

            // ===== GLOW + RAYS COMBINED =====

            {
                const app = await createApp('glow-rays');
                if (!app) return;

                const centerX = 140, centerY = 100;

                // Radial glow base
                const glowGradient = new FillGradient({
                    type: 'radial',
                    center: { x: 0.5, y: 0.5 },
                    innerRadius: 0,
                    outerCenter: { x: 0.5, y: 0.5 },
                    outerRadius: 0.5,
                    colorStops: [
                        { offset: 0, color: 'rgba(255, 215, 0, 0.6)' },
                        { offset: 0.4, color: 'rgba(255, 215, 0, 0.3)' },
                        { offset: 1, color: 'rgba(255, 215, 0, 0)' }
                    ]
                });
                const glow = new Graphics();
                glow.circle(centerX, centerY, 65).fill(glowGradient);
                app.stage.addChild(glow);

                // Rays with mask
                const rayCount = 10, outerRadius = 75, rayWidth = 0.12;

                const rayCircleGradient = new FillGradient({
                    type: 'radial',
                    center: { x: 0.5, y: 0.5 },
                    innerRadius: 0,
                    outerCenter: { x: 0.5, y: 0.5 },
                    outerRadius: 0.5,
                    colorStops: [
                        { offset: 0, color: 'rgba(255, 255, 255, 0.8)' },
                        { offset: 0.3, color: 'rgba(255, 215, 0, 0.6)' },
                        { offset: 0.6, color: 'rgba(255, 215, 0, 0.2)' },
                        { offset: 1, color: 'rgba(255, 215, 0, 0)' }
                    ]
                });

                const rayCircle = new Graphics();
                rayCircle.circle(centerX, centerY, outerRadius).fill(rayCircleGradient);

                const rayMask = new Graphics();
                for (let i = 0; i < rayCount; i++) {
                    const angle = (i / rayCount) * Math.PI * 2;
                    const sa = angle - rayWidth / 2, ea = angle + rayWidth / 2;
                    rayMask.moveTo(centerX, centerY);
                    rayMask.lineTo(centerX + Math.cos(sa) * (outerRadius + 10), centerY + Math.sin(sa) * (outerRadius + 10));
                    rayMask.lineTo(centerX + Math.cos(ea) * (outerRadius + 10), centerY + Math.sin(ea) * (outerRadius + 10));
                    rayMask.closePath();
                }
                rayMask.fill(0xffffff);

                rayCircle.mask = rayMask;
                app.stage.addChild(rayMask);
                app.stage.addChild(rayCircle);

                const center = new Graphics();
                center.circle(centerX, centerY, 12).fill(0xffffff);
                app.stage.addChild(center);
            }

            console.log('All gradient tests initialized!');
        }

        runTests().catch(console.error);
    </script>
</body>
</html>
