<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SimpleScreen Demo - GameByte Framework</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #1a1a2e; transition: background 0.3s ease; }
        body.light-theme { background: #e8eef5; }
        canvas { display: block; margin: 0 auto; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8/dist/pixi.min.js"></script>
    <script src="/gamebyte.umd.js"></script>

    <script>
        // =====================================================
        // SimpleScreen Demo - Framework Screen Management
        // =====================================================
        // This demo showcases the framework's SimpleScreen class:
        // - Custom screens extending SimpleScreen
        // - Screen lifecycle: setup, show, hide, destroy
        // - Push/pop stack navigation pattern
        // - Slide and fade transitions using AnimationPresets
        // - Framework's animate() utility and Easing functions
        // =====================================================

        const {
            createGame,
            GameStyleButton,
            GameStyleColors,
            graphics,
            loadFrameworkFont,
            SimpleScreen,
            AnimationPresets,
            Easing,
            animate,
            lerp
        } = GameByteFramework;

        const CONFIG = { width: 360, height: 640 };

        // ===== THEME DETECTION =====
        function detectTheme() {
            try {
                if (window.parent && window.parent.document) {
                    const parentTheme = window.parent.document.documentElement.getAttribute('data-theme');
                    if (parentTheme) return parentTheme;
                }
            } catch (e) { /* Cross-origin */ }

            const urlParams = new URLSearchParams(window.location.search);
            const themeParam = urlParams.get('theme');
            if (themeParam) return themeParam;

            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) {
                return 'light';
            }
            return 'dark';
        }

        let currentTheme = detectTheme();

        function setupThemeListener() {
            try {
                if (window.parent && window.parent.document) {
                    const observer = new MutationObserver((mutations) => {
                        mutations.forEach((mutation) => {
                            if (mutation.attributeName === 'data-theme') {
                                const newTheme = window.parent.document.documentElement.getAttribute('data-theme');
                                if (newTheme && newTheme !== currentTheme) {
                                    currentTheme = newTheme;
                                    applyTheme();
                                }
                            }
                        });
                    });
                    observer.observe(window.parent.document.documentElement, { attributes: true });
                }
            } catch (e) {
                window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', (e) => {
                    currentTheme = e.matches ? 'light' : 'dark';
                    applyTheme();
                });
            }
        }

        // ===== THEME COLOR PALETTES =====
        const THEME_COLORS = {
            dark: {
                background: 0x1a1a2e,
                textPrimary: 0xffffff,
                textSecondary: 0xcccccc,
                screenColors: [0x2196F3, 0x9C27B0, 0xFF9800, 0xE91E63, 0x00BCD4],
                homeScreen: 0x1a1a2e
            },
            light: {
                background: 0xe8eef5,
                textPrimary: 0x2d3748,
                textSecondary: 0x4a5568,
                screenColors: [0x63b3ed, 0xb794f4, 0xf6ad55, 0xf687b3, 0x4fd1c5],
                homeScreen: 0xe8eef5
            }
        };

        function getColors() {
            return THEME_COLORS[currentTheme] || THEME_COLORS.dark;
        }

        const canvas = document.createElement('canvas');
        canvas.width = CONFIG.width;
        canvas.height = CONFIG.height;
        document.body.appendChild(canvas);

        const game = createGame();
        let renderer, stage, screenStack;

        // ===== SCREEN STACK MANAGER =====
        // Simple stack-based screen management using SimpleScreen
        class ScreenStack {
            constructor(stage) {
                this.stage = stage;
                this.screens = [];
                this.gfx = graphics();
                this.container = this.gfx.createContainer();
                stage.addChild(this.container);
            }

            async push(screen, transition = 'slide') {
                const current = this.screens[this.screens.length - 1];

                // Initialize new screen
                screen.initialize(CONFIG.width, CONFIG.height);
                this.screens.push(screen);
                this.container.addChild(screen.getContainer());

                // Hide current screen (no animation needed)
                if (current) {
                    current.getContainer().visible = false;
                }

                // Show new screen with custom transition
                if (transition === 'slide') {
                    await this.slideInScreen(screen);
                } else if (transition === 'fade') {
                    await screen.show();
                }
            }

            async pop(transition = 'slide') {
                if (this.screens.length <= 1) return;

                const current = this.screens.pop();
                const previous = this.screens[this.screens.length - 1];

                // Show previous screen first
                if (previous) {
                    previous.getContainer().visible = true;
                }

                // Animate out current screen
                if (transition === 'slide') {
                    await this.slideOutScreen(current);
                } else if (transition === 'fade') {
                    await current.hide();
                }

                // Cleanup
                this.container.removeChild(current.getContainer());
                current.destroy();
            }

            async slideInScreen(screen) {
                const container = screen.getContainer();
                container.visible = true;
                await AnimationPresets.slideX(container, CONFIG.width, 0, 300);
            }

            async slideOutScreen(screen) {
                const container = screen.getContainer();
                await AnimationPresets.slideX(container, 0, CONFIG.width, 300);
            }

            get stackSize() {
                return this.screens.length;
            }

            getCurrentScreen() {
                return this.screens[this.screens.length - 1];
            }
        }

        // ===== DEMO SCREEN CLASS =====
        // Custom screen extending SimpleScreen
        class DemoScreen extends SimpleScreen {
            constructor(title, color, depth, onPush, onPop) {
                super(`screen-${depth}`);
                this.title = title;
                this.color = color;
                this.depth = depth;
                this.onPushCallback = onPush;
                this.onPopCallback = onPop;
            }

            setup() {
                const gfx = graphics();
                const colors = getColors();

                // Background
                const bg = gfx.createGraphics();
                bg.rect(0, 0, this._width, this._height);
                bg.fill(this.color);
                this.container.addChild(bg);

                // Screen title
                const titleText = gfx.createText(this.title, {
                    fontSize: 28,
                    fontWeight: 'bold',
                    fill: 0xffffff
                });
                titleText.x = this._width / 2 - titleText.width / 2;
                titleText.y = 50;
                this.container.addChild(titleText);

                // Depth indicator
                const depthText = gfx.createText(`Stack Depth: ${this.depth}`, {
                    fontSize: 16,
                    fill: 0xffffff
                });
                depthText.x = this._width / 2 - depthText.width / 2;
                depthText.y = 95;
                depthText.alpha = 0.8;
                this.container.addChild(depthText);

                // Decorative circles
                for (let i = 0; i < 3; i++) {
                    const circle = gfx.createGraphics();
                    circle.circle(0, 0, 40 + i * 30);
                    circle.stroke({ width: 2, color: 0xffffff, alpha: 0.2 });
                    circle.x = this._width / 2;
                    circle.y = this._height / 2 - 50;
                    this.container.addChild(circle);
                }

                // Push button (slide transition)
                const pushSlideBtn = new GameStyleButton({
                    text: 'Push (Slide)',
                    width: 140,
                    height: 50,
                    fontSize: 14,
                    colorScheme: GameStyleColors.GREEN_BUTTON
                });
                pushSlideBtn.setPosition(30, this._height - 200);
                pushSlideBtn.on('click', () => this.onPushCallback('slide'));
                this.container.addChild(pushSlideBtn.getContainer());

                // Push button (fade transition)
                const pushFadeBtn = new GameStyleButton({
                    text: 'Push (Fade)',
                    width: 140,
                    height: 50,
                    fontSize: 14,
                    colorScheme: GameStyleColors.BLUE_BUTTON
                });
                pushFadeBtn.setPosition(190, this._height - 200);
                pushFadeBtn.on('click', () => this.onPushCallback('fade'));
                this.container.addChild(pushFadeBtn.getContainer());

                // Pop button (only show if not home screen)
                if (this.depth > 1) {
                    const popBtn = new GameStyleButton({
                        text: 'Pop Screen',
                        width: 300,
                        height: 55,
                        fontSize: 18,
                        colorScheme: GameStyleColors.RED_BUTTON
                    });
                    popBtn.setPosition(30, this._height - 130);
                    popBtn.on('click', () => this.onPopCallback());
                    this.container.addChild(popBtn.getContainer());
                }

                // Info text
                const infoText = gfx.createText('Tap buttons to navigate screens', {
                    fontSize: 12,
                    fill: 0xffffff
                });
                infoText.x = this._width / 2 - infoText.width / 2;
                infoText.y = this._height - 50;
                infoText.alpha = 0.6;
                this.container.addChild(infoText);
            }

            // Override default fade transition with custom slide for this demo
            async animateIn() {
                // Custom slide animation using framework utilities
                return AnimationPresets.fadeIn(this.container, 300);
            }

            async animateOut() {
                return AnimationPresets.fadeOut(this.container, 200);
            }
        }

        // ===== SCREEN FACTORY =====
        function createDemoScreen(screenStack, transition) {
            const colors = getColors();
            const depth = screenStack.stackSize + 1;
            const colorIndex = (depth - 1) % colors.screenColors.length;
            const screenColor = depth === 1 ? colors.homeScreen : colors.screenColors[colorIndex];
            const screenTitle = depth === 1 ? 'Home Screen' : `Screen ${depth}`;

            const screen = new DemoScreen(
                screenTitle,
                screenColor,
                depth,
                (trans) => createDemoScreen(screenStack, trans),
                () => screenStack.pop(transition)
            );

            screenStack.push(screen, transition);
        }

        let isRecreating = false;
        async function applyTheme() {
            if (isRecreating) return;
            isRecreating = true;

            document.body.classList.toggle('light-theme', currentTheme === 'light');
            if (stage && window.createDemo) {
                await loadFrameworkFont();
                window.createDemo();
            }
            setTimeout(() => { isRecreating = false; }, 100);
        }

        (async () => {
            await loadFrameworkFont();
            await game.initialize(canvas, '2d');
            renderer = game.make('renderer');
            stage = renderer.getStage();

            setupThemeListener();

            function createDemo() {
                // Clear stage
                while (stage.children.length > 0) {
                    stage.removeChildAt(0);
                }

                // Create screen stack manager
                screenStack = new ScreenStack(stage);

                // Push initial home screen with fade transition
                createDemoScreen(screenStack, 'fade');
            }

            window.createDemo = createDemo;

            document.body.classList.toggle('light-theme', currentTheme === 'light');
            createDemo();
            game.start();
        })();
    </script>
</body>
</html>
