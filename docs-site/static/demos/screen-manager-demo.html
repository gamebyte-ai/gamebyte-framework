<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ScreenManager Demo - GameByte Framework</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #1a1a2e; transition: background 0.3s ease; }
        body.light-theme { background: #e8eef5; }
        canvas { display: block; margin: 0 auto; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8/dist/pixi.min.js"></script>
    <script src="/gamebyte.umd.js"></script>

    <script>
        // =====================================================
        // ScreenManager Demo - Using Framework Abstractions
        // =====================================================
        // This demo showcases:
        // - Screen navigation with push/pop stack
        // - Slide and fade transitions
        // - graphics() abstraction instead of direct PIXI usage
        // =====================================================

        const {
            createGame,
            GameStyleButton,
            GameStyleColors,
            graphics,
            loadFrameworkFont
        } = GameByteFramework;

        const CONFIG = { width: 360, height: 640 };

        // ===== THEME DETECTION =====
        function detectTheme() {
            try {
                if (window.parent && window.parent.document) {
                    const parentTheme = window.parent.document.documentElement.getAttribute('data-theme');
                    if (parentTheme) return parentTheme;
                }
            } catch (e) { /* Cross-origin */ }

            const urlParams = new URLSearchParams(window.location.search);
            const themeParam = urlParams.get('theme');
            if (themeParam) return themeParam;

            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) {
                return 'light';
            }
            return 'dark';
        }

        let currentTheme = detectTheme();

        function setupThemeListener() {
            try {
                if (window.parent && window.parent.document) {
                    const observer = new MutationObserver((mutations) => {
                        mutations.forEach((mutation) => {
                            if (mutation.attributeName === 'data-theme') {
                                const newTheme = window.parent.document.documentElement.getAttribute('data-theme');
                                if (newTheme && newTheme !== currentTheme) {
                                    currentTheme = newTheme;
                                    applyTheme();
                                }
                            }
                        });
                    });
                    observer.observe(window.parent.document.documentElement, { attributes: true });
                }
            } catch (e) {
                window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', (e) => {
                    currentTheme = e.matches ? 'light' : 'dark';
                    applyTheme();
                });
            }
        }

        // ===== THEME COLOR PALETTES =====
        const THEME_COLORS = {
            dark: {
                background: 0x1a1a2e,
                textPrimary: 0xffffff,
                textSecondary: 0xcccccc,
                screenColors: [0x2196F3, 0x9C27B0, 0xFF9800, 0xE91E63, 0x00BCD4],
                homeScreen: 0x1a1a2e
            },
            light: {
                background: 0xe8eef5,
                textPrimary: 0x2d3748,
                textSecondary: 0x4a5568,
                screenColors: [0x63b3ed, 0xb794f4, 0xf6ad55, 0xf687b3, 0x4fd1c5],
                homeScreen: 0xe8eef5
            }
        };

        function getColors() {
            return THEME_COLORS[currentTheme] || THEME_COLORS.dark;
        }

        const canvas = document.createElement('canvas');
        canvas.width = CONFIG.width;
        canvas.height = CONFIG.height;
        document.body.appendChild(canvas);

        const game = createGame();
        let renderer, stage, screenManager;

        // ===== DEMO SCREEN MANAGER =====
        class DemoScreenManager {
            constructor(stage, gfx) {
                this.stage = stage;
                this.gfx = gfx;
                this.screens = [];
                this.container = gfx.createContainer();
                stage.addChild(this.container);
            }

            async push(screen, transition = 'slide') {
                const current = this.screens[this.screens.length - 1];
                this.screens.push(screen);
                this.container.addChild(screen.container);

                if (transition === 'slide') {
                    screen.container.x = CONFIG.width;
                    await this.animate(screen.container, { x: 0 }, 300);
                    if (current) {
                        current.container.visible = false;
                    }
                } else {
                    screen.container.alpha = 0;
                    await this.animate(screen.container, { alpha: 1 }, 200);
                    if (current) {
                        current.container.visible = false;
                    }
                }
            }

            async pop(transition = 'slide') {
                if (this.screens.length <= 1) return;
                const current = this.screens.pop();
                const previous = this.screens[this.screens.length - 1];

                if (previous) {
                    previous.container.visible = true;
                }

                if (transition === 'slide') {
                    await this.animate(current.container, { x: CONFIG.width }, 300);
                } else {
                    await this.animate(current.container, { alpha: 0 }, 200);
                }

                this.container.removeChild(current.container);
                if (current.destroy) current.destroy();
            }

            animate(target, props, duration) {
                return new Promise((resolve) => {
                    const startProps = {};
                    for (const key in props) {
                        startProps[key] = target[key];
                    }
                    const startTime = performance.now();

                    const tick = () => {
                        const elapsed = performance.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        const eased = 1 - Math.pow(1 - progress, 3); // easeOutCubic

                        for (const key in props) {
                            target[key] = startProps[key] + (props[key] - startProps[key]) * eased;
                        }

                        if (progress < 1) {
                            requestAnimationFrame(tick);
                        } else {
                            resolve();
                        }
                    };
                    requestAnimationFrame(tick);
                });
            }

            get stackSize() {
                return this.screens.length;
            }
        }

        // ===== SCREEN FACTORY =====
        function createScreen(gfx, title, color, depth, onPush, onPop) {
            const colors = getColors();
            const container = gfx.createContainer();

            // Background
            const bg = gfx.createGraphics();
            bg.rect(0, 0, CONFIG.width, CONFIG.height);
            bg.fill(color);
            container.addChild(bg);

            // Screen title
            const titleText = gfx.createText(title, {
                fontSize: 28,
                fontWeight: 'bold',
                fill: 0xffffff
            });
            titleText.x = CONFIG.width / 2 - titleText.width / 2;
            titleText.y = 50;
            container.addChild(titleText);

            // Depth indicator
            const depthText = gfx.createText(`Stack Depth: ${depth}`, {
                fontSize: 16,
                fill: 0xffffff
            });
            depthText.x = CONFIG.width / 2 - depthText.width / 2;
            depthText.y = 95;
            depthText.alpha = 0.8;
            container.addChild(depthText);

            // Decorative circles
            for (let i = 0; i < 3; i++) {
                const circle = gfx.createGraphics();
                circle.circle(0, 0, 40 + i * 30);
                circle.stroke({ width: 2, color: 0xffffff, alpha: 0.2 });
                circle.x = CONFIG.width / 2;
                circle.y = CONFIG.height / 2 - 50;
                container.addChild(circle);
            }

            // Push button (slide transition)
            const pushSlideBtn = new GameStyleButton({
                text: 'Push (Slide)',
                width: 140,
                height: 50,
                fontSize: 14,
                colorScheme: GameStyleColors.GREEN_BUTTON
            });
            pushSlideBtn.setPosition(30, CONFIG.height - 200);
            pushSlideBtn.on('click', () => onPush('slide'));
            container.addChild(pushSlideBtn.getContainer());

            // Push button (fade transition)
            const pushFadeBtn = new GameStyleButton({
                text: 'Push (Fade)',
                width: 140,
                height: 50,
                fontSize: 14,
                colorScheme: GameStyleColors.BLUE_BUTTON
            });
            pushFadeBtn.setPosition(190, CONFIG.height - 200);
            pushFadeBtn.on('click', () => onPush('fade'));
            container.addChild(pushFadeBtn.getContainer());

            // Pop button
            if (depth > 1) {
                const popBtn = new GameStyleButton({
                    text: 'Pop Screen',
                    width: 300,
                    height: 55,
                    fontSize: 18,
                    colorScheme: GameStyleColors.RED_BUTTON
                });
                popBtn.setPosition(30, CONFIG.height - 130);
                popBtn.on('click', onPop);
                container.addChild(popBtn.getContainer());
            }

            // Info text
            const infoText = gfx.createText('Tap buttons to navigate screens', {
                fontSize: 12,
                fill: 0xffffff
            });
            infoText.x = CONFIG.width / 2 - infoText.width / 2;
            infoText.y = CONFIG.height - 50;
            infoText.alpha = 0.6;
            container.addChild(infoText);

            return { container };
        }

        function pushNewScreen(gfx, screenManager, transition) {
            const colors = getColors();
            const depth = screenManager.stackSize + 1;
            const colorIndex = (depth - 1) % colors.screenColors.length;
            const screenColor = depth === 1 ? colors.homeScreen : colors.screenColors[colorIndex];
            const screenTitle = depth === 1 ? 'Home Screen' : `Screen ${depth}`;

            const screen = createScreen(
                gfx,
                screenTitle,
                screenColor,
                depth,
                (trans) => pushNewScreen(gfx, screenManager, trans),
                () => screenManager.pop(transition)
            );

            screenManager.push(screen, transition);
        }

        let isRecreating = false;
        async function applyTheme() {
            if (isRecreating) return;
            isRecreating = true;

            document.body.classList.toggle('light-theme', currentTheme === 'light');
            if (stage && window.createDemo) {
                await loadFrameworkFont();
                window.createDemo();
            }
            setTimeout(() => { isRecreating = false; }, 100);
        }

        (async () => {
            await loadFrameworkFont();
            await game.initialize(canvas, '2d');
            renderer = game.make('renderer');
            stage = renderer.getStage();

            setupThemeListener();

            function createDemo() {
                const gfx = graphics();

                // Clear stage
                while (stage.children.length > 0) {
                    stage.removeChildAt(0);
                }

                // Create screen manager
                screenManager = new DemoScreenManager(stage, gfx);

                // Push initial home screen
                pushNewScreen(gfx, screenManager, 'fade');
            }

            window.createDemo = createDemo;

            document.body.classList.toggle('light-theme', currentTheme === 'light');
            createDemo();
            game.start();
        })();
    </script>
</body>
</html>
