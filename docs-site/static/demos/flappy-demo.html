<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GameByte - Flappy Game Demo</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        h1 { color: #fff; margin-bottom: 10px; font-size: 24px; }
        p { color: #8892b0; margin-bottom: 20px; font-size: 14px; }
        #game-container {
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
        }
        canvas { display: block; }
        .info { color: #8892b0; margin-top: 20px; font-size: 12px; text-align: center; }
    </style>
</head>
<body>
    <h1>Flappy Bird</h1>
    <p>GameByte Framework Demo - Full Game Flow</p>
    <div id="game-container"></div>
    <div class="info">
        Features: SplashScreen, Main Menu, GameTopBar, ResultScreen
    </div>

    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8/dist/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="/gamebyte.umd.js"></script>

    <script>
        const {
            createGame,
            graphics,
            loadFrameworkFont,
            GraphicsEngine,
            RenderingMode,
            SplashScreen,
            GameStyleButton,
            GameStyleColors,
            GameTopBar,
            ResultScreen
        } = GameByteFramework;

        const CONFIG = { width: 400, height: 600 };
        const GRAVITY = 0.5;
        const FLAP_FORCE = -9;
        const PIPE_SPEED = 3;
        const PIPE_GAP = 150;
        const PIPE_SPAWN_INTERVAL = 90;

        let app, game;
        let bird, ground;
        let pipes = [];
        let clouds = [];
        let particles = [];
        let score = 0, highScore = 0;
        let frameCount = 0;
        let birdVelocity = 0;
        let birdRotation = 0;
        let wingAngle = 0;

        // UI components
        let splashScreen, mainMenuContainer, gameTopBar, resultScreen;
        let playButton, tapInstruction;

        // Game states: 'splash' -> 'menu' -> 'playing' -> 'gameover'
        let gameState = 'splash';

        async function init() {
            // Load framework font
            await loadFrameworkFont();
            GraphicsEngine.initialize(RenderingMode.RENDERER_2D);

            // Initialize Pixi app
            app = new PIXI.Application();
            await app.init({
                width: CONFIG.width,
                height: CONFIG.height,
                backgroundColor: 0x70C5CE,
                antialias: true
            });
            document.getElementById('game-container').appendChild(app.canvas);

            // Create game environment
            createBackground();
            createBird();
            createGround();

            // Initialize UI components
            createSplashScreen();
            createMainMenu();
            createGameTopBar();
            createResultScreen();

            // Setup input
            setupInput();

            // Start with splash screen
            showSplashScreen();

            app.ticker.add(gameLoop);
        }

        function createSplashScreen() {
            splashScreen = new SplashScreen({
                title: 'FLAPPY',
                subtitle: 'BIRD',
                backgroundColor: 0x70C5CE,
                textColor: 0xFFFFFF,
                duration: 2000
            });

            const container = splashScreen.getContainer();
            container.visible = false;
            app.stage.addChild(container);

            splashScreen.on('complete', () => {
                container.visible = false;
                showMainMenu();
            });
        }

        function createMainMenu() {
            mainMenuContainer = new PIXI.Container();
            mainMenuContainer.visible = false;

            // Title
            const titleText = new PIXI.Text({
                text: 'FLAPPY BIRD',
                style: {
                    fontSize: 48,
                    fill: 0xFFFFFF,
                    fontWeight: 'bold',
                    fontFamily: 'Lilita One, Arial',
                    stroke: { color: 0x000000, width: 5 }
                }
            });
            titleText.anchor.set(0.5);
            titleText.x = CONFIG.width / 2;
            titleText.y = 150;
            mainMenuContainer.addChild(titleText);

            // Play button
            playButton = new GameStyleButton({
                width: 200,
                height: 60,
                label: 'PLAY',
                variant: 'primary'
            });
            const playButtonContainer = playButton.getContainer();
            playButtonContainer.x = CONFIG.width / 2;
            playButtonContainer.y = CONFIG.height / 2;
            mainMenuContainer.addChild(playButtonContainer);

            playButton.on('click', () => {
                startGame();
            });

            // Tap instruction
            tapInstruction = new PIXI.Text({
                text: 'Tap anywhere to flap!',
                style: {
                    fontSize: 20,
                    fill: 0xFFFFFF,
                    fontFamily: 'Lilita One, Arial',
                    stroke: { color: 0x000000, width: 3 }
                }
            });
            tapInstruction.anchor.set(0.5);
            tapInstruction.x = CONFIG.width / 2;
            tapInstruction.y = CONFIG.height / 2 + 80;
            mainMenuContainer.addChild(tapInstruction);

            // High score
            if (highScore > 0) {
                const highScoreText = new PIXI.Text({
                    text: `Best: ${highScore}`,
                    style: {
                        fontSize: 18,
                        fill: 0xFFFFFF,
                        fontFamily: 'Arial'
                    }
                });
                highScoreText.anchor.set(0.5);
                highScoreText.x = CONFIG.width / 2;
                highScoreText.y = CONFIG.height / 2 + 120;
                mainMenuContainer.addChild(highScoreText);
            }

            app.stage.addChild(mainMenuContainer);
        }

        function createGameTopBar() {
            gameTopBar = new GameTopBar({
                width: CONFIG.width,
                showLives: false,
                showCoins: false
            });

            const container = gameTopBar.getContainer();
            container.visible = false;
            app.stage.addChild(container);

            // Update score display
            gameTopBar.setScore(0);
        }

        function createResultScreen() {
            resultScreen = new ResultScreen({
                type: 'defeat',
                title: 'GAME OVER'
            });

            resultScreen.initialize(CONFIG.width, CONFIG.height);
            const container = resultScreen.getContainer();
            container.visible = false;
            app.stage.addChild(container);

            resultScreen.on('replay', () => {
                restartGame();
            });

            resultScreen.on('home', () => {
                backToMenu();
            });
        }

        function showSplashScreen() {
            gameState = 'splash';
            const container = splashScreen.getContainer();
            container.visible = true;
            splashScreen.show();
        }

        function showMainMenu() {
            gameState = 'menu';
            mainMenuContainer.visible = true;
            gameTopBar.getContainer().visible = false;
            resultScreen.getContainer().visible = false;

            // Reset bird to idle position
            bird.x = 80;
            bird.y = CONFIG.height / 2;
            bird.rotation = 0;
            birdVelocity = 0;
            birdRotation = 0;
        }

        function startGame() {
            gameState = 'playing';
            mainMenuContainer.visible = false;
            gameTopBar.getContainer().visible = true;
            resultScreen.getContainer().visible = false;

            // Reset game state
            score = 0;
            frameCount = 0;
            birdVelocity = 0;
            birdRotation = 0;
            gameTopBar.setScore(0);

            // Clear pipes and particles
            pipes.forEach(pipe => app.stage.removeChild(pipe));
            pipes = [];
            particles.forEach(p => app.stage.removeChild(p));
            particles = [];

            // Reset bird
            bird.x = 80;
            bird.y = CONFIG.height / 2;
            bird.rotation = 0;
        }

        function endGame() {
            gameState = 'gameover';

            if (score > highScore) {
                highScore = score;
            }

            // Hide game UI
            gameTopBar.getContainer().visible = false;

            // Show result screen
            const variant = score > highScore / 2 ? 'victory' : 'defeat';
            resultScreen.setVariant(variant);
            resultScreen.setScore(score);
            resultScreen.setBestScore(highScore);

            const container = resultScreen.getContainer();
            container.visible = true;
            resultScreen.show();

            // Death animation
            birdVelocity = -5;
        }

        function restartGame() {
            resultScreen.getContainer().visible = false;
            startGame();
        }

        function backToMenu() {
            resultScreen.getContainer().visible = false;

            // Clear game elements
            pipes.forEach(pipe => app.stage.removeChild(pipe));
            pipes = [];
            particles.forEach(p => app.stage.removeChild(p));
            particles = [];

            showMainMenu();
        }

        function createBackground() {
            // Gradient sky
            const sky = new PIXI.Graphics();
            sky.rect(0, 0, CONFIG.width, CONFIG.height);
            sky.fill({ color: 0x70C5CE });
            app.stage.addChild(sky);

            // Sun
            const sun = new PIXI.Graphics();
            sun.circle(CONFIG.width - 60, 60, 40);
            sun.fill({ color: 0xFFD93D });
            sun.circle(CONFIG.width - 60, 60, 35);
            sun.fill({ color: 0xFFE873 });
            app.stage.addChild(sun);

            // Clouds
            for (let i = 0; i < 5; i++) {
                createCloud(Math.random() * CONFIG.width, 50 + Math.random() * 150);
            }
        }

        function createCloud(x, y) {
            const cloud = new PIXI.Container();

            const parts = [
                { x: 0, y: 0, r: 25 },
                { x: 20, y: -10, r: 30 },
                { x: 45, y: -5, r: 25 },
                { x: 60, y: 5, r: 20 }
            ];

            parts.forEach(part => {
                const circle = new PIXI.Graphics();
                circle.circle(part.x, part.y, part.r);
                circle.fill({ color: 0xFFFFFF, alpha: 0.8 });
                cloud.addChild(circle);
            });

            cloud.x = x;
            cloud.y = y;
            cloud.speed = 0.3 + Math.random() * 0.3;
            app.stage.addChild(cloud);
            clouds.push(cloud);
        }

        function createBird() {
            bird = new PIXI.Container();

            // Body
            const body = new PIXI.Graphics();
            body.ellipse(0, 0, 20, 15);
            body.fill({ color: 0xF9D71C });
            body.stroke({ color: 0xE6C419, width: 2 });
            bird.addChild(body);

            // Wing
            const wing = new PIXI.Graphics();
            wing.ellipse(-5, 5, 12, 8);
            wing.fill({ color: 0xE6C419 });
            wing.pivot.set(-5, 5);
            bird.wing = wing;
            bird.addChild(wing);

            // Eye
            const eye = new PIXI.Graphics();
            eye.circle(8, -5, 6);
            eye.fill({ color: 0xFFFFFF });
            eye.circle(9, -5, 3);
            eye.fill({ color: 0x000000 });
            bird.addChild(eye);

            // Beak
            const beak = new PIXI.Graphics();
            beak.poly([15, 0, 25, 3, 15, 6]);
            beak.fill({ color: 0xE67E22 });
            bird.addChild(beak);

            bird.x = 80;
            bird.y = CONFIG.height / 2;
            app.stage.addChild(bird);
        }

        function createGround() {
            ground = new PIXI.Container();

            // Dirt
            const dirt = new PIXI.Graphics();
            dirt.rect(0, 0, CONFIG.width + 50, 80);
            dirt.fill({ color: 0xDEB887 });
            ground.addChild(dirt);

            // Grass
            const grass = new PIXI.Graphics();
            grass.rect(0, 0, CONFIG.width + 50, 20);
            grass.fill({ color: 0x4CAF50 });
            ground.addChild(grass);

            // Grass details
            for (let i = 0; i < CONFIG.width + 50; i += 10) {
                const blade = new PIXI.Graphics();
                blade.poly([i, 20, i + 5, 0, i + 10, 20]);
                blade.fill({ color: 0x388E3C });
                ground.addChild(blade);
            }

            ground.y = CONFIG.height - 80;
            app.stage.addChild(ground);
        }

        function setupInput() {
            const flap = () => {
                if (gameState !== 'playing') return;

                birdVelocity = FLAP_FORCE;
                createFlapParticles();
            };

            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    e.preventDefault();
                    flap();
                }
            });

            app.canvas.addEventListener('pointerdown', (e) => {
                // Don't flap if clicking on UI elements
                if (gameState === 'playing') {
                    flap();
                }
            });
        }

        function createPipe() {
            const gapY = 150 + Math.random() * (CONFIG.height - 350);

            const pipeContainer = new PIXI.Container();
            pipeContainer.x = CONFIG.width + 30;
            pipeContainer.gapY = gapY;
            pipeContainer.scored = false;

            // Top pipe
            const topPipe = createPipeGraphics(gapY - PIPE_GAP / 2, true);
            pipeContainer.addChild(topPipe);

            // Bottom pipe
            const bottomPipe = createPipeGraphics(CONFIG.height - 80 - (gapY + PIPE_GAP / 2), false);
            bottomPipe.y = gapY + PIPE_GAP / 2;
            pipeContainer.addChild(bottomPipe);

            // Add behind bird but in front of background
            const birdIndex = app.stage.children.indexOf(bird);
            app.stage.addChildAt(pipeContainer, birdIndex);
            pipes.push(pipeContainer);
        }

        function createPipeGraphics(height, isTop) {
            const pipe = new PIXI.Container();
            const pipeWidth = 60;
            const capHeight = 30;
            const capWidth = 70;

            // Pipe body
            const body = new PIXI.Graphics();
            if (isTop) {
                body.rect(0, 0, pipeWidth, height - capHeight);
            } else {
                body.rect(0, capHeight, pipeWidth, height - capHeight);
            }
            body.fill({ color: 0x73BF2E });
            body.stroke({ color: 0x5A9A24, width: 2 });

            // Highlight
            const highlight = new PIXI.Graphics();
            if (isTop) {
                highlight.rect(5, 0, 10, height - capHeight);
            } else {
                highlight.rect(5, capHeight, 10, height - capHeight);
            }
            highlight.fill({ color: 0x8FD93A, alpha: 0.5 });

            // Pipe cap
            const cap = new PIXI.Graphics();
            const capY = isTop ? height - capHeight : 0;
            cap.roundRect(-5, capY, capWidth, capHeight, 5);
            cap.fill({ color: 0x73BF2E });
            cap.stroke({ color: 0x5A9A24, width: 2 });

            // Cap highlight
            const capHighlight = new PIXI.Graphics();
            capHighlight.roundRect(0, capY + 3, 15, capHeight - 6, 3);
            capHighlight.fill({ color: 0x8FD93A, alpha: 0.5 });

            pipe.addChild(body);
            pipe.addChild(highlight);
            pipe.addChild(cap);
            pipe.addChild(capHighlight);

            return pipe;
        }

        function createFlapParticles() {
            for (let i = 0; i < 5; i++) {
                const particle = new PIXI.Graphics();
                particle.circle(0, 0, 3);
                particle.fill({ color: 0xFFFFFF });
                particle.x = bird.x - 15;
                particle.y = bird.y + 10;
                particle.vx = -2 - Math.random() * 2;
                particle.vy = (Math.random() - 0.5) * 3;
                particle.life = 1;
                app.stage.addChildAt(particle, app.stage.children.indexOf(bird));
                particles.push(particle);
            }
        }

        function gameLoop() {
            frameCount++;

            // Animate clouds (always)
            clouds.forEach(cloud => {
                cloud.x -= cloud.speed;
                if (cloud.x < -100) cloud.x = CONFIG.width + 50;
            });

            // Animate bird wing (always)
            wingAngle += 0.3;
            bird.wing.rotation = Math.sin(wingAngle) * 0.5;

            // Idle animation when in menu or splash
            if (gameState === 'menu' || gameState === 'splash') {
                bird.y = CONFIG.height / 2 + Math.sin(frameCount / 20) * 10;
                return;
            }

            if (gameState !== 'playing') return;

            // Bird physics
            birdVelocity += GRAVITY;
            bird.y += birdVelocity;

            // Bird rotation
            const targetRotation = Math.min(Math.max(birdVelocity * 0.1, -0.5), 1.2);
            birdRotation += (targetRotation - birdRotation) * 0.1;
            bird.rotation = birdRotation;

            // Spawn pipes
            if (frameCount % PIPE_SPAWN_INTERVAL === 0) {
                createPipe();
            }

            // Update pipes
            for (let i = pipes.length - 1; i >= 0; i--) {
                const pipe = pipes[i];
                pipe.x -= PIPE_SPEED;

                // Score
                if (!pipe.scored && pipe.x + 30 < bird.x) {
                    pipe.scored = true;
                    score++;
                    gameTopBar.setScore(score);
                }

                // Remove off-screen pipes
                if (pipe.x < -80) {
                    app.stage.removeChild(pipe);
                    pipes.splice(i, 1);
                    continue;
                }

                // Collision detection
                const birdLeft = bird.x - 18;
                const birdRight = bird.x + 18;
                const birdTop = bird.y - 12;
                const birdBottom = bird.y + 12;

                const pipeLeft = pipe.x;
                const pipeRight = pipe.x + 60;
                const gapTop = pipe.gapY - PIPE_GAP / 2;
                const gapBottom = pipe.gapY + PIPE_GAP / 2;

                if (birdRight > pipeLeft && birdLeft < pipeRight) {
                    if (birdTop < gapTop || birdBottom > gapBottom) {
                        endGame();
                        return;
                    }
                }
            }

            // Ground collision
            if (bird.y > CONFIG.height - 95) {
                bird.y = CONFIG.height - 95;
                endGame();
                return;
            }

            // Ceiling collision
            if (bird.y < 15) {
                bird.y = 15;
                birdVelocity = 0;
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
                p.alpha = p.life;

                if (p.life <= 0) {
                    app.stage.removeChild(p);
                    particles.splice(i, 1);
                }
            }
        }

        init().catch(console.error);
    </script>
</body>
</html>
