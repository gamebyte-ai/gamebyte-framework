<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GameByte - Snake Game Demo</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        h1 { color: #fff; margin-bottom: 10px; font-size: 24px; }
        p { color: #8892b0; margin-bottom: 20px; font-size: 14px; }
        #game-container {
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
        }
        canvas { display: block; }
        .info { color: #8892b0; margin-top: 20px; font-size: 12px; text-align: center; }
    </style>
</head>
<body>
    <h1>Snake Game</h1>
    <p>GameByte Framework Demo - Full Game Flow</p>
    <div id="game-container"></div>
    <div class="info">
        Arrow keys to change direction. Eat food to grow!
    </div>

    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8/dist/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="/gamebyte.umd.js"></script>

    <script>
        const {
            createGame,
            graphics,
            loadFrameworkFont,
            GameStyleButton,
            GameStyleColors,
            GameTopBar,
            ResultScreen,
            CelebrationManager,
            GraphicsEngine,
            RenderingMode
        } = GameByteFramework;

        const CONFIG = { width: 500, height: 500 };
        const GRID_SIZE = 20;
        const GRID_WIDTH = CONFIG.width / GRID_SIZE;
        const GRID_HEIGHT = CONFIG.height / GRID_SIZE;

        let app;
        let gameState = 'splash'; // 'splash' -> 'menu' -> 'playing' -> 'gameover'

        // UI Components
        let splashScreen;
        let mainMenuContainer;
        let gameTopBar;
        let resultScreen;

        // Snake game state
        let snake = [];
        let snakeGraphics = [];
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let food = { x: 0, y: 0 };
        let foodGraphic;
        let specialFood = null;
        let specialFoodGraphic = null;
        let score = 0;
        let highScore = 0;
        let speed = 150;
        let lastMove = 0;
        let gridContainer;
        let gameContainer;

        async function init() {
            // Load framework font
            await loadFrameworkFont();

            // Initialize GraphicsEngine for graphics() function
            GraphicsEngine.initialize(RenderingMode.RENDERER_2D);

            app = new PIXI.Application();
            await app.init({
                width: CONFIG.width,
                height: CONFIG.height,
                backgroundColor: 0x1a1a2e,
                antialias: true
            });
            document.getElementById('game-container').appendChild(app.canvas);

            setupInput();
            showSplashScreen();

            app.ticker.add(gameLoop);
        }

        function showSplashScreen() {
            gameState = 'splash';

            splashScreen = new PIXI.Container();

            // Background
            const bg = new PIXI.Graphics();
            bg.rect(0, 0, CONFIG.width, CONFIG.height);
            bg.fill({ color: 0x1a1a2e });
            splashScreen.addChild(bg);

            // Title
            const title = new PIXI.Text({
                text: 'SNAKE',
                style: {
                    fontFamily: 'Lilita One',
                    fontSize: 72,
                    fill: 0x2ECC71,
                    align: 'center'
                }
            });
            title.anchor.set(0.5);
            title.x = CONFIG.width / 2;
            title.y = CONFIG.height / 2 - 30;
            splashScreen.addChild(title);

            // Subtitle
            const subtitle = new PIXI.Text({
                text: 'A GameByte Demo',
                style: {
                    fontFamily: 'Lilita One',
                    fontSize: 20,
                    fill: 0x8892b0,
                    align: 'center'
                }
            });
            subtitle.anchor.set(0.5);
            subtitle.x = CONFIG.width / 2;
            subtitle.y = CONFIG.height / 2 + 30;
            splashScreen.addChild(subtitle);

            app.stage.addChild(splashScreen);

            // Auto-advance after 2 seconds
            setTimeout(() => {
                app.stage.removeChild(splashScreen);
                showMainMenu();
            }, 2000);
        }

        function showMainMenu() {
            gameState = 'menu';

            const factory = graphics();
            mainMenuContainer = factory.createContainer();

            // Title
            const title = factory.createText('SNAKE', {
                fontFamily: 'Lilita One',
                fontSize: 72,
                fill: 0x2ECC71,
                align: 'center'
            });
            title.anchor.set(0.5);
            title.x = CONFIG.width / 2;
            title.y = 120;
            mainMenuContainer.addChild(title);

            // High score display
            if (highScore > 0) {
                const highScoreText = factory.createText(`Best: ${highScore}`, {
                    fontFamily: 'Lilita One',
                    fontSize: 24,
                    fill: 0xF39C12,
                    align: 'center'
                });
                highScoreText.anchor.set(0.5);
                highScoreText.x = CONFIG.width / 2;
                highScoreText.y = 200;
                mainMenuContainer.addChild(highScoreText);
            }

            // Play button
            const playButton = new GameStyleButton({
                text: 'PLAY',
                variant: 'primary',
                width: 200,
                height: 60,
                fontSize: 28
            });

            const playContainer = playButton.getContainer();
            playContainer.x = CONFIG.width / 2 - 100;
            playContainer.y = 280;

            playButton.on('click', () => {
                app.stage.removeChild(mainMenuContainer);
                startGame();
            });

            mainMenuContainer.addChild(playContainer);

            // Instructions
            const instructions = factory.createText('Use Arrow Keys to Move', {
                fontFamily: 'Lilita One',
                fontSize: 16,
                fill: 0x8892b0,
                align: 'center'
            });
            instructions.anchor.set(0.5);
            instructions.x = CONFIG.width / 2;
            instructions.y = 380;
            mainMenuContainer.addChild(instructions);

            app.stage.addChild(mainMenuContainer);
        }

        function startGame() {
            gameState = 'playing';
            score = 0;
            speed = 150;

            // Create game container
            gameContainer = new PIXI.Container();
            app.stage.addChild(gameContainer);

            // Draw grid
            drawGrid();

            // Create top bar
            gameTopBar = new GameTopBar({
                width: CONFIG.width,
                title: 'SNAKE',
                showCoins: false,
                showLives: false
            });
            gameTopBar.updateScore(score);

            app.stage.addChild(gameTopBar.getContainer());

            // Initialize snake game
            initSnake();

            // Start game loop
            lastMove = Date.now();
        }

        function drawGrid() {
            gridContainer = new PIXI.Container();
            gameContainer.addChild(gridContainer);

            const grid = new PIXI.Graphics();
            grid.rect(0, 0, CONFIG.width, CONFIG.height);
            grid.fill({ color: 0x0a0a1a });

            // Grid lines
            for (let i = 0; i <= GRID_WIDTH; i++) {
                grid.moveTo(i * GRID_SIZE, 0);
                grid.lineTo(i * GRID_SIZE, CONFIG.height);
            }
            for (let i = 0; i <= GRID_HEIGHT; i++) {
                grid.moveTo(0, i * GRID_SIZE);
                grid.lineTo(CONFIG.width, i * GRID_SIZE);
            }
            grid.stroke({ color: 0x1a1a3e, width: 1 });

            gridContainer.addChild(grid);
        }

        function initSnake() {
            // Clear old snake
            snakeGraphics.forEach(s => gridContainer.removeChild(s));
            snakeGraphics = [];

            // Initial snake position
            snake = [
                { x: 12, y: 12 },
                { x: 11, y: 12 },
                { x: 10, y: 12 }
            ];

            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };

            // Draw snake
            snake.forEach((segment, i) => {
                const graphic = createSnakeSegment(segment.x, segment.y, i === 0);
                snakeGraphics.push(graphic);
            });

            // Spawn food
            spawnFood();
        }

        function createSnakeSegment(x, y, isHead) {
            const segment = new PIXI.Graphics();
            const padding = 2;

            if (isHead) {
                segment.roundRect(padding, padding, GRID_SIZE - padding * 2, GRID_SIZE - padding * 2, 5);
                segment.fill({ color: 0x27AE60 });
                segment.stroke({ color: 0x2ECC71, width: 2 });

                // Eyes
                segment.circle(direction.x > 0 ? 13 : 7, direction.y > 0 ? 13 : 7, 3);
                segment.fill({ color: 0xFFFFFF });
                segment.circle(direction.x > 0 ? 13 : 7, direction.y > 0 ? 13 : 7, 1.5);
                segment.fill({ color: 0x000000 });
            } else {
                segment.roundRect(padding, padding, GRID_SIZE - padding * 2, GRID_SIZE - padding * 2, 4);
                segment.fill({ color: 0x2ECC71 });
            }

            segment.x = x * GRID_SIZE;
            segment.y = y * GRID_SIZE;
            gridContainer.addChild(segment);
            return segment;
        }

        function spawnFood() {
            let validPosition = false;
            while (!validPosition) {
                food.x = Math.floor(Math.random() * GRID_WIDTH);
                food.y = Math.floor(Math.random() * GRID_HEIGHT);
                validPosition = !snake.some(s => s.x === food.x && s.y === food.y);
            }

            if (foodGraphic) gridContainer.removeChild(foodGraphic);

            foodGraphic = new PIXI.Graphics();
            foodGraphic.circle(GRID_SIZE / 2, GRID_SIZE / 2, GRID_SIZE / 2 - 3);
            foodGraphic.fill({ color: 0xE74C3C });
            foodGraphic.stroke({ color: 0xC0392B, width: 2 });

            // Shine effect
            foodGraphic.circle(GRID_SIZE / 3, GRID_SIZE / 3, 3);
            foodGraphic.fill({ color: 0xFFFFFF, alpha: 0.5 });

            foodGraphic.x = food.x * GRID_SIZE;
            foodGraphic.y = food.y * GRID_SIZE;
            gridContainer.addChild(foodGraphic);

            // Random chance for special food
            if (Math.random() < 0.2 && !specialFood) {
                spawnSpecialFood();
            }
        }

        function spawnSpecialFood() {
            let validPosition = false;
            specialFood = { x: 0, y: 0, timer: 200 };

            while (!validPosition) {
                specialFood.x = Math.floor(Math.random() * GRID_WIDTH);
                specialFood.y = Math.floor(Math.random() * GRID_HEIGHT);
                validPosition = !snake.some(s => s.x === specialFood.x && s.y === specialFood.y) &&
                               !(specialFood.x === food.x && specialFood.y === food.y);
            }

            specialFoodGraphic = new PIXI.Graphics();
            // Star shape
            const cx = GRID_SIZE / 2;
            const cy = GRID_SIZE / 2;
            const points = [];
            for (let i = 0; i < 10; i++) {
                const radius = i % 2 === 0 ? 8 : 4;
                const angle = (i * Math.PI / 5) - Math.PI / 2;
                points.push(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius);
            }
            specialFoodGraphic.poly(points);
            specialFoodGraphic.fill({ color: 0xF39C12 });
            specialFoodGraphic.stroke({ color: 0xE67E22, width: 1 });

            specialFoodGraphic.x = specialFood.x * GRID_SIZE;
            specialFoodGraphic.y = specialFood.y * GRID_SIZE;
            gridContainer.addChild(specialFoodGraphic);
        }

        function setupInput() {
            window.addEventListener('keydown', (e) => {
                if (gameState !== 'playing') return;

                switch (e.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        if (direction.y !== 1) nextDirection = { x: 0, y: -1 };
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        if (direction.y !== -1) nextDirection = { x: 0, y: 1 };
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        if (direction.x !== 1) nextDirection = { x: -1, y: 0 };
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        if (direction.x !== -1) nextDirection = { x: 1, y: 0 };
                        break;
                }

                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                    e.preventDefault();
                }
            });
        }

        function gameLoop(ticker) {
            if (gameState !== 'playing') return;

            const now = Date.now();
            if (now - lastMove < speed) return;
            lastMove = now;

            // Update direction
            direction = { ...nextDirection };

            // Calculate new head position
            const head = snake[0];
            const newHead = {
                x: head.x + direction.x,
                y: head.y + direction.y
            };

            // Check wall collision
            if (newHead.x < 0 || newHead.x >= GRID_WIDTH ||
                newHead.y < 0 || newHead.y >= GRID_HEIGHT) {
                endGame();
                return;
            }

            // Check self collision
            if (snake.some(s => s.x === newHead.x && s.y === newHead.y)) {
                endGame();
                return;
            }

            // Add new head
            snake.unshift(newHead);

            // Check food collision
            let ate = false;
            if (newHead.x === food.x && newHead.y === food.y) {
                score += 10;
                ate = true;
                speed = Math.max(50, speed - 2);
                gameTopBar.updateScore(score);
                spawnFood();
            }

            // Check special food collision
            if (specialFood && newHead.x === specialFood.x && newHead.y === specialFood.y) {
                score += 50;
                ate = true;
                gameTopBar.updateScore(score);
                // Add extra segments
                for (let i = 0; i < 2; i++) {
                    const tail = snake[snake.length - 1];
                    snake.push({ ...tail });
                }
                removeSpecialFood();
            }

            // Remove tail if didn't eat
            if (!ate) {
                snake.pop();
            }

            // Update graphics
            updateSnakeGraphics();

            // Update special food timer
            if (specialFood) {
                specialFood.timer--;
                if (specialFood.timer <= 0) {
                    removeSpecialFood();
                }
                // Blinking effect
                if (specialFoodGraphic) {
                    specialFoodGraphic.alpha = specialFood.timer % 20 < 10 ? 1 : 0.5;
                }
            }

            // Animate food
            if (foodGraphic) {
                foodGraphic.scale.set(1 + Math.sin(now / 200) * 0.1);
            }
        }

        function updateSnakeGraphics() {
            // Remove old graphics
            snakeGraphics.forEach(s => gridContainer.removeChild(s));
            snakeGraphics = [];

            // Create new graphics
            snake.forEach((segment, i) => {
                const graphic = createSnakeSegment(segment.x, segment.y, i === 0);
                snakeGraphics.push(graphic);
            });
        }

        function removeSpecialFood() {
            if (specialFoodGraphic) {
                gridContainer.removeChild(specialFoodGraphic);
                specialFoodGraphic = null;
            }
            specialFood = null;
        }

        function endGame() {
            gameState = 'gameover';

            // Update high score
            if (score > highScore) {
                highScore = score;
            }

            // Clean up game container
            app.stage.removeChild(gameContainer);
            if (gameTopBar) {
                app.stage.removeChild(gameTopBar.getContainer());
            }

            // Show result screen
            showResultScreen();
        }

        function showResultScreen() {
            const isNewHighScore = score === highScore && score > 0;

            resultScreen = new ResultScreen({
                title: isNewHighScore ? 'NEW RECORD!' : 'GAME OVER',
                score: score,
                stars: Math.min(3, Math.floor(score / 100)),
                message: isNewHighScore ? `Amazing! You scored ${score} points!` : `You scored ${score} points`,
                showCoins: false,
                buttonText: 'PLAY AGAIN'
            });

            resultScreen.on('continue', () => {
                app.stage.removeChild(resultScreen.getContainer());
                showMainMenu();
            });

            app.stage.addChild(resultScreen.getContainer());

            // Show celebration if new high score
            if (isNewHighScore && score > 0) {
                const celebration = new CelebrationManager(app.stage, CONFIG.width, CONFIG.height);
                celebration.victory({ confetti: true, sound: false });
            }
        }

        init().catch(console.error);
    </script>
</body>
</html>
