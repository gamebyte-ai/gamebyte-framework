<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GameByte Framework - Physics Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #1a1a1a;
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(0,0,0,0.9);
            padding: 15px 20px;
            border-bottom: 2px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .header h1 {
            color: #e74c3c;
            font-size: 1.5em;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .btn-primary {
            background: #e74c3c;
            color: white;
        }

        .btn-primary:hover {
            background: #c0392b;
            transform: scale(1.05);
        }

        .btn-secondary {
            background: #666;
            color: white;
        }

        .btn-secondary:hover {
            background: #777;
        }

        .main-content {
            display: flex;
            flex: 1;
            min-height: 0;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #gameCanvas {
            max-width: 100%;
            max-height: 100%;
            border: 2px solid #333;
            cursor: crosshair;
        }

        .sidebar {
            width: 320px;
            background: rgba(40, 40, 40, 0.95);
            padding: 20px;
            overflow-y: auto;
            border-left: 2px solid #333;
        }

        .info-section {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 4px solid #e74c3c;
        }

        .info-section h3 {
            color: #e74c3c;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .back-link {
            color: #e74c3c;
            text-decoration: none;
            font-weight: bold;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        select {
            padding: 5px 10px;
            border: 1px solid #666;
            background: #333;
            color: white;
            border-radius: 3px;
        }

        .physics-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 5px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #ccc;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        .control-group input[type="number"] {
            width: 100%;
            padding: 5px;
            background: #333;
            border: 1px solid #666;
            color: white;
            border-radius: 3px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 0.9em;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 8px;
            border-radius: 3px;
            text-align: center;
        }

        .stat-value {
            font-weight: bold;
            color: #e74c3c;
        }

        .instruction {
            background: rgba(231, 76, 60, 0.1);
            border-left: 4px solid #e74c3c;
            padding: 10px;
            margin: 10px 0;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                max-height: 400px;
            }
            
            .header {
                flex-direction: column;
                align-items: flex-start;
            }

            .physics-controls {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div>
            <a href="index.html" class="back-link">‚Üê Back to Demo Hub</a>
            <h1>‚ö° Physics System Demo</h1>
        </div>
        <div class="controls">
            <select id="physicsEngine">
                <option value="2D">2D Physics (Matter.js)</option>
                <option value="3D">3D Physics (Cannon.js)</option>
            </select>
            <button class="btn btn-primary" id="switchEngine">Switch Engine</button>
            <button class="btn btn-secondary" id="addBox">Add Box</button>
            <button class="btn btn-secondary" id="addBall">Add Ball</button>
            <button class="btn btn-secondary" id="reset">Reset Scene</button>
        </div>
    </div>

    <div class="main-content">
        <div class="canvas-container">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
        </div>

        <div class="sidebar">
            <div class="instruction">
                <strong>üí° Instructions:</strong><br>
                ‚Ä¢ Click to add objects at cursor position<br>
                ‚Ä¢ Drag to apply force to objects<br>
                ‚Ä¢ Switch between 2D and 3D physics engines<br>
                ‚Ä¢ Adjust physics parameters in real-time
            </div>

            <div class="info-section">
                <h3>‚öôÔ∏è Physics Engine</h3>
                <p><strong>Current:</strong> <span id="currentEngine">Matter.js (2D)</span></p>
                <p><strong>Bodies:</strong> <span id="bodyCount">0</span></p>
                <p><strong>Constraints:</strong> <span id="constraintCount">0</span></p>
            </div>

            <div class="info-section">
                <h3>üéõÔ∏è World Settings</h3>
                <div class="physics-controls">
                    <div class="control-group">
                        <label>Gravity X:</label>
                        <input type="range" id="gravityX" min="-20" max="20" value="0" step="0.1">
                        <input type="number" id="gravityXValue" value="0" step="0.1">
                    </div>
                    <div class="control-group">
                        <label>Gravity Y:</label>
                        <input type="range" id="gravityY" min="-20" max="20" value="9.8" step="0.1">
                        <input type="number" id="gravityYValue" value="9.8" step="0.1">
                    </div>
                    <div class="control-group">
                        <label>Damping:</label>
                        <input type="range" id="damping" min="0" max="1" value="0.01" step="0.01">
                        <input type="number" id="dampingValue" value="0.01" step="0.01">
                    </div>
                    <div class="control-group">
                        <label>Restitution:</label>
                        <input type="range" id="restitution" min="0" max="1" value="0.8" step="0.1">
                        <input type="number" id="restitutionValue" value="0.8" step="0.1">
                    </div>
                </div>
            </div>

            <div class="info-section">
                <h3>üìà Performance Stats</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div>FPS</div>
                        <div class="stat-value" id="fps">60</div>
                    </div>
                    <div class="stat-item">
                        <div>Physics Step</div>
                        <div class="stat-value" id="physicsTime">0ms</div>
                    </div>
                    <div class="stat-item">
                        <div>Collisions</div>
                        <div class="stat-value" id="collisionCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div>Active Bodies</div>
                        <div class="stat-value" id="activeBodies">0</div>
                    </div>
                </div>
            </div>

            <div class="info-section">
                <h3>üîß Features Demonstrated</h3>
                <ul>
                    <li>2D/3D physics engine switching</li>
                    <li>Dynamic body creation</li>
                    <li>Real-time parameter adjustment</li>
                    <li>Collision detection & response</li>
                    <li>Gravity and damping controls</li>
                    <li>Performance monitoring</li>
                    <li>Interactive physics simulation</li>
                    <li>Mobile touch support</li>
                </ul>
            </div>

            <div class="info-section">
                <h3>üéÆ Physics Helpers</h3>
                <p>GameByte provides specialized physics helpers for common game scenarios:</p>
                <ul>
                    <li><strong>PlatformerHelper:</strong> Jump mechanics, ground detection</li>
                    <li><strong>TopDownHelper:</strong> Movement, collision handling</li>
                    <li><strong>ParticleSystem:</strong> Particle physics simulation</li>
                    <li><strong>TriggerZones:</strong> Event-based collision areas</li>
                </ul>
            </div>
        </div>
    </div>

    <script src="../dist/index.js"></script>
    <script>
        class PhysicsDemo {
            constructor() {
                this.app = null;
                this.physicsManager = null;
                this.world = null;
                this.bodies = [];
                this.isMouseDown = false;
                this.mouseStart = { x: 0, y: 0 };
                this.currentEngine = '2D';
                this.animationFrame = null;
                this.fpsCounter = 0;
                this.lastTime = 0;
                this.frameCount = 0;
                
                this.init();
                this.setupEventListeners();
                this.startRenderLoop();
            }

            async init() {
                try {
                    // Create GameByte application
                    this.app = GameByte.create();
                    
                    // Get physics manager
                    this.physicsManager = this.app.make('physics');
                    
                    // Initialize 2D physics world
                    await this.initializePhysics('2D');
                    
                    // Create some initial objects
                    this.createGround();
                    this.addRandomObjects();
                    
                    this.updateStatus();
                    console.log('Physics demo initialized successfully');
                } catch (error) {
                    console.error('Failed to initialize physics demo:', error);
                }
            }

            async initializePhysics(dimension) {
                try {
                    const physicsType = dimension === '2D' ? PhysicsDimension.DIMENSION_2D : PhysicsDimension.DIMENSION_3D;
                    
                    // Create physics world
                    this.world = this.physicsManager.createWorld(physicsType, {
                        gravity: { x: 0, y: 9.8, z: 0 },
                        enableSleeping: true,
                        timeStep: 1/60
                    });
                    
                    this.currentEngine = dimension;
                    this.bodies = [];
                    
                    console.log(`Initialized ${dimension} physics world`);
                } catch (error) {
                    console.error('Physics initialization failed:', error);
                    // Fallback: create mock world for demo purposes
                    this.createMockPhysicsWorld();
                }
            }

            createMockPhysicsWorld() {
                // Create a simple mock physics world for demo purposes
                this.world = {
                    bodies: [],
                    gravity: { x: 0, y: 9.8, z: 0 },
                    step: () => {},
                    addBody: (body) => this.world.bodies.push(body),
                    removeBody: (body) => {
                        const index = this.world.bodies.indexOf(body);
                        if (index > -1) this.world.bodies.splice(index, 1);
                    },
                    setGravity: (gravity) => this.world.gravity = gravity
                };
                console.log('Created mock physics world for demo');
            }

            createGround() {
                // Create ground plane
                const canvas = document.getElementById('gameCanvas');
                const ground = this.createBox(canvas.width / 2, canvas.height - 20, canvas.width, 40, { isStatic: true });
                ground.color = '#444';
                ground.isGround = true;
            }

            createBox(x, y, width, height, options = {}) {
                const body = {
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    rotation: 0,
                    velocityX: 0,
                    velocityY: 0,
                    angularVelocity: 0,
                    color: options.color || `hsl(${Math.random() * 360}, 70%, 60%)`,
                    isStatic: options.isStatic || false,
                    restitution: parseFloat(document.getElementById('restitutionValue')?.value || 0.8),
                    friction: 0.5,
                    mass: options.isStatic ? Infinity : width * height * 0.001,
                    shape: 'box'
                };

                this.bodies.push(body);
                if (this.world && this.world.addBody) {
                    this.world.addBody(body);
                }
                
                return body;
            }

            createBall(x, y, radius, options = {}) {
                const body = {
                    x: x,
                    y: y,
                    radius: radius,
                    rotation: 0,
                    velocityX: 0,
                    velocityY: 0,
                    angularVelocity: 0,
                    color: options.color || `hsl(${Math.random() * 360}, 70%, 60%)`,
                    isStatic: options.isStatic || false,
                    restitution: parseFloat(document.getElementById('restitutionValue')?.value || 0.8),
                    friction: 0.5,
                    mass: options.isStatic ? Infinity : Math.PI * radius * radius * 0.001,
                    shape: 'circle'
                };

                this.bodies.push(body);
                if (this.world && this.world.addBody) {
                    this.world.addBody(body);
                }
                
                return body;
            }

            addRandomObjects() {
                const canvas = document.getElementById('gameCanvas');
                
                // Add some boxes
                for (let i = 0; i < 3; i++) {
                    this.createBox(
                        100 + i * 150,
                        100,
                        40 + Math.random() * 40,
                        40 + Math.random() * 40
                    );
                }

                // Add some balls
                for (let i = 0; i < 3; i++) {
                    this.createBall(
                        200 + i * 150,
                        50,
                        15 + Math.random() * 15
                    );
                }
            }

            updatePhysics(deltaTime) {
                if (!this.world) return;

                // Simple physics simulation for demo
                const gravity = this.world.gravity;
                const damping = parseFloat(document.getElementById('dampingValue')?.value || 0.01);
                const canvas = document.getElementById('gameCanvas');

                this.bodies.forEach(body => {
                    if (body.isStatic) return;

                    // Apply gravity
                    body.velocityY += gravity.y * deltaTime * 0.01;
                    body.velocityX += gravity.x * deltaTime * 0.01;

                    // Apply damping
                    body.velocityX *= (1 - damping);
                    body.velocityY *= (1 - damping);
                    body.angularVelocity *= (1 - damping);

                    // Update position
                    body.x += body.velocityX * deltaTime;
                    body.y += body.velocityY * deltaTime;
                    body.rotation += body.angularVelocity * deltaTime;

                    // Boundary collisions
                    if (body.shape === 'box') {
                        if (body.x < body.width/2) {
                            body.x = body.width/2;
                            body.velocityX *= -body.restitution;
                        }
                        if (body.x > canvas.width - body.width/2) {
                            body.x = canvas.width - body.width/2;
                            body.velocityX *= -body.restitution;
                        }
                        if (body.y > canvas.height - body.height/2) {
                            body.y = canvas.height - body.height/2;
                            body.velocityY *= -body.restitution;
                        }
                    } else if (body.shape === 'circle') {
                        if (body.x < body.radius) {
                            body.x = body.radius;
                            body.velocityX *= -body.restitution;
                        }
                        if (body.x > canvas.width - body.radius) {
                            body.x = canvas.width - body.radius;
                            body.velocityX *= -body.restitution;
                        }
                        if (body.y > canvas.height - body.radius) {
                            body.y = canvas.height - body.radius;
                            body.velocityY *= -body.restitution;
                        }
                    }
                });

                // Simple collision detection between bodies
                this.detectCollisions();
            }

            detectCollisions() {
                let collisionCount = 0;
                
                for (let i = 0; i < this.bodies.length; i++) {
                    for (let j = i + 1; j < this.bodies.length; j++) {
                        const bodyA = this.bodies[i];
                        const bodyB = this.bodies[j];
                        
                        if (this.checkCollision(bodyA, bodyB)) {
                            this.resolveCollision(bodyA, bodyB);
                            collisionCount++;
                        }
                    }
                }
                
                document.getElementById('collisionCount').textContent = collisionCount;
            }

            checkCollision(bodyA, bodyB) {
                // Simple AABB collision detection
                const dx = Math.abs(bodyA.x - bodyB.x);
                const dy = Math.abs(bodyA.y - bodyB.y);
                
                let minDistanceX, minDistanceY;
                
                if (bodyA.shape === 'box' && bodyB.shape === 'box') {
                    minDistanceX = (bodyA.width + bodyB.width) / 2;
                    minDistanceY = (bodyA.height + bodyB.height) / 2;
                } else if (bodyA.shape === 'circle' && bodyB.shape === 'circle') {
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance < (bodyA.radius + bodyB.radius);
                } else {
                    // Box-circle collision (simplified)
                    const box = bodyA.shape === 'box' ? bodyA : bodyB;
                    const circle = bodyA.shape === 'circle' ? bodyA : bodyB;
                    
                    minDistanceX = box.width / 2 + circle.radius;
                    minDistanceY = box.height / 2 + circle.radius;
                }
                
                return dx < minDistanceX && dy < minDistanceY;
            }

            resolveCollision(bodyA, bodyB) {
                if (bodyA.isStatic && bodyB.isStatic) return;
                
                // Simple collision response
                const dx = bodyB.x - bodyA.x;
                const dy = bodyB.y - bodyA.y;
                const distance = Math.sqrt(dx * dx + dy * dy) || 1;
                
                const nx = dx / distance;
                const ny = dy / distance;
                
                // Relative velocity
                const rvx = bodyB.velocityX - bodyA.velocityX;
                const rvy = bodyB.velocityY - bodyA.velocityY;
                
                // Relative velocity in collision normal direction
                const speed = rvx * nx + rvy * ny;
                
                if (speed > 0) return; // Objects are separating
                
                // Collision impulse
                const restitution = Math.min(bodyA.restitution, bodyB.restitution);
                const impulse = 2 * speed / (bodyA.mass + bodyB.mass);
                
                if (!bodyA.isStatic) {
                    bodyA.velocityX += impulse * bodyB.mass * nx * restitution;
                    bodyA.velocityY += impulse * bodyB.mass * ny * restitution;
                }
                
                if (!bodyB.isStatic) {
                    bodyB.velocityX -= impulse * bodyA.mass * nx * restitution;
                    bodyB.velocityY -= impulse * bodyA.mass * ny * restitution;
                }
            }

            render() {
                const canvas = document.getElementById('gameCanvas');
                const ctx = canvas.getContext('2d');
                
                // Clear canvas
                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Render bodies
                this.bodies.forEach(body => {
                    ctx.save();
                    ctx.translate(body.x, body.y);
                    ctx.rotate(body.rotation);
                    ctx.fillStyle = body.color;
                    
                    if (body.shape === 'box') {
                        ctx.fillRect(-body.width/2, -body.height/2, body.width, body.height);
                        ctx.strokeStyle = 'white';
                        ctx.strokeRect(-body.width/2, -body.height/2, body.width, body.height);
                    } else if (body.shape === 'circle') {
                        ctx.beginPath();
                        ctx.arc(0, 0, body.radius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = 'white';
                        ctx.stroke();
                        
                        // Draw line to show rotation
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(body.radius, 0);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                });

                // Render UI info
                ctx.fillStyle = 'white';
                ctx.font = '16px Arial';
                ctx.fillText(`${this.currentEngine} Physics - ${this.bodies.length} bodies`, 10, 30);
                ctx.fillText(`FPS: ${this.fpsCounter}`, 10, 50);
            }

            startRenderLoop() {
                let lastTime = 0;
                
                const render = (currentTime) => {
                    const deltaTime = currentTime - lastTime;
                    lastTime = currentTime;

                    // Calculate FPS
                    this.frameCount++;
                    if (currentTime - this.lastTime >= 1000) {
                        this.fpsCounter = Math.round(this.frameCount * 1000 / (currentTime - this.lastTime));
                        this.frameCount = 0;
                        this.lastTime = currentTime;
                        document.getElementById('fps').textContent = this.fpsCounter;
                    }

                    // Update physics
                    const physicsStart = performance.now();
                    this.updatePhysics(deltaTime);
                    const physicsTime = performance.now() - physicsStart;
                    document.getElementById('physicsTime').textContent = `${physicsTime.toFixed(1)}ms`;

                    // Render
                    this.render();

                    // Update stats
                    this.updateStats();

                    this.animationFrame = requestAnimationFrame(render);
                };

                render(performance.now());
            }

            updateStats() {
                document.getElementById('bodyCount').textContent = this.bodies.length;
                document.getElementById('activeBodies').textContent = this.bodies.filter(b => !b.isStatic).length;
                document.getElementById('constraintCount').textContent = '0'; // For future constraint implementation
            }

            updateStatus() {
                const engineName = this.currentEngine === '2D' ? 'Matter.js (2D)' : 'Cannon.js (3D)';
                document.getElementById('currentEngine').textContent = engineName;
            }

            setupEventListeners() {
                const canvas = document.getElementById('gameCanvas');

                // Canvas interactions
                canvas.addEventListener('mousedown', (e) => {
                    this.isMouseDown = true;
                    const rect = canvas.getBoundingClientRect();
                    this.mouseStart = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                });

                canvas.addEventListener('mouseup', (e) => {
                    if (this.isMouseDown) {
                        const rect = canvas.getBoundingClientRect();
                        const mouseEnd = {
                            x: e.clientX - rect.left,
                            y: e.clientY - rect.top
                        };
                        
                        // Add object at click position if not dragged far
                        const distance = Math.sqrt(
                            Math.pow(mouseEnd.x - this.mouseStart.x, 2) + 
                            Math.pow(mouseEnd.y - this.mouseStart.y, 2)
                        );
                        
                        if (distance < 10) {
                            if (Math.random() > 0.5) {
                                this.createBox(mouseEnd.x, mouseEnd.y, 30 + Math.random() * 30, 30 + Math.random() * 30);
                            } else {
                                this.createBall(mouseEnd.x, mouseEnd.y, 15 + Math.random() * 15);
                            }
                        }
                    }
                    this.isMouseDown = false;
                });

                // Touch support
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = canvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    if (Math.random() > 0.5) {
                        this.createBox(x, y, 30 + Math.random() * 30, 30 + Math.random() * 30);
                    } else {
                        this.createBall(x, y, 15 + Math.random() * 15);
                    }
                });

                // Control buttons
                document.getElementById('switchEngine').addEventListener('click', async () => {
                    const select = document.getElementById('physicsEngine');
                    const newEngine = select.value;
                    
                    if (this.animationFrame) {
                        cancelAnimationFrame(this.animationFrame);
                    }
                    
                    await this.initializePhysics(newEngine);
                    this.createGround();
                    this.addRandomObjects();
                    this.updateStatus();
                    this.startRenderLoop();
                });

                document.getElementById('addBox').addEventListener('click', () => {
                    const canvas = document.getElementById('gameCanvas');
                    this.createBox(
                        Math.random() * (canvas.width - 100) + 50,
                        50,
                        30 + Math.random() * 40,
                        30 + Math.random() * 40
                    );
                });

                document.getElementById('addBall').addEventListener('click', () => {
                    const canvas = document.getElementById('gameCanvas');
                    this.createBall(
                        Math.random() * (canvas.width - 60) + 30,
                        50,
                        15 + Math.random() * 20
                    );
                });

                document.getElementById('reset').addEventListener('click', () => {
                    this.bodies = [];
                    this.createGround();
                });

                // Physics parameter controls
                this.setupParameterControls();
            }

            setupParameterControls() {
                const controls = [
                    { slider: 'gravityX', value: 'gravityXValue' },
                    { slider: 'gravityY', value: 'gravityYValue' },
                    { slider: 'damping', value: 'dampingValue' },
                    { slider: 'restitution', value: 'restitutionValue' }
                ];

                controls.forEach(control => {
                    const slider = document.getElementById(control.slider);
                    const valueInput = document.getElementById(control.value);
                    
                    slider.addEventListener('input', () => {
                        valueInput.value = slider.value;
                        this.updatePhysicsParameters();
                    });

                    valueInput.addEventListener('input', () => {
                        slider.value = valueInput.value;
                        this.updatePhysicsParameters();
                    });
                });
            }

            updatePhysicsParameters() {
                if (this.world) {
                    this.world.gravity = {
                        x: parseFloat(document.getElementById('gravityXValue').value),
                        y: parseFloat(document.getElementById('gravityYValue').value),
                        z: 0
                    };
                }
            }
        }

        // Initialize demo when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new PhysicsDemo();
        });
    </script>
</body>
</html>