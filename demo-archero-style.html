<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Archero-Style Menu - GameByte Framework</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            touch-action: none;
        }
        #game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
        }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="loading">Loading GameByte Framework...</div>
    <div id="game-container"></div>

    <script>
        /**
         * Archero-Style Menu Demo (Standalone)
         *
         * This demo uses direct PIXI.js v8 API for standalone operation.
         * For framework-integrated usage, use:
         * - graphics().createGraphics() instead of new PIXI.Graphics()
         * - graphics().createContainer() instead of new PIXI.Container()
         * - graphics().createText() instead of new PIXI.Text()
         *
         * See ArcheroMenu component for the framework-integrated version.
         */

        // Function to load script and wait for it
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        // Load all dependencies sequentially
        (async () => {
            try {
                document.getElementById('loading').textContent = 'Loading Pixi.js...';
                await loadScript('https://cdn.jsdelivr.net/npm/pixi.js@8/dist/pixi.min.js');
                console.log('‚úÖ Pixi.js loaded');

                document.getElementById('loading').textContent = 'Loading GSAP...';
                await loadScript('https://cdn.jsdelivr.net/npm/gsap@3/dist/gsap.min.js');
                console.log('‚úÖ GSAP loaded');

                document.getElementById('loading').textContent = 'Loading GameByte Framework...';
                await loadScript('./dist/gamebyte.umd.js');
                console.log('‚úÖ GameByte Framework loaded');

                document.getElementById('loading').textContent = 'Initializing game...';

                // Wait a bit for DOM to be fully ready
                await new Promise(resolve => setTimeout(resolve, 100));

                // Now start the game
                await initGame();
            } catch (error) {
                console.error('‚ùå Error loading dependencies:', error);
                document.getElementById('loading').textContent = 'Error loading: ' + error.message;
            }
        })();

        async function initGame() {
            try {
                // Check if dependencies loaded
                if (typeof PIXI === 'undefined') {
                    console.error('‚ùå Pixi.js not loaded');
                    document.getElementById('loading').textContent = 'Error: Pixi.js not loaded';
                    return;
                }
                if (typeof gsap === 'undefined') {
                    console.error('‚ùå GSAP not loaded');
                    document.getElementById('loading').textContent = 'Error: GSAP not loaded';
                    return;
                }
                if (typeof GameByteFramework === 'undefined') {
                    console.error('‚ùå GameByte Framework not loaded');
                    document.getElementById('loading').textContent = 'Error: GameByte Framework not loaded';
                    return;
                }

                const { createGame } = GameByteFramework;

            // 9:16 aspect ratio (mobile portrait)
            const ASPECT_RATIO = 9 / 16;
            const BASE_WIDTH = 1080;
            const BASE_HEIGHT = 1920;

            // Calculate canvas size
            function getCanvasSize() {
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                const windowAspect = windowWidth / windowHeight;

                let width, height;
                if (windowAspect > ASPECT_RATIO) {
                    height = windowHeight;
                    width = height * ASPECT_RATIO;
                } else {
                    width = windowWidth;
                    height = width / ASPECT_RATIO;
                }
                return { width, height };
            }

            // Create game
            const game = createGame();

            // Create canvas with 9:16 aspect ratio
            const canvas = document.createElement('canvas');
            canvas.width = BASE_WIDTH;
            canvas.height = BASE_HEIGHT;

            // Set initial display size
            const initialSize = getCanvasSize();
            canvas.style.width = initialSize.width + 'px';
            canvas.style.height = initialSize.height + 'px';
            canvas.style.display = 'block';

            document.getElementById('game-container').appendChild(canvas);
            console.log('‚úÖ Canvas created:', initialSize.width, 'x', initialSize.height);

            // Initialize with 2D renderer
            console.log('‚è≥ Initializing game...');
            await game.initialize(canvas, '2d');
            console.log('‚úÖ Game initialized successfully');

            // Fix canvas style - framework might have changed it
            canvas.style.width = initialSize.width + 'px';
            canvas.style.height = initialSize.height + 'px';
            console.log('üîß Canvas style fixed:', canvas.style.width, 'x', canvas.style.height);

            document.getElementById('loading').style.display = 'none';
            console.log('‚úÖ Loading screen hidden');

            // Get renderer
            const renderer = game.make('renderer');
            console.log('üé® Renderer:', renderer);
            const stage = renderer.getStage();
            console.log('üé≠ Stage:', stage);
            console.log('üìê Canvas dimensions:', canvas.width, 'x', canvas.height);
            console.log('üìè Canvas style:', canvas.style.width, 'x', canvas.style.height);
            console.log('üë∂ Stage children before adding:', stage.children.length);

            // Archero color palette
            const COLORS = {
                navBg: 0x0f1624,
                navBgLight: 0x1a2332,
                separator: 0x2d3f5f,
                activeYellow: 0xFFD700,
                activeOrange: 0xFFA500,
                red: 0xFF3B3B,
                blue: 0x3B7BFF,
                purple: 0x9B3BFF,
                green: 0x3BFF7B
            };

            // Section configuration - Archero style
            const sections = [
                { name: 'Shop', color: 0x4a90e2, icon: 'üè™', iconColor: 0xFF6B6B },
                { name: 'Gear', color: 0x5a67d8, icon: '‚öîÔ∏è', iconColor: 0x9B3BFF },
                { name: 'Campaign', color: 0xf6ad55, icon: 'üéØ', iconColor: 0xFFD700 },
                { name: 'Trophy', color: 0x48bb78, icon: 'üèÜ', iconColor: 0x3BFF7B },
                { name: 'Chest', color: 0xe53e3e, icon: 'üéÅ', iconColor: 0xFF3B3B }
            ];

            // State management
            let activeSection = 2; // Campaign is default active (middle)
            let isAnimating = false;

            // Create main containers
            const contentContainer = new PIXI.Container();
            const uiContainer = new PIXI.Container();
            stage.addChild(contentContainer);
            stage.addChild(uiContainer);

            // Set initial position to show Campaign (index 2)
            contentContainer.x = -BASE_WIDTH * activeSection;

            // Create section panels
            sections.forEach((section, index) => {
                const panel = new PIXI.Container();
                panel.x = BASE_WIDTH * index;

                // Background gradient
                const bg = new PIXI.Graphics();
                bg.rect(0, 0, BASE_WIDTH, BASE_HEIGHT);
                bg.fill({ color: section.color });
                panel.addChild(bg);

                // Add some Archero-style decorative elements
                // Top wave decoration
                for (let i = 0; i < 10; i++) {
                    const wave = new PIXI.Graphics();
                    const waveX = (BASE_WIDTH / 10) * i;
                    wave.moveTo(waveX, 150);
                    wave.bezierCurveTo(
                        waveX + 60, 120,
                        waveX + 60, 180,
                        waveX + 120, 150
                    );
                    wave.stroke({ color: 0xFFD700, width: 8 });
                    panel.addChild(wave);
                }

                // Title with strong outline (Archero style)
                const titleBg = new PIXI.Graphics();
                titleBg.roundRect(BASE_WIDTH / 2 - 300, BASE_HEIGHT / 2 - 250, 600, 150, 20);
                titleBg.fill({ color: 0xFFFFFF, alpha: 0.15 });
                titleBg.stroke({ color: 0xFFFFFF, width: 4, alpha: 0.3 });
                panel.addChild(titleBg);

                const title = new PIXI.Text({
                    text: `${section.icon}\n${section.name}`,
                    style: {
                        fontSize: 100,
                        fill: 0xFFFFFF,
                        fontWeight: '900',
                        align: 'center',
                        stroke: { color: 0x000000, width: 8 },
                        dropShadow: {
                            distance: 6,
                            alpha: 0.8,
                            blur: 4,
                            color: 0x000000
                        }
                    }
                });
                title.anchor.set(0.5);
                title.position.set(BASE_WIDTH / 2, BASE_HEIGHT / 2 - 180);
                panel.addChild(title);

                // Add some floating decorative circles (Archero has these)
                for (let i = 0; i < 5; i++) {
                    const circle = new PIXI.Graphics();
                    const size = Math.random() * 100 + 50;
                    const x = Math.random() * BASE_WIDTH;
                    const y = Math.random() * (BASE_HEIGHT - 600) + 200;
                    circle.circle(x, y, size);
                    circle.fill({ color: 0xFFFFFF, alpha: 0.08 });
                    circle.stroke({ color: 0xFFFFFF, width: 3, alpha: 0.15 });
                    panel.addChild(circle);
                }

                contentContainer.addChild(panel);
            });

            // Create Archero-style bottom navigation
            const NAV_HEIGHT = 280;
            const NAV_Y = BASE_HEIGHT - NAV_HEIGHT;

            const navBar = new PIXI.Container();
            navBar.y = NAV_Y;
            uiContainer.addChild(navBar);

            // Navy blue gradient background (Archero style)
            const navBg = new PIXI.Graphics();
            navBg.rect(0, 0, BASE_WIDTH, NAV_HEIGHT);
            navBg.fill({
                color: COLORS.navBg,
                alpha: 1.0
            });
            navBar.addChild(navBg);

            // Top separator line (light blue)
            const separator = new PIXI.Graphics();
            separator.rect(0, 0, BASE_WIDTH, 3);
            separator.fill({ color: COLORS.separator });
            navBar.addChild(separator);

            // Darker overlay for depth
            const overlay = new PIXI.Graphics();
            overlay.rect(0, 3, BASE_WIDTH, NAV_HEIGHT - 3);
            overlay.fill({
                color: COLORS.navBgLight,
                alpha: 0.5
            });
            navBar.addChild(overlay);

            // Navigation buttons
            const navButtons = [];
            const BUTTON_SIZE = 180; // Bigger icons
            const ACTIVE_BUTTON_SIZE = 320; // Much bigger for active (2x almost)

            // Calculate total width: 1 active + 4 inactive buttons with padding
            const totalButtonsWidth = ACTIVE_BUTTON_SIZE + (BUTTON_SIZE * (sections.length - 1));
            const padding = 40; // Padding from edges
            const availableWidth = BASE_WIDTH - (padding * 2);

            // Calculate spacing between buttons
            const totalSpacing = availableWidth - totalButtonsWidth;
            const spacingBetweenButtons = totalSpacing / (sections.length - 1);

            sections.forEach((section, index) => {
                const buttonContainer = new PIXI.Container();

                // Active button should be elevated (moved up)
                const isActive = index === activeSection;
                buttonContainer.y = isActive ? NAV_HEIGHT / 2 - 40 : NAV_HEIGHT / 2;

                const size = isActive ? ACTIVE_BUTTON_SIZE : BUTTON_SIZE;

                // Calculate X position - distribute evenly across screen
                let xPos = padding;

                for (let i = 0; i < index; i++) {
                    const btnSize = (i === activeSection) ? ACTIVE_BUTTON_SIZE : BUTTON_SIZE;
                    xPos += btnSize + spacingBetweenButtons;
                }

                // Add half of current button size to center it
                xPos += size / 2;

                buttonContainer.x = xPos;

                // Button background - Archero style
                const btnBg = new PIXI.Graphics();

                buttonContainer.addChild(btnBg);

                // Store button data for later animation
                const buttonData = {
                    container: buttonContainer,
                    bg: btnBg,
                    section: section,
                    overlay: null,
                    icon: null,
                    label: null
                };

                if (isActive) {
                    // Active: Gold gradient with Pixi.js v8 API
                    const gradient = new PIXI.FillGradient({
                        type: 'linear',
                        start: { x: 0, y: 0 },
                        end: { x: 0, y: 1 },
                        colorStops: [
                            { offset: 0, color: 0xFFE55C },    // Light gold top
                            { offset: 0.5, color: 0xFFD700 },  // Gold middle
                            { offset: 1, color: 0xFFA500 }     // Orange bottom
                        ]
                    });

                    btnBg.roundRect(-size/2, -size/2, size, size, 30);
                    btnBg.fill(gradient);

                    // Top shine/highlight overlay with gradient - glossy shine effect
                    const overlay = new PIXI.Graphics();
                    const overlayWidth = size * 0.92; // 92% of button width - wider
                    const overlayHeight = size * 0.22; // Taller for more shine coverage

                    // Single gradient overlay for smooth shine effect
                    const shineGradient = new PIXI.FillGradient({
                        type: 'linear',
                        start: { x: 0, y: 0 },
                        end: { x: 0, y: 1 },
                        colorStops: [
                            { offset: 0, color: 0xFFFFFF },      // Pure white at top
                            { offset: 0.8, color: 0xFFE55C },    // Light gold
                            { offset: 1, color: 0xFFD700 }       // Gold at bottom
                        ]
                    });

                    overlay.roundRect(-overlayWidth/2, -size/2 + 8, overlayWidth, overlayHeight, 25);
                    overlay.fill(shineGradient);
                    overlay.alpha = 0.5; // Overall shine brightness
                    buttonContainer.addChild(overlay);
                    buttonData.overlay = overlay;

                    // NO BORDER - removed stroke
                } else {
                    // Inactive: No background, no border - just transparent
                    btnBg.rect(-size/2, -size/2, size, size);
                    btnBg.fill({ color: 0x000000, alpha: 0.0 });
                }

                // Icon with strong outline (Archero 3D style)
                const icon = new PIXI.Text({
                    text: section.icon,
                    style: {
                        fontSize: isActive ? 140 : 90, // Much bigger icons
                        fontFamily: 'system-ui',
                        stroke: { color: 0x000000, width: 8 },
                        dropShadow: {
                            distance: 6,
                            alpha: 0.8,
                            blur: 4,
                            color: 0x000000
                        }
                    }
                });
                icon.anchor.set(0.5);
                icon.y = isActive ? -35 : -10; // Move icons up more
                buttonContainer.addChild(icon);
                buttonData.icon = icon;

                // Label (only for active button - Archero style)
                if (isActive) {
                    const label = new PIXI.Text({
                        text: section.name,
                        style: {
                            fontSize: 40, // Bigger label
                            fill: 0x4A2F1A, // Dark brown - kontrast i√ßin
                            fontWeight: '900',
                            stroke: { color: 0xFFE55C, width: 4 }, // Light gold stroke - parlak
                            dropShadow: {
                                distance: 3,
                                alpha: 0.6,
                                blur: 3,
                                color: 0x000000
                            }
                        }
                    });
                    label.anchor.set(0.5);
                    label.y = 55; // Move label up more
                    buttonContainer.addChild(label);
                    buttonData.label = label;
                }

                // Notification badge (red dot - some buttons have this)
                if (index !== activeSection && Math.random() > 0.5) {
                    const badge = new PIXI.Graphics();
                    badge.circle(size/2 - 20, -size/2 + 20, 18);
                    badge.fill({ color: COLORS.red });
                    badge.stroke({ color: 0xFFFFFF, width: 4 });

                    const exclamation = new PIXI.Text({
                        text: '!',
                        style: {
                            fontSize: 24,
                            fill: 0xFFFFFF,
                            fontWeight: 'bold'
                        }
                    });
                    exclamation.anchor.set(0.5);
                    exclamation.position.set(size/2 - 20, -size/2 + 20);
                    buttonContainer.addChild(badge);
                    buttonContainer.addChild(exclamation);
                }

                // Make interactive
                buttonContainer.eventMode = 'static';
                buttonContainer.cursor = 'pointer';

                // Click handler
                buttonContainer.on('pointerdown', () => {
                    if (!isAnimating && index !== activeSection) {
                        switchToSection(index);
                    }
                });

                // Hover effect (scale pulse)
                buttonContainer.on('pointerover', () => {
                    if (index !== activeSection) {
                        gsap.to(buttonContainer.scale, { x: 1.1, y: 1.1, duration: 0.2 });
                    }
                });

                buttonContainer.on('pointerout', () => {
                    if (index !== activeSection) {
                        gsap.to(buttonContainer.scale, { x: 1, y: 1, duration: 0.2 });
                    }
                });

                navButtons.push(buttonData);
                navBar.addChild(buttonContainer);
            });

            // Particle system for tap effects
            const particlesContainer = new PIXI.Container();
            stage.addChild(particlesContainer);
            const particles = [];

            function createParticles(x, y, color) {
                for (let i = 0; i < 30; i++) {
                    const particle = new PIXI.Graphics();
                    const size = Math.random() * 8 + 3;
                    particle.circle(0, 0, size);
                    particle.fill({ color, alpha: 1 });
                    particle.stroke({ color: 0xFFFFFF, width: 2 });

                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 12 + 6;

                    particle.x = x;
                    particle.y = y;
                    particle.vx = Math.cos(angle) * speed;
                    particle.vy = Math.sin(angle) * speed;
                    particle.life = 1.0;

                    particlesContainer.addChild(particle);
                    particles.push(particle);
                }
            }

            // Animation function - Archero style
            function switchToSection(newSection) {
                if (isAnimating) return;
                isAnimating = true;

                const oldSection = activeSection;
                activeSection = newSection;

                // Emit particles
                const clicked = navButtons[newSection];
                createParticles(
                    clicked.container.x,
                    clicked.container.y + navBar.y,
                    clicked.section.iconColor
                );

                // Scroll content with bounce
                gsap.to(contentContainer, {
                    x: -BASE_WIDTH * newSection,
                    duration: 0.5,
                    ease: 'back.out(1.2)',
                    onComplete: () => { isAnimating = false; }
                });

                // Animate NEW active button
                const newBtn = navButtons[newSection];

                // Recreate background as active with Pixi.js v8 gradient API
                newBtn.bg.clear();

                const gradient = new PIXI.FillGradient({
                    type: 'linear',
                    start: { x: 0, y: 0 },
                    end: { x: 0, y: 1 },
                    colorStops: [
                        { offset: 0, color: 0xFFE55C },    // Light gold top
                        { offset: 0.5, color: 0xFFD700 },  // Gold middle
                        { offset: 1, color: 0xFFA500 }     // Orange bottom
                    ]
                });

                newBtn.bg.roundRect(-ACTIVE_BUTTON_SIZE/2, -ACTIVE_BUTTON_SIZE/2, ACTIVE_BUTTON_SIZE, ACTIVE_BUTTON_SIZE, 30);
                newBtn.bg.fill(gradient);

                // Add shine/highlight overlay if not exists - single gradient
                if (!newBtn.overlay) {
                    const overlay = new PIXI.Graphics();
                    const overlayWidth = ACTIVE_BUTTON_SIZE * 0.92; // 92% of button width - wider
                    const overlayHeight = ACTIVE_BUTTON_SIZE * 0.22; // Taller for more shine coverage

                    // Single gradient overlay for smooth shine effect
                    const shineGradient = new PIXI.FillGradient({
                        type: 'linear',
                        start: { x: 0, y: 0 },
                        end: { x: 0, y: 1 },
                        colorStops: [
                            { offset: 0, color: 0xFFFFFF },      // Pure white at top
                            { offset: 0.8, color: 0xFFE55C },    // Light gold
                            { offset: 1, color: 0xFFD700 }       // Gold at bottom
                        ]
                    });

                    overlay.roundRect(-overlayWidth/2, -ACTIVE_BUTTON_SIZE/2 + 8, overlayWidth, overlayHeight, 25);
                    overlay.fill(shineGradient);
                    overlay.alpha = 0.5; // Overall shine brightness
                    newBtn.container.addChildAt(overlay, newBtn.container.getChildIndex(newBtn.bg) + 1);
                    newBtn.overlay = overlay;
                }

                // Move button up (elevated)
                gsap.to(newBtn.container, {
                    y: NAV_HEIGHT / 2 - 40,
                    duration: 0.5,
                    ease: 'elastic.out(1, 0.5)'
                });

                // Scale up with elastic bounce
                gsap.to(newBtn.container.scale, {
                    x: 1.0,
                    y: 1.0,
                    duration: 0.5,
                    ease: 'elastic.out(1, 0.5)'
                });

                // Icon grows and moves up
                gsap.to(newBtn.icon, {
                    y: -35, // Move up more
                    duration: 0.3,
                    ease: 'back.out(2)'
                });
                gsap.to(newBtn.icon.style, {
                    fontSize: 140, // Bigger icon size
                    duration: 0.3
                });

                // Add label
                if (!newBtn.label) {
                    const label = new PIXI.Text({
                        text: newBtn.section.name,
                        style: {
                            fontSize: 40, // Bigger label
                            fill: 0x4A2F1A, // Dark brown - kontrast i√ßin
                            fontWeight: '900',
                            stroke: { color: 0xFFE55C, width: 4 } // Light gold stroke - parlak
                        }
                    });
                    label.anchor.set(0.5);
                    label.y = 55; // Move up more
                    label.alpha = 0;
                    newBtn.container.addChild(label);
                    newBtn.label = label;

                    gsap.to(label, { alpha: 1, duration: 0.3, delay: 0.2 });
                }

                // Animate OLD active button
                const oldBtn = navButtons[oldSection];

                // Recreate background as inactive (transparent/borderless)
                oldBtn.bg.clear();
                oldBtn.bg.rect(-BUTTON_SIZE/2, -BUTTON_SIZE/2, BUTTON_SIZE, BUTTON_SIZE);
                oldBtn.bg.fill({ color: 0x000000, alpha: 0.0 }); // Completely transparent

                // Remove overlay
                if (oldBtn.overlay) {
                    oldBtn.container.removeChild(oldBtn.overlay);
                    oldBtn.overlay = null;
                }

                // Move button back down
                gsap.to(oldBtn.container, {
                    y: NAV_HEIGHT / 2,
                    duration: 0.3,
                    ease: 'power2.out'
                });

                // Scale down
                gsap.to(oldBtn.container.scale, {
                    x: 1.0,
                    y: 1.0,
                    duration: 0.3,
                    ease: 'power2.out'
                });

                // Icon shrinks and moves to inactive position
                gsap.to(oldBtn.icon, {
                    y: -10, // Match inactive icon position
                    duration: 0.3
                });
                gsap.to(oldBtn.icon.style, {
                    fontSize: 90, // Match inactive icon size
                    duration: 0.3
                });

                // Remove label
                if (oldBtn.label) {
                    gsap.to(oldBtn.label, {
                        alpha: 0,
                        duration: 0.2,
                        onComplete: () => {
                            if (oldBtn.label) {
                                oldBtn.container.removeChild(oldBtn.label);
                                oldBtn.label = null;
                            }
                        }
                    });
                }

                // Reposition ALL buttons to make space for the new active button
                navButtons.forEach((btn, i) => {
                    // Recalculate positions based on new active button
                    const totalButtonsWidth = ACTIVE_BUTTON_SIZE + (BUTTON_SIZE * (sections.length - 1));
                    const totalSpacing = availableWidth - totalButtonsWidth;
                    const spacingBetweenButtons = totalSpacing / (sections.length - 1);

                    let xPos = padding;

                    for (let j = 0; j < i; j++) {
                        const btnSize = (j === newSection) ? ACTIVE_BUTTON_SIZE : BUTTON_SIZE;
                        xPos += btnSize + spacingBetweenButtons;
                    }

                    // Add half of current button size to center it
                    const currentSize = (i === newSection) ? ACTIVE_BUTTON_SIZE : BUTTON_SIZE;
                    xPos += currentSize / 2;

                    // Animate to new position
                    gsap.to(btn.container, {
                        x: xPos,
                        duration: 0.4,
                        ease: 'power2.out'
                    });
                });
            }

            // Touch/Swipe support
            let touchStartX = 0;
            stage.eventMode = 'static';
            stage.hitArea = new PIXI.Rectangle(0, 0, BASE_WIDTH, BASE_HEIGHT);

            stage.on('pointerdown', (e) => {
                if (e.target === stage) {
                    touchStartX = e.global.x;
                }
            });

            stage.on('pointerup', (e) => {
                if (e.target === stage) {
                    const deltaX = e.global.x - touchStartX;
                    if (Math.abs(deltaX) > 100) {
                        if (deltaX < 0 && activeSection < sections.length - 1) {
                            switchToSection(activeSection + 1);
                        } else if (deltaX > 0 && activeSection > 0) {
                            switchToSection(activeSection - 1);
                        }
                    }
                }
            });

            // Particle update loop
            renderer.on('tick', (deltaTime) => {
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx * deltaTime * 0.016;
                    p.y += p.vy * deltaTime * 0.016;
                    p.vy += 0.3; // gravity
                    p.life -= deltaTime * 0.02;
                    p.alpha = p.life;
                    p.scale.set(p.life);

                    if (p.life <= 0) {
                        particlesContainer.removeChild(p);
                        particles.splice(i, 1);
                    }
                }
            });

            // Resize handler
            window.addEventListener('resize', () => {
                const newSize = getCanvasSize();
                canvas.style.width = newSize.width + 'px';
                canvas.style.height = newSize.height + 'px';
            });

            // Start game loop
            game.start();

            console.log('üë∂ Stage children after adding all:', stage.children.length);
            console.log('üì¶ Content container children:', contentContainer.children.length);
            console.log('üé® UI container children:', uiContainer.children.length);
            console.log('‚ú® Archero-style menu loaded!');
            console.log('üì± Swipe or tap to navigate');

            } catch (error) {
                console.error('‚ùå Error initializing game:', error);
                document.getElementById('loading').textContent = 'Error: ' + error.message;
            }
        }
    </script>
</body>
</html>
