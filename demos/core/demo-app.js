/**\n * Demo Application - Comprehensive GameByte Framework demonstration\n * \n * This application demonstrates:\n * - Laravel-inspired architecture with DI/IoC patterns\n * - Service provider lifecycle management\n * - Facade pattern for clean static APIs\n * - Scene management with smooth transitions\n * - Event-driven service communication\n * - Mobile-first responsive design\n */\n\n// Import core framework components\nimport { GameByte } from '../../dist/index.js';\nimport { Facade } from '../../dist/facades/Facade.js';\n\n// Import demo service providers\nimport { DemoServiceProvider } from './providers/DemoServiceProvider.js';\nimport { DemoUIServiceProvider } from './providers/DemoUIServiceProvider.js';\n\n// Import demo facades\nimport { DemoScore } from './facades/DemoScore.js';\nimport { DemoGameState } from './facades/DemoGameState.js';\nimport { DemoNotifications } from './facades/DemoNotifications.js';\n\n// Import demo scenes\nimport { DemoSplashScene } from './scenes/DemoSplashScene.js';\nimport { DemoMainMenuScene } from './scenes/DemoMainMenuScene.js';\nimport { DemoGameplayScene } from './scenes/DemoGameplayScene.js';\n\n// Import services for direct registration (alternative to providers)\nimport { ScoreService } from './services/ScoreService.js';\nimport { GameStateService } from './services/GameStateService.js';\nimport { NotificationService } from './services/NotificationService.js';\n\n/**\n * Demo Application Class\n * \n * Orchestrates the entire demo, showcasing:\n * - Framework initialization and bootstrapping\n * - Service provider registration and booting\n * - Facade setup and static API access\n * - Scene management and transitions\n * - Cross-service communication via events\n */\nexport class DemoApplication {\n  constructor() {\n    // Create GameByte framework instance\n    this.app = GameByte.create();\n    \n    // Demo state\n    this.canvas = null;\n    this.renderer = null;\n    this.isRunning = false;\n    this.lastFrameTime = 0;\n    this.frameCount = 0;\n    \n    // Scene management\n    this.scenes = new Map();\n    this.currentScene = null;\n    this.sceneTransition = null;\n    \n    // Touch handling\n    this.touchHandlers = [];\n    \n    console.log('🚀 DemoApplication: Created with GameByte Framework v' + GameByte.VERSION);\n  }\n  \n  /**\n   * Initialize the demo application\n   * \n   * Demonstrates the complete framework initialization process:\n   * 1. Register service providers (DI/IoC pattern)\n   * 2. Boot all services (lifecycle management)\n   * 3. Setup facades (static API access)\n   * 4. Initialize scenes (scene management)\n   * 5. Setup event system (cross-service communication)\n   */\n  async initialize(canvas) {\n    try {\n      console.log('🎬 DemoApplication: Starting initialization...');\n      \n      this.canvas = canvas;\n      \n      // Step 1: Register Service Providers\n      // This demonstrates the Laravel-inspired service provider pattern\n      console.log('📦 DemoApplication: Registering service providers...');\n      await this.registerServiceProviders();\n      \n      // Step 2: Boot the Framework\n      // This triggers the service provider boot methods\n      console.log('🚀 DemoApplication: Booting framework...');\n      await this.app.boot();\n      \n      // Step 3: Setup Facades\n      // This enables clean static API access to services\n      console.log('🎭 DemoApplication: Setting up facades...');\n      this.setupFacades();\n      \n      // Step 4: Initialize Canvas Renderer\n      // Setup basic 2D canvas rendering\n      console.log('🎨 DemoApplication: Initializing renderer...');\n      this.setupRenderer();\n      \n      // Step 5: Register Scenes\n      // Setup scene management system\n      console.log('🎬 DemoApplication: Registering scenes...');\n      await this.registerScenes();\n      \n      // Step 6: Setup Event System\n      // Connect services through events\n      console.log('📡 DemoApplication: Setting up event system...');\n      this.setupEventSystem();\n      \n      // Step 7: Setup Input Handling\n      // Mobile-first touch and keyboard input\n      console.log('👆 DemoApplication: Setting up input handling...');\n      this.setupInputHandling();\n      \n      // Step 8: Initialize UI Notification System\n      console.log('📱 DemoApplication: Initializing UI system...');\n      this.initializeUI();\n      \n      console.log('✅ DemoApplication: Initialization complete!');\n      \n      // Show welcome notification\n      DemoNotifications.showSuccess('GameByte Framework Demo loaded successfully!');\n      \n    } catch (error) {\n      console.error('❌ DemoApplication: Initialization failed:', error);\n      this.showError('Initialization Failed', error.message, error.stack);\n      throw error;\n    }\n  }\n  \n  /**\n   * Register Service Providers\n   * \n   * Demonstrates the service provider pattern:\n   * - DI container registration\n   * - Service lifecycle management\n   * - Cross-service dependencies\n   */\n  async registerServiceProviders() {\n    console.log('  📋 Registering DemoServiceProvider...');\n    this.app.register(new DemoServiceProvider());\n    \n    console.log('  📋 Registering DemoUIServiceProvider...');\n    this.app.register(new DemoUIServiceProvider());\n    \n    // Alternative: Direct service registration (without providers)\n    // This shows the flexibility of the DI container\n    console.log('  📋 Registering services directly...');\n    \n    // These would normally be registered by service providers,\n    // but we can also register them directly for demonstration\n    this.app.singleton('demo.score.direct', () => new ScoreService());\n    this.app.singleton('demo.gamestate.direct', () => new GameStateService());\n    this.app.singleton('demo.notifications.direct', () => new NotificationService());\n    \n    console.log('✅ Service providers registered successfully');\n  }\n  \n  /**\n   * Setup Facades\n   * \n   * Demonstrates the facade pattern:\n   * - Static API access to services\n   * - Clean, expressive syntax\n   * - Service resolution through DI container\n   */\n  setupFacades() {\n    // Set application instance on all facades\n    DemoScore.setApplication(this.app);\n    DemoGameState.setApplication(this.app);\n    DemoNotifications.setApplication(this.app);\n    \n    // Also set on base Facade class for framework facades\n    Facade.setApplication(this.app);\n    \n    console.log('✅ Facades configured with application instance');\n  }\n  \n  /**\n   * Setup basic canvas renderer\n   */\n  setupRenderer() {\n    this.renderer = {\n      canvas: this.canvas,\n      ctx: this.canvas.getContext('2d'),\n      width: this.canvas.width,\n      height: this.canvas.height,\n      \n      clear: () => {\n        this.renderer.ctx.clearRect(0, 0, this.renderer.width, this.renderer.height);\n      },\n      \n      getContext: () => this.renderer.ctx\n    };\n    \n    console.log('✅ Canvas renderer initialized');\n  }\n  \n  /**\n   * Register Demo Scenes\n   * \n   * Demonstrates scene management:\n   * - Scene lifecycle (initialize -> activate -> deactivate -> destroy)\n   * - Scene transitions\n   * - State management between scenes\n   */\n  async registerScenes() {\n    // Create and register scenes\n    const splashScene = new DemoSplashScene();\n    const mainMenuScene = new DemoMainMenuScene();\n    const gameplayScene = new DemoGameplayScene();\n    \n    this.scenes.set('splash', splashScene);\n    this.scenes.set('mainmenu', mainMenuScene);\n    this.scenes.set('gameplay', gameplayScene);\n    \n    // Initialize all scenes\n    for (const [name, scene] of this.scenes) {\n      console.log(`  🎬 Initializing ${name} scene...`);\n      await scene.initialize();\n      \n      // Setup scene event handlers\n      this.setupSceneEventHandlers(scene);\n    }\n    \n    console.log('✅ All scenes registered and initialized');\n  }\n  \n  /**\n   * Setup Scene Event Handlers\n   * \n   * Demonstrates event-driven architecture:\n   * - Scene-to-scene communication\n   * - Service integration with scenes\n   * - UI feedback and notifications\n   */\n  setupSceneEventHandlers(scene) {\n    switch (scene.id) {\n      case 'splash':\n        scene.on('complete', () => {\n          this.transitionToScene('mainmenu');\n        });\n        break;\n        \n      case 'mainmenu':\n        scene.on('button:play', () => {\n          DemoNotifications.showInfo('Starting interactive demo...');\n          this.transitionToScene('gameplay');\n        });\n        \n        scene.on('button:architecture', () => {\n          this.showArchitectureDemo();\n        });\n        \n        scene.on('button:services', () => {\n          this.showServicesDemo();\n        });\n        \n        scene.on('button:facades', () => {\n          this.showFacadesDemo();\n        });\n        \n        scene.on('button:settings', () => {\n          this.showSettingsDemo();\n        });\n        break;\n        \n      case 'gameplay':\n        scene.on('score:add', (points, reason) => {\n          DemoScore.addScore(points, reason);\n        });\n        \n        scene.on('combo:achieved', (combo, points) => {\n          DemoNotifications.comboAchieved(combo, points);\n        });\n        \n        scene.on('obstacle:hit', () => {\n          DemoNotifications.showWarning('Obstacle hit! Combo reset.');\n        });\n        \n        scene.on('paused', () => {\n          DemoGameState.pauseGame();\n        });\n        \n        scene.on('resumed', () => {\n          DemoGameState.resumeGame();\n        });\n        break;\n    }\n  }\n  \n  /**\n   * Setup Event System\n   * \n   * Demonstrates cross-service communication:\n   * - Service-to-service events\n   * - Application-level event handling\n   * - UI updates from service events\n   */\n  setupEventSystem() {\n    // Listen for score changes and update UI\n    DemoScore.on('score:changed', (data) => {\n      if (this.currentScene && this.currentScene.id === 'gameplay') {\n        this.currentScene.updateUI({\n          score: data.current,\n          highScore: DemoScore.getHighScore()\n        });\n      }\n    });\n    \n    // Listen for high score achievements\n    DemoScore.on('highscore:achieved', (data) => {\n      DemoNotifications.gameOver(data.newScore, true);\n    });\n    \n    // Listen for state changes\n    DemoGameState.on('state:changed', (data) => {\n      console.log(`🔄 State changed: ${data.previous} -> ${data.current}`);\n    });\n    \n    // Listen for FPS updates\n    DemoGameState.on('fps:updated', (fps) => {\n      if (this.currentScene && this.currentScene.id === 'gameplay') {\n        this.currentScene.updateUI({ fps });\n      }\n    });\n    \n    // Listen for performance warnings\n    DemoGameState.on('performance:warning', (data) => {\n      if (data.type === 'low_fps') {\n        DemoNotifications.lowPerformanceWarning(data.fps);\n      }\n    });\n    \n    console.log('✅ Event system configured');\n  }\n  \n  /**\n   * Setup Input Handling\n   * \n   * Demonstrates mobile-first input:\n   * - Touch events with proper mobile optimization\n   * - Keyboard events for desktop testing\n   * - Input event delegation to current scene\n   */\n  setupInputHandling() {\n    // Touch events\n    this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });\n    this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });\n    this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });\n    \n    // Mouse events for desktop testing\n    this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));\n    this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));\n    this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));\n    \n    // Keyboard events\n    document.addEventListener('keydown', this.handleKeyDown.bind(this));\n    \n    // Prevent default touch behaviors\n    document.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });\n    document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });\n    \n    console.log('✅ Mobile-first input handling configured');\n  }\n  \n  /**\n   * Initialize UI System\n   */\n  initializeUI() {\n    // Initialize notification system with canvas parent\n    DemoNotifications.initialize(this.canvas.parentElement);\n    \n    console.log('✅ UI system initialized');\n  }\n  \n  /**\n   * Start the demo application\n   * \n   * Demonstrates:\n   * - Application lifecycle management\n   * - Scene activation\n   * - Game loop initialization\n   */\n  async start() {\n    if (this.isRunning) return;\n    \n    console.log('▶️ DemoApplication: Starting...');\n    \n    // Set initial game state\n    DemoGameState.setState('splash');\n    \n    // Start with splash scene\n    await this.transitionToScene('splash');\n    \n    // Start game loop\n    this.isRunning = true;\n    this.lastFrameTime = performance.now();\n    this.gameLoop();\n    \n    console.log('✅ DemoApplication: Started successfully');\n  }\n  \n  /**\n   * Main Game Loop\n   * \n   * Demonstrates:\n   * - Frame rate management\n   * - Scene update and render cycle\n   * - Performance monitoring\n   */\n  gameLoop() {\n    if (!this.isRunning) return;\n    \n    const currentTime = performance.now();\n    const deltaTime = (currentTime - this.lastFrameTime) / 1000; // Convert to seconds\n    this.lastFrameTime = currentTime;\n    \n    // Update frame rate tracking\n    this.frameCount++;\n    if (this.frameCount % 60 === 0) {\n      DemoGameState.updateFPS();\n    }\n    \n    // Clear canvas\n    this.renderer.clear();\n    \n    // Update and render current scene\n    if (this.currentScene) {\n      this.currentScene.update(deltaTime);\n      this.currentScene.render(this.renderer);\n    }\n    \n    // Continue game loop\n    requestAnimationFrame(() => this.gameLoop());\n  }\n  \n  /**\n   * Transition to a different scene\n   * \n   * Demonstrates:\n   * - Scene lifecycle management\n   * - Smooth scene transitions\n   * - State management during transitions\n   */\n  async transitionToScene(sceneId) {\n    const targetScene = this.scenes.get(sceneId);\n    if (!targetScene) {\n      console.error(`❌ Scene '${sceneId}' not found`);\n      return;\n    }\n    \n    console.log(`🎬 Transitioning to scene: ${sceneId}`);\n    \n    // Deactivate current scene\n    if (this.currentScene) {\n      this.currentScene.deactivate();\n    }\n    \n    // Activate new scene\n    this.currentScene = targetScene;\n    this.currentScene.activate();\n    \n    // Update game state\n    const stateMap = {\n      'splash': 'splash',\n      'mainmenu': 'menu',\n      'gameplay': 'playing'\n    };\n    \n    if (stateMap[sceneId]) {\n      DemoGameState.setState(stateMap[sceneId]);\n    }\n  }\n  \n  /**\n   * Touch Event Handlers\n   */\n  handleTouchStart(event) {\n    event.preventDefault();\n    \n    for (const touch of event.changedTouches) {\n      const rect = this.canvas.getBoundingClientRect();\n      const x = touch.clientX - rect.left;\n      const y = touch.clientY - rect.top;\n      \n      if (this.currentScene && this.currentScene.handleTouch) {\n        this.currentScene.handleTouch(x, y);\n      }\n    }\n  }\n  \n  handleTouchMove(event) {\n    event.preventDefault();\n    // Handle touch move if needed\n  }\n  \n  handleTouchEnd(event) {\n    event.preventDefault();\n    // Handle touch end if needed\n  }\n  \n  /**\n   * Mouse Event Handlers (for desktop testing)\n   */\n  handleMouseDown(event) {\n    const rect = this.canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    \n    if (this.currentScene && this.currentScene.handleTouch) {\n      this.currentScene.handleTouch(x, y);\n    }\n  }\n  \n  handleMouseMove(event) {\n    // Handle mouse move if needed\n  }\n  \n  handleMouseUp(event) {\n    // Handle mouse up if needed\n  }\n  \n  /**\n   * Keyboard Event Handler\n   */\n  handleKeyDown(event) {\n    if (this.currentScene && this.currentScene.handleKeyboard) {\n      if (this.currentScene.handleKeyboard(event.key)) {\n        event.preventDefault();\n      }\n    }\n  }\n  \n  /**\n   * Handle Escape Key (global)\n   */\n  handleEscape() {\n    if (this.currentScene && this.currentScene.id === 'gameplay') {\n      if (DemoGameState.isPaused()) {\n        this.transitionToScene('mainmenu');\n      } else {\n        DemoGameState.pauseGame();\n      }\n    } else if (this.currentScene && this.currentScene.id !== 'mainmenu') {\n      this.transitionToScene('mainmenu');\n    }\n  }\n  \n  /**\n   * Handle Space Key (global)\n   */\n  handleSpace() {\n    if (this.currentScene && this.currentScene.id === 'gameplay') {\n      DemoGameState.togglePause();\n    }\n  }\n  \n  /**\n   * Handle Resize Events\n   */\n  handleResize() {\n    if (this.canvas && this.renderer) {\n      const rect = this.canvas.getBoundingClientRect();\n      const dpr = window.devicePixelRatio || 1;\n      \n      this.canvas.width = rect.width * dpr;\n      this.canvas.height = rect.height * dpr;\n      this.canvas.style.width = rect.width + 'px';\n      this.canvas.style.height = rect.height + 'px';\n      \n      this.renderer.width = this.canvas.width;\n      this.renderer.height = this.canvas.height;\n      \n      // Scale context for high DPI displays\n      this.renderer.ctx.scale(dpr, dpr);\n      \n      console.log(`📐 Canvas resized: ${rect.width}x${rect.height} (${this.canvas.width}x${this.canvas.height})`);\n    }\n  }\n  \n  /**\n   * Architecture Demo\n   * \n   * Demonstrates DI/IoC patterns in action\n   */\n  showArchitectureDemo() {\n    console.log('🏗️ Architecture Demo:');\n    \n    // Show service container contents\n    const container = this.app.getContainer();\n    const bindings = container.getBindings();\n    \n    console.log('  📋 DI Container bindings:');\n    for (const [key] of bindings) {\n      console.log(`    - ${key}`);\n    }\n    \n    // Show service provider information\n    const providers = this.app.getProviders();\n    console.log('  📦 Registered service providers:');\n    for (const [name, provider] of providers) {\n      console.log(`    - ${name}: ${provider.constructor.name}`);\n    }\n    \n    DemoNotifications.showInfo('Architecture information logged to console');\n  }\n  \n  /**\n   * Services Demo\n   * \n   * Demonstrates service integration and cross-service communication\n   */\n  showServicesDemo() {\n    console.log('⚙️ Services Demo:');\n    \n    // Demonstrate service resolution\n    const scoreService = this.app.make('demo.score');\n    const gameStateService = this.app.make('demo.gamestate');\n    const notificationService = this.app.make('demo.notifications');\n    \n    console.log('  📊 Service instances resolved:');\n    console.log('    - ScoreService:', scoreService.constructor.name);\n    console.log('    - GameStateService:', gameStateService.constructor.name);\n    console.log('    - NotificationService:', notificationService.constructor.name);\n    \n    // Demonstrate service interaction\n    console.log('  🔄 Service interaction example:');\n    const currentScore = scoreService.currentScore;\n    const currentState = gameStateService.currentState;\n    \n    console.log(`    - Current score: ${currentScore}`);\n    console.log(`    - Current state: ${currentState}`);\n    \n    DemoNotifications.showInfo('Service information logged to console');\n  }\n  \n  /**\n   * Facades Demo\n   * \n   * Demonstrates static API access through facades\n   */\n  showFacadesDemo() {\n    console.log('🎭 Facades Demo:');\n    \n    // Demonstrate facade usage\n    console.log('  📊 Facade API examples:');\n    \n    const score = DemoScore.getCurrentScore();\n    const highScore = DemoScore.getHighScore();\n    const state = DemoGameState.getCurrentState();\n    const settings = DemoGameState.getSettings();\n    \n    console.log(`    - DemoScore.getCurrentScore(): ${score}`);\n    console.log(`    - DemoScore.getHighScore(): ${highScore}`);\n    console.log(`    - DemoGameState.getCurrentState(): ${state}`);\n    console.log('    - DemoGameState.getSettings():', settings);\n    \n    // Demonstrate facade method calls\n    DemoScore.addScore(100, 'facade_demo');\n    DemoGameState.updateSetting('demo_run', true);\n    \n    DemoNotifications.showInfo('Facade examples logged to console and demonstrated');\n  }\n  \n  /**\n   * Settings Demo\n   * \n   * Demonstrates settings management through services\n   */\n  showSettingsDemo() {\n    console.log('⚙️ Settings Demo:');\n    \n    const currentSettings = DemoGameState.getSettings();\n    console.log('  📋 Current settings:', currentSettings);\n    \n    // Toggle some settings for demonstration\n    const newSoundState = !DemoGameState.getSetting('soundEnabled');\n    DemoGameState.updateSetting('soundEnabled', newSoundState);\n    \n    const newVolume = Math.random();\n    DemoGameState.updateSetting('soundVolume', newVolume);\n    \n    console.log(`  🔄 Updated soundEnabled to: ${newSoundState}`);\n    console.log(`  🔄 Updated soundVolume to: ${newVolume.toFixed(2)}`);\n    \n    DemoNotifications.showInfo('Settings updated - check console for details');\n  }\n  \n  /**\n   * Show Error\n   */\n  showError(title, message, details) {\n    console.error(`❌ ${title}: ${message}`);\n    if (details) console.error(details);\n    \n    // Try to show error notification if possible\n    try {\n      if (DemoNotifications && DemoNotifications.showError) {\n        DemoNotifications.showError(message, details);\n      }\n    } catch (e) {\n      console.error('Failed to show error notification:', e);\n    }\n  }\n  \n  /**\n   * Stop the demo application\n   */\n  stop() {\n    console.log('⏹️ DemoApplication: Stopping...');\n    \n    this.isRunning = false;\n    \n    if (this.currentScene) {\n      this.currentScene.deactivate();\n    }\n    \n    console.log('✅ DemoApplication: Stopped');\n  }\n  \n  /**\n   * Destroy the demo application\n   */\n  destroy() {\n    console.log('🧹 DemoApplication: Destroying...');\n    \n    this.stop();\n    \n    // Destroy all scenes\n    for (const scene of this.scenes.values()) {\n      scene.destroy();\n    }\n    this.scenes.clear();\n    \n    // Destroy framework\n    if (this.app) {\n      this.app.destroy();\n    }\n    \n    console.log('✅ DemoApplication: Destroyed');\n  }\n}