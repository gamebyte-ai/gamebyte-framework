import { EventEmitter } from 'eventemitter3';

/**
 * Demo Gameplay Scene - showcases interactive demo with service integration
 * 
 * This scene demonstrates:
 * - Real-time service interaction through facades
 * - Mobile-optimized gameplay with touch controls
 * - Score system integration
 * - State management during gameplay
 * - Performance monitoring and optimization
 */
export class DemoGameplayScene extends EventEmitter {
  constructor() {\n    super();\n    \n    // Scene identification\n    this.id = 'gameplay';\n    this.name = 'Interactive Demo';\n    \n    // Scene state\n    this.isActive = false;\n    this.initialized = false;\n    this.isPaused = false;\n    \n    // Game objects\n    this.player = null;\n    this.collectibles = [];\n    this.particles = [];\n    this.obstacles = [];\n    \n    // Timing\n    this.lastUpdateTime = 0;\n    this.gameStartTime = 0;\n    this.gameDuration = 0;\n    \n    // Score tracking\n    this.scoreMultiplier = 1;\n    this.combo = 0;\n    this.lastCollectTime = 0;\n    \n    // UI elements\n    this.ui = {\n      score: 0,\n      highScore: 0,\n      multiplier: 1,\n      fps: 60,\n      showDebugInfo: false\n    };\n    \n    // Game settings\n    this.settings = {\n      spawnRate: 1000, // ms between spawns\n      playerSpeed: 200, // pixels per second\n      collectibleSpeed: 100,\n      maxCollectibles: 10,\n      comboTimeWindow: 2000, // ms\n      difficultyIncrease: 0.1\n    };\n    \n    // Touch controls\n    this.touchControls = {\n      isPressed: false,\n      startX: 0,\n      startY: 0,\n      currentX: 0,\n      currentY: 0\n    };\n    \n    // Colors\n    this.colors = {\n      background: '#0a0a0a',\n      player: '#007AFF',\n      collectible: '#34C759',\n      obstacle: '#FF3B30',\n      particle: '#FFD60A',\n      ui: '#FFFFFF',\n      uiSecondary: '#8E8E93'\n    };\n    \n    console.log('🎮 DemoGameplayScene: Created');\n  }\n  \n  /**\n   * Initialize the scene\n   */\n  async initialize() {\n    if (this.initialized) return;\n    \n    console.log('🚀 DemoGameplayScene: Initializing...');\n    \n    // Initialize game objects\n    this.initializePlayer();\n    this.initializeGameObjects();\n    \n    this.initialized = true;\n    this.emit('initialized');\n    \n    console.log('✅ DemoGameplayScene: Initialized successfully');\n  }\n  \n  /**\n   * Initialize player\n   */\n  initializePlayer() {\n    this.player = {\n      x: 100,\n      y: 300,\n      width: 30,\n      height: 30,\n      speed: this.settings.playerSpeed,\n      targetX: 100,\n      targetY: 300,\n      trail: [],\n      color: this.colors.player\n    };\n  }\n  \n  /**\n   * Initialize game objects\n   */\n  initializeGameObjects() {\n    this.collectibles = [];\n    this.particles = [];\n    this.obstacles = [];\n    this.combo = 0;\n    this.scoreMultiplier = 1;\n  }\n  \n  /**\n   * Activate the scene\n   */\n  activate() {\n    if (this.isActive) return;\n    \n    this.isActive = true;\n    this.isPaused = false;\n    this.gameStartTime = Date.now();\n    this.lastUpdateTime = this.gameStartTime;\n    \n    // Reset game state\n    this.initializeGameObjects();\n    this.initializePlayer();\n    \n    // Start spawning collectibles\n    this.startSpawning();\n    \n    this.emit('activated');\n    console.log('▶️ DemoGameplayScene: Activated');\n  }\n  \n  /**\n   * Start spawning game objects\n   */\n  startSpawning() {\n    this.spawnInterval = setInterval(() => {\n      if (this.isActive && !this.isPaused) {\n        this.spawnCollectible();\n        \n        // Occasionally spawn obstacles\n        if (Math.random() < 0.3) {\n          this.spawnObstacle();\n        }\n      }\n    }, this.settings.spawnRate);\n  }\n  \n  /**\n   * Spawn a collectible\n   */\n  spawnCollectible() {\n    if (this.collectibles.length >= this.settings.maxCollectibles) return;\n    \n    const collectible = {\n      x: 800 + Math.random() * 200,\n      y: 50 + Math.random() * 500,\n      width: 20,\n      height: 20,\n      speed: this.settings.collectibleSpeed * (1 + this.gameDuration / 60000), // Increase with time\n      value: 10 + Math.floor(Math.random() * 20),\n      type: Math.random() < 0.8 ? 'normal' : 'bonus',\n      color: Math.random() < 0.8 ? this.colors.collectible : this.colors.particle,\n      rotation: 0,\n      rotationSpeed: (Math.random() - 0.5) * 360 // degrees per second\n    };\n    \n    if (collectible.type === 'bonus') {\n      collectible.value *= 3;\n    }\n    \n    this.collectibles.push(collectible);\n  }\n  \n  /**\n   * Spawn an obstacle\n   */\n  spawnObstacle() {\n    const obstacle = {\n      x: 800 + Math.random() * 100,\n      y: 50 + Math.random() * 500,\n      width: 30,\n      height: 30,\n      speed: this.settings.collectibleSpeed * 0.8,\n      color: this.colors.obstacle,\n      rotation: 0,\n      rotationSpeed: 180\n    };\n    \n    this.obstacles.push(obstacle);\n  }\n  \n  /**\n   * Deactivate the scene\n   */\n  deactivate() {\n    if (!this.isActive) return;\n    \n    this.isActive = false;\n    \n    // Clear intervals\n    if (this.spawnInterval) {\n      clearInterval(this.spawnInterval);\n      this.spawnInterval = null;\n    }\n    \n    this.emit('deactivated');\n    console.log('⏸️ DemoGameplayScene: Deactivated');\n  }\n  \n  /**\n   * Pause the game\n   */\n  pause() {\n    this.isPaused = true;\n    this.emit('paused');\n    console.log('⏸️ DemoGameplayScene: Paused');\n  }\n  \n  /**\n   * Resume the game\n   */\n  resume() {\n    this.isPaused = false;\n    this.lastUpdateTime = Date.now();\n    this.emit('resumed');\n    console.log('▶️ DemoGameplayScene: Resumed');\n  }\n  \n  /**\n   * Update scene logic\n   */\n  update(deltaTime) {\n    if (!this.isActive || this.isPaused) return;\n    \n    const now = Date.now();\n    const dt = (now - this.lastUpdateTime) / 1000; // Convert to seconds\n    this.lastUpdateTime = now;\n    \n    this.gameDuration = now - this.gameStartTime;\n    \n    // Update game objects\n    this.updatePlayer(dt);\n    this.updateCollectibles(dt);\n    this.updateObstacles(dt);\n    this.updateParticles(dt);\n    \n    // Check collisions\n    this.checkCollisions();\n    \n    // Update combo system\n    this.updateCombo();\n    \n    // Clean up off-screen objects\n    this.cleanupObjects();\n    \n    this.emit('updated', deltaTime);\n  }\n  \n  /**\n   * Update player movement\n   */\n  updatePlayer(dt) {\n    if (!this.player) return;\n    \n    // Smooth movement towards target\n    const dx = this.player.targetX - this.player.x;\n    const dy = this.player.targetY - this.player.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    \n    if (distance > 5) {\n      const moveDistance = this.player.speed * dt;\n      const moveRatio = Math.min(moveDistance / distance, 1);\n      \n      this.player.x += dx * moveRatio;\n      this.player.y += dy * moveRatio;\n    }\n    \n    // Update trail\n    this.player.trail.push({ x: this.player.x, y: this.player.y, time: Date.now() });\n    this.player.trail = this.player.trail.filter(point => Date.now() - point.time < 500);\n  }\n  \n  /**\n   * Update collectibles\n   */\n  updateCollectibles(dt) {\n    for (const collectible of this.collectibles) {\n      collectible.x -= collectible.speed * dt;\n      collectible.rotation += collectible.rotationSpeed * dt;\n    }\n  }\n  \n  /**\n   * Update obstacles\n   */\n  updateObstacles(dt) {\n    for (const obstacle of this.obstacles) {\n      obstacle.x -= obstacle.speed * dt;\n      obstacle.rotation += obstacle.rotationSpeed * dt;\n    }\n  }\n  \n  /**\n   * Update particle effects\n   */\n  updateParticles(dt) {\n    for (const particle of this.particles) {\n      particle.x += particle.vx * dt;\n      particle.y += particle.vy * dt;\n      particle.life -= dt;\n      particle.alpha = Math.max(0, particle.life / particle.maxLife);\n      particle.scale *= 0.98; // Shrink over time\n    }\n  }\n  \n  /**\n   * Check collisions between game objects\n   */\n  checkCollisions() {\n    if (!this.player) return;\n    \n    // Check collectible collisions\n    for (let i = this.collectibles.length - 1; i >= 0; i--) {\n      const collectible = this.collectibles[i];\n      \n      if (this.checkCollision(this.player, collectible)) {\n        this.collectItem(collectible, i);\n      }\n    }\n    \n    // Check obstacle collisions\n    for (let i = this.obstacles.length - 1; i >= 0; i--) {\n      const obstacle = this.obstacles[i];\n      \n      if (this.checkCollision(this.player, obstacle)) {\n        this.hitObstacle(obstacle, i);\n      }\n    }\n  }\n  \n  /**\n   * Check collision between two objects\n   */\n  checkCollision(obj1, obj2) {\n    return obj1.x < obj2.x + obj2.width &&\n           obj1.x + obj1.width > obj2.x &&\n           obj1.y < obj2.y + obj2.height &&\n           obj1.y + obj1.height > obj2.y;\n  }\n  \n  /**\n   * Handle item collection\n   */\n  collectItem(collectible, index) {\n    // Remove collectible\n    this.collectibles.splice(index, 1);\n    \n    // Update combo\n    const now = Date.now();\n    if (now - this.lastCollectTime < this.settings.comboTimeWindow) {\n      this.combo++;\n    } else {\n      this.combo = 1;\n    }\n    this.lastCollectTime = now;\n    \n    // Calculate score with combo multiplier\n    const comboMultiplier = Math.min(1 + (this.combo - 1) * 0.1, 3); // Max 3x\n    const points = Math.floor(collectible.value * comboMultiplier * this.scoreMultiplier);\n    \n    // Add score through facade\n    this.emit('score:add', points, collectible.type === 'bonus' ? 'bonus_collected' : 'item_collected');\n    \n    // Create particle effect\n    this.createCollectionEffect(collectible.x, collectible.y, collectible.type === 'bonus');\n    \n    // Combo notification\n    if (this.combo > 1) {\n      this.emit('combo:achieved', this.combo, points);\n    }\n    \n    // Haptic feedback\n    if ('vibrate' in navigator) {\n      navigator.vibrate(collectible.type === 'bonus' ? [50, 25, 50] : [25]);\n    }\n  }\n  \n  /**\n   * Handle obstacle collision\n   */\n  hitObstacle(obstacle, index) {\n    // Remove obstacle\n    this.obstacles.splice(index, 1);\n    \n    // Break combo\n    this.combo = 0;\n    \n    // Create explosion effect\n    this.createExplosionEffect(obstacle.x, obstacle.y);\n    \n    // Reset multiplier\n    this.scoreMultiplier = 1;\n    \n    // Haptic feedback\n    if ('vibrate' in navigator) {\n      navigator.vibrate([100, 50, 100]);\n    }\n    \n    this.emit('obstacle:hit');\n  }\n  \n  /**\n   * Create collection particle effect\n   */\n  createCollectionEffect(x, y, isBonus) {\n    const particleCount = isBonus ? 12 : 6;\n    const color = isBonus ? this.colors.particle : this.colors.collectible;\n    \n    for (let i = 0; i < particleCount; i++) {\n      const angle = (Math.PI * 2 * i) / particleCount;\n      const speed = 100 + Math.random() * 100;\n      \n      this.particles.push({\n        x: x,\n        y: y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        life: 0.5 + Math.random() * 0.5,\n        maxLife: 1,\n        alpha: 1,\n        scale: 1,\n        color: color,\n        size: isBonus ? 6 : 4\n      });\n    }\n  }\n  \n  /**\n   * Create explosion particle effect\n   */\n  createExplosionEffect(x, y) {\n    for (let i = 0; i < 20; i++) {\n      const angle = Math.random() * Math.PI * 2;\n      const speed = 50 + Math.random() * 150;\n      \n      this.particles.push({\n        x: x,\n        y: y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        life: 0.3 + Math.random() * 0.4,\n        maxLife: 0.7,\n        alpha: 1,\n        scale: 1,\n        color: this.colors.obstacle,\n        size: 3 + Math.random() * 4\n      });\n    }\n  }\n  \n  /**\n   * Update combo system\n   */\n  updateCombo() {\n    const now = Date.now();\n    if (now - this.lastCollectTime > this.settings.comboTimeWindow && this.combo > 0) {\n      this.combo = 0;\n    }\n  }\n  \n  /**\n   * Clean up off-screen objects\n   */\n  cleanupObjects() {\n    // Remove off-screen collectibles\n    this.collectibles = this.collectibles.filter(obj => obj.x > -50);\n    \n    // Remove off-screen obstacles\n    this.obstacles = this.obstacles.filter(obj => obj.x > -50);\n    \n    // Remove dead particles\n    this.particles = this.particles.filter(particle => particle.life > 0);\n  }\n  \n  /**\n   * Render the gameplay scene\n   */\n  render(renderer) {\n    if (!this.isActive) return;\n    \n    const ctx = renderer.getContext ? renderer.getContext('2d') : renderer;\n    const canvas = ctx.canvas;\n    const width = canvas.width;\n    const height = canvas.height;\n    \n    // Clear canvas\n    ctx.fillStyle = this.colors.background;\n    ctx.fillRect(0, 0, width, height);\n    \n    // Render background pattern\n    this.renderBackground(ctx, width, height);\n    \n    // Render game objects\n    this.renderPlayer(ctx);\n    this.renderCollectibles(ctx);\n    this.renderObstacles(ctx);\n    this.renderParticles(ctx);\n    \n    // Render UI\n    this.renderUI(ctx, width, height);\n    \n    // Render pause overlay if paused\n    if (this.isPaused) {\n      this.renderPauseOverlay(ctx, width, height);\n    }\n    \n    this.emit('rendered', renderer);\n  }\n  \n  /**\n   * Render background pattern\n   */\n  renderBackground(ctx, width, height) {\n    ctx.save();\n    ctx.globalAlpha = 0.1;\n    ctx.strokeStyle = this.colors.ui;\n    ctx.lineWidth = 1;\n    \n    // Grid pattern\n    const gridSize = 50;\n    for (let x = 0; x < width; x += gridSize) {\n      ctx.beginPath();\n      ctx.moveTo(x, 0);\n      ctx.lineTo(x, height);\n      ctx.stroke();\n    }\n    \n    for (let y = 0; y < height; y += gridSize) {\n      ctx.beginPath();\n      ctx.moveTo(0, y);\n      ctx.lineTo(width, y);\n      ctx.stroke();\n    }\n    \n    ctx.restore();\n  }\n  \n  /**\n   * Render player with trail effect\n   */\n  renderPlayer(ctx) {\n    if (!this.player) return;\n    \n    // Render trail\n    ctx.save();\n    for (let i = 0; i < this.player.trail.length; i++) {\n      const point = this.player.trail[i];\n      const age = (Date.now() - point.time) / 500;\n      const alpha = (1 - age) * 0.3;\n      const size = (1 - age) * this.player.width * 0.8;\n      \n      if (alpha > 0) {\n        ctx.globalAlpha = alpha;\n        ctx.fillStyle = this.player.color;\n        ctx.fillRect(\n          point.x - size/2,\n          point.y - size/2,\n          size,\n          size\n        );\n      }\n    }\n    ctx.restore();\n    \n    // Render player\n    ctx.fillStyle = this.player.color;\n    ctx.fillRect(\n      this.player.x - this.player.width/2,\n      this.player.y - this.player.height/2,\n      this.player.width,\n      this.player.height\n    );\n    \n    // Player glow effect\n    ctx.save();\n    ctx.globalAlpha = 0.5;\n    ctx.shadowColor = this.player.color;\n    ctx.shadowBlur = 10;\n    ctx.fillStyle = this.player.color;\n    ctx.fillRect(\n      this.player.x - this.player.width/2,\n      this.player.y - this.player.height/2,\n      this.player.width,\n      this.player.height\n    );\n    ctx.restore();\n  }\n  \n  /**\n   * Render collectibles\n   */\n  renderCollectibles(ctx) {\n    for (const collectible of this.collectibles) {\n      ctx.save();\n      ctx.translate(collectible.x, collectible.y);\n      ctx.rotate(collectible.rotation * Math.PI / 180);\n      \n      ctx.fillStyle = collectible.color;\n      ctx.fillRect(\n        -collectible.width/2,\n        -collectible.height/2,\n        collectible.width,\n        collectible.height\n      );\n      \n      // Bonus items get extra effects\n      if (collectible.type === 'bonus') {\n        ctx.strokeStyle = collectible.color;\n        ctx.lineWidth = 2;\n        ctx.strokeRect(\n          -collectible.width/2 - 3,\n          -collectible.height/2 - 3,\n          collectible.width + 6,\n          collectible.height + 6\n        );\n      }\n      \n      ctx.restore();\n    }\n  }\n  \n  /**\n   * Render obstacles\n   */\n  renderObstacles(ctx) {\n    for (const obstacle of this.obstacles) {\n      ctx.save();\n      ctx.translate(obstacle.x, obstacle.y);\n      ctx.rotate(obstacle.rotation * Math.PI / 180);\n      \n      ctx.fillStyle = obstacle.color;\n      ctx.fillRect(\n        -obstacle.width/2,\n        -obstacle.height/2,\n        obstacle.width,\n        obstacle.height\n      );\n      \n      ctx.restore();\n    }\n  }\n  \n  /**\n   * Render particle effects\n   */\n  renderParticles(ctx) {\n    for (const particle of this.particles) {\n      ctx.save();\n      ctx.globalAlpha = particle.alpha;\n      ctx.fillStyle = particle.color;\n      \n      const size = particle.size * particle.scale;\n      ctx.fillRect(\n        particle.x - size/2,\n        particle.y - size/2,\n        size,\n        size\n      );\n      \n      ctx.restore();\n    }\n  }\n  \n  /**\n   * Render UI elements\n   */\n  renderUI(ctx, width, height) {\n    const padding = 20;\n    const fontSize = 16;\n    \n    ctx.fillStyle = this.colors.ui;\n    ctx.font = `bold ${fontSize}px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif`;\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'top';\n    \n    // Score\n    ctx.fillText(`Score: ${this.ui.score}`, padding, padding);\n    \n    // High Score\n    ctx.fillStyle = this.colors.uiSecondary;\n    ctx.fillText(`High: ${this.ui.highScore}`, padding, padding + 25);\n    \n    // Combo\n    if (this.combo > 1) {\n      ctx.fillStyle = this.colors.collectible;\n      ctx.font = `bold ${fontSize + 2}px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif`;\n      ctx.fillText(`${this.combo}x Combo!`, padding, padding + 55);\n    }\n    \n    // Multiplier\n    if (this.scoreMultiplier > 1) {\n      ctx.fillStyle = this.colors.particle;\n      ctx.fillText(`${this.scoreMultiplier}x Multiplier`, padding, padding + 80);\n    }\n    \n    // Instructions (mobile-optimized)\n    ctx.fillStyle = this.colors.uiSecondary;\n    ctx.font = `${fontSize - 2}px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif`;\n    ctx.textAlign = 'right';\n    ctx.fillText('Tap to move player', width - padding, height - 60);\n    ctx.fillText('Collect green items', width - padding, height - 40);\n    ctx.fillText('Avoid red obstacles', width - padding, height - 20);\n    \n    // FPS (if debug enabled)\n    if (this.ui.showDebugInfo) {\n      ctx.textAlign = 'right';\n      ctx.textBaseline = 'top';\n      ctx.fillText(`FPS: ${this.ui.fps}`, width - padding, padding);\n    }\n  }\n  \n  /**\n   * Render pause overlay\n   */\n  renderPauseOverlay(ctx, width, height) {\n    // Semi-transparent overlay\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n    ctx.fillRect(0, 0, width, height);\n    \n    // Pause text\n    ctx.fillStyle = this.colors.ui;\n    ctx.font = 'bold 36px -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText('PAUSED', width/2, height/2 - 20);\n    \n    // Instructions\n    ctx.font = '16px -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif';\n    ctx.fillStyle = this.colors.uiSecondary;\n    ctx.fillText('Tap to resume', width/2, height/2 + 20);\n  }\n  \n  /**\n   * Handle touch/click events\n   */\n  handleTouch(x, y) {\n    if (!this.isActive) return false;\n    \n    if (this.isPaused) {\n      this.resume();\n      return true;\n    }\n    \n    // Set player target position\n    if (this.player) {\n      this.player.targetX = Math.max(15, Math.min(x, 785)); // Keep within bounds\n      this.player.targetY = Math.max(15, Math.min(y, 585));\n    }\n    \n    return true;\n  }\n  \n  /**\n   * Handle keyboard input\n   */\n  handleKeyboard(key) {\n    if (!this.isActive) return false;\n    \n    switch (key) {\n      case ' ':\n      case 'Escape':\n        if (this.isPaused) {\n          this.resume();\n        } else {\n          this.pause();\n        }\n        return true;\n        \n      case 'd':\n      case 'D':\n        this.ui.showDebugInfo = !this.ui.showDebugInfo;\n        return true;\n        \n      // WASD movement for desktop\n      case 'w':\n      case 'ArrowUp':\n        if (this.player) this.player.targetY = Math.max(15, this.player.targetY - 50);\n        return true;\n        \n      case 's':\n      case 'ArrowDown':\n        if (this.player) this.player.targetY = Math.min(585, this.player.targetY + 50);\n        return true;\n        \n      case 'a':\n      case 'ArrowLeft':\n        if (this.player) this.player.targetX = Math.max(15, this.player.targetX - 50);\n        return true;\n        \n      case 'd':\n      case 'ArrowRight':\n        if (this.player) this.player.targetX = Math.min(785, this.player.targetX + 50);\n        return true;\n    }\n    \n    return false;\n  }\n  \n  /**\n   * Update UI data from external sources\n   */\n  updateUI(data) {\n    Object.assign(this.ui, data);\n  }\n  \n  /**\n   * Get current game statistics\n   */\n  getGameStats() {\n    return {\n      duration: this.gameDuration,\n      score: this.ui.score,\n      combo: this.combo,\n      multiplier: this.scoreMultiplier,\n      collectiblesOnScreen: this.collectibles.length,\n      obstaclesOnScreen: this.obstacles.length,\n      particlesOnScreen: this.particles.length\n    };\n  }\n  \n  /**\n   * Clean up scene resources\n   */\n  destroy() {\n    this.deactivate();\n    this.removeAllListeners();\n    \n    this.player = null;\n    this.collectibles = [];\n    this.particles = [];\n    this.obstacles = [];\n    this.initialized = false;\n    \n    console.log('🧹 DemoGameplayScene: Destroyed');\n  }\n}