<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Runner - GameByte Framework</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #000;
            touch-action: none;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>

    <!-- Load dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8/dist/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="../../dist/gamebyte.umd.js"></script>

    <script>
        // GameByte 3D Runner Example
        // Demonstrates: Hybrid renderer (Three.js 3D + Pixi.js UI)

        const { createGame } = GameByteFramework;

        // Game configuration
        const CONFIG = {
            width: 800,
            height: 600,
            laneCount: 3,
            laneWidth: 2,
            playerSpeed: 0.3,
            obstacleSpeed: 0.4,
            spawnDistance: -50,
            removeDistance: 10,
            spawnInterval: 60
        };

        // Game state
        const gameState = {
            score: 0,
            distance: 0,
            coins: 0,
            gameOver: false,
            currentLane: 1,
            targetLane: 1,
            isJumping: false,
            jumpVelocity: 0,
            obstacles: [],
            collectibles: [],
            frameCount: 0
        };

        // Create game instance
        const game = createGame();

        // Get container
        const container = document.getElementById('game-container');

        // Main initialization
        (async () => {
            // For hybrid mode, we'll create separate canvases for 3D and UI
            // Since hybrid renderer isn't directly exposed in UMD build, we'll simulate it

            // Create 3D canvas (Three.js)
            const canvas3D = document.createElement('canvas');
            canvas3D.width = CONFIG.width;
            canvas3D.height = CONFIG.height;
            canvas3D.style.zIndex = '1';
            container.appendChild(canvas3D);

            // Create UI canvas (Pixi.js)
            const canvasUI = document.createElement('canvas');
            canvasUI.width = CONFIG.width;
            canvasUI.height = CONFIG.height;
            canvasUI.style.zIndex = '2';
            canvasUI.style.pointerEvents = 'auto';
            container.appendChild(canvasUI);

            // Initialize Three.js
            const threeScene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, CONFIG.width / CONFIG.height, 0.1, 1000);
            const threeRenderer = new THREE.WebGLRenderer({ canvas: canvas3D, antialias: true });
            threeRenderer.setSize(CONFIG.width, CONFIG.height);
            threeRenderer.setClearColor(0x87CEEB); // Sky blue

            // Initialize Pixi.js for UI
            const pixiApp = new PIXI.Application();
            await pixiApp.init({
                canvas: canvasUI,
                width: CONFIG.width,
                height: CONFIG.height,
                backgroundAlpha: 0
            });

            // Scene containers (UI only)
            const scenes = {
                splash: new PIXI.Container(),
                loading: new PIXI.Container(),
                menu: new PIXI.Container(),
                game: new PIXI.Container(),
                gameOver: new PIXI.Container()
            };

            let currentScene = null;
            let topBar = null;
            let player = null;
            let ground = null;
            let lanes = [];

            // ============================================
            // THREE.JS 3D SETUP
            // ============================================
            function setup3DScene() {
                // Camera position
                camera.position.set(0, 4, 8);
                camera.lookAt(0, 0, -10);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                threeScene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 5);
                threeScene.add(directionalLight);

                // Ground
                const groundGeometry = new THREE.PlaneGeometry(CONFIG.laneCount * CONFIG.laneWidth + 2, 100);
                const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = 0;
                ground.position.z = -40;
                threeScene.add(ground);

                // Lane markers
                for (let i = 0; i <= CONFIG.laneCount; i++) {
                    const x = (i - CONFIG.laneCount / 2) * CONFIG.laneWidth;
                    const lineGeometry = new THREE.BoxGeometry(0.1, 0.02, 100);
                    const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.position.set(x, 0.01, -40);
                    threeScene.add(line);
                }

                // Player
                const playerGeometry = new THREE.BoxGeometry(0.8, 1.5, 0.8);
                const playerMaterial = new THREE.MeshLambertMaterial({ color: 0x00ffff });
                player = new THREE.Mesh(playerGeometry, playerMaterial);
                player.position.set(0, 0.75, 0);
                threeScene.add(player);
            }

            function clear3DScene() {
                // Remove obstacles and collectibles
                gameState.obstacles.forEach(obs => threeScene.remove(obs));
                gameState.collectibles.forEach(col => threeScene.remove(col));
                gameState.obstacles = [];
                gameState.collectibles = [];
            }

            function getLaneX(lane) {
                return (lane - 1) * CONFIG.laneWidth;
            }

            function spawnObstacle() {
                const lane = Math.floor(Math.random() * CONFIG.laneCount);
                const obstacleGeometry = new THREE.BoxGeometry(1.5, 1.5, 1);
                const obstacleMaterial = new THREE.MeshLambertMaterial({ color: 0xff3333 });
                const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                obstacle.position.set(getLaneX(lane), 0.75, CONFIG.spawnDistance);
                obstacle.lane = lane;
                threeScene.add(obstacle);
                gameState.obstacles.push(obstacle);
            }

            function spawnCoin() {
                const lane = Math.floor(Math.random() * CONFIG.laneCount);
                const coinGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 16);
                const coinMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
                const coin = new THREE.Mesh(coinGeometry, coinMaterial);
                coin.rotation.x = Math.PI / 2;
                coin.position.set(getLaneX(lane), 1.5, CONFIG.spawnDistance - 10);
                coin.lane = lane;
                threeScene.add(coin);
                gameState.collectibles.push(coin);
            }

            // ============================================
            // SCENE: SPLASH
            // ============================================
            function createSplashScene() {
                const cont = scenes.splash;
                cont.removeChildren();

                // Semi-transparent overlay
                const bg = new PIXI.Graphics();
                bg.rect(0, 0, CONFIG.width, CONFIG.height);
                bg.fill({ color: 0x1a1a2e, alpha: 0.95 });
                cont.addChild(bg);

                // Logo
                const logoContainer = new PIXI.Container();
                logoContainer.x = CONFIG.width / 2;
                logoContainer.y = CONFIG.height / 2 - 30;

                const logo = new PIXI.Graphics();
                logo.rect(-50, -20, 25, 35);
                logo.fill(0xffffff);
                logo.rect(-15, -35, 25, 35);
                logo.fill(0xffffff);
                logo.rect(-15, 10, 25, 35);
                logo.fill(0xffffff);
                logo.rect(20, -20, 65, 40);
                logo.fill(0xffffff);

                logoContainer.addChild(logo);
                cont.addChild(logoContainer);

                const brandText = new PIXI.Text({
                    text: 'GameByte',
                    style: { fontFamily: 'Arial Black', fontSize: 32, fill: 0xffffff, fontWeight: 'bold' }
                });
                brandText.anchor.set(0.5);
                brandText.x = CONFIG.width / 2;
                brandText.y = CONFIG.height / 2 + 50;
                cont.addChild(brandText);

                setTimeout(() => switchScene('loading'), 2000);
            }

            // ============================================
            // SCENE: LOADING
            // ============================================
            function createLoadingScene() {
                const cont = scenes.loading;
                cont.removeChildren();

                const bg = new PIXI.Graphics();
                bg.rect(0, 0, CONFIG.width, CONFIG.height);
                bg.fill({ color: 0x1a1a2e, alpha: 0.95 });
                cont.addChild(bg);

                const loadingText = new PIXI.Text({
                    text: 'Loading',
                    style: { fontFamily: 'Arial', fontSize: 24, fill: 0xffffff }
                });
                loadingText.anchor.set(0.5);
                loadingText.x = CONFIG.width / 2;
                loadingText.y = CONFIG.height - 60;
                cont.addChild(loadingText);

                setTimeout(() => switchScene('menu'), 1500);
            }

            // ============================================
            // SCENE: MENU
            // ============================================
            function createMenuScene() {
                const cont = scenes.menu;
                cont.removeChildren();

                const bg = new PIXI.Graphics();
                bg.rect(0, 0, CONFIG.width, CONFIG.height);
                bg.fill({ color: 0x000000, alpha: 0.7 });
                cont.addChild(bg);

                // Title
                const title = new PIXI.Text({
                    text: '3D RUNNER',
                    style: {
                        fontFamily: 'Arial Black',
                        fontSize: 56,
                        fill: 0x00ffff,
                        fontWeight: 'bold'
                    }
                });
                title.anchor.set(0.5);
                title.x = CONFIG.width / 2;
                title.y = 150;
                cont.addChild(title);

                const subtitle = new PIXI.Text({
                    text: 'Hybrid 3D + 2D UI Demo',
                    style: { fontFamily: 'Arial', fontSize: 18, fill: 0x888888 }
                });
                subtitle.anchor.set(0.5);
                subtitle.x = CONFIG.width / 2;
                subtitle.y = 210;
                cont.addChild(subtitle);

                // Play button
                const playButton = createButton('PLAY', CONFIG.width / 2, 320, 0x00aa00, () => {
                    resetGame();
                    switchScene('game');
                });
                cont.addChild(playButton);

                // Controls
                const controls = new PIXI.Text({
                    text: 'A/D or Left/Right to switch lanes\nSpace to jump',
                    style: { fontFamily: 'Arial', fontSize: 14, fill: 0x666666, align: 'center' }
                });
                controls.anchor.set(0.5);
                controls.x = CONFIG.width / 2;
                controls.y = CONFIG.height - 80;
                cont.addChild(controls);

                // High score
                const highScore = localStorage.getItem('3dRunnerHighScore') || 0;
                const highScoreText = new PIXI.Text({
                    text: `High Score: ${highScore}`,
                    style: { fontFamily: 'Arial', fontSize: 18, fill: 0xFFD700 }
                });
                highScoreText.anchor.set(0.5);
                highScoreText.x = CONFIG.width / 2;
                highScoreText.y = 400;
                cont.addChild(highScoreText);

                // Setup 3D scene for background
                setup3DScene();
            }

            // ============================================
            // SCENE: GAME
            // ============================================
            function createGameScene() {
                const cont = scenes.game;
                cont.removeChildren();

                // TopBar (UI overlay)
                topBar = createTopBar();
                cont.addChild(topBar);

                // Make sure 3D scene is setup
                if (!player) setup3DScene();
            }

            function createTopBar() {
                const bar = new PIXI.Container();

                const bg = new PIXI.Graphics();
                bg.rect(0, 0, CONFIG.width, 60);
                bg.fill({ color: 0x000000, alpha: 0.7 });
                bar.addChild(bg);

                // Score
                const scoreText = new PIXI.Text({
                    text: 'Score: 0',
                    style: { fontFamily: 'Arial', fontSize: 22, fill: 0xffffff, fontWeight: 'bold' }
                });
                scoreText.x = 20;
                scoreText.y = 15;
                scoreText.name = 'scoreText';
                bar.addChild(scoreText);

                // Coins
                const coinIcon = new PIXI.Graphics();
                coinIcon.circle(0, 0, 12);
                coinIcon.fill(0xFFD700);
                coinIcon.x = CONFIG.width - 100;
                coinIcon.y = 30;
                bar.addChild(coinIcon);

                const coinText = new PIXI.Text({
                    text: '0',
                    style: { fontFamily: 'Arial', fontSize: 22, fill: 0xFFD700, fontWeight: 'bold' }
                });
                coinText.x = CONFIG.width - 80;
                coinText.y = 15;
                coinText.name = 'coinText';
                bar.addChild(coinText);

                // Distance
                const distText = new PIXI.Text({
                    text: '0m',
                    style: { fontFamily: 'Arial', fontSize: 18, fill: 0x00ffff }
                });
                distText.anchor.set(0.5, 0);
                distText.x = CONFIG.width / 2;
                distText.y = 18;
                distText.name = 'distText';
                bar.addChild(distText);

                return bar;
            }

            function updateTopBar() {
                if (!topBar) return;
                const scoreText = topBar.getChildByName('scoreText');
                const coinText = topBar.getChildByName('coinText');
                const distText = topBar.getChildByName('distText');
                if (scoreText) scoreText.text = `Score: ${gameState.score}`;
                if (coinText) coinText.text = `${gameState.coins}`;
                if (distText) distText.text = `${Math.floor(gameState.distance)}m`;
            }

            // ============================================
            // SCENE: GAME OVER
            // ============================================
            function createGameOverScene() {
                const cont = scenes.gameOver;
                cont.removeChildren();

                const bg = new PIXI.Graphics();
                bg.rect(0, 0, CONFIG.width, CONFIG.height);
                bg.fill({ color: 0x000000, alpha: 0.85 });
                cont.addChild(bg);

                const gameOverText = new PIXI.Text({
                    text: 'GAME OVER',
                    style: { fontFamily: 'Arial Black', fontSize: 48, fill: 0xff3333, fontWeight: 'bold' }
                });
                gameOverText.anchor.set(0.5);
                gameOverText.x = CONFIG.width / 2;
                gameOverText.y = 150;
                cont.addChild(gameOverText);

                // Stats
                const scoreText = new PIXI.Text({
                    text: `Score: ${gameState.score}`,
                    style: { fontFamily: 'Arial', fontSize: 32, fill: 0xffffff }
                });
                scoreText.anchor.set(0.5);
                scoreText.x = CONFIG.width / 2;
                scoreText.y = 250;
                cont.addChild(scoreText);

                const distText = new PIXI.Text({
                    text: `Distance: ${Math.floor(gameState.distance)}m`,
                    style: { fontFamily: 'Arial', fontSize: 24, fill: 0x00ffff }
                });
                distText.anchor.set(0.5);
                distText.x = CONFIG.width / 2;
                distText.y = 300;
                cont.addChild(distText);

                const coinText = new PIXI.Text({
                    text: `Coins: ${gameState.coins}`,
                    style: { fontFamily: 'Arial', fontSize: 24, fill: 0xFFD700 }
                });
                coinText.anchor.set(0.5);
                coinText.x = CONFIG.width / 2;
                coinText.y = 340;
                cont.addChild(coinText);

                // High score
                const highScore = parseInt(localStorage.getItem('3dRunnerHighScore') || '0');
                if (gameState.score > highScore) {
                    localStorage.setItem('3dRunnerHighScore', gameState.score.toString());

                    const newHighText = new PIXI.Text({
                        text: 'NEW HIGH SCORE!',
                        style: { fontFamily: 'Arial Black', fontSize: 24, fill: 0xFFD700 }
                    });
                    newHighText.anchor.set(0.5);
                    newHighText.x = CONFIG.width / 2;
                    newHighText.y = 390;
                    cont.addChild(newHighText);
                }

                // Buttons
                const retryButton = createButton('RETRY', CONFIG.width / 2, 470, 0x00aa00, () => {
                    resetGame();
                    switchScene('game');
                });
                cont.addChild(retryButton);

                const menuButton = createButton('MENU', CONFIG.width / 2, 540, 0x3498db, () => {
                    switchScene('menu');
                });
                cont.addChild(menuButton);
            }

            // ============================================
            // HELPER FUNCTIONS
            // ============================================
            function createButton(text, x, y, color, onClick) {
                const button = new PIXI.Container();
                button.x = x;
                button.y = y;

                const bg = new PIXI.Graphics();
                bg.roundRect(-90, -22, 180, 44, 22);
                bg.fill(color);
                button.addChild(bg);

                const label = new PIXI.Text({
                    text: text,
                    style: { fontFamily: 'Arial Black', fontSize: 20, fill: 0xffffff, fontWeight: 'bold' }
                });
                label.anchor.set(0.5);
                button.addChild(label);

                button.eventMode = 'static';
                button.cursor = 'pointer';

                button.on('pointerdown', () => button.scale.set(0.95));
                button.on('pointerup', () => { button.scale.set(1); onClick(); });
                button.on('pointerupoutside', () => button.scale.set(1));

                return button;
            }

            function switchScene(sceneName) {
                if (currentScene) pixiApp.stage.removeChild(currentScene);

                switch (sceneName) {
                    case 'splash': createSplashScene(); break;
                    case 'loading': createLoadingScene(); break;
                    case 'menu': createMenuScene(); break;
                    case 'game': createGameScene(); break;
                    case 'gameOver': createGameOverScene(); break;
                }

                currentScene = scenes[sceneName];
                pixiApp.stage.addChild(currentScene);
            }

            function resetGame() {
                gameState.score = 0;
                gameState.distance = 0;
                gameState.coins = 0;
                gameState.gameOver = false;
                gameState.currentLane = 1;
                gameState.targetLane = 1;
                gameState.isJumping = false;
                gameState.jumpVelocity = 0;
                gameState.frameCount = 0;

                clear3DScene();

                if (player) {
                    player.position.set(0, 0.75, 0);
                }
            }

            function triggerGameOver() {
                if (gameState.gameOver) return;
                gameState.gameOver = true;
                switchScene('gameOver');
            }

            // ============================================
            // INPUT
            // ============================================
            document.addEventListener('keydown', (e) => {
                if (gameState.gameOver || currentScene !== scenes.game) return;

                switch (e.key) {
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        if (gameState.targetLane > 0) gameState.targetLane--;
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        if (gameState.targetLane < 2) gameState.targetLane++;
                        break;
                    case ' ':
                        if (!gameState.isJumping) {
                            gameState.isJumping = true;
                            gameState.jumpVelocity = 0.3;
                        }
                        break;
                }
            });

            // ============================================
            // UPDATE LOOP
            // ============================================
            function gameLoop() {
                requestAnimationFrame(gameLoop);

                // Render 3D scene
                threeRenderer.render(threeScene, camera);

                // Game logic only when playing
                if (currentScene === scenes.game && !gameState.gameOver) {
                    gameState.frameCount++;

                    // Move player to target lane
                    const targetX = getLaneX(gameState.targetLane);
                    player.position.x += (targetX - player.position.x) * 0.2;

                    // Jump physics
                    if (gameState.isJumping) {
                        player.position.y += gameState.jumpVelocity;
                        gameState.jumpVelocity -= 0.015;

                        if (player.position.y <= 0.75) {
                            player.position.y = 0.75;
                            gameState.isJumping = false;
                        }
                    }

                    // Move obstacles
                    for (let i = gameState.obstacles.length - 1; i >= 0; i--) {
                        const obs = gameState.obstacles[i];
                        obs.position.z += CONFIG.obstacleSpeed;

                        // Remove if past player
                        if (obs.position.z > CONFIG.removeDistance) {
                            threeScene.remove(obs);
                            gameState.obstacles.splice(i, 1);
                            gameState.score += 10;
                            continue;
                        }

                        // Collision check
                        if (obs.position.z > -1 && obs.position.z < 1) {
                            const playerLane = gameState.targetLane;
                            if (obs.lane === playerLane && player.position.y < 2) {
                                triggerGameOver();
                                return;
                            }
                        }
                    }

                    // Move collectibles
                    for (let i = gameState.collectibles.length - 1; i >= 0; i--) {
                        const coin = gameState.collectibles[i];
                        coin.position.z += CONFIG.obstacleSpeed;
                        coin.rotation.y += 0.1;

                        if (coin.position.z > CONFIG.removeDistance) {
                            threeScene.remove(coin);
                            gameState.collectibles.splice(i, 1);
                            continue;
                        }

                        // Collection check
                        if (coin.position.z > -1.5 && coin.position.z < 1.5) {
                            const playerLane = gameState.targetLane;
                            if (coin.lane === playerLane) {
                                threeScene.remove(coin);
                                gameState.collectibles.splice(i, 1);
                                gameState.coins++;
                                gameState.score += 50;
                            }
                        }
                    }

                    // Spawn obstacles and coins
                    if (gameState.frameCount % CONFIG.spawnInterval === 0) {
                        spawnObstacle();
                        if (Math.random() > 0.5) spawnCoin();
                    }

                    // Update distance
                    gameState.distance += CONFIG.obstacleSpeed;
                    gameState.score = Math.floor(gameState.distance) + gameState.coins * 50;

                    updateTopBar();
                }
            }

            // ============================================
            // START GAME
            // ============================================
            switchScene('splash');
            gameLoop();

        })();
    </script>
</body>
</html>
