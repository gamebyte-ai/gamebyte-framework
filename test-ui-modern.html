<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GameByte - Modern UI Components</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
        }
        #game-container {
            position: relative;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
            border-radius: 10px;
            overflow: hidden;
        }
        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #fff;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            max-width: 250px;
            backdrop-filter: blur(10px);
        }
        .info-title {
            font-weight: bold;
            color: #4ecca3;
            margin-bottom: 8px;
        }
        .info-item {
            margin: 4px 0;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="info">
            <div class="info-title">🎨 Modern UI Components</div>
            <div class="info-item">✅ Modern buttons with effects</div>
            <div class="info-item">✅ Gradient backgrounds</div>
            <div class="info-item">✅ Glow & shadow effects</div>
            <div class="info-item">✅ Ripple animations</div>
            <div class="info-item">💡 Click buttons to test!</div>
        </div>
    </div>

    <!-- Load Pixi.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.14.0/dist/pixi.min.js"></script>

    <!-- Load GameByte UMD Build -->
    <script src="./dist/gamebyte.umd.js"></script>

    <script>
        const { createGame, BaseScene } = GameByteFramework;

        let game, sceneManager, renderer;

        // Modern UIButton Component (inline for demo)
        class UIButton {
            constructor(config = {}) {
                this.events = {};  // Simple event system
                this.config = {
                    text: config.text || '',
                    width: Math.max(config.width || 180, 44),
                    height: Math.max(config.height || 60, 44),
                    fontSize: config.fontSize || 24,
                    fontFamily: config.fontFamily || 'Arial Black, Arial, sans-serif',
                    fontWeight: config.fontWeight || 'bold',
                    textColor: config.textColor !== undefined ? config.textColor : 0xFFFFFF,
                    backgroundColor: config.backgroundColor !== undefined ? config.backgroundColor : 0x007AFF,
                    hoverColor: config.hoverColor !== undefined ? config.hoverColor : 0x0096FF,
                    pressedColor: config.pressedColor !== undefined ? config.pressedColor : 0x0056B3,
                    disabledColor: config.disabledColor !== undefined ? config.disabledColor : 0x999999,
                    borderRadius: config.borderRadius !== undefined ? config.borderRadius : 12,
                    disabled: config.disabled || false,
                    gradient: config.gradient || { enabled: true }
                };

                this.container = new PIXI.Container();
                this.background = new PIXI.Graphics();
                this.rippleContainer = new PIXI.Container();
                this.gradientSprite = null;
                this.activeRipples = [];
                this.isPressed = false;
                this.isHovered = false;

                this.container.addChild(this.background);
                this.container.addChild(this.rippleContainer);

                if (this.config.text) {
                    this.textField = new PIXI.Text(this.config.text, {
                        fontFamily: this.config.fontFamily,
                        fontSize: this.config.fontSize,
                        fontWeight: this.config.fontWeight,
                        fill: this.config.textColor,
                        align: 'center'
                    });
                    this.textField.anchor.set(0.5);
                    this.textField.x = this.config.width / 2;
                    this.textField.y = this.config.height / 2;
                    this.container.addChild(this.textField);
                }

                this.render();
                this.setupInteractivity();
            }

            setupInteractivity() {
                this.container.eventMode = 'static';
                this.container.cursor = this.config.disabled ? 'default' : 'pointer';
                this.container.on('pointerdown', (e) => this.onPointerDown(e));
                this.container.on('pointerup', (e) => this.onPointerUp(e));
                this.container.on('pointerupoutside', () => this.onPointerUpOutside());
                this.container.on('pointerover', () => this.onPointerOver());
                this.container.on('pointerout', () => this.onPointerOut());
            }

            render() {
                this.background.clear();
                const color = this.getCurrentColor();

                if (this.config.gradient.enabled) {
                    const colorTop = this.lightenColor(color, 0.2);
                    const colorBottom = this.darkenColor(color, 0.2);

                    const canvas = document.createElement('canvas');
                    canvas.width = this.config.width;
                    canvas.height = this.config.height;
                    const ctx = canvas.getContext('2d');

                    const gradient = ctx.createLinearGradient(0, 0, 0, this.config.height);
                    gradient.addColorStop(0, '#' + colorTop.toString(16).padStart(6, '0'));
                    gradient.addColorStop(1, '#' + colorBottom.toString(16).padStart(6, '0'));

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.roundRect(0, 0, this.config.width, this.config.height, this.config.borderRadius);
                    ctx.fill();

                    const texture = PIXI.Texture.from(canvas);
                    const sprite = new PIXI.Sprite(texture);
                    this.background.clear();
                    // Remove old sprite if exists
                    if (this.gradientSprite) {
                        this.container.removeChild(this.gradientSprite);
                        this.gradientSprite.destroy();
                    }
                    this.gradientSprite = sprite;
                    this.container.addChildAt(sprite, 0);
                } else {
                    this.background.beginFill(color);
                    this.background.drawRoundedRect(0, 0, this.config.width, this.config.height, this.config.borderRadius);
                    this.background.endFill();
                }
            }

            getCurrentColor() {
                if (this.config.disabled) return this.config.disabledColor;
                if (this.isPressed) return this.config.pressedColor;
                if (this.isHovered) return this.config.hoverColor;
                return this.config.backgroundColor;
            }

            lightenColor(color, amount) {
                const r = Math.min(255, ((color >> 16) & 0xFF) + Math.floor(255 * amount));
                const g = Math.min(255, ((color >> 8) & 0xFF) + Math.floor(255 * amount));
                const b = Math.min(255, (color & 0xFF) + Math.floor(255 * amount));
                return (r << 16) | (g << 8) | b;
            }

            darkenColor(color, amount) {
                const r = Math.max(0, ((color >> 16) & 0xFF) - Math.floor(255 * amount));
                const g = Math.max(0, ((color >> 8) & 0xFF) - Math.floor(255 * amount));
                const b = Math.max(0, (color & 0xFF) - Math.floor(255 * amount));
                return (r << 16) | (g << 8) | b;
            }

            onPointerDown(event) {
                if (this.config.disabled) return;
                this.isPressed = true;
                this.render();
                this.container.scale.set(0.95);
                this.createRipple(event.getLocalPosition(this.container));
                this.emit('press', event);
            }

            onPointerUp(event) {
                if (this.config.disabled) return;
                this.isPressed = false;
                this.render();
                this.container.scale.set(1);
                this.emit('click', event);
            }

            onPointerUpOutside() {
                if (this.config.disabled) return;
                this.isPressed = false;
                this.render();
                this.container.scale.set(1);
            }

            onPointerOver() {
                if (this.config.disabled) return;
                this.isHovered = true;
                this.render();
            }

            onPointerOut() {
                if (this.config.disabled) return;
                this.isHovered = false;
                this.render();
            }

            createRipple(pos) {
                const ripple = new PIXI.Graphics();
                ripple.x = pos.x;
                ripple.y = pos.y;
                this.rippleContainer.addChild(ripple);
                this.activeRipples.push({
                    graphics: ripple,
                    startTime: Date.now(),
                    x: pos.x,
                    y: pos.y
                });
            }

            update(deltaTime) {
                const now = Date.now();
                const duration = 400;

                this.activeRipples = this.activeRipples.filter(ripple => {
                    const elapsed = now - ripple.startTime;
                    if (elapsed >= duration) {
                        this.rippleContainer.removeChild(ripple.graphics);
                        ripple.graphics.destroy();
                        return false;
                    }

                    const progress = elapsed / duration;
                    const radius = progress * Math.max(this.config.width, this.config.height);
                    const alpha = 1 - progress;

                    ripple.graphics.clear();
                    ripple.graphics.beginFill(0xFFFFFF, alpha * 0.5);
                    ripple.graphics.drawCircle(0, 0, radius);
                    ripple.graphics.endFill();

                    return true;
                });
            }

            getContainer() {
                return this.container;
            }

            destroy() {
                this.activeRipples.forEach(ripple => ripple.graphics.destroy());
                if (this.gradientSprite) {
                    this.gradientSprite.destroy();
                }
                this.container.destroy({ children: true });
                this.events = {};
            }

            // Simple event emitter methods
            on(event, callback) {
                if (!this.events[event]) this.events[event] = [];
                this.events[event].push(callback);
            }

            emit(event, ...args) {
                if (this.events[event]) {
                    this.events[event].forEach(callback => callback(...args));
                }
            }
        }

        // Modern UI Demo Scene
        class ModernUIScene extends BaseScene {
            constructor() {
                super('modern-ui', 'Modern UI Demo');
                this.buttons = [];
            }

            async initialize() {
                await super.initialize();
                console.log('✅ Modern UI Scene initializing...');

                // Create background
                const background = new PIXI.Graphics();
                background.beginFill(0x1a1a2e);
                background.drawRect(0, 0, 800, 600);
                background.endFill();
                this.container.addChild(background);

                // Title
                const title = new PIXI.Text('MODERN UI COMPONENTS', {
                    fontFamily: 'Arial Black, Arial',
                    fontSize: 32,
                    fill: 0x4ECCA3,
                    fontWeight: 'bold'
                });
                title.anchor.set(0.5);
                title.x = 400;
                title.y = 50;
                this.container.addChild(title);

                // Create demo buttons
                this.createDemoButtons();

                console.log('✅ Modern UI Scene initialized');
            }

            createDemoButtons() {
                // Primary Button (Green)
                const primaryBtn = new UIButton({
                    text: 'PRIMARY',
                    width: 200,
                    height: 60,
                    backgroundColor: 0x4CAF50,
                    gradient: {
                        enabled: true,
                        colorTop: 0x66BB6A,
                        colorBottom: 0x388E3C
                    },
                    glowEffect: true,
                    shadowEffect: true
                });
                primaryBtn.getContainer().x = 150;
                primaryBtn.getContainer().y = 150;
                primaryBtn.on('click', () => this.showMessage('Primary button clicked!'));
                this.container.addChild(primaryBtn.getContainer());
                this.buttons.push(primaryBtn);

                // Success Button (Blue)
                const successBtn = new UIButton({
                    text: 'SUCCESS',
                    width: 200,
                    height: 60,
                    backgroundColor: 0x2196F3,
                    gradient: {
                        enabled: true,
                        colorTop: 0x42A5F5,
                        colorBottom: 0x1976D2
                    },
                    glowEffect: true,
                    shadowEffect: true
                });
                successBtn.getContainer().x = 450;
                successBtn.getContainer().y = 150;
                successBtn.on('click', () => this.showMessage('Success button clicked!'));
                this.container.addChild(successBtn.getContainer());
                this.buttons.push(successBtn);

                // Warning Button (Orange)
                const warningBtn = new UIButton({
                    text: 'WARNING',
                    width: 200,
                    height: 60,
                    backgroundColor: 0xFF9800,
                    gradient: {
                        enabled: true,
                        colorTop: 0xFFB74D,
                        colorBottom: 0xF57C00
                    },
                    glowEffect: true,
                    shadowEffect: true
                });
                warningBtn.getContainer().x = 150;
                warningBtn.getContainer().y = 250;
                warningBtn.on('click', () => this.showMessage('Warning button clicked!'));
                this.container.addChild(warningBtn.getContainer());
                this.buttons.push(warningBtn);

                // Danger Button (Red)
                const dangerBtn = new UIButton({
                    text: 'DANGER',
                    width: 200,
                    height: 60,
                    backgroundColor: 0xF44336,
                    gradient: {
                        enabled: true,
                        colorTop: 0xEF5350,
                        colorBottom: 0xC62828
                    },
                    glowEffect: true,
                    shadowEffect: true
                });
                dangerBtn.getContainer().x = 450;
                dangerBtn.getContainer().y = 250;
                dangerBtn.on('click', () => this.showMessage('Danger button clicked!'));
                this.container.addChild(dangerBtn.getContainer());
                this.buttons.push(dangerBtn);

                // Disabled Button
                const disabledBtn = new UIButton({
                    text: 'DISABLED',
                    width: 200,
                    height: 60,
                    backgroundColor: 0x9E9E9E,
                    disabled: true,
                    glowEffect: false,
                    shadowEffect: false
                });
                disabledBtn.getContainer().x = 150;
                disabledBtn.getContainer().y = 350;
                this.container.addChild(disabledBtn.getContainer());
                this.buttons.push(disabledBtn);

                // Large Button
                const largeBtn = new UIButton({
                    text: 'PLAY NOW',
                    width: 500,
                    height: 80,
                    fontSize: 32,
                    backgroundColor: 0x9C27B0,
                    gradient: {
                        enabled: true,
                        colorTop: 0xAB47BC,
                        colorBottom: 0x7B1FA2
                    },
                    glowEffect: true,
                    shadowEffect: true,
                    borderRadius: 16
                });
                largeBtn.getContainer().x = 150;
                largeBtn.getContainer().y = 470;
                largeBtn.on('click', () => this.showMessage('🎮 Starting game...'));
                this.container.addChild(largeBtn.getContainer());
                this.buttons.push(largeBtn);
            }

            showMessage(text) {
                const message = new PIXI.Text(text, {
                    fontFamily: 'Arial',
                    fontSize: 24,
                    fill: 0xFFFFFF,
                    fontWeight: 'bold'
                });
                message.anchor.set(0.5);
                message.x = 400;
                message.y = 100;
                message.alpha = 0;
                this.container.addChild(message);

                // Fade in and out animation
                let alpha = 0;
                let direction = 1;
                let holdTime = 0;
                const animate = () => {
                    if (direction === 1) {
                        alpha += 0.05;
                        if (alpha >= 1) {
                            direction = 0;
                            alpha = 1;
                        }
                    } else if (direction === 0) {
                        holdTime++;
                        if (holdTime > 30) {
                            direction = -1;
                        }
                    } else {
                        alpha -= 0.05;
                    }

                    message.alpha = alpha;

                    if (alpha > 0 || direction >= 0) {
                        requestAnimationFrame(animate);
                    } else {
                        this.container.removeChild(message);
                        message.destroy();
                    }
                };
                animate();
            }

            update(deltaTime) {
                super.update(deltaTime);

                // Update button ripple animations
                this.buttons.forEach(button => {
                    if (button.update) {
                        button.update(deltaTime);
                    }
                });
            }

            destroy() {
                this.buttons.forEach(button => button.destroy());
                super.destroy();
            }
        }

        async function init() {
            try {
                console.log('🎮 Initializing Modern UI Demo...');

                // 1. Create game
                game = createGame();
                console.log('✅ GameByte created');

                // 2. Create canvas
                const canvas = document.createElement('canvas');
                canvas.width = 800;
                canvas.height = 600;
                document.getElementById('game-container').insertBefore(canvas, document.getElementById('info'));
                console.log('✅ Canvas created: 800x600');

                // 3. Initialize
                await game.initialize(canvas, '2d');
                console.log('✅ Game initialized');

                // 4. Get managers
                sceneManager = game.make('scene.manager');
                renderer = game.make('renderer');
                console.log('✅ Managers obtained');

                // 5. Create and add scene
                const uiScene = new ModernUIScene();
                sceneManager.add(uiScene);
                console.log('✅ Scene added');

                // 6. Switch to scene
                await sceneManager.switchTo('modern-ui');
                console.log('✅ Scene activated');

                // 7. Add scene container to stage
                const stage = renderer.getStage();
                const currentScene = sceneManager.getCurrentScene();
                if (stage && currentScene) {
                    stage.addChild(currentScene.getContainer());
                    console.log('✅ Scene container added to stage');
                }

                // 8. Hook renderer
                renderer.on('tick', (deltaTime) => {
                    sceneManager.update(deltaTime);
                });

                // 9. Start game loop
                game.start();
                console.log('✅ Game loop started');

                console.log('🎉 Modern UI Demo running!');

            } catch (error) {
                console.error('❌ Error:', error);
            }
        }

        // Wait for everything to load
        window.addEventListener('load', init);
    </script>
</body>
</html>
