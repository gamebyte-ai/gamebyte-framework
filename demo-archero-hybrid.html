<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Archero Menu (3D Hybrid) - GameByte Framework</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            touch-action: none;
        }
        #game-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
        }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 100;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="loading">Loading...</div>
    <div id="game-container"></div>

    <!-- Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8/dist/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3/dist/gsap.min.js"></script>
    <script src="./dist/gamebyte.umd.js"></script>

    <script>
        // Manual hybrid setup (Three.js + Pixi.js stacked canvases)
        // This demonstrates the pattern without using HybridRenderer class

        (async () => {
            const { createGame, ArcheroMenu, ARCHERO_COLORS } = GameByteFramework;

            // Mobile-first 9:16 dimensions
            const BASE_WIDTH = 1080;
            const BASE_HEIGHT = 1920;
            const ASPECT_RATIO = 9 / 16;

            // Calculate responsive size (like vanilla)
            function getCanvasSize() {
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                const windowAspect = windowWidth / windowHeight;

                let width, height;
                if (windowAspect > ASPECT_RATIO) {
                    height = windowHeight;
                    width = height * ASPECT_RATIO;
                } else {
                    width = windowWidth;
                    height = width / ASPECT_RATIO;
                }
                return { width, height };
            }

            const size = getCanvasSize();

            // Get container
            const container = document.getElementById('game-container');
            container.style.position = 'relative';
            container.style.width = size.width + 'px';
            container.style.height = size.height + 'px';

            // === THREE.JS 3D BACKGROUND ===

            // Create Three.js canvas
            const threeCanvas = document.createElement('canvas');
            threeCanvas.id = 'three-canvas';
            threeCanvas.style.position = 'absolute';
            threeCanvas.style.top = '0';
            threeCanvas.style.left = '0';
            threeCanvas.style.zIndex = '1';
            threeCanvas.style.width = size.width + 'px';
            threeCanvas.style.height = size.height + 'px';
            container.appendChild(threeCanvas);

            // Create Three.js renderer
            const threeRenderer = new THREE.WebGLRenderer({
                canvas: threeCanvas,
                antialias: true
            });
            threeRenderer.setSize(BASE_WIDTH, BASE_HEIGHT, false);
            threeRenderer.setPixelRatio(window.devicePixelRatio || 1);
            threeRenderer.setClearColor(0x0a0e1a, 1.0);

            // Create scene and camera
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, BASE_WIDTH / BASE_HEIGHT, 0.1, 1000);
            camera.position.z = 5;

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(5, 5, 5);
            scene.add(pointLight);

            // 3D objects for each section
            const objects3D = [
                createRotatingCube(0xFF3B3B),    // Shop - Red cube
                createRotatingTorus(0x9B3BFF),   // Gear - Purple torus
                createRotatingIcosahedron(0xFFD700), // Campaign - Gold icosahedron
                createRotatingOctahedron(0x3BFF7B),  // Trophy - Green octahedron
                createRotatingDodecahedron(0x3B7BFF) // Chest - Blue dodecahedron
            ];

            // Add all objects to scene (will show/hide based on active section)
            objects3D.forEach(obj => scene.add(obj));

            // Helper functions to create 3D objects
            function createRotatingCube(color) {
                const geometry = new THREE.BoxGeometry(2, 2, 2);
                const material = new THREE.MeshStandardMaterial({
                    color,
                    metalness: 0.8,
                    roughness: 0.2
                });
                return new THREE.Mesh(geometry, material);
            }

            function createRotatingTorus(color) {
                const geometry = new THREE.TorusGeometry(1.5, 0.5, 16, 100);
                const material = new THREE.MeshStandardMaterial({
                    color,
                    metalness: 0.8,
                    roughness: 0.2
                });
                return new THREE.Mesh(geometry, material);
            }

            function createRotatingIcosahedron(color) {
                const geometry = new THREE.IcosahedronGeometry(1.8, 0);
                const material = new THREE.MeshStandardMaterial({
                    color,
                    metalness: 0.8,
                    roughness: 0.2
                });
                return new THREE.Mesh(geometry, material);
            }

            function createRotatingOctahedron(color) {
                const geometry = new THREE.OctahedronGeometry(1.8, 0);
                const material = new THREE.MeshStandardMaterial({
                    color,
                    metalness: 0.8,
                    roughness: 0.2
                });
                return new THREE.Mesh(geometry, material);
            }

            function createRotatingDodecahedron(color) {
                const geometry = new THREE.DodecahedronGeometry(1.5, 0);
                const material = new THREE.MeshStandardMaterial({
                    color,
                    metalness: 0.8,
                    roughness: 0.2
                });
                return new THREE.Mesh(geometry, material);
            }

            // Show only active section's 3D object
            function showOnly3DObject(index) {
                objects3D.forEach((obj, i) => {
                    obj.visible = (i === index);
                });
            }

            showOnly3DObject(2); // Start with Campaign (index 2)

            console.log('âœ… Three.js initialized');

            // === PIXI.JS 2D UI OVERLAY ===

            // Create Pixi.js canvas
            const pixiCanvas = document.createElement('canvas');
            pixiCanvas.id = 'pixi-canvas';
            pixiCanvas.style.position = 'absolute';
            pixiCanvas.style.top = '0';
            pixiCanvas.style.left = '0';
            pixiCanvas.style.zIndex = '2';
            pixiCanvas.style.pointerEvents = 'auto';
            container.appendChild(pixiCanvas);

            // Initialize game with Pixi.js (transparent background)
            const game = createGame();

            // Manually set canvas size before initialization
            pixiCanvas.width = BASE_WIDTH;
            pixiCanvas.height = BASE_HEIGHT;
            pixiCanvas.style.width = size.width + 'px';
            pixiCanvas.style.height = size.height + 'px';

            // Initialize with transparent background for overlay
            await game.initialize(pixiCanvas, '2d', {
                transparent: true,
                backgroundColor: 0x000000, // Will be transparent anyway
                resolution: 1, // Fix: Don't scale by devicePixelRatio
                autoDensity: false // Fix: Don't auto-adjust density
            });

            // Fix canvas style after framework initialization
            pixiCanvas.style.width = size.width + 'px';
            pixiCanvas.style.height = size.height + 'px';

            const renderer = game.make('renderer');
            const pixiStage = renderer.getStage();

            console.log('âœ… Pixi.js initialized');

            // Define menu sections
            const sections = [
                { name: 'Shop', icon: 'ðŸ›’', iconColor: ARCHERO_COLORS.red },
                { name: 'Gear', icon: 'âš™ï¸', iconColor: ARCHERO_COLORS.purple },
                { name: 'Campaign', icon: 'ðŸŽ¯', iconColor: ARCHERO_COLORS.activeYellow },
                { name: 'Trophy', icon: 'ðŸ†', iconColor: ARCHERO_COLORS.green },
                { name: 'Chest', icon: 'ðŸ“¦', iconColor: ARCHERO_COLORS.blue }
            ];

            // Create Archero menu
            const menu = new ArcheroMenu({
                sections,
                activeSection: 2, // Start with Campaign
                onSectionChange: (index, section) => {
                    console.log('Section changed to:', section.name);

                    // Switch 3D object
                    showOnly3DObject(index);

                    // Animate camera slightly
                    gsap.to(camera.position, {
                        x: (Math.random() - 0.5) * 2,
                        y: (Math.random() - 0.5) * 2,
                        duration: 0.5,
                        ease: 'power2.out'
                    });
                },
                canvasWidth: BASE_WIDTH,
                canvasHeight: BASE_HEIGHT,
                enableSwipe: true,
                enableParticles: false // Disable 2D particles for cleaner hybrid demo
            });

            // Add menu to Pixi stage
            pixiStage.addChild(menu.getContainer());

            // === RENDER LOOP ===

            // Start Pixi.js rendering
            renderer.start();

            // Three.js animation loop
            function animateThree() {
                requestAnimationFrame(animateThree);

                // Rotate active 3D object
                objects3D.forEach((obj) => {
                    if (obj.visible) {
                        obj.rotation.x += 0.01;
                        obj.rotation.y += 0.01;
                    }
                });

                // Render Three.js scene
                threeRenderer.render(scene, camera);
            }
            animateThree();

            // Update menu in Pixi render loop
            renderer.on('tick', (deltaTime) => {
                menu.update(deltaTime);
            });

            // Handle window resize
            window.addEventListener('resize', () => {
                const newSize = getCanvasSize();

                container.style.width = newSize.width + 'px';
                container.style.height = newSize.height + 'px';

                // Resize both canvases - update CSS only
                threeCanvas.style.width = newSize.width + 'px';
                threeCanvas.style.height = newSize.height + 'px';
                pixiCanvas.style.width = newSize.width + 'px';
                pixiCanvas.style.height = newSize.height + 'px';
            });

            // Hide loading
            document.getElementById('loading').style.display = 'none';

            console.log('âœ… Hybrid Archero menu ready! (3D + 2D)');
            console.log('   Three.js: 3D rotating objects per section');
            console.log('   Pixi.js: 2D UI overlay with Archero menu');
        })();
    </script>
</body>
</html>
